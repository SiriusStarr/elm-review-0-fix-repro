const __elmTestSymbol = Symbol('elmTestSymbol');
(function(scope){
'use strict';

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}

function F2(fun) {
  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })
}
function F3(fun) {
  return F(3, fun, function(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  });
}
function F4(fun) {
  return F(4, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  });
}
function F5(fun) {
  return F(5, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  });
}
function F6(fun) {
  return F(6, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  });
}
function F7(fun) {
  return F(7, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  });
}
function F8(fun) {
  return F(8, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  });
}
function F9(fun) {
  return F(9, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  });
}

function A2(fun, a, b) {
  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
}
function A3(fun, a, b, c) {
  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
}
function A4(fun, a, b, c, d) {
  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e) {
  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f) {
  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g) {
  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h) {
  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i) {
  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}

('Compiled in DEV mode. Follow the advice at https://elm-lang.org/0.19.1/optimize for better performance and smaller assets.');


var _JsArray_empty = [];

function _JsArray_singleton(value)
{
    return [value];
}

function _JsArray_length(array)
{
    return array.length;
}

var _JsArray_initialize = F3(function(size, offset, func)
{
    var result = new Array(size);

    for (var i = 0; i < size; i++)
    {
        result[i] = func(offset + i);
    }

    return result;
});

var _JsArray_initializeFromList = F2(function (max, ls)
{
    var result = new Array(max);

    for (var i = 0; i < max && ls.b; i++)
    {
        result[i] = ls.a;
        ls = ls.b;
    }

    result.length = i;
    return _Utils_Tuple2(result, ls);
});

var _JsArray_unsafeGet = F2(function(index, array)
{
    return array[index];
});

var _JsArray_unsafeSet = F3(function(index, value, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[index] = value;
    return result;
});

var _JsArray_push = F2(function(value, array)
{
    var length = array.length;
    var result = new Array(length + 1);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[length] = value;
    return result;
});

var _JsArray_foldl = F3(function(func, acc, array)
{
    var length = array.length;

    for (var i = 0; i < length; i++)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_foldr = F3(function(func, acc, array)
{
    for (var i = array.length - 1; i >= 0; i--)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_map = F2(function(func, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = func(array[i]);
    }

    return result;
});

var _JsArray_indexedMap = F3(function(func, offset, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = A2(func, offset + i, array[i]);
    }

    return result;
});

var _JsArray_slice = F3(function(from, to, array)
{
    return array.slice(from, to);
});

var _JsArray_appendN = F3(function(n, dest, source)
{
    var destLen = dest.length;
    var itemsToCopy = n - destLen;

    if (itemsToCopy > source.length)
    {
        itemsToCopy = source.length;
    }

    var size = destLen + itemsToCopy;
    var result = new Array(size);

    for (var i = 0; i < destLen; i++)
    {
        result[i] = dest[i];
    }

    for (var i = 0; i < itemsToCopy; i++)
    {
        result[i + destLen] = source[i];
    }

    return result;
});



// LOG

var _Debug_log_UNUSED = F2(function(tag, value)
{
	return value;
});

var _Debug_log = F2(function(tag, value)
{
	console.elmlog(tag + ': ' + _Debug_toString(value));
	return value;
});


// TODOS

function _Debug_todo(moduleName, region)
{
	return function(message) {
		_Debug_crash(8, moduleName, region, message);
	};
}

function _Debug_todoCase(moduleName, region, value)
{
	return function(message) {
		_Debug_crash(9, moduleName, region, value, message);
	};
}


// TO STRING

function _Debug_toString_UNUSED(value)
{
	return '<internals>';
}

function _Debug_toString(value)
{
	return _Debug_toAnsiString(false, value);
}

function _Debug_toAnsiString(ansi, value)
{
	if (typeof value === 'function')
	{
		return _Debug_internalColor(ansi, '<function>');
	}

	if (typeof value === 'boolean')
	{
		return _Debug_ctorColor(ansi, value ? 'True' : 'False');
	}

	if (typeof value === 'number')
	{
		return _Debug_numberColor(ansi, value + '');
	}

	if (value instanceof String)
	{
		return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
	}

	if (typeof value === 'string')
	{
		return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, false) + '"');
	}

	if (typeof value === 'object' && '$' in value)
	{
		var tag = value.$;

		if (typeof tag === 'number')
		{
			return _Debug_internalColor(ansi, '<internals>');
		}

		if (tag[0] === '#')
		{
			var output = [];
			for (var k in value)
			{
				if (k === '$') continue;
				output.push(_Debug_toAnsiString(ansi, value[k]));
			}
			return '(' + output.join(',') + ')';
		}

		if (tag === 'Set_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Set')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
		}

		if (tag === 'RBNode_elm_builtin' || tag === 'RBEmpty_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Dict')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
		}

		if (tag === 'Array_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Array')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
		}

		if (tag === '::' || tag === '[]')
		{
			var output = '[';

			value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b)

			for (; value.b; value = value.b) // WHILE_CONS
			{
				output += ',' + _Debug_toAnsiString(ansi, value.a);
			}
			return output + ']';
		}

		var output = '';
		for (var i in value)
		{
			if (i === '$') continue;
			var str = _Debug_toAnsiString(ansi, value[i]);
			var c0 = str[0];
			var parenless = c0 === '{' || c0 === '(' || c0 === '[' || c0 === '<' || c0 === '"' || str.indexOf(' ') < 0;
			output += ' ' + (parenless ? str : '(' + str + ')');
		}
		return _Debug_ctorColor(ansi, tag) + output;
	}

	if (typeof DataView === 'function' && value instanceof DataView)
	{
		return _Debug_stringColor(ansi, '<' + value.byteLength + ' bytes>');
	}

	if (typeof File !== 'undefined' && value instanceof File)
	{
		return _Debug_internalColor(ansi, '<' + value.name + '>');
	}

	if (typeof value === 'object')
	{
		var output = [];
		for (var key in value)
		{
			var field = key[0] === '_' ? key.slice(1) : key;
			output.push(_Debug_fadeColor(ansi, field) + ' = ' + _Debug_toAnsiString(ansi, value[key]));
		}
		if (output.length === 0)
		{
			return '{}';
		}
		return '{ ' + output.join(', ') + ' }';
	}

	return _Debug_internalColor(ansi, '<internals>');
}

function _Debug_addSlashes(str, isChar)
{
	var s = str
		.replace(/\\/g, '\\\\')
		.replace(/\n/g, '\\n')
		.replace(/\t/g, '\\t')
		.replace(/\r/g, '\\r')
		.replace(/\v/g, '\\v')
		.replace(/\0/g, '\\0');

	if (isChar)
	{
		return s.replace(/\'/g, '\\\'');
	}
	else
	{
		return s.replace(/\"/g, '\\"');
	}
}

function _Debug_ctorColor(ansi, string)
{
	return ansi ? '\x1b[96m' + string + '\x1b[0m' : string;
}

function _Debug_numberColor(ansi, string)
{
	return ansi ? '\x1b[95m' + string + '\x1b[0m' : string;
}

function _Debug_stringColor(ansi, string)
{
	return ansi ? '\x1b[93m' + string + '\x1b[0m' : string;
}

function _Debug_charColor(ansi, string)
{
	return ansi ? '\x1b[92m' + string + '\x1b[0m' : string;
}

function _Debug_fadeColor(ansi, string)
{
	return ansi ? '\x1b[37m' + string + '\x1b[0m' : string;
}

function _Debug_internalColor(ansi, string)
{
	return ansi ? '\x1b[36m' + string + '\x1b[0m' : string;
}

function _Debug_toHexDigit(n)
{
	return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
}


// CRASH


function _Debug_crash_UNUSED(identifier)
{
	throw new Error('https://github.com/elm/core/blob/1.0.0/hints/' + identifier + '.md');
}


function _Debug_crash(identifier, fact1, fact2, fact3, fact4)
{
	switch(identifier)
	{
		case 0:
			throw new Error('What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.');

		case 1:
			throw new Error('Browser.application programs cannot handle URLs like this:\n\n    ' + document.location.href + '\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.');

		case 2:
			var jsonErrorString = fact1;
			throw new Error('Problem with the flags given to your Elm program on initialization.\n\n' + jsonErrorString);

		case 3:
			var portName = fact1;
			throw new Error('There can only be one port named `' + portName + '`, but your program has multiple.');

		case 4:
			var portName = fact1;
			var problem = fact2;
			throw new Error('Trying to send an unexpected type of value through port `' + portName + '`:\n' + problem);

		case 5:
			throw new Error('Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.');

		case 6:
			var moduleName = fact1;
			throw new Error('Your page is loading multiple Elm scripts with a module named ' + moduleName + '. Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!');

		case 8:
			var moduleName = fact1;
			var region = fact2;
			var message = fact3;
			throw new Error('TODO in module `' + moduleName + '` ' + _Debug_regionToString(region) + '\n\n' + message);

		case 9:
			var moduleName = fact1;
			var region = fact2;
			var value = fact3;
			var message = fact4;
			throw new Error(
				'TODO in module `' + moduleName + '` from the `case` expression '
				+ _Debug_regionToString(region) + '\n\nIt received the following value:\n\n    '
				+ _Debug_toString(value).replace('\n', '\n    ')
				+ '\n\nBut the branch that handles it says:\n\n    ' + message.replace('\n', '\n    ')
			);

		case 10:
			throw new Error('Bug in https://github.com/elm/virtual-dom/issues');

		case 11:
			throw new Error('Cannot perform mod 0. Division by zero error.');
	}
}

function _Debug_regionToString(region)
{
	if (region.start.line === region.end.line)
	{
		return 'on line ' + region.start.line;
	}
	return 'on lines ' + region.start.line + ' through ' + region.end.line;
}



// EQUALITY

function _Utils_eq(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

function _Utils_eqHelp(x, y, depth, stack)
{
	if (x === y)
	{
		return true;
	}

	if (typeof x !== 'object' || x === null || y === null)
	{
		typeof x === 'function' && _Debug_crash(5);
		return false;
	}

	if (depth > 100)
	{
		stack.push(_Utils_Tuple2(x,y));
		return true;
	}

	/**/
	if (x.$ === 'Set_elm_builtin')
	{
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	}
	if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin')
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	/**_UNUSED/
	if (x.$ < 0)
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	for (var key in x)
	{
		if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack))
		{
			return false;
		}
	}
	return true;
}

var _Utils_equal = F2(_Utils_eq);
var _Utils_notEqual = F2(function(a, b) { return !_Utils_eq(a,b); });



// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
// the particular integer values assigned to LT, EQ, and GT.

function _Utils_cmp(x, y, ord)
{
	if (typeof x !== 'object')
	{
		return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
	}

	/**/
	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? 0 : a < b ? -1 : 1;
	}
	//*/

	/**_UNUSED/
	if (typeof x.$ === 'undefined')
	//*/
	/**/
	if (x.$[0] === '#')
	//*/
	{
		return (ord = _Utils_cmp(x.a, y.a))
			? ord
			: (ord = _Utils_cmp(x.b, y.b))
				? ord
				: _Utils_cmp(x.c, y.c);
	}

	// traverse conses until end of a list or a mismatch
	for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) {} // WHILE_CONSES
	return ord || (x.b ? /*GT*/ 1 : y.b ? /*LT*/ -1 : /*EQ*/ 0);
}

var _Utils_lt = F2(function(a, b) { return _Utils_cmp(a, b) < 0; });
var _Utils_le = F2(function(a, b) { return _Utils_cmp(a, b) < 1; });
var _Utils_gt = F2(function(a, b) { return _Utils_cmp(a, b) > 0; });
var _Utils_ge = F2(function(a, b) { return _Utils_cmp(a, b) >= 0; });

var _Utils_compare = F2(function(x, y)
{
	var n = _Utils_cmp(x, y);
	return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
});


// COMMON VALUES

var _Utils_Tuple0_UNUSED = 0;
var _Utils_Tuple0 = { $: '#0' };

function _Utils_Tuple2_UNUSED(a, b) { return { a: a, b: b }; }
function _Utils_Tuple2(a, b) { return { $: '#2', a: a, b: b }; }

function _Utils_Tuple3_UNUSED(a, b, c) { return { a: a, b: b, c: c }; }
function _Utils_Tuple3(a, b, c) { return { $: '#3', a: a, b: b, c: c }; }

function _Utils_chr_UNUSED(c) { return c; }
function _Utils_chr(c) { return new String(c); }


// RECORDS

function _Utils_update(oldRecord, updatedFields)
{
	var newRecord = {};

	for (var key in oldRecord)
	{
		newRecord[key] = oldRecord[key];
	}

	for (var key in updatedFields)
	{
		newRecord[key] = updatedFields[key];
	}

	return newRecord;
}


// APPEND

var _Utils_append = F2(_Utils_ap);

function _Utils_ap(xs, ys)
{
	// append Strings
	if (typeof xs === 'string')
	{
		return xs + ys;
	}

	// append Lists
	if (!xs.b)
	{
		return ys;
	}
	var root = _List_Cons(xs.a, ys);
	xs = xs.b
	for (var curr = root; xs.b; xs = xs.b) // WHILE_CONS
	{
		curr = curr.b = _List_Cons(xs.a, ys);
	}
	return root;
}



var _List_Nil_UNUSED = { $: 0 };
var _List_Nil = { $: '[]' };

function _List_Cons_UNUSED(hd, tl) { return { $: 1, a: hd, b: tl }; }
function _List_Cons(hd, tl) { return { $: '::', a: hd, b: tl }; }


var _List_cons = F2(_List_Cons);

function _List_fromArray(arr)
{
	var out = _List_Nil;
	for (var i = arr.length; i--; )
	{
		out = _List_Cons(arr[i], out);
	}
	return out;
}

function _List_toArray(xs)
{
	for (var out = []; xs.b; xs = xs.b) // WHILE_CONS
	{
		out.push(xs.a);
	}
	return out;
}

var _List_map2 = F3(function(f, xs, ys)
{
	for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) // WHILE_CONSES
	{
		arr.push(A2(f, xs.a, ys.a));
	}
	return _List_fromArray(arr);
});

var _List_map3 = F4(function(f, xs, ys, zs)
{
	for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A3(f, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map4 = F5(function(f, ws, xs, ys, zs)
{
	for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map5 = F6(function(f, vs, ws, xs, ys, zs)
{
	for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_sortBy = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		return _Utils_cmp(f(a), f(b));
	}));
});

var _List_sortWith = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		var ord = A2(f, a, b);
		return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
	}));
});



// MATH

var _Basics_add = F2(function(a, b) { return a + b; });
var _Basics_sub = F2(function(a, b) { return a - b; });
var _Basics_mul = F2(function(a, b) { return a * b; });
var _Basics_fdiv = F2(function(a, b) { return a / b; });
var _Basics_idiv = F2(function(a, b) { return (a / b) | 0; });
var _Basics_pow = F2(Math.pow);

var _Basics_remainderBy = F2(function(b, a) { return a % b; });

// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
var _Basics_modBy = F2(function(modulus, x)
{
	var answer = x % modulus;
	return modulus === 0
		? _Debug_crash(11)
		:
	((answer > 0 && modulus < 0) || (answer < 0 && modulus > 0))
		? answer + modulus
		: answer;
});


// TRIGONOMETRY

var _Basics_pi = Math.PI;
var _Basics_e = Math.E;
var _Basics_cos = Math.cos;
var _Basics_sin = Math.sin;
var _Basics_tan = Math.tan;
var _Basics_acos = Math.acos;
var _Basics_asin = Math.asin;
var _Basics_atan = Math.atan;
var _Basics_atan2 = F2(Math.atan2);


// MORE MATH

function _Basics_toFloat(x) { return x; }
function _Basics_truncate(n) { return n | 0; }
function _Basics_isInfinite(n) { return n === Infinity || n === -Infinity; }

var _Basics_ceiling = Math.ceil;
var _Basics_floor = Math.floor;
var _Basics_round = Math.round;
var _Basics_sqrt = Math.sqrt;
var _Basics_log = Math.log;
var _Basics_isNaN = isNaN;


// BOOLEANS

function _Basics_not(bool) { return !bool; }
var _Basics_and = F2(function(a, b) { return a && b; });
var _Basics_or  = F2(function(a, b) { return a || b; });
var _Basics_xor = F2(function(a, b) { return a !== b; });



var _String_cons = F2(function(chr, str)
{
	return chr + str;
});

function _String_uncons(string)
{
	var word = string.charCodeAt(0);
	return !isNaN(word)
		? $elm$core$Maybe$Just(
			0xD800 <= word && word <= 0xDBFF
				? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2))
				: _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))
		)
		: $elm$core$Maybe$Nothing;
}

var _String_append = F2(function(a, b)
{
	return a + b;
});

function _String_length(str)
{
	return str.length;
}

var _String_map = F2(function(func, string)
{
	var len = string.length;
	var array = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = string.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			array[i] = func(_Utils_chr(string[i] + string[i+1]));
			i += 2;
			continue;
		}
		array[i] = func(_Utils_chr(string[i]));
		i++;
	}
	return array.join('');
});

var _String_filter = F2(function(isGood, str)
{
	var arr = [];
	var len = str.length;
	var i = 0;
	while (i < len)
	{
		var char = str[i];
		var word = str.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += str[i];
			i++;
		}

		if (isGood(_Utils_chr(char)))
		{
			arr.push(char);
		}
	}
	return arr.join('');
});

function _String_reverse(str)
{
	var len = str.length;
	var arr = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = str.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			arr[len - i] = str[i + 1];
			i++;
			arr[len - i] = str[i - 1];
			i++;
		}
		else
		{
			arr[len - i] = str[i];
			i++;
		}
	}
	return arr.join('');
}

var _String_foldl = F3(function(func, state, string)
{
	var len = string.length;
	var i = 0;
	while (i < len)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += string[i];
			i++;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_foldr = F3(function(func, state, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_split = F2(function(sep, str)
{
	return str.split(sep);
});

var _String_join = F2(function(sep, strs)
{
	return strs.join(sep);
});

var _String_slice = F3(function(start, end, str) {
	return str.slice(start, end);
});

function _String_trim(str)
{
	return str.trim();
}

function _String_trimLeft(str)
{
	return str.replace(/^\s+/, '');
}

function _String_trimRight(str)
{
	return str.replace(/\s+$/, '');
}

function _String_words(str)
{
	return _List_fromArray(str.trim().split(/\s+/g));
}

function _String_lines(str)
{
	return _List_fromArray(str.split(/\r\n|\r|\n/g));
}

function _String_toUpper(str)
{
	return str.toUpperCase();
}

function _String_toLower(str)
{
	return str.toLowerCase();
}

var _String_any = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (isGood(_Utils_chr(char)))
		{
			return true;
		}
	}
	return false;
});

var _String_all = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (!isGood(_Utils_chr(char)))
		{
			return false;
		}
	}
	return true;
});

var _String_contains = F2(function(sub, str)
{
	return str.indexOf(sub) > -1;
});

var _String_startsWith = F2(function(sub, str)
{
	return str.indexOf(sub) === 0;
});

var _String_endsWith = F2(function(sub, str)
{
	return str.length >= sub.length &&
		str.lastIndexOf(sub) === str.length - sub.length;
});

var _String_indexes = F2(function(sub, str)
{
	var subLen = sub.length;

	if (subLen < 1)
	{
		return _List_Nil;
	}

	var i = 0;
	var is = [];

	while ((i = str.indexOf(sub, i)) > -1)
	{
		is.push(i);
		i = i + subLen;
	}

	return _List_fromArray(is);
});


// TO STRING

function _String_fromNumber(number)
{
	return number + '';
}


// INT CONVERSIONS

function _String_toInt(str)
{
	var total = 0;
	var code0 = str.charCodeAt(0);
	var start = code0 == 0x2B /* + */ || code0 == 0x2D /* - */ ? 1 : 0;

	for (var i = start; i < str.length; ++i)
	{
		var code = str.charCodeAt(i);
		if (code < 0x30 || 0x39 < code)
		{
			return $elm$core$Maybe$Nothing;
		}
		total = 10 * total + code - 0x30;
	}

	return i == start
		? $elm$core$Maybe$Nothing
		: $elm$core$Maybe$Just(code0 == 0x2D ? -total : total);
}


// FLOAT CONVERSIONS

function _String_toFloat(s)
{
	// check if it is a hex, octal, or binary number
	if (s.length === 0 || /[\sxbo]/.test(s))
	{
		return $elm$core$Maybe$Nothing;
	}
	var n = +s;
	// faster isNaN check
	return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
}

function _String_fromList(chars)
{
	return _List_toArray(chars).join('');
}




function _Char_toCode(char)
{
	var code = char.charCodeAt(0);
	if (0xD800 <= code && code <= 0xDBFF)
	{
		return (code - 0xD800) * 0x400 + char.charCodeAt(1) - 0xDC00 + 0x10000
	}
	return code;
}

function _Char_fromCode(code)
{
	return _Utils_chr(
		(code < 0 || 0x10FFFF < code)
			? '\uFFFD'
			:
		(code <= 0xFFFF)
			? String.fromCharCode(code)
			:
		(code -= 0x10000,
			String.fromCharCode(Math.floor(code / 0x400) + 0xD800, code % 0x400 + 0xDC00)
		)
	);
}

function _Char_toUpper(char)
{
	return _Utils_chr(char.toUpperCase());
}

function _Char_toLower(char)
{
	return _Utils_chr(char.toLowerCase());
}

function _Char_toLocaleUpper(char)
{
	return _Utils_chr(char.toLocaleUpperCase());
}

function _Char_toLocaleLower(char)
{
	return _Utils_chr(char.toLocaleLowerCase());
}



/**/
function _Json_errorToString(error)
{
	return $elm$json$Json$Decode$errorToString(error);
}
//*/


// CORE DECODERS

function _Json_succeed(msg)
{
	return {
		$: 0,
		a: msg
	};
}

function _Json_fail(msg)
{
	return {
		$: 1,
		a: msg
	};
}

function _Json_decodePrim(decoder)
{
	return { $: 2, b: decoder };
}

var _Json_decodeInt = _Json_decodePrim(function(value) {
	return (typeof value !== 'number')
		? _Json_expecting('an INT', value)
		:
	(-2147483647 < value && value < 2147483647 && (value | 0) === value)
		? $elm$core$Result$Ok(value)
		:
	(isFinite(value) && !(value % 1))
		? $elm$core$Result$Ok(value)
		: _Json_expecting('an INT', value);
});

var _Json_decodeBool = _Json_decodePrim(function(value) {
	return (typeof value === 'boolean')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a BOOL', value);
});

var _Json_decodeFloat = _Json_decodePrim(function(value) {
	return (typeof value === 'number')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a FLOAT', value);
});

var _Json_decodeValue = _Json_decodePrim(function(value) {
	return $elm$core$Result$Ok(_Json_wrap(value));
});

var _Json_decodeString = _Json_decodePrim(function(value) {
	return (typeof value === 'string')
		? $elm$core$Result$Ok(value)
		: (value instanceof String)
			? $elm$core$Result$Ok(value + '')
			: _Json_expecting('a STRING', value);
});

function _Json_decodeList(decoder) { return { $: 3, b: decoder }; }
function _Json_decodeArray(decoder) { return { $: 4, b: decoder }; }

function _Json_decodeNull(value) { return { $: 5, c: value }; }

var _Json_decodeField = F2(function(field, decoder)
{
	return {
		$: 6,
		d: field,
		b: decoder
	};
});

var _Json_decodeIndex = F2(function(index, decoder)
{
	return {
		$: 7,
		e: index,
		b: decoder
	};
});

function _Json_decodeKeyValuePairs(decoder)
{
	return {
		$: 8,
		b: decoder
	};
}

function _Json_mapMany(f, decoders)
{
	return {
		$: 9,
		f: f,
		g: decoders
	};
}

var _Json_andThen = F2(function(callback, decoder)
{
	return {
		$: 10,
		b: decoder,
		h: callback
	};
});

function _Json_oneOf(decoders)
{
	return {
		$: 11,
		g: decoders
	};
}


// DECODING OBJECTS

var _Json_map1 = F2(function(f, d1)
{
	return _Json_mapMany(f, [d1]);
});

var _Json_map2 = F3(function(f, d1, d2)
{
	return _Json_mapMany(f, [d1, d2]);
});

var _Json_map3 = F4(function(f, d1, d2, d3)
{
	return _Json_mapMany(f, [d1, d2, d3]);
});

var _Json_map4 = F5(function(f, d1, d2, d3, d4)
{
	return _Json_mapMany(f, [d1, d2, d3, d4]);
});

var _Json_map5 = F6(function(f, d1, d2, d3, d4, d5)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
});

var _Json_map6 = F7(function(f, d1, d2, d3, d4, d5, d6)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
});

var _Json_map7 = F8(function(f, d1, d2, d3, d4, d5, d6, d7)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
});

var _Json_map8 = F9(function(f, d1, d2, d3, d4, d5, d6, d7, d8)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
});


// DECODE

var _Json_runOnString = F2(function(decoder, string)
{
	try
	{
		var value = JSON.parse(string);
		return _Json_runHelp(decoder, value);
	}
	catch (e)
	{
		return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'This is not valid JSON! ' + e.message, _Json_wrap(string)));
	}
});

var _Json_run = F2(function(decoder, value)
{
	return _Json_runHelp(decoder, _Json_unwrap(value));
});

function _Json_runHelp(decoder, value)
{
	switch (decoder.$)
	{
		case 2:
			return decoder.b(value);

		case 5:
			return (value === null)
				? $elm$core$Result$Ok(decoder.c)
				: _Json_expecting('null', value);

		case 3:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('a LIST', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);

		case 4:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);

		case 6:
			var field = decoder.d;
			if (typeof value !== 'object' || value === null || !(field in value))
			{
				return _Json_expecting('an OBJECT with a field named `' + field + '`', value);
			}
			var result = _Json_runHelp(decoder.b, value[field]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, field, result.a));

		case 7:
			var index = decoder.e;
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			if (index >= value.length)
			{
				return _Json_expecting('a LONGER array. Need index ' + index + ' but only see ' + value.length + ' entries', value);
			}
			var result = _Json_runHelp(decoder.b, value[index]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, index, result.a));

		case 8:
			if (typeof value !== 'object' || value === null || _Json_isArray(value))
			{
				return _Json_expecting('an OBJECT', value);
			}

			var keyValuePairs = _List_Nil;
			// TODO test perf of Object.keys and switch when support is good enough
			for (var key in value)
			{
				if (value.hasOwnProperty(key))
				{
					var result = _Json_runHelp(decoder.b, value[key]);
					if (!$elm$core$Result$isOk(result))
					{
						return $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, key, result.a));
					}
					keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
				}
			}
			return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));

		case 9:
			var answer = decoder.f;
			var decoders = decoder.g;
			for (var i = 0; i < decoders.length; i++)
			{
				var result = _Json_runHelp(decoders[i], value);
				if (!$elm$core$Result$isOk(result))
				{
					return result;
				}
				answer = answer(result.a);
			}
			return $elm$core$Result$Ok(answer);

		case 10:
			var result = _Json_runHelp(decoder.b, value);
			return (!$elm$core$Result$isOk(result))
				? result
				: _Json_runHelp(decoder.h(result.a), value);

		case 11:
			var errors = _List_Nil;
			for (var temp = decoder.g; temp.b; temp = temp.b) // WHILE_CONS
			{
				var result = _Json_runHelp(temp.a, value);
				if ($elm$core$Result$isOk(result))
				{
					return result;
				}
				errors = _List_Cons(result.a, errors);
			}
			return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));

		case 1:
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value)));

		case 0:
			return $elm$core$Result$Ok(decoder.a);
	}
}

function _Json_runArrayDecoder(decoder, value, toElmValue)
{
	var len = value.length;
	var array = new Array(len);
	for (var i = 0; i < len; i++)
	{
		var result = _Json_runHelp(decoder, value[i]);
		if (!$elm$core$Result$isOk(result))
		{
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, i, result.a));
		}
		array[i] = result.a;
	}
	return $elm$core$Result$Ok(toElmValue(array));
}

function _Json_isArray(value)
{
	return Array.isArray(value) || (typeof FileList !== 'undefined' && value instanceof FileList);
}

function _Json_toElmArray(array)
{
	return A2($elm$core$Array$initialize, array.length, function(i) { return array[i]; });
}

function _Json_expecting(type, value)
{
	return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'Expecting ' + type, _Json_wrap(value)));
}


// EQUALITY

function _Json_equality(x, y)
{
	if (x === y)
	{
		return true;
	}

	if (x.$ !== y.$)
	{
		return false;
	}

	switch (x.$)
	{
		case 0:
		case 1:
			return x.a === y.a;

		case 2:
			return x.b === y.b;

		case 5:
			return x.c === y.c;

		case 3:
		case 4:
		case 8:
			return _Json_equality(x.b, y.b);

		case 6:
			return x.d === y.d && _Json_equality(x.b, y.b);

		case 7:
			return x.e === y.e && _Json_equality(x.b, y.b);

		case 9:
			return x.f === y.f && _Json_listEquality(x.g, y.g);

		case 10:
			return x.h === y.h && _Json_equality(x.b, y.b);

		case 11:
			return _Json_listEquality(x.g, y.g);
	}
}

function _Json_listEquality(aDecoders, bDecoders)
{
	var len = aDecoders.length;
	if (len !== bDecoders.length)
	{
		return false;
	}
	for (var i = 0; i < len; i++)
	{
		if (!_Json_equality(aDecoders[i], bDecoders[i]))
		{
			return false;
		}
	}
	return true;
}


// ENCODE

var _Json_encode = F2(function(indentLevel, value)
{
	return JSON.stringify(_Json_unwrap(value), null, indentLevel) + '';
});

function _Json_wrap(value) { return { $: 0, a: value }; }
function _Json_unwrap(value) { return value.a; }

function _Json_wrap_UNUSED(value) { return value; }
function _Json_unwrap_UNUSED(value) { return value; }

function _Json_emptyArray() { return []; }
function _Json_emptyObject() { return {}; }

var _Json_addField = F3(function(key, value, object)
{
	object[key] = _Json_unwrap(value);
	return object;
});

function _Json_addEntry(func)
{
	return F2(function(entry, array)
	{
		array.push(_Json_unwrap(func(entry)));
		return array;
	});
}

var _Json_encodeNull = _Json_wrap(null);




// STRINGS


var _Parser_isSubString = F5(function(smallString, offset, row, col, bigString)
{
	var smallLength = smallString.length;
	var isGood = offset + smallLength <= bigString.length;

	for (var i = 0; isGood && i < smallLength; )
	{
		var code = bigString.charCodeAt(offset);
		isGood =
			smallString[i++] === bigString[offset++]
			&& (
				code === 0x000A /* \n */
					? ( row++, col=1 )
					: ( col++, (code & 0xF800) === 0xD800 ? smallString[i++] === bigString[offset++] : 1 )
			)
	}

	return _Utils_Tuple3(isGood ? offset : -1, row, col);
});



// CHARS


var _Parser_isSubChar = F3(function(predicate, offset, string)
{
	return (
		string.length <= offset
			? -1
			:
		(string.charCodeAt(offset) & 0xF800) === 0xD800
			? (predicate(_Utils_chr(string.substr(offset, 2))) ? offset + 2 : -1)
			:
		(predicate(_Utils_chr(string[offset]))
			? ((string[offset] === '\n') ? -2 : (offset + 1))
			: -1
		)
	);
});


var _Parser_isAsciiCode = F3(function(code, offset, string)
{
	return string.charCodeAt(offset) === code;
});



// NUMBERS


var _Parser_chompBase10 = F2(function(offset, string)
{
	for (; offset < string.length; offset++)
	{
		var code = string.charCodeAt(offset);
		if (code < 0x30 || 0x39 < code)
		{
			return offset;
		}
	}
	return offset;
});


var _Parser_consumeBase = F3(function(base, offset, string)
{
	for (var total = 0; offset < string.length; offset++)
	{
		var digit = string.charCodeAt(offset) - 0x30;
		if (digit < 0 || base <= digit) break;
		total = base * total + digit;
	}
	return _Utils_Tuple2(offset, total);
});


var _Parser_consumeBase16 = F2(function(offset, string)
{
	for (var total = 0; offset < string.length; offset++)
	{
		var code = string.charCodeAt(offset);
		if (0x30 <= code && code <= 0x39)
		{
			total = 16 * total + code - 0x30;
		}
		else if (0x41 <= code && code <= 0x46)
		{
			total = 16 * total + code - 55;
		}
		else if (0x61 <= code && code <= 0x66)
		{
			total = 16 * total + code - 87;
		}
		else
		{
			break;
		}
	}
	return _Utils_Tuple2(offset, total);
});



// FIND STRING


var _Parser_findSubString = F5(function(smallString, offset, row, col, bigString)
{
	var newOffset = bigString.indexOf(smallString, offset);
	var target = newOffset < 0 ? bigString.length : newOffset + smallString.length;

	while (offset < target)
	{
		var code = bigString.charCodeAt(offset++);
		code === 0x000A /* \n */
			? ( col=1, row++ )
			: ( col++, (code & 0xF800) === 0xD800 && offset++ )
	}

	return _Utils_Tuple3(newOffset, row, col);
});



var _Bitwise_and = F2(function(a, b)
{
	return a & b;
});

var _Bitwise_or = F2(function(a, b)
{
	return a | b;
});

var _Bitwise_xor = F2(function(a, b)
{
	return a ^ b;
});

function _Bitwise_complement(a)
{
	return ~a;
};

var _Bitwise_shiftLeftBy = F2(function(offset, a)
{
	return a << offset;
});

var _Bitwise_shiftRightBy = F2(function(offset, a)
{
	return a >> offset;
});

var _Bitwise_shiftRightZfBy = F2(function(offset, a)
{
	return a >>> offset;
});



// TASKS

function _Scheduler_succeed(value)
{
	return {
		$: 0,
		a: value
	};
}

function _Scheduler_fail(error)
{
	return {
		$: 1,
		a: error
	};
}

function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		c: null
	};
}

var _Scheduler_andThen = F2(function(callback, task)
{
	return {
		$: 3,
		b: callback,
		d: task
	};
});

var _Scheduler_onError = F2(function(callback, task)
{
	return {
		$: 4,
		b: callback,
		d: task
	};
});

function _Scheduler_receive(callback)
{
	return {
		$: 5,
		b: callback
	};
}


// PROCESSES

var _Scheduler_guid = 0;

function _Scheduler_rawSpawn(task)
{
	var proc = {
		$: 0,
		e: _Scheduler_guid++,
		f: task,
		g: null,
		h: []
	};

	_Scheduler_enqueue(proc);

	return proc;
}

function _Scheduler_spawn(task)
{
	return _Scheduler_binding(function(callback) {
		callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
	});
}

function _Scheduler_rawSend(proc, msg)
{
	proc.h.push(msg);
	_Scheduler_enqueue(proc);
}

var _Scheduler_send = F2(function(proc, msg)
{
	return _Scheduler_binding(function(callback) {
		_Scheduler_rawSend(proc, msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});

function _Scheduler_kill(proc)
{
	return _Scheduler_binding(function(callback) {
		var task = proc.f;
		if (task.$ === 2 && task.c)
		{
			task.c();
		}

		proc.f = null;

		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
}


/* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/


var _Scheduler_working = false;
var _Scheduler_queue = [];


function _Scheduler_enqueue(proc)
{
	_Scheduler_queue.push(proc);
	if (_Scheduler_working)
	{
		return;
	}
	_Scheduler_working = true;
	while (proc = _Scheduler_queue.shift())
	{
		_Scheduler_step(proc);
	}
	_Scheduler_working = false;
}


function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			});
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}



function _Process_sleep(time)
{
	return _Scheduler_binding(function(callback) {
		var id = setTimeout(function() {
			callback(_Scheduler_succeed(_Utils_Tuple0));
		}, time);

		return function() { clearTimeout(id); };
	});
}




// PROGRAMS


var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		flagDecoder,
		args,
		impl.init,
		impl.update,
		impl.subscriptions,
		function() { return function() {} }
	);
});



// INITIALIZE A PROGRAM


function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder)
{
	var result = A2(_Json_run, flagDecoder, _Json_wrap(args ? args['flags'] : undefined));
	$elm$core$Result$isOk(result) || _Debug_crash(2 /**/, _Json_errorToString(result.a) /**/);
	var managers = {};
	var initPair = init(result.a);
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);

	function sendToApp(msg, viewMetadata)
	{
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));

	return ports ? { ports: ports } : {};
}



// TRACK PRELOADS
//
// This is used by code in elm/browser and elm/http
// to register any HTTP requests that are triggered by init.
//


var _Platform_preload;


function _Platform_registerPreload(url)
{
	_Platform_preload.add(url);
}



// EFFECT MANAGERS


var _Platform_effectManagers = {};


function _Platform_setupEffects(managers, sendToApp)
{
	var ports;

	// setup all necessary effect managers
	for (var key in _Platform_effectManagers)
	{
		var manager = _Platform_effectManagers[key];

		if (manager.a)
		{
			ports = ports || {};
			ports[key] = manager.a(key, sendToApp);
		}

		managers[key] = _Platform_instantiateManager(manager, sendToApp);
	}

	return ports;
}


function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap)
{
	return {
		b: init,
		c: onEffects,
		d: onSelfMsg,
		e: cmdMap,
		f: subMap
	};
}


function _Platform_instantiateManager(info, sendToApp)
{
	var router = {
		g: sendToApp,
		h: undefined
	};

	var onEffects = info.c;
	var onSelfMsg = info.d;
	var cmdMap = info.e;
	var subMap = info.f;

	function loop(state)
	{
		return A2(_Scheduler_andThen, loop, _Scheduler_receive(function(msg)
		{
			var value = msg.a;

			if (msg.$ === 0)
			{
				return A3(onSelfMsg, router, value, state);
			}

			return cmdMap && subMap
				? A4(onEffects, router, value.i, value.j, state)
				: A3(onEffects, router, cmdMap ? value.i : value.j, state);
		}));
	}

	return router.h = _Scheduler_rawSpawn(A2(_Scheduler_andThen, loop, info.b));
}



// ROUTING


var _Platform_sendToApp = F2(function(router, msg)
{
	return _Scheduler_binding(function(callback)
	{
		router.g(msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});


var _Platform_sendToSelf = F2(function(router, msg)
{
	return A2(_Scheduler_send, router.h, {
		$: 0,
		a: msg
	});
});



// BAGS


function _Platform_leaf(home)
{
	return function(value)
	{
		return {
			$: 1,
			k: home,
			l: value
		};
	};
}


function _Platform_batch(list)
{
	return {
		$: 2,
		m: list
	};
}


var _Platform_map = F2(function(tagger, bag)
{
	return {
		$: 3,
		n: tagger,
		o: bag
	}
});



// PIPE BAGS INTO EFFECT MANAGERS
//
// Effects must be queued!
//
// Say your init contains a synchronous command, like Time.now or Time.here
//
//   - This will produce a batch of effects (FX_1)
//   - The synchronous task triggers the subsequent `update` call
//   - This will produce a batch of effects (FX_2)
//
// If we just start dispatching FX_2, subscriptions from FX_2 can be processed
// before subscriptions from FX_1. No good! Earlier versions of this code had
// this problem, leading to these reports:
//
//   https://github.com/elm/core/issues/980
//   https://github.com/elm/core/pull/981
//   https://github.com/elm/compiler/issues/1776
//
// The queue is necessary to avoid ordering issues for synchronous commands.


// Why use true/false here? Why not just check the length of the queue?
// The goal is to detect "are we currently dispatching effects?" If we
// are, we need to bail and let the ongoing while loop handle things.
//
// Now say the queue has 1 element. When we dequeue the final element,
// the queue will be empty, but we are still actively dispatching effects.
// So you could get queue jumping in a really tricky category of cases.
//
var _Platform_effectsQueue = [];
var _Platform_effectsActive = false;


function _Platform_enqueueEffects(managers, cmdBag, subBag)
{
	_Platform_effectsQueue.push({ p: managers, q: cmdBag, r: subBag });

	if (_Platform_effectsActive) return;

	_Platform_effectsActive = true;
	for (var fx; fx = _Platform_effectsQueue.shift(); )
	{
		_Platform_dispatchEffects(fx.p, fx.q, fx.r);
	}
	_Platform_effectsActive = false;
}


function _Platform_dispatchEffects(managers, cmdBag, subBag)
{
	var effectsDict = {};
	_Platform_gatherEffects(true, cmdBag, effectsDict, null);
	_Platform_gatherEffects(false, subBag, effectsDict, null);

	for (var home in managers)
	{
		_Scheduler_rawSend(managers[home], {
			$: 'fx',
			a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
		});
	}
}


function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers)
{
	switch (bag.$)
	{
		case 1:
			var home = bag.k;
			var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
			effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
			return;

		case 2:
			for (var list = bag.m; list.b; list = list.b) // WHILE_CONS
			{
				_Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
			}
			return;

		case 3:
			_Platform_gatherEffects(isCmd, bag.o, effectsDict, {
				s: bag.n,
				t: taggers
			});
			return;
	}
}


function _Platform_toEffect(isCmd, home, taggers, value)
{
	function applyTaggers(x)
	{
		for (var temp = taggers; temp; temp = temp.t)
		{
			x = temp.s(x);
		}
		return x;
	}

	var map = isCmd
		? _Platform_effectManagers[home].e
		: _Platform_effectManagers[home].f;

	return A2(map, applyTaggers, value)
}


function _Platform_insert(isCmd, newEffect, effects)
{
	effects = effects || { i: _List_Nil, j: _List_Nil };

	isCmd
		? (effects.i = _List_Cons(newEffect, effects.i))
		: (effects.j = _List_Cons(newEffect, effects.j));

	return effects;
}



// PORTS


function _Platform_checkPortName(name)
{
	if (_Platform_effectManagers[name])
	{
		_Debug_crash(3, name)
	}
}



// OUTGOING PORTS


function _Platform_outgoingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		e: _Platform_outgoingPortMap,
		u: converter,
		a: _Platform_setupOutgoingPort
	};
	return _Platform_leaf(name);
}


var _Platform_outgoingPortMap = F2(function(tagger, value) { return value; });


function _Platform_setupOutgoingPort(name)
{
	var subs = [];
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Process_sleep(0);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, cmdList, state)
	{
		for ( ; cmdList.b; cmdList = cmdList.b) // WHILE_CONS
		{
			// grab a separate reference to subs in case unsubscribe is called
			var currentSubs = subs;
			var value = _Json_unwrap(converter(cmdList.a));
			for (var i = 0; i < currentSubs.length; i++)
			{
				currentSubs[i](value);
			}
		}
		return init;
	});

	// PUBLIC API

	function subscribe(callback)
	{
		subs.push(callback);
	}

	function unsubscribe(callback)
	{
		// copy subs into a new array in case unsubscribe is called within a
		// subscribed callback
		subs = subs.slice();
		var index = subs.indexOf(callback);
		if (index >= 0)
		{
			subs.splice(index, 1);
		}
	}

	return {
		subscribe: subscribe,
		unsubscribe: unsubscribe
	};
}



// INCOMING PORTS


function _Platform_incomingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		f: _Platform_incomingPortMap,
		u: converter,
		a: _Platform_setupIncomingPort
	};
	return _Platform_leaf(name);
}


var _Platform_incomingPortMap = F2(function(tagger, finalTagger)
{
	return function(value)
	{
		return tagger(finalTagger(value));
	};
});


function _Platform_setupIncomingPort(name, sendToApp)
{
	var subs = _List_Nil;
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Scheduler_succeed(null);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, subList, state)
	{
		subs = subList;
		return init;
	});

	// PUBLIC API

	function send(incomingValue)
	{
		var result = A2(_Json_run, converter, _Json_wrap(incomingValue));

		$elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);

		var value = result.a;
		for (var temp = subs; temp.b; temp = temp.b) // WHILE_CONS
		{
			sendToApp(temp.a(value));
		}
	}

	return { send: send };
}



// EXPORT ELM MODULES
//
// Have DEBUG and PROD versions so that we can (1) give nicer errors in
// debug mode and (2) not pay for the bits needed for that in prod mode.
//


function _Platform_export_UNUSED(exports)
{
	scope['Elm']
		? _Platform_mergeExportsProd(scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsProd(obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6)
				: _Platform_mergeExportsProd(obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}


function _Platform_export(exports)
{
	scope['Elm']
		? _Platform_mergeExportsDebug('Elm', scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsDebug(moduleName, obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6, moduleName)
				: _Platform_mergeExportsDebug(moduleName + '.' + name, obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}



function _Test_runThunk(thunk)
{
  try {
    // Attempt to run the thunk as normal.
    return $elm$core$Result$Ok(thunk(_Utils_Tuple0));
  } catch (err) {
    // If it throws, return an error instead of crashing.
    return $elm$core$Result$Err(err.toString());
  }
}
var $elm$core$Maybe$Just = function (a) {
	return {$: 'Just', a: a};
};
var $elm$core$Maybe$Nothing = {$: 'Nothing'};
var $elm$core$List$cons = _List_cons;
var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
var $elm$core$Array$foldr = F3(
	function (func, baseCase, _v0) {
		var tree = _v0.c;
		var tail = _v0.d;
		var helper = F2(
			function (node, acc) {
				if (node.$ === 'SubTree') {
					var subTree = node.a;
					return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
				} else {
					var values = node.a;
					return A3($elm$core$Elm$JsArray$foldr, func, acc, values);
				}
			});
		return A3(
			$elm$core$Elm$JsArray$foldr,
			helper,
			A3($elm$core$Elm$JsArray$foldr, func, baseCase, tail),
			tree);
	});
var $elm$core$Array$toList = function (array) {
	return A3($elm$core$Array$foldr, $elm$core$List$cons, _List_Nil, array);
};
var $elm$core$Dict$foldr = F3(
	function (func, acc, t) {
		foldr:
		while (true) {
			if (t.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = t.b;
				var value = t.c;
				var left = t.d;
				var right = t.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldr, func, acc, right)),
					$temp$t = left;
				func = $temp$func;
				acc = $temp$acc;
				t = $temp$t;
				continue foldr;
			}
		}
	});
var $elm$core$Dict$toList = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, list) {
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(key, value),
					list);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Dict$keys = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, keyList) {
				return A2($elm$core$List$cons, key, keyList);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Set$toList = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$keys(dict);
};
var $elm$core$Basics$EQ = {$: 'EQ'};
var $elm$core$Basics$GT = {$: 'GT'};
var $elm$core$Basics$LT = {$: 'LT'};
var $elm$core$Result$Err = function (a) {
	return {$: 'Err', a: a};
};
var $elm$json$Json$Decode$Failure = F2(
	function (a, b) {
		return {$: 'Failure', a: a, b: b};
	});
var $elm$json$Json$Decode$Field = F2(
	function (a, b) {
		return {$: 'Field', a: a, b: b};
	});
var $elm$json$Json$Decode$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $elm$core$Result$Ok = function (a) {
	return {$: 'Ok', a: a};
};
var $elm$json$Json$Decode$OneOf = function (a) {
	return {$: 'OneOf', a: a};
};
var $elm$core$Basics$False = {$: 'False'};
var $elm$core$Basics$add = _Basics_add;
var $elm$core$String$all = _String_all;
var $elm$core$Basics$and = _Basics_and;
var $elm$core$Basics$append = _Utils_append;
var $elm$json$Json$Encode$encode = _Json_encode;
var $elm$core$String$fromInt = _String_fromNumber;
var $elm$core$String$join = F2(
	function (sep, chunks) {
		return A2(
			_String_join,
			sep,
			_List_toArray(chunks));
	});
var $elm$core$String$split = F2(
	function (sep, string) {
		return _List_fromArray(
			A2(_String_split, sep, string));
	});
var $elm$json$Json$Decode$indent = function (str) {
	return A2(
		$elm$core$String$join,
		'\n    ',
		A2($elm$core$String$split, '\n', str));
};
var $elm$core$List$foldl = F3(
	function (func, acc, list) {
		foldl:
		while (true) {
			if (!list.b) {
				return acc;
			} else {
				var x = list.a;
				var xs = list.b;
				var $temp$func = func,
					$temp$acc = A2(func, x, acc),
					$temp$list = xs;
				func = $temp$func;
				acc = $temp$acc;
				list = $temp$list;
				continue foldl;
			}
		}
	});
var $elm$core$List$length = function (xs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, i) {
				return i + 1;
			}),
		0,
		xs);
};
var $elm$core$List$map2 = _List_map2;
var $elm$core$Basics$le = _Utils_le;
var $elm$core$Basics$sub = _Basics_sub;
var $elm$core$List$rangeHelp = F3(
	function (lo, hi, list) {
		rangeHelp:
		while (true) {
			if (_Utils_cmp(lo, hi) < 1) {
				var $temp$lo = lo,
					$temp$hi = hi - 1,
					$temp$list = A2($elm$core$List$cons, hi, list);
				lo = $temp$lo;
				hi = $temp$hi;
				list = $temp$list;
				continue rangeHelp;
			} else {
				return list;
			}
		}
	});
var $elm$core$List$range = F2(
	function (lo, hi) {
		return A3($elm$core$List$rangeHelp, lo, hi, _List_Nil);
	});
var $elm$core$List$indexedMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$map2,
			f,
			A2(
				$elm$core$List$range,
				0,
				$elm$core$List$length(xs) - 1),
			xs);
	});
var $elm$core$Char$toCode = _Char_toCode;
var $elm$core$Char$isLower = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (97 <= code) && (code <= 122);
};
var $elm$core$Char$isUpper = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 90) && (65 <= code);
};
var $elm$core$Basics$or = _Basics_or;
var $elm$core$Char$isAlpha = function (_char) {
	return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
};
var $elm$core$Char$isDigit = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 57) && (48 <= code);
};
var $elm$core$Char$isAlphaNum = function (_char) {
	return $elm$core$Char$isLower(_char) || ($elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char));
};
var $elm$core$List$reverse = function (list) {
	return A3($elm$core$List$foldl, $elm$core$List$cons, _List_Nil, list);
};
var $elm$core$String$uncons = _String_uncons;
var $elm$json$Json$Decode$errorOneOf = F2(
	function (i, error) {
		return '\n\n(' + ($elm$core$String$fromInt(i + 1) + (') ' + $elm$json$Json$Decode$indent(
			$elm$json$Json$Decode$errorToString(error))));
	});
var $elm$json$Json$Decode$errorToString = function (error) {
	return A2($elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
};
var $elm$json$Json$Decode$errorToStringHelp = F2(
	function (error, context) {
		errorToStringHelp:
		while (true) {
			switch (error.$) {
				case 'Field':
					var f = error.a;
					var err = error.b;
					var isSimple = function () {
						var _v1 = $elm$core$String$uncons(f);
						if (_v1.$ === 'Nothing') {
							return false;
						} else {
							var _v2 = _v1.a;
							var _char = _v2.a;
							var rest = _v2.b;
							return $elm$core$Char$isAlpha(_char) && A2($elm$core$String$all, $elm$core$Char$isAlphaNum, rest);
						}
					}();
					var fieldName = isSimple ? ('.' + f) : ('[\'' + (f + '\']'));
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, fieldName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'Index':
					var i = error.a;
					var err = error.b;
					var indexName = '[' + ($elm$core$String$fromInt(i) + ']');
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, indexName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'OneOf':
					var errors = error.a;
					if (!errors.b) {
						return 'Ran into a Json.Decode.oneOf with no possibilities' + function () {
							if (!context.b) {
								return '!';
							} else {
								return ' at json' + A2(
									$elm$core$String$join,
									'',
									$elm$core$List$reverse(context));
							}
						}();
					} else {
						if (!errors.b.b) {
							var err = errors.a;
							var $temp$error = err,
								$temp$context = context;
							error = $temp$error;
							context = $temp$context;
							continue errorToStringHelp;
						} else {
							var starter = function () {
								if (!context.b) {
									return 'Json.Decode.oneOf';
								} else {
									return 'The Json.Decode.oneOf at json' + A2(
										$elm$core$String$join,
										'',
										$elm$core$List$reverse(context));
								}
							}();
							var introduction = starter + (' failed in the following ' + ($elm$core$String$fromInt(
								$elm$core$List$length(errors)) + ' ways:'));
							return A2(
								$elm$core$String$join,
								'\n\n',
								A2(
									$elm$core$List$cons,
									introduction,
									A2($elm$core$List$indexedMap, $elm$json$Json$Decode$errorOneOf, errors)));
						}
					}
				default:
					var msg = error.a;
					var json = error.b;
					var introduction = function () {
						if (!context.b) {
							return 'Problem with the given value:\n\n';
						} else {
							return 'Problem with the value at json' + (A2(
								$elm$core$String$join,
								'',
								$elm$core$List$reverse(context)) + ':\n\n    ');
						}
					}();
					return introduction + ($elm$json$Json$Decode$indent(
						A2($elm$json$Json$Encode$encode, 4, json)) + ('\n\n' + msg));
			}
		}
	});
var $elm$core$Array$branchFactor = 32;
var $elm$core$Array$Array_elm_builtin = F4(
	function (a, b, c, d) {
		return {$: 'Array_elm_builtin', a: a, b: b, c: c, d: d};
	});
var $elm$core$Elm$JsArray$empty = _JsArray_empty;
var $elm$core$Basics$ceiling = _Basics_ceiling;
var $elm$core$Basics$fdiv = _Basics_fdiv;
var $elm$core$Basics$logBase = F2(
	function (base, number) {
		return _Basics_log(number) / _Basics_log(base);
	});
var $elm$core$Basics$toFloat = _Basics_toFloat;
var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling(
	A2($elm$core$Basics$logBase, 2, $elm$core$Array$branchFactor));
var $elm$core$Array$empty = A4($elm$core$Array$Array_elm_builtin, 0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
var $elm$core$Array$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $elm$core$Basics$apL = F2(
	function (f, x) {
		return f(x);
	});
var $elm$core$Basics$apR = F2(
	function (x, f) {
		return f(x);
	});
var $elm$core$Basics$eq = _Utils_equal;
var $elm$core$Basics$floor = _Basics_floor;
var $elm$core$Elm$JsArray$length = _JsArray_length;
var $elm$core$Basics$gt = _Utils_gt;
var $elm$core$Basics$max = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) > 0) ? x : y;
	});
var $elm$core$Basics$mul = _Basics_mul;
var $elm$core$Array$SubTree = function (a) {
	return {$: 'SubTree', a: a};
};
var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
var $elm$core$Array$compressNodes = F2(
	function (nodes, acc) {
		compressNodes:
		while (true) {
			var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodes);
			var node = _v0.a;
			var remainingNodes = _v0.b;
			var newAcc = A2(
				$elm$core$List$cons,
				$elm$core$Array$SubTree(node),
				acc);
			if (!remainingNodes.b) {
				return $elm$core$List$reverse(newAcc);
			} else {
				var $temp$nodes = remainingNodes,
					$temp$acc = newAcc;
				nodes = $temp$nodes;
				acc = $temp$acc;
				continue compressNodes;
			}
		}
	});
var $elm$core$Tuple$first = function (_v0) {
	var x = _v0.a;
	return x;
};
var $elm$core$Array$treeFromBuilder = F2(
	function (nodeList, nodeListSize) {
		treeFromBuilder:
		while (true) {
			var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
			if (newNodeSize === 1) {
				return A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodeList).a;
			} else {
				var $temp$nodeList = A2($elm$core$Array$compressNodes, nodeList, _List_Nil),
					$temp$nodeListSize = newNodeSize;
				nodeList = $temp$nodeList;
				nodeListSize = $temp$nodeListSize;
				continue treeFromBuilder;
			}
		}
	});
var $elm$core$Array$builderToArray = F2(
	function (reverseNodeList, builder) {
		if (!builder.nodeListSize) {
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail),
				$elm$core$Array$shiftStep,
				$elm$core$Elm$JsArray$empty,
				builder.tail);
		} else {
			var treeLen = builder.nodeListSize * $elm$core$Array$branchFactor;
			var depth = $elm$core$Basics$floor(
				A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, treeLen - 1));
			var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.nodeList) : builder.nodeList;
			var tree = A2($elm$core$Array$treeFromBuilder, correctNodeList, builder.nodeListSize);
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail) + treeLen,
				A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep),
				tree,
				builder.tail);
		}
	});
var $elm$core$Basics$idiv = _Basics_idiv;
var $elm$core$Basics$lt = _Utils_lt;
var $elm$core$Array$initializeHelp = F5(
	function (fn, fromIndex, len, nodeList, tail) {
		initializeHelp:
		while (true) {
			if (fromIndex < 0) {
				return A2(
					$elm$core$Array$builderToArray,
					false,
					{nodeList: nodeList, nodeListSize: (len / $elm$core$Array$branchFactor) | 0, tail: tail});
			} else {
				var leaf = $elm$core$Array$Leaf(
					A3($elm$core$Elm$JsArray$initialize, $elm$core$Array$branchFactor, fromIndex, fn));
				var $temp$fn = fn,
					$temp$fromIndex = fromIndex - $elm$core$Array$branchFactor,
					$temp$len = len,
					$temp$nodeList = A2($elm$core$List$cons, leaf, nodeList),
					$temp$tail = tail;
				fn = $temp$fn;
				fromIndex = $temp$fromIndex;
				len = $temp$len;
				nodeList = $temp$nodeList;
				tail = $temp$tail;
				continue initializeHelp;
			}
		}
	});
var $elm$core$Basics$remainderBy = _Basics_remainderBy;
var $elm$core$Array$initialize = F2(
	function (len, fn) {
		if (len <= 0) {
			return $elm$core$Array$empty;
		} else {
			var tailLen = len % $elm$core$Array$branchFactor;
			var tail = A3($elm$core$Elm$JsArray$initialize, tailLen, len - tailLen, fn);
			var initialFromIndex = (len - tailLen) - $elm$core$Array$branchFactor;
			return A5($elm$core$Array$initializeHelp, fn, initialFromIndex, len, _List_Nil, tail);
		}
	});
var $elm$core$Basics$True = {$: 'True'};
var $elm$core$Result$isOk = function (result) {
	if (result.$ === 'Ok') {
		return true;
	} else {
		return false;
	}
};
var $elm$json$Json$Decode$andThen = _Json_andThen;
var $elm$json$Json$Decode$value = _Json_decodeValue;
var $author$project$Runner$askTestsCount = _Platform_incomingPort('askTestsCount', $elm$json$Json$Decode$value);
var $elm_explorations$test$Test$Runner$Failure$DuplicatedName = {$: 'DuplicatedName'};
var $elm_explorations$test$Test$Internal$ElmTestVariant__Batch = function (a) {
	return { __elmTestSymbol: __elmTestSymbol,$: 'ElmTestVariant__Batch', a: a};
};
var $elm_explorations$test$Test$Runner$Failure$EmptyList = {$: 'EmptyList'};
var $elm_explorations$test$Test$Runner$Failure$Invalid = function (a) {
	return {$: 'Invalid', a: a};
};
var $elm$core$List$foldrHelper = F4(
	function (fn, acc, ctr, ls) {
		if (!ls.b) {
			return acc;
		} else {
			var a = ls.a;
			var r1 = ls.b;
			if (!r1.b) {
				return A2(fn, a, acc);
			} else {
				var b = r1.a;
				var r2 = r1.b;
				if (!r2.b) {
					return A2(
						fn,
						a,
						A2(fn, b, acc));
				} else {
					var c = r2.a;
					var r3 = r2.b;
					if (!r3.b) {
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(fn, c, acc)));
					} else {
						var d = r3.a;
						var r4 = r3.b;
						var res = (ctr > 500) ? A3(
							$elm$core$List$foldl,
							fn,
							acc,
							$elm$core$List$reverse(r4)) : A4($elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(
									fn,
									c,
									A2(fn, d, res))));
					}
				}
			}
		}
	});
var $elm$core$List$foldr = F3(
	function (fn, acc, ls) {
		return A4($elm$core$List$foldrHelper, fn, acc, 0, ls);
	});
var $elm$core$List$append = F2(
	function (xs, ys) {
		if (!ys.b) {
			return xs;
		} else {
			return A3($elm$core$List$foldr, $elm$core$List$cons, ys, xs);
		}
	});
var $elm$core$List$concat = function (lists) {
	return A3($elm$core$List$foldr, $elm$core$List$append, _List_Nil, lists);
};
var $elm$core$List$map = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, acc) {
					return A2(
						$elm$core$List$cons,
						f(x),
						acc);
				}),
			_List_Nil,
			xs);
	});
var $elm$core$List$concatMap = F2(
	function (f, list) {
		return $elm$core$List$concat(
			A2($elm$core$List$map, f, list));
	});
var $elm$core$Basics$identity = function (x) {
	return x;
};
var $elm$core$Set$Set_elm_builtin = function (a) {
	return {$: 'Set_elm_builtin', a: a};
};
var $elm$core$Dict$RBEmpty_elm_builtin = {$: 'RBEmpty_elm_builtin'};
var $elm$core$Dict$empty = $elm$core$Dict$RBEmpty_elm_builtin;
var $elm$core$Set$empty = $elm$core$Set$Set_elm_builtin($elm$core$Dict$empty);
var $elm$core$Dict$Black = {$: 'Black'};
var $elm$core$Dict$RBNode_elm_builtin = F5(
	function (a, b, c, d, e) {
		return {$: 'RBNode_elm_builtin', a: a, b: b, c: c, d: d, e: e};
	});
var $elm$core$Dict$Red = {$: 'Red'};
var $elm$core$Dict$balance = F5(
	function (color, key, value, left, right) {
		if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Red')) {
			var _v1 = right.a;
			var rK = right.b;
			var rV = right.c;
			var rLeft = right.d;
			var rRight = right.e;
			if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
				var _v3 = left.a;
				var lK = left.b;
				var lV = left.c;
				var lLeft = left.d;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					key,
					value,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					rK,
					rV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, left, rLeft),
					rRight);
			}
		} else {
			if ((((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) && (left.d.$ === 'RBNode_elm_builtin')) && (left.d.a.$ === 'Red')) {
				var _v5 = left.a;
				var lK = left.b;
				var lV = left.c;
				var _v6 = left.d;
				var _v7 = _v6.a;
				var llK = _v6.b;
				var llV = _v6.c;
				var llLeft = _v6.d;
				var llRight = _v6.e;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					lK,
					lV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, lRight, right));
			} else {
				return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, left, right);
			}
		}
	});
var $elm$core$Basics$compare = _Utils_compare;
var $elm$core$Dict$insertHelp = F3(
	function (key, value, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
		} else {
			var nColor = dict.a;
			var nKey = dict.b;
			var nValue = dict.c;
			var nLeft = dict.d;
			var nRight = dict.e;
			var _v1 = A2($elm$core$Basics$compare, key, nKey);
			switch (_v1.$) {
				case 'LT':
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						A3($elm$core$Dict$insertHelp, key, value, nLeft),
						nRight);
				case 'EQ':
					return A5($elm$core$Dict$RBNode_elm_builtin, nColor, nKey, value, nLeft, nRight);
				default:
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						nLeft,
						A3($elm$core$Dict$insertHelp, key, value, nRight));
			}
		}
	});
var $elm$core$Dict$insert = F3(
	function (key, value, dict) {
		var _v0 = A3($elm$core$Dict$insertHelp, key, value, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $elm$core$Set$insert = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return $elm$core$Set$Set_elm_builtin(
			A3($elm$core$Dict$insert, key, _Utils_Tuple0, dict));
	});
var $elm$core$Dict$isEmpty = function (dict) {
	if (dict.$ === 'RBEmpty_elm_builtin') {
		return true;
	} else {
		return false;
	}
};
var $elm$core$Set$isEmpty = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$isEmpty(dict);
};
var $elm$core$Dict$get = F2(
	function (targetKey, dict) {
		get:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return $elm$core$Maybe$Nothing;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var _v1 = A2($elm$core$Basics$compare, targetKey, key);
				switch (_v1.$) {
					case 'LT':
						var $temp$targetKey = targetKey,
							$temp$dict = left;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
					case 'EQ':
						return $elm$core$Maybe$Just(value);
					default:
						var $temp$targetKey = targetKey,
							$temp$dict = right;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
				}
			}
		}
	});
var $elm$core$Dict$member = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$get, key, dict);
		if (_v0.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var $elm$core$Set$member = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return A2($elm$core$Dict$member, key, dict);
	});
var $elm_explorations$test$Test$Internal$duplicatedName = function (tests) {
	var names = function (test) {
		names:
		while (true) {
			switch (test.$) {
				case 'ElmTestVariant__Labeled':
					var str = test.a;
					return _List_fromArray(
						[str]);
				case 'ElmTestVariant__Batch':
					var subtests = test.a;
					return A2($elm$core$List$concatMap, names, subtests);
				case 'ElmTestVariant__UnitTest':
					return _List_Nil;
				case 'ElmTestVariant__FuzzTest':
					return _List_Nil;
				case 'ElmTestVariant__Skipped':
					var subTest = test.a;
					var $temp$test = subTest;
					test = $temp$test;
					continue names;
				default:
					var subTest = test.a;
					var $temp$test = subTest;
					test = $temp$test;
					continue names;
			}
		}
	};
	var accumDuplicates = F2(
		function (newName, _v2) {
			var dups = _v2.a;
			var uniques = _v2.b;
			return A2($elm$core$Set$member, newName, uniques) ? _Utils_Tuple2(
				A2($elm$core$Set$insert, newName, dups),
				uniques) : _Utils_Tuple2(
				dups,
				A2($elm$core$Set$insert, newName, uniques));
		});
	var _v1 = A3(
		$elm$core$List$foldl,
		accumDuplicates,
		_Utils_Tuple2($elm$core$Set$empty, $elm$core$Set$empty),
		A2($elm$core$List$concatMap, names, tests));
	var dupsAccum = _v1.a;
	var uniquesAccum = _v1.b;
	return $elm$core$Set$isEmpty(dupsAccum) ? $elm$core$Result$Ok(uniquesAccum) : $elm$core$Result$Err(dupsAccum);
};
var $elm_explorations$test$Test$Internal$ElmTestVariant__UnitTest = function (a) {
	return { __elmTestSymbol: __elmTestSymbol,$: 'ElmTestVariant__UnitTest', a: a};
};
var $elm_explorations$test$Test$Expectation$Fail = function (a) {
	return {$: 'Fail', a: a};
};
var $elm_explorations$test$Test$Distribution$NoDistribution = {$: 'NoDistribution'};
var $elm_explorations$test$Test$Expectation$fail = function (_v0) {
	var description = _v0.description;
	var reason = _v0.reason;
	return $elm_explorations$test$Test$Expectation$Fail(
		{description: description, distributionReport: $elm_explorations$test$Test$Distribution$NoDistribution, given: $elm$core$Maybe$Nothing, reason: reason});
};
var $elm_explorations$test$Test$Internal$failNow = function (record) {
	return $elm_explorations$test$Test$Internal$ElmTestVariant__UnitTest(
		function (_v0) {
			return _List_fromArray(
				[
					$elm_explorations$test$Test$Expectation$fail(record)
				]);
		});
};
var $elm$core$List$isEmpty = function (xs) {
	if (!xs.b) {
		return true;
	} else {
		return false;
	}
};
var $elm_explorations$test$Test$concat = function (tests) {
	if ($elm$core$List$isEmpty(tests)) {
		return $elm_explorations$test$Test$Internal$failNow(
			{
				description: 'This `concat` has no tests in it. Let\'s give it some!',
				reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$EmptyList)
			});
	} else {
		var _v0 = $elm_explorations$test$Test$Internal$duplicatedName(tests);
		if (_v0.$ === 'Err') {
			var dups = _v0.a;
			var dupDescription = function (duped) {
				return 'A test group contains multiple tests named \'' + (duped + '\'. Do some renaming so that tests have unique names.');
			};
			return $elm_explorations$test$Test$Internal$failNow(
				{
					description: A2(
						$elm$core$String$join,
						'\n',
						A2(
							$elm$core$List$map,
							dupDescription,
							$elm$core$Set$toList(dups))),
					reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$DuplicatedName)
				});
		} else {
			return $elm_explorations$test$Test$Internal$ElmTestVariant__Batch(tests);
		}
	}
};
var $elm$json$Json$Decode$field = _Json_decodeField;
var $elm$json$Json$Decode$int = _Json_decodeInt;
var $elm$json$Json$Decode$map = _Json_map1;
var $elm$json$Json$Decode$null = _Json_decodeNull;
var $elm$json$Json$Decode$oneOf = _Json_oneOf;
var $author$project$Runner$receiveRunTest = _Platform_incomingPort('receiveRunTest', $elm$json$Json$Decode$int);
var $elm$json$Json$Encode$int = _Json_wrap;
var $elm$json$Json$Encode$object = function (pairs) {
	return _Json_wrap(
		A3(
			$elm$core$List$foldl,
			F2(
				function (_v0, obj) {
					var k = _v0.a;
					var v = _v0.b;
					return A3(_Json_addField, k, v, obj);
				}),
			_Json_emptyObject(_Utils_Tuple0),
			pairs));
};
var $author$project$Runner$sendResult = _Platform_outgoingPort(
	'sendResult',
	function ($) {
		return $elm$json$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'id',
					$elm$json$Json$Encode$int($.id)),
					_Utils_Tuple2(
					'result',
					$elm$core$Basics$identity($.result))
				]));
	});
var $elm$json$Json$Encode$string = _Json_wrap;
var $author$project$Runner$sendTestsCount = _Platform_outgoingPort(
	'sendTestsCount',
	function ($) {
		return $elm$json$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'kind',
					$elm$json$Json$Encode$string($.kind)),
					_Utils_Tuple2(
					'testsCount',
					$elm$json$Json$Encode$int($.testsCount))
				]));
	});
var $elm$json$Json$Decode$string = _Json_decodeString;
var $elm$json$Json$Decode$succeed = _Json_succeed;
var $author$project$NoUnsortedCases$DeclarationOrder = {$: 'DeclarationOrder'};
var $author$project$NoUnsortedCases$Elementwise = {$: 'Elementwise'};
var $author$project$NoUnsortedCases$RuleConfig = function (a) {
	return {$: 'RuleConfig', a: a};
};
var $author$project$NoUnsortedCases$defaults = $author$project$NoUnsortedCases$RuleConfig(
	{
		lookPastUnsortable: true,
		sortLists: $author$project$NoUnsortedCases$Elementwise,
		sortLiterals: true,
		sortTypesFromDependencies: $author$project$NoUnsortedCases$DeclarationOrder,
		sortablePredicate: F2(
			function (_v0, _v1) {
				return true;
			})
	});
var $elm_explorations$test$Test$Runner$Failure$BadDescription = {$: 'BadDescription'};
var $elm_explorations$test$Test$Internal$ElmTestVariant__Labeled = F2(
	function (a, b) {
		return { __elmTestSymbol: __elmTestSymbol,$: 'ElmTestVariant__Labeled', a: a, b: b};
	});
var $elm$core$String$isEmpty = function (string) {
	return string === '';
};
var $elm$core$String$trim = _String_trim;
var $elm_explorations$test$Test$describe = F2(
	function (untrimmedDesc, tests) {
		var desc = $elm$core$String$trim(untrimmedDesc);
		if ($elm$core$String$isEmpty(desc)) {
			return $elm_explorations$test$Test$Internal$failNow(
				{
					description: 'This `describe` has a blank description. Let\'s give it a useful one!',
					reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$BadDescription)
				});
		} else {
			if ($elm$core$List$isEmpty(tests)) {
				return $elm_explorations$test$Test$Internal$failNow(
					{
						description: 'This `describe ' + (desc + '` has no tests in it. Let\'s give it some!'),
						reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$EmptyList)
					});
			} else {
				var _v0 = $elm_explorations$test$Test$Internal$duplicatedName(tests);
				if (_v0.$ === 'Err') {
					var dups = _v0.a;
					var dupDescription = function (duped) {
						return 'Contains multiple tests named \'' + (duped + '\'. Let\'s rename them so we know which is which.');
					};
					return A2(
						$elm_explorations$test$Test$Internal$ElmTestVariant__Labeled,
						desc,
						$elm_explorations$test$Test$Internal$failNow(
							{
								description: A2(
									$elm$core$String$join,
									'\n',
									A2(
										$elm$core$List$map,
										dupDescription,
										$elm$core$Set$toList(dups))),
								reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$DuplicatedName)
							}));
				} else {
					var childrenNames = _v0.a;
					return A2($elm$core$Set$member, desc, childrenNames) ? A2(
						$elm_explorations$test$Test$Internal$ElmTestVariant__Labeled,
						desc,
						$elm_explorations$test$Test$Internal$failNow(
							{
								description: 'The test \'' + (desc + '\' contains a child test of the same name. Let\'s rename them so we know which is which.'),
								reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$DuplicatedName)
							})) : A2(
						$elm_explorations$test$Test$Internal$ElmTestVariant__Labeled,
						desc,
						$elm_explorations$test$Test$Internal$ElmTestVariant__Batch(tests));
				}
			}
		}
	});
var $elm_explorations$test$Test$Expectation$Pass = function (a) {
	return {$: 'Pass', a: a};
};
var $elm_explorations$test$Expect$pass = $elm_explorations$test$Test$Expectation$Pass(
	{distributionReport: $elm_explorations$test$Test$Distribution$NoDistribution});
var $elm_explorations$test$Expect$allHelp = F2(
	function (list, query) {
		allHelp:
		while (true) {
			if (!list.b) {
				return $elm_explorations$test$Expect$pass;
			} else {
				var check = list.a;
				var rest = list.b;
				var _v1 = check(query);
				if (_v1.$ === 'Pass') {
					var $temp$list = rest,
						$temp$query = query;
					list = $temp$list;
					query = $temp$query;
					continue allHelp;
				} else {
					var outcome = _v1;
					return outcome;
				}
			}
		}
	});
var $elm_explorations$test$Expect$all = F2(
	function (list, query) {
		return $elm$core$List$isEmpty(list) ? $elm_explorations$test$Test$Expectation$fail(
			{
				description: 'Expect.all was given an empty list. You must make at least one expectation to have a valid test!',
				reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$EmptyList)
			}) : A2($elm_explorations$test$Expect$allHelp, list, query);
	});
var $elm$core$Basics$always = F2(
	function (a, _v0) {
		return a;
	});
var $elm$core$String$concat = function (strings) {
	return A2($elm$core$String$join, '', strings);
};
var $jfmengels$elm_review$Ansi$bold = function (text) {
	return $elm$core$String$concat(
		_List_fromArray(
			['\u001B[1m', text, '\u001B[22m']));
};
var $elm$core$Basics$composeR = F3(
	function (f, g, x) {
		return g(
			f(x));
	});
var $jfmengels$elm_review$Ansi$noColor = '\u001B[39m';
var $jfmengels$elm_review$Ansi$applyColor = F2(
	function (color, string) {
		return $elm$core$String$concat(
			_List_fromArray(
				['\u001B[' + (color + 'm'), string, $jfmengels$elm_review$Ansi$noColor]));
	});
var $jfmengels$elm_review$Ansi$red = $jfmengels$elm_review$Ansi$applyColor('31');
var $jfmengels$elm_review$Review$Test$FailureMessage$failureMessage = F2(
	function (title, content) {
		return A2($elm$core$Basics$composeR, $jfmengels$elm_review$Ansi$bold, $jfmengels$elm_review$Ansi$red)(title) + ('\n\n' + content);
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes = function (string) {
	return '`' + (string + '`');
};
var $jfmengels$elm_review$Review$Test$FailureMessage$emptyDetails = function (errorMessage) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'EMPTY ERROR DETAILS',
		'I found an error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(errorMessage) + '\n\nbut its details were empty. I require having details as I believe they will\nhelp the user who encounters the problem.\n\nThe details could:\n- explain what the problem is\n- explain the reasoning behind the problem\n- give suggestions on how to solve the problem or alternatives'));
};
var $elm_explorations$test$Test$Runner$Failure$Equality = F2(
	function (a, b) {
		return {$: 'Equality', a: a, b: b};
	});
var $elm$core$String$contains = _String_contains;
var $elm_explorations$test$Test$Runner$Failure$Custom = {$: 'Custom'};
var $elm_explorations$test$Expect$fail = function (str) {
	return $elm_explorations$test$Test$Expectation$fail(
		{description: str, reason: $elm_explorations$test$Test$Runner$Failure$Custom});
};
var $elm$core$Basics$not = _Basics_not;
var $elm_explorations$test$Test$Internal$toString = _Debug_toString;
var $elm_explorations$test$Expect$testWith = F5(
	function (makeReason, label, runTest, expected, actual) {
		return A2(runTest, actual, expected) ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Test$Expectation$fail(
			{
				description: label,
				reason: A2(
					makeReason,
					$elm_explorations$test$Test$Internal$toString(expected),
					$elm_explorations$test$Test$Internal$toString(actual))
			});
	});
var $elm$core$String$toFloat = _String_toFloat;
var $elm$core$String$toInt = _String_toInt;
var $elm_explorations$test$Expect$equateWith = F4(
	function (reason, comparison, b, a) {
		var isJust = function (x) {
			if (x.$ === 'Just') {
				return true;
			} else {
				return false;
			}
		};
		var isFloat = function (x) {
			return isJust(
				$elm$core$String$toFloat(x)) && (!isJust(
				$elm$core$String$toInt(x)));
		};
		var usesFloats = isFloat(
			$elm_explorations$test$Test$Internal$toString(a)) || isFloat(
			$elm_explorations$test$Test$Internal$toString(b));
		var floatError = A2($elm$core$String$contains, reason, 'not') ? 'Do not use Expect.notEqual with floats. Use Expect.notWithin instead.' : 'Do not use Expect.equal with floats. Use Expect.within instead.';
		return usesFloats ? $elm_explorations$test$Expect$fail(floatError) : A5($elm_explorations$test$Expect$testWith, $elm_explorations$test$Test$Runner$Failure$Equality, reason, comparison, b, a);
	});
var $elm_explorations$test$Expect$equal = A2($elm_explorations$test$Expect$equateWith, 'Expect.equal', $elm$core$Basics$eq);
var $jfmengels$elm_review$Review$Rule$errorDetails = function (_v0) {
	var err = _v0.a;
	return err.details;
};
var $jfmengels$elm_review$Review$Rule$errorMessage = function (_v0) {
	var err = _v0.a;
	return err.message;
};
var $elm_explorations$test$Expect$onFail = F2(
	function (str, expectation) {
		if (expectation.$ === 'Pass') {
			return expectation;
		} else {
			var failure = expectation.a;
			return $elm_explorations$test$Test$Expectation$Fail(
				_Utils_update(
					failure,
					{description: str, reason: $elm_explorations$test$Test$Runner$Failure$Custom}));
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$formatDetails = function (details) {
	if (details.b && (!details.b.b)) {
		var detail = details.a;
		return $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(detail);
	} else {
		var details_ = details;
		return function (str) {
			return '```\n' + (str + '\n  ```');
		}(
			A2(
				$elm$core$String$join,
				'\n\n',
				A2(
					$elm$core$List$map,
					function (str) {
						return '  ' + str;
					},
					details_)));
	}
};
var $jfmengels$elm_review$Review$Test$FailureMessage$unexpectedDetails = F2(
	function (expectedDetails, error) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED ERROR DETAILS',
			'I found an error for a file with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nand I was expecting its details to be:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(expectedDetails) + ('\n\nbut I found these details:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(
				$jfmengels$elm_review$Review$Rule$errorDetails(error)))))));
	});
var $jfmengels$elm_review$Review$Test$checkDetailsAreCorrect = F2(
	function (error_, _v0) {
		var expectedError = _v0.a;
		return $elm_explorations$test$Expect$all(
			_List_fromArray(
				[
					function (_v1) {
					return A2(
						$elm_explorations$test$Expect$onFail,
						$jfmengels$elm_review$Review$Test$FailureMessage$emptyDetails(
							$jfmengels$elm_review$Review$Rule$errorMessage(error_)),
						A2(
							$elm_explorations$test$Expect$equal,
							false,
							$elm$core$List$isEmpty(
								$jfmengels$elm_review$Review$Rule$errorDetails(error_))));
				},
					function (_v2) {
					return A2(
						$elm_explorations$test$Expect$onFail,
						A2($jfmengels$elm_review$Review$Test$FailureMessage$unexpectedDetails, expectedError.details, error_),
						A2(
							$elm_explorations$test$Expect$equal,
							expectedError.details,
							$jfmengels$elm_review$Review$Rule$errorDetails(error_)));
				}
				]));
	});
var $jfmengels$elm_review$Review$Test$getUnder = function (_v0) {
	var expectedError = _v0.a;
	var _v1 = expectedError.under;
	if (_v1.$ === 'Under') {
		var str = _v1.a;
		return str;
	} else {
		var str = _v1.a;
		return str;
	}
};
var $jfmengels$elm_review$Review$Test$extractExpectedErrorData = function (expectedError) {
	var expectedErrorContent = expectedError.a;
	return {
		details: expectedErrorContent.details,
		message: expectedErrorContent.message,
		under: $jfmengels$elm_review$Review$Test$getUnder(expectedError)
	};
};
var $jfmengels$elm_review$Review$Fix$Errored = function (a) {
	return {$: 'Errored', a: a};
};
var $jfmengels$elm_review$Review$Fix$Unchanged = {$: 'Unchanged'};
var $elm$json$Json$Decode$decodeString = _Json_runOnString;
var $elm$project_metadata_utils$Elm$Project$Application = function (a) {
	return {$: 'Application', a: a};
};
var $elm$project_metadata_utils$Elm$Project$Package = function (a) {
	return {$: 'Package', a: a};
};
var $elm$project_metadata_utils$Elm$Project$ApplicationInfo = F6(
	function (elm, dirs, depsDirect, depsIndirect, testDepsDirect, testDepsIndirect) {
		return {depsDirect: depsDirect, depsIndirect: depsIndirect, dirs: dirs, elm: elm, testDepsDirect: testDepsDirect, testDepsIndirect: testDepsIndirect};
	});
var $elm$json$Json$Decode$at = F2(
	function (fields, decoder) {
		return A3($elm$core$List$foldr, $elm$json$Json$Decode$field, decoder, fields);
	});
var $elm$json$Json$Decode$fail = _Json_fail;
var $elm$project_metadata_utils$Elm$Version$Version = F3(
	function (a, b, c) {
		return {$: 'Version', a: a, b: b, c: c};
	});
var $elm$core$Basics$ge = _Utils_ge;
var $elm$project_metadata_utils$Elm$Version$checkNumbers = F3(
	function (major, minor, patch) {
		return ((major >= 0) && ((minor >= 0) && (patch >= 0))) ? $elm$core$Maybe$Just(
			A3($elm$project_metadata_utils$Elm$Version$Version, major, minor, patch)) : $elm$core$Maybe$Nothing;
	});
var $elm$project_metadata_utils$Elm$Version$fromString = function (string) {
	var _v0 = A2(
		$elm$core$List$map,
		$elm$core$String$toInt,
		A2($elm$core$String$split, '.', string));
	if ((((((_v0.b && (_v0.a.$ === 'Just')) && _v0.b.b) && (_v0.b.a.$ === 'Just')) && _v0.b.b.b) && (_v0.b.b.a.$ === 'Just')) && (!_v0.b.b.b.b)) {
		var major = _v0.a.a;
		var _v1 = _v0.b;
		var minor = _v1.a.a;
		var _v2 = _v1.b;
		var patch = _v2.a.a;
		return A3($elm$project_metadata_utils$Elm$Version$checkNumbers, major, minor, patch);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$project_metadata_utils$Elm$Version$decoderHelp = function (string) {
	var _v0 = $elm$project_metadata_utils$Elm$Version$fromString(string);
	if (_v0.$ === 'Just') {
		var version = _v0.a;
		return $elm$json$Json$Decode$succeed(version);
	} else {
		return $elm$json$Json$Decode$fail('I need a valid version like \"2.0.1\"');
	}
};
var $elm$project_metadata_utils$Elm$Version$decoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$Version$decoderHelp, $elm$json$Json$Decode$string);
var $elm$json$Json$Decode$keyValuePairs = _Json_decodeKeyValuePairs;
var $elm$project_metadata_utils$Elm$Package$Name = F2(
	function (a, b) {
		return {$: 'Name', a: a, b: b};
	});
var $elm$core$String$any = _String_any;
var $elm$project_metadata_utils$Elm$Package$isBadChar = function (_char) {
	return $elm$core$Char$isUpper(_char) || (_Utils_eq(
		_char,
		_Utils_chr('.')) || _Utils_eq(
		_char,
		_Utils_chr('_')));
};
var $elm$core$String$startsWith = _String_startsWith;
var $elm$project_metadata_utils$Elm$Package$isBadProjectName = function (project) {
	var _v0 = $elm$core$String$uncons(project);
	if (_v0.$ === 'Nothing') {
		return true;
	} else {
		var _v1 = _v0.a;
		var c = _v1.a;
		return A2($elm$core$String$contains, '--', project) || (A2($elm$core$String$any, $elm$project_metadata_utils$Elm$Package$isBadChar, project) || (A2($elm$core$String$startsWith, '-', project) || (!$elm$core$Char$isLower(c))));
	}
};
var $elm$project_metadata_utils$Elm$Package$fromString = function (string) {
	var _v0 = A2($elm$core$String$split, '/', string);
	if ((_v0.b && _v0.b.b) && (!_v0.b.b.b)) {
		var author = _v0.a;
		var _v1 = _v0.b;
		var project = _v1.a;
		return $elm$project_metadata_utils$Elm$Package$isBadProjectName(project) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
			A2($elm$project_metadata_utils$Elm$Package$Name, author, project));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$project_metadata_utils$Elm$Project$verifyDepNames = F2(
	function (revDeps, pairs) {
		verifyDepNames:
		while (true) {
			if (!pairs.b) {
				return $elm$json$Json$Decode$succeed(
					$elm$core$List$reverse(revDeps));
			} else {
				var _v1 = pairs.a;
				var key = _v1.a;
				var con = _v1.b;
				var otherPairs = pairs.b;
				var _v2 = $elm$project_metadata_utils$Elm$Package$fromString(key);
				if (_v2.$ === 'Just') {
					var pkg = _v2.a;
					var $temp$revDeps = A2(
						$elm$core$List$cons,
						_Utils_Tuple2(pkg, con),
						revDeps),
						$temp$pairs = otherPairs;
					revDeps = $temp$revDeps;
					pairs = $temp$pairs;
					continue verifyDepNames;
				} else {
					return $elm$json$Json$Decode$fail('\"' + (key + '\" is not a valid package name.'));
				}
			}
		}
	});
var $elm$project_metadata_utils$Elm$Project$depsDecoder = function (constraintDecoder) {
	return A2(
		$elm$json$Json$Decode$andThen,
		$elm$project_metadata_utils$Elm$Project$verifyDepNames(_List_Nil),
		$elm$json$Json$Decode$keyValuePairs(constraintDecoder));
};
var $elm$json$Json$Decode$list = _Json_decodeList;
var $elm$json$Json$Decode$map6 = _Json_map6;
var $elm$project_metadata_utils$Elm$Project$applicationDecoder = A7(
	$elm$json$Json$Decode$map6,
	$elm$project_metadata_utils$Elm$Project$ApplicationInfo,
	A2($elm$json$Json$Decode$field, 'elm-version', $elm$project_metadata_utils$Elm$Version$decoder),
	A2(
		$elm$json$Json$Decode$field,
		'source-directories',
		$elm$json$Json$Decode$list($elm$json$Json$Decode$string)),
	A2(
		$elm$json$Json$Decode$at,
		_List_fromArray(
			['dependencies', 'direct']),
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Version$decoder)),
	A2(
		$elm$json$Json$Decode$at,
		_List_fromArray(
			['dependencies', 'indirect']),
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Version$decoder)),
	A2(
		$elm$json$Json$Decode$at,
		_List_fromArray(
			['test-dependencies', 'direct']),
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Version$decoder)),
	A2(
		$elm$json$Json$Decode$at,
		_List_fromArray(
			['test-dependencies', 'indirect']),
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Version$decoder)));
var $elm$project_metadata_utils$Elm$Project$PackageInfo = F8(
	function (name, summary, license, version, exposed, deps, testDeps, elm) {
		return {deps: deps, elm: elm, exposed: exposed, license: license, name: name, summary: summary, testDeps: testDeps, version: version};
	});
var $elm$project_metadata_utils$Elm$Constraint$Constraint = F4(
	function (a, b, c, d) {
		return {$: 'Constraint', a: a, b: b, c: c, d: d};
	});
var $elm$core$Maybe$andThen = F2(
	function (callback, maybeValue) {
		if (maybeValue.$ === 'Just') {
			var value = maybeValue.a;
			return callback(value);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $elm$project_metadata_utils$Elm$Version$compare = F2(
	function (_v0, _v1) {
		var major1 = _v0.a;
		var minor1 = _v0.b;
		var patch1 = _v0.c;
		var major2 = _v1.a;
		var minor2 = _v1.b;
		var patch2 = _v1.c;
		var _v2 = A2($elm$core$Basics$compare, major1, major2);
		switch (_v2.$) {
			case 'LT':
				return $elm$core$Basics$LT;
			case 'GT':
				return $elm$core$Basics$GT;
			default:
				var _v3 = A2($elm$core$Basics$compare, minor1, minor2);
				switch (_v3.$) {
					case 'LT':
						return $elm$core$Basics$LT;
					case 'EQ':
						return A2($elm$core$Basics$compare, patch1, patch2);
					default:
						return $elm$core$Basics$GT;
				}
		}
	});
var $elm$project_metadata_utils$Elm$Constraint$checkConstraint = function (constraint) {
	var lower = constraint.a;
	var upper = constraint.d;
	var _v0 = A2($elm$project_metadata_utils$Elm$Version$compare, lower, upper);
	switch (_v0.$) {
		case 'LT':
			return $elm$core$Maybe$Just(constraint);
		case 'EQ':
			return $elm$core$Maybe$Just(constraint);
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $elm$core$Maybe$map4 = F5(
	function (func, ma, mb, mc, md) {
		if (ma.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var a = ma.a;
			if (mb.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var b = mb.a;
				if (mc.$ === 'Nothing') {
					return $elm$core$Maybe$Nothing;
				} else {
					var c = mc.a;
					if (md.$ === 'Nothing') {
						return $elm$core$Maybe$Nothing;
					} else {
						var d = md.a;
						return $elm$core$Maybe$Just(
							A4(func, a, b, c, d));
					}
				}
			}
		}
	});
var $elm$project_metadata_utils$Elm$Constraint$LessOrEq = {$: 'LessOrEq'};
var $elm$project_metadata_utils$Elm$Constraint$LessThan = {$: 'LessThan'};
var $elm$project_metadata_utils$Elm$Constraint$opFromString = function (op) {
	switch (op) {
		case '<':
			return $elm$core$Maybe$Just($elm$project_metadata_utils$Elm$Constraint$LessThan);
		case '<=':
			return $elm$core$Maybe$Just($elm$project_metadata_utils$Elm$Constraint$LessOrEq);
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $elm$project_metadata_utils$Elm$Constraint$fromString = function (string) {
	var _v0 = A2($elm$core$String$split, ' ', string);
	if ((((((_v0.b && _v0.b.b) && _v0.b.b.b) && (_v0.b.b.a === 'v')) && _v0.b.b.b.b) && _v0.b.b.b.b.b) && (!_v0.b.b.b.b.b.b)) {
		var lower = _v0.a;
		var _v1 = _v0.b;
		var lop = _v1.a;
		var _v2 = _v1.b;
		var _v3 = _v2.b;
		var uop = _v3.a;
		var _v4 = _v3.b;
		var upper = _v4.a;
		return A2(
			$elm$core$Maybe$andThen,
			$elm$project_metadata_utils$Elm$Constraint$checkConstraint,
			A5(
				$elm$core$Maybe$map4,
				$elm$project_metadata_utils$Elm$Constraint$Constraint,
				$elm$project_metadata_utils$Elm$Version$fromString(lower),
				$elm$project_metadata_utils$Elm$Constraint$opFromString(lop),
				$elm$project_metadata_utils$Elm$Constraint$opFromString(uop),
				$elm$project_metadata_utils$Elm$Version$fromString(upper)));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$project_metadata_utils$Elm$Constraint$decoderHelp = function (string) {
	var _v0 = $elm$project_metadata_utils$Elm$Constraint$fromString(string);
	if (_v0.$ === 'Just') {
		var constraint = _v0.a;
		return $elm$json$Json$Decode$succeed(constraint);
	} else {
		return $elm$json$Json$Decode$fail('I need a valid constraint like \"1.0.0 <= v < 2.0.0\"');
	}
};
var $elm$project_metadata_utils$Elm$Constraint$decoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$Constraint$decoderHelp, $elm$json$Json$Decode$string);
var $elm$core$Dict$fromList = function (assocs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, dict) {
				var key = _v0.a;
				var value = _v0.b;
				return A3($elm$core$Dict$insert, key, value, dict);
			}),
		$elm$core$Dict$empty,
		assocs);
};
var $elm$project_metadata_utils$Elm$License$License = F2(
	function (a, b) {
		return {$: 'License', a: a, b: b};
	});
var $elm$project_metadata_utils$Elm$License$osiApprovedSpdxLicenses = _List_fromArray(
	[
		A2($elm$project_metadata_utils$Elm$License$License, 'AFL-1.1', 'Academic Free License v1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AFL-1.2', 'Academic Free License v1.2'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AFL-2.0', 'Academic Free License v2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AFL-2.1', 'Academic Free License v2.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AFL-3.0', 'Academic Free License v3.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'APL-1.0', 'Adaptive Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Apache-1.1', 'Apache License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Apache-2.0', 'Apache License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'APSL-1.0', 'Apple Public Source License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'APSL-1.1', 'Apple Public Source License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'APSL-1.2', 'Apple Public Source License 1.2'),
		A2($elm$project_metadata_utils$Elm$License$License, 'APSL-2.0', 'Apple Public Source License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Artistic-1.0', 'Artistic License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Artistic-1.0-Perl', 'Artistic License 1.0 (Perl)'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Artistic-1.0-cl8', 'Artistic License 1.0 w/clause 8'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Artistic-2.0', 'Artistic License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AAL', 'Attribution Assurance License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'BSL-1.0', 'Boost Software License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'BSD-2-Clause', 'BSD 2-clause \"Simplified\" License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'BSD-3-Clause', 'BSD 3-clause \"New\" or \"Revised\" License'),
		A2($elm$project_metadata_utils$Elm$License$License, '0BSD', 'BSD Zero Clause License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CECILL-2.1', 'CeCILL Free Software License Agreement v2.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CNRI-Python', 'CNRI Python License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CDDL-1.0', 'Common Development and Distribution License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CPAL-1.0', 'Common Public Attribution License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CPL-1.0', 'Common Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CATOSL-1.1', 'Computer Associates Trusted Open Source License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'CUA-OPL-1.0', 'CUA Office Public License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'EPL-1.0', 'Eclipse Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'ECL-1.0', 'Educational Community License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'ECL-2.0', 'Educational Community License v2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'EFL-1.0', 'Eiffel Forum License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'EFL-2.0', 'Eiffel Forum License v2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Entessa', 'Entessa Public License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'EUDatagrid', 'EU DataGrid Software License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'EUPL-1.1', 'European Union Public License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Fair', 'Fair License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Frameworx-1.0', 'Frameworx Open License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'AGPL-3.0', 'GNU Affero General Public License v3.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'GPL-2.0', 'GNU General Public License v2.0 only'),
		A2($elm$project_metadata_utils$Elm$License$License, 'GPL-3.0', 'GNU General Public License v3.0 only'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LGPL-2.1', 'GNU Lesser General Public License v2.1 only'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LGPL-3.0', 'GNU Lesser General Public License v3.0 only'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LGPL-2.0', 'GNU Library General Public License v2 only'),
		A2($elm$project_metadata_utils$Elm$License$License, 'HPND', 'Historic Permission Notice and Disclaimer'),
		A2($elm$project_metadata_utils$Elm$License$License, 'IPL-1.0', 'IBM Public License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Intel', 'Intel Open Source License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'IPA', 'IPA Font License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'ISC', 'ISC License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LPPL-1.3c', 'LaTeX Project Public License v1.3c'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LiLiQ-P-1.1', 'Licence Libre du Qubec  Permissive version 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LiLiQ-Rplus-1.1', 'Licence Libre du Qubec  Rciprocit forte version 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LiLiQ-R-1.1', 'Licence Libre du Qubec  Rciprocit version 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LPL-1.02', 'Lucent Public License v1.02'),
		A2($elm$project_metadata_utils$Elm$License$License, 'LPL-1.0', 'Lucent Public License Version 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MS-PL', 'Microsoft Public License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MS-RL', 'Microsoft Reciprocal License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MirOS', 'MirOS Licence'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MIT', 'MIT License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Motosoto', 'Motosoto License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MPL-1.0', 'Mozilla Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MPL-1.1', 'Mozilla Public License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MPL-2.0', 'Mozilla Public License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'MPL-2.0-no-copyleft-exception', 'Mozilla Public License 2.0 (no copyleft exception)'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Multics', 'Multics License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'NASA-1.3', 'NASA Open Source Agreement 1.3'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Naumen', 'Naumen Public License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'NGPL', 'Nethack General Public License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Nokia', 'Nokia Open Source License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'NPOSL-3.0', 'Non-Profit Open Software License 3.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'NTP', 'NTP License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OCLC-2.0', 'OCLC Research Public License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OGTSL', 'Open Group Test Suite License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OSL-1.0', 'Open Software License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OSL-2.0', 'Open Software License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OSL-2.1', 'Open Software License 2.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OSL-3.0', 'Open Software License 3.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OSET-PL-2.1', 'OSET Public License version 2.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'PHP-3.0', 'PHP License v3.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'PostgreSQL', 'PostgreSQL License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Python-2.0', 'Python License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'QPL-1.0', 'Q Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'RPSL-1.0', 'RealNetworks Public Source License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'RPL-1.1', 'Reciprocal Public License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'RPL-1.5', 'Reciprocal Public License 1.5'),
		A2($elm$project_metadata_utils$Elm$License$License, 'RSCPL', 'Ricoh Source Code Public License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'OFL-1.1', 'SIL Open Font License 1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'SimPL-2.0', 'Simple Public License 2.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Sleepycat', 'Sleepycat License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'SISSL', 'Sun Industry Standards Source License v1.1'),
		A2($elm$project_metadata_utils$Elm$License$License, 'SPL-1.0', 'Sun Public License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Watcom-1.0', 'Sybase Open Watcom Public License 1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'UPL-1.0', 'Universal Permissive License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'NCSA', 'University of Illinois/NCSA Open Source License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'VSL-1.0', 'Vovida Software License v1.0'),
		A2($elm$project_metadata_utils$Elm$License$License, 'W3C', 'W3C Software Notice and License (2002-12-31)'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Xnet', 'X.Net License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'Zlib', 'zlib License'),
		A2($elm$project_metadata_utils$Elm$License$License, 'ZPL-2.0', 'Zope Public License 2.0')
	]);
var $elm$project_metadata_utils$Elm$License$spdxDict = $elm$core$Dict$fromList(
	A2(
		$elm$core$List$map,
		function (license) {
			var abbr = license.a;
			return _Utils_Tuple2(abbr, license);
		},
		$elm$project_metadata_utils$Elm$License$osiApprovedSpdxLicenses));
var $elm$project_metadata_utils$Elm$License$fromString = function (string) {
	return A2($elm$core$Dict$get, string, $elm$project_metadata_utils$Elm$License$spdxDict);
};
var $elm$project_metadata_utils$Elm$License$decoderHelp = function (string) {
	var _v0 = $elm$project_metadata_utils$Elm$License$fromString(string);
	if (_v0.$ === 'Just') {
		var license = _v0.a;
		return $elm$json$Json$Decode$succeed(license);
	} else {
		return $elm$json$Json$Decode$fail('I need an OSI approved license in SPDX format <https://spdx.org/licenses/>');
	}
};
var $elm$project_metadata_utils$Elm$License$decoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$License$decoderHelp, $elm$json$Json$Decode$string);
var $elm$project_metadata_utils$Elm$Package$decoderHelp = function (string) {
	var _v0 = $elm$project_metadata_utils$Elm$Package$fromString(string);
	if (_v0.$ === 'Just') {
		var name = _v0.a;
		return $elm$json$Json$Decode$succeed(name);
	} else {
		return $elm$json$Json$Decode$fail('I need a valid package name like \"elm/core\"');
	}
};
var $elm$project_metadata_utils$Elm$Package$decoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$Package$decoderHelp, $elm$json$Json$Decode$string);
var $elm$project_metadata_utils$Elm$Project$ExposedDict = function (a) {
	return {$: 'ExposedDict', a: a};
};
var $elm$project_metadata_utils$Elm$Project$ExposedList = function (a) {
	return {$: 'ExposedList', a: a};
};
var $elm$core$String$length = _String_length;
var $elm$project_metadata_utils$Elm$Project$checkHeaders = function (dict) {
	checkHeaders:
	while (true) {
		if (!dict.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			var _v1 = dict.a;
			var header = _v1.a;
			var others = dict.b;
			if ($elm$core$String$length(header) < 20) {
				var $temp$dict = others;
				dict = $temp$dict;
				continue checkHeaders;
			} else {
				return $elm$core$Maybe$Just(header);
			}
		}
	}
};
var $elm$project_metadata_utils$Elm$Project$checkExposedDict = function (dict) {
	var _v0 = $elm$project_metadata_utils$Elm$Project$checkHeaders(dict);
	if (_v0.$ === 'Nothing') {
		return $elm$json$Json$Decode$succeed(dict);
	} else {
		var badHeader = _v0.a;
		return $elm$json$Json$Decode$fail('The \"' + (badHeader + '\" header is too long. Twenty characters max!'));
	}
};
var $elm$project_metadata_utils$Elm$Module$Name = function (a) {
	return {$: 'Name', a: a};
};
var $elm$core$List$any = F2(
	function (isOkay, list) {
		any:
		while (true) {
			if (!list.b) {
				return false;
			} else {
				var x = list.a;
				var xs = list.b;
				if (isOkay(x)) {
					return true;
				} else {
					var $temp$isOkay = isOkay,
						$temp$list = xs;
					isOkay = $temp$isOkay;
					list = $temp$list;
					continue any;
				}
			}
		}
	});
var $elm$core$Basics$composeL = F3(
	function (g, f, x) {
		return g(
			f(x));
	});
var $elm$core$List$all = F2(
	function (isOkay, list) {
		return !A2(
			$elm$core$List$any,
			A2($elm$core$Basics$composeL, $elm$core$Basics$not, isOkay),
			list);
	});
var $elm$project_metadata_utils$Elm$Module$isInner = function (_char) {
	return $elm$core$Char$isAlphaNum(_char) || _Utils_eq(
		_char,
		_Utils_chr('_'));
};
var $elm$project_metadata_utils$Elm$Module$isGoodChunk = function (chunk) {
	var _v0 = $elm$core$String$uncons(chunk);
	if (_v0.$ === 'Nothing') {
		return false;
	} else {
		var _v1 = _v0.a;
		var _char = _v1.a;
		var rest = _v1.b;
		return $elm$core$Char$isUpper(_char) && A2($elm$core$String$all, $elm$project_metadata_utils$Elm$Module$isInner, rest);
	}
};
var $elm$project_metadata_utils$Elm$Module$fromString = function (string) {
	return A2(
		$elm$core$List$all,
		$elm$project_metadata_utils$Elm$Module$isGoodChunk,
		A2($elm$core$String$split, '.', string)) ? $elm$core$Maybe$Just(
		$elm$project_metadata_utils$Elm$Module$Name(string)) : $elm$core$Maybe$Nothing;
};
var $elm$project_metadata_utils$Elm$Module$decoderHelp = function (string) {
	var _v0 = $elm$project_metadata_utils$Elm$Module$fromString(string);
	if (_v0.$ === 'Just') {
		var name = _v0.a;
		return $elm$json$Json$Decode$succeed(name);
	} else {
		return $elm$json$Json$Decode$fail('I need a valid module name like \"Json.Decode\"');
	}
};
var $elm$project_metadata_utils$Elm$Module$decoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$Module$decoderHelp, $elm$json$Json$Decode$string);
var $elm$project_metadata_utils$Elm$Project$exposedDecoder = $elm$json$Json$Decode$oneOf(
	_List_fromArray(
		[
			A2(
			$elm$json$Json$Decode$map,
			$elm$project_metadata_utils$Elm$Project$ExposedList,
			$elm$json$Json$Decode$list($elm$project_metadata_utils$Elm$Module$decoder)),
			A2(
			$elm$json$Json$Decode$map,
			$elm$project_metadata_utils$Elm$Project$ExposedDict,
			A2(
				$elm$json$Json$Decode$andThen,
				$elm$project_metadata_utils$Elm$Project$checkExposedDict,
				$elm$json$Json$Decode$keyValuePairs(
					$elm$json$Json$Decode$list($elm$project_metadata_utils$Elm$Module$decoder))))
		]));
var $elm$json$Json$Decode$map8 = _Json_map8;
var $elm$project_metadata_utils$Elm$Project$summaryCheck = function (summary) {
	return ($elm$core$String$length(summary) < 80) ? $elm$json$Json$Decode$succeed(summary) : $elm$json$Json$Decode$fail('The \"summary\" field must have fewer than 80 characters.');
};
var $elm$project_metadata_utils$Elm$Project$summaryDecoder = A2($elm$json$Json$Decode$andThen, $elm$project_metadata_utils$Elm$Project$summaryCheck, $elm$json$Json$Decode$string);
var $elm$project_metadata_utils$Elm$Project$packageDecoder = A9(
	$elm$json$Json$Decode$map8,
	$elm$project_metadata_utils$Elm$Project$PackageInfo,
	A2($elm$json$Json$Decode$field, 'name', $elm$project_metadata_utils$Elm$Package$decoder),
	A2($elm$json$Json$Decode$field, 'summary', $elm$project_metadata_utils$Elm$Project$summaryDecoder),
	A2($elm$json$Json$Decode$field, 'license', $elm$project_metadata_utils$Elm$License$decoder),
	A2($elm$json$Json$Decode$field, 'version', $elm$project_metadata_utils$Elm$Version$decoder),
	A2($elm$json$Json$Decode$field, 'exposed-modules', $elm$project_metadata_utils$Elm$Project$exposedDecoder),
	A2(
		$elm$json$Json$Decode$field,
		'dependencies',
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Constraint$decoder)),
	A2(
		$elm$json$Json$Decode$field,
		'test-dependencies',
		$elm$project_metadata_utils$Elm$Project$depsDecoder($elm$project_metadata_utils$Elm$Constraint$decoder)),
	A2($elm$json$Json$Decode$field, 'elm-version', $elm$project_metadata_utils$Elm$Constraint$decoder));
var $elm$project_metadata_utils$Elm$Project$decoderHelp = function (tipe) {
	switch (tipe) {
		case 'application':
			return A2($elm$json$Json$Decode$map, $elm$project_metadata_utils$Elm$Project$Application, $elm$project_metadata_utils$Elm$Project$applicationDecoder);
		case 'package':
			return A2($elm$json$Json$Decode$map, $elm$project_metadata_utils$Elm$Project$Package, $elm$project_metadata_utils$Elm$Project$packageDecoder);
		default:
			var other = tipe;
			return $elm$json$Json$Decode$fail('The "type" field must be either "application" or "package", so ' + ('\"' + (other + '\" is not acceptable.')));
	}
};
var $elm$project_metadata_utils$Elm$Project$decoder = A2(
	$elm$json$Json$Decode$andThen,
	$elm$project_metadata_utils$Elm$Project$decoderHelp,
	A2($elm$json$Json$Decode$field, 'type', $elm$json$Json$Decode$string));
var $elm$core$Basics$neq = _Utils_notEqual;
var $stil4m$elm_syntax$Elm$Parser$State$State = function (a) {
	return {$: 'State', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$State$emptyState = $stil4m$elm_syntax$Elm$Parser$State$State(
	{comments: _List_Nil, indents: _List_Nil});
var $stil4m$elm_syntax$Elm$Syntax$File$File = F4(
	function (moduleDefinition, imports, declarations, comments) {
		return {comments: comments, declarations: declarations, imports: imports, moduleDefinition: moduleDefinition};
	});
var $stil4m$elm_syntax$Combine$Parser = function (a) {
	return {$: 'Parser', a: a};
};
var $elm$parser$Parser$Advanced$Bad = F2(
	function (a, b) {
		return {$: 'Bad', a: a, b: b};
	});
var $elm$parser$Parser$Advanced$Good = F3(
	function (a, b, c) {
		return {$: 'Good', a: a, b: b, c: c};
	});
var $elm$parser$Parser$Advanced$Parser = function (a) {
	return {$: 'Parser', a: a};
};
var $elm$parser$Parser$Advanced$andThen = F2(
	function (callback, _v0) {
		var parseA = _v0.a;
		return $elm$parser$Parser$Advanced$Parser(
			function (s0) {
				var _v1 = parseA(s0);
				if (_v1.$ === 'Bad') {
					var p = _v1.a;
					var x = _v1.b;
					return A2($elm$parser$Parser$Advanced$Bad, p, x);
				} else {
					var p1 = _v1.a;
					var a = _v1.b;
					var s1 = _v1.c;
					var _v2 = callback(a);
					var parseB = _v2.a;
					var _v3 = parseB(s1);
					if (_v3.$ === 'Bad') {
						var p2 = _v3.a;
						var x = _v3.b;
						return A2($elm$parser$Parser$Advanced$Bad, p1 || p2, x);
					} else {
						var p2 = _v3.a;
						var b = _v3.b;
						var s2 = _v3.c;
						return A3($elm$parser$Parser$Advanced$Good, p1 || p2, b, s2);
					}
				}
			});
	});
var $elm$parser$Parser$andThen = $elm$parser$Parser$Advanced$andThen;
var $elm$parser$Parser$Advanced$map = F2(
	function (func, _v0) {
		var parse = _v0.a;
		return $elm$parser$Parser$Advanced$Parser(
			function (s0) {
				var _v1 = parse(s0);
				if (_v1.$ === 'Good') {
					var p = _v1.a;
					var a = _v1.b;
					var s1 = _v1.c;
					return A3(
						$elm$parser$Parser$Advanced$Good,
						p,
						func(a),
						s1);
				} else {
					var p = _v1.a;
					var x = _v1.b;
					return A2($elm$parser$Parser$Advanced$Bad, p, x);
				}
			});
	});
var $elm$parser$Parser$map = $elm$parser$Parser$Advanced$map;
var $elm$core$Tuple$mapSecond = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			x,
			func(y));
	});
var $stil4m$elm_syntax$Combine$andMap = F2(
	function (_v0, _v1) {
		var rp = _v0.a;
		var lp = _v1.a;
		return $stil4m$elm_syntax$Combine$Parser(
			function (state) {
				return A2(
					$elm$parser$Parser$andThen,
					function (_v2) {
						var newState = _v2.a;
						var a = _v2.b;
						return A2(
							$elm$parser$Parser$map,
							$elm$core$Tuple$mapSecond(a),
							rp(newState));
					},
					lp(state));
			});
	});
var $stil4m$elm_syntax$Elm$Parser$State$getComments = function (_v0) {
	var s = _v0.a;
	return $elm$core$List$reverse(s.comments);
};
var $elm$parser$Parser$Advanced$succeed = function (a) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			return A3($elm$parser$Parser$Advanced$Good, false, a, s);
		});
};
var $elm$parser$Parser$succeed = $elm$parser$Parser$Advanced$succeed;
var $stil4m$elm_syntax$Combine$succeed = function (res) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$succeed(
				_Utils_Tuple2(state, res));
		});
};
var $stil4m$elm_syntax$Combine$withState = function (f) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return function (_v0) {
				var p = _v0.a;
				return p(state);
			}(
				f(state));
		});
};
var $stil4m$elm_syntax$Elm$Parser$File$collectComments = $stil4m$elm_syntax$Combine$withState(
	A2($elm$core$Basics$composeR, $stil4m$elm_syntax$Elm$Parser$State$getComments, $stil4m$elm_syntax$Combine$succeed));
var $stil4m$elm_syntax$Elm$Syntax$Declaration$AliasDeclaration = function (a) {
	return {$: 'AliasDeclaration', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Declaration$CustomTypeDeclaration = function (a) {
	return {$: 'CustomTypeDeclaration', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Node$Node = F2(
	function (a, b) {
		return {$: 'Node', a: a, b: b};
	});
var $elm$parser$Parser$Advanced$Empty = {$: 'Empty'};
var $elm$parser$Parser$Advanced$Append = F2(
	function (a, b) {
		return {$: 'Append', a: a, b: b};
	});
var $elm$parser$Parser$Advanced$oneOfHelp = F3(
	function (s0, bag, parsers) {
		oneOfHelp:
		while (true) {
			if (!parsers.b) {
				return A2($elm$parser$Parser$Advanced$Bad, false, bag);
			} else {
				var parse = parsers.a.a;
				var remainingParsers = parsers.b;
				var _v1 = parse(s0);
				if (_v1.$ === 'Good') {
					var step = _v1;
					return step;
				} else {
					var step = _v1;
					var p = step.a;
					var x = step.b;
					if (p) {
						return step;
					} else {
						var $temp$s0 = s0,
							$temp$bag = A2($elm$parser$Parser$Advanced$Append, bag, x),
							$temp$parsers = remainingParsers;
						s0 = $temp$s0;
						bag = $temp$bag;
						parsers = $temp$parsers;
						continue oneOfHelp;
					}
				}
			}
		}
	});
var $elm$parser$Parser$Advanced$oneOf = function (parsers) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			return A3($elm$parser$Parser$Advanced$oneOfHelp, s, $elm$parser$Parser$Advanced$Empty, parsers);
		});
};
var $elm$parser$Parser$oneOf = $elm$parser$Parser$Advanced$oneOf;
var $stil4m$elm_syntax$Combine$choice = function (xs) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$oneOf(
				A2(
					$elm$core$List$map,
					function (_v0) {
						var x = _v0.a;
						return x(state);
					},
					xs));
		});
};
var $stil4m$elm_syntax$Elm$Syntax$Declaration$Destructuring = F2(
	function (a, b) {
		return {$: 'Destructuring', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Range$Range = F2(
	function (start, end) {
		return {end: end, start: start};
	});
var $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange = {
	end: {column: 0, row: 0},
	start: {column: 0, row: 0}
};
var $elm$core$List$head = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(x);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm$core$Maybe$map2 = F3(
	function (func, ma, mb) {
		if (ma.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var a = ma.a;
			if (mb.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var b = mb.a;
				return $elm$core$Maybe$Just(
					A2(func, a, b));
			}
		}
	});
var $stil4m$elm_syntax$Elm$Syntax$Range$compareLocations = F2(
	function (left, right) {
		return (_Utils_cmp(left.row, right.row) < 0) ? $elm$core$Basics$LT : ((_Utils_cmp(left.row, right.row) > 0) ? $elm$core$Basics$GT : A2($elm$core$Basics$compare, left.column, right.column));
	});
var $elm$core$List$sortWith = _List_sortWith;
var $stil4m$elm_syntax$Elm$Syntax$Range$sortLocations = $elm$core$List$sortWith($stil4m$elm_syntax$Elm$Syntax$Range$compareLocations);
var $elm$core$Maybe$withDefault = F2(
	function (_default, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return value;
		} else {
			return _default;
		}
	});
var $stil4m$elm_syntax$Elm$Syntax$Range$combine = function (ranges) {
	var starts = $stil4m$elm_syntax$Elm$Syntax$Range$sortLocations(
		A2(
			$elm$core$List$map,
			function ($) {
				return $.start;
			},
			ranges));
	var ends = $elm$core$List$reverse(
		$stil4m$elm_syntax$Elm$Syntax$Range$sortLocations(
			A2(
				$elm$core$List$map,
				function ($) {
					return $.end;
				},
				ranges)));
	return A2(
		$elm$core$Maybe$withDefault,
		$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
		A3(
			$elm$core$Maybe$map2,
			$stil4m$elm_syntax$Elm$Syntax$Range$Range,
			$elm$core$List$head(starts),
			$elm$core$List$head(ends)));
};
var $stil4m$elm_syntax$Elm$Syntax$Node$combine = F3(
	function (f, a, b) {
		var r1 = a.a;
		var r2 = b.a;
		return A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$combine(
				_List_fromArray(
					[r1, r2])),
			A2(f, a, b));
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$Application = function (a) {
	return {$: 'Application', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$CaseBlock = F2(
	function (expression, cases) {
		return {cases: cases, expression: expression};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$CaseExpression = function (a) {
	return {$: 'CaseExpression', a: a};
};
var $stil4m$elm_syntax$Combine$Done = function (a) {
	return {$: 'Done', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Function = F3(
	function (documentation, signature, declaration) {
		return {declaration: declaration, documentation: documentation, signature: signature};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$FunctionImplementation = F3(
	function (name, _arguments, expression) {
		return {_arguments: _arguments, expression: expression, name: name};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$IfBlock = F3(
	function (a, b, c) {
		return {$: 'IfBlock', a: a, b: b, c: c};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$Lambda = F2(
	function (args, expression) {
		return {args: args, expression: expression};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$LambdaExpression = function (a) {
	return {$: 'LambdaExpression', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$LetBlock = F2(
	function (declarations, expression) {
		return {declarations: declarations, expression: expression};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$LetDestructuring = F2(
	function (a, b) {
		return {$: 'LetDestructuring', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$LetExpression = function (a) {
	return {$: 'LetExpression', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$LetFunction = function (a) {
	return {$: 'LetFunction', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$ListExpr = function (a) {
	return {$: 'ListExpr', a: a};
};
var $stil4m$elm_syntax$Combine$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Negation = function (a) {
	return {$: 'Negation', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Operator = function (a) {
	return {$: 'Operator', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$ParenthesizedExpression = function (a) {
	return {$: 'ParenthesizedExpression', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$PrefixOperator = function (a) {
	return {$: 'PrefixOperator', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$RecordExpr = function (a) {
	return {$: 'RecordExpr', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$RecordUpdateExpression = F2(
	function (a, b) {
		return {$: 'RecordUpdateExpression', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$TupledExpression = function (a) {
	return {$: 'TupledExpression', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$UnitExpr = {$: 'UnitExpr'};
var $stil4m$elm_syntax$Combine$andThen = F2(
	function (f, _v0) {
		var p = _v0.a;
		return $stil4m$elm_syntax$Combine$Parser(
			function (state) {
				return A2(
					$elm$parser$Parser$andThen,
					function (_v1) {
						var s = _v1.a;
						var a = _v1.b;
						return function (_v2) {
							var x = _v2.a;
							return x(s);
						}(
							f(a));
					},
					p(state));
			});
	});
var $elm$parser$Parser$Advanced$backtrackable = function (_v0) {
	var parse = _v0.a;
	return $elm$parser$Parser$Advanced$Parser(
		function (s0) {
			var _v1 = parse(s0);
			if (_v1.$ === 'Bad') {
				var x = _v1.b;
				return A2($elm$parser$Parser$Advanced$Bad, false, x);
			} else {
				var a = _v1.b;
				var s1 = _v1.c;
				return A3($elm$parser$Parser$Advanced$Good, false, a, s1);
			}
		});
};
var $elm$parser$Parser$backtrackable = $elm$parser$Parser$Advanced$backtrackable;
var $stil4m$elm_syntax$Combine$backtrackable = function (_v0) {
	var p = _v0.a;
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$backtrackable(
				p(state));
		});
};
var $elm$core$String$slice = _String_slice;
var $elm$parser$Parser$Advanced$mapChompedString = F2(
	function (func, _v0) {
		var parse = _v0.a;
		return $elm$parser$Parser$Advanced$Parser(
			function (s0) {
				var _v1 = parse(s0);
				if (_v1.$ === 'Bad') {
					var p = _v1.a;
					var x = _v1.b;
					return A2($elm$parser$Parser$Advanced$Bad, p, x);
				} else {
					var p = _v1.a;
					var a = _v1.b;
					var s1 = _v1.c;
					return A3(
						$elm$parser$Parser$Advanced$Good,
						p,
						A2(
							func,
							A3($elm$core$String$slice, s0.offset, s1.offset, s0.src),
							a),
						s1);
				}
			});
	});
var $elm$parser$Parser$Advanced$getChompedString = function (parser) {
	return A2($elm$parser$Parser$Advanced$mapChompedString, $elm$core$Basics$always, parser);
};
var $elm$parser$Parser$getChompedString = $elm$parser$Parser$Advanced$getChompedString;
var $elm$parser$Parser$Expecting = function (a) {
	return {$: 'Expecting', a: a};
};
var $elm$parser$Parser$Advanced$Token = F2(
	function (a, b) {
		return {$: 'Token', a: a, b: b};
	});
var $elm$parser$Parser$toToken = function (str) {
	return A2(
		$elm$parser$Parser$Advanced$Token,
		str,
		$elm$parser$Parser$Expecting(str));
};
var $elm$parser$Parser$Advanced$AddRight = F2(
	function (a, b) {
		return {$: 'AddRight', a: a, b: b};
	});
var $elm$parser$Parser$Advanced$DeadEnd = F4(
	function (row, col, problem, contextStack) {
		return {col: col, contextStack: contextStack, problem: problem, row: row};
	});
var $elm$parser$Parser$Advanced$fromState = F2(
	function (s, x) {
		return A2(
			$elm$parser$Parser$Advanced$AddRight,
			$elm$parser$Parser$Advanced$Empty,
			A4($elm$parser$Parser$Advanced$DeadEnd, s.row, s.col, x, s.context));
	});
var $elm$parser$Parser$Advanced$isSubString = _Parser_isSubString;
var $elm$core$Basics$negate = function (n) {
	return -n;
};
var $elm$parser$Parser$Advanced$token = function (_v0) {
	var str = _v0.a;
	var expecting = _v0.b;
	var progress = !$elm$core$String$isEmpty(str);
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			var _v1 = A5($elm$parser$Parser$Advanced$isSubString, str, s.offset, s.row, s.col, s.src);
			var newOffset = _v1.a;
			var newRow = _v1.b;
			var newCol = _v1.c;
			return _Utils_eq(newOffset, -1) ? A2(
				$elm$parser$Parser$Advanced$Bad,
				false,
				A2($elm$parser$Parser$Advanced$fromState, s, expecting)) : A3(
				$elm$parser$Parser$Advanced$Good,
				progress,
				_Utils_Tuple0,
				{col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src});
		});
};
var $elm$parser$Parser$token = function (str) {
	return $elm$parser$Parser$Advanced$token(
		$elm$parser$Parser$toToken(str));
};
var $stil4m$elm_syntax$Combine$string = function (s) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$map,
				function (x) {
					return _Utils_Tuple2(state, x);
				},
				$elm$parser$Parser$getChompedString(
					$elm$parser$Parser$token(s)));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$caseToken = $stil4m$elm_syntax$Combine$string('case');
var $stil4m$elm_syntax$Elm$Syntax$Expression$CharLiteral = function (a) {
	return {$: 'CharLiteral', a: a};
};
var $elm$parser$Parser$Problem = function (a) {
	return {$: 'Problem', a: a};
};
var $elm$parser$Parser$Advanced$problem = function (x) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			return A2(
				$elm$parser$Parser$Advanced$Bad,
				false,
				A2($elm$parser$Parser$Advanced$fromState, s, x));
		});
};
var $elm$parser$Parser$problem = function (msg) {
	return $elm$parser$Parser$Advanced$problem(
		$elm$parser$Parser$Problem(msg));
};
var $stil4m$elm_syntax$Combine$fail = function (m) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$map,
				function (x) {
					return _Utils_Tuple2(state, x);
				},
				$elm$parser$Parser$problem(m));
		});
};
var $elm$core$Maybe$map = F2(
	function (f, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return $elm$core$Maybe$Just(
				f(value));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $elm$parser$Parser$UnexpectedChar = {$: 'UnexpectedChar'};
var $elm$parser$Parser$Advanced$isSubChar = _Parser_isSubChar;
var $elm$parser$Parser$Advanced$chompIf = F2(
	function (isGood, expecting) {
		return $elm$parser$Parser$Advanced$Parser(
			function (s) {
				var newOffset = A3($elm$parser$Parser$Advanced$isSubChar, isGood, s.offset, s.src);
				return _Utils_eq(newOffset, -1) ? A2(
					$elm$parser$Parser$Advanced$Bad,
					false,
					A2($elm$parser$Parser$Advanced$fromState, s, expecting)) : (_Utils_eq(newOffset, -2) ? A3(
					$elm$parser$Parser$Advanced$Good,
					true,
					_Utils_Tuple0,
					{col: 1, context: s.context, indent: s.indent, offset: s.offset + 1, row: s.row + 1, src: s.src}) : A3(
					$elm$parser$Parser$Advanced$Good,
					true,
					_Utils_Tuple0,
					{col: s.col + 1, context: s.context, indent: s.indent, offset: newOffset, row: s.row, src: s.src}));
			});
	});
var $elm$parser$Parser$chompIf = function (isGood) {
	return A2($elm$parser$Parser$Advanced$chompIf, isGood, $elm$parser$Parser$UnexpectedChar);
};
var $elm$parser$Parser$Advanced$map2 = F3(
	function (func, _v0, _v1) {
		var parseA = _v0.a;
		var parseB = _v1.a;
		return $elm$parser$Parser$Advanced$Parser(
			function (s0) {
				var _v2 = parseA(s0);
				if (_v2.$ === 'Bad') {
					var p = _v2.a;
					var x = _v2.b;
					return A2($elm$parser$Parser$Advanced$Bad, p, x);
				} else {
					var p1 = _v2.a;
					var a = _v2.b;
					var s1 = _v2.c;
					var _v3 = parseB(s1);
					if (_v3.$ === 'Bad') {
						var p2 = _v3.a;
						var x = _v3.b;
						return A2($elm$parser$Parser$Advanced$Bad, p1 || p2, x);
					} else {
						var p2 = _v3.a;
						var b = _v3.b;
						var s2 = _v3.c;
						return A3(
							$elm$parser$Parser$Advanced$Good,
							p1 || p2,
							A2(func, a, b),
							s2);
					}
				}
			});
	});
var $elm$parser$Parser$Advanced$keeper = F2(
	function (parseFunc, parseArg) {
		return A3($elm$parser$Parser$Advanced$map2, $elm$core$Basics$apL, parseFunc, parseArg);
	});
var $elm$parser$Parser$keeper = $elm$parser$Parser$Advanced$keeper;
var $stil4m$elm_syntax$Combine$fromCore = function (p) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$keeper,
				$elm$parser$Parser$succeed(
					function (v) {
						return _Utils_Tuple2(state, v);
					}),
				p);
		});
};
var $elm$core$String$foldr = _String_foldr;
var $elm$core$String$toList = function (string) {
	return A3($elm$core$String$foldr, $elm$core$List$cons, _List_Nil, string);
};
var $stil4m$elm_syntax$Combine$Char$satisfy = function (pred) {
	return $stil4m$elm_syntax$Combine$fromCore(
		A2(
			$elm$parser$Parser$andThen,
			function (s) {
				var _v0 = $elm$core$String$toList(s);
				if (!_v0.b) {
					return $elm$parser$Parser$succeed($elm$core$Maybe$Nothing);
				} else {
					var c = _v0.a;
					return $elm$parser$Parser$succeed(
						$elm$core$Maybe$Just(c));
				}
			},
			$elm$parser$Parser$getChompedString(
				$elm$parser$Parser$chompIf(pred))));
};
var $stil4m$elm_syntax$Combine$Char$anyChar = A2(
	$stil4m$elm_syntax$Combine$andThen,
	A2(
		$elm$core$Basics$composeR,
		$elm$core$Maybe$map($stil4m$elm_syntax$Combine$succeed),
		$elm$core$Maybe$withDefault(
			$stil4m$elm_syntax$Combine$fail('expected any character'))),
	$stil4m$elm_syntax$Combine$Char$satisfy(
		$elm$core$Basics$always(true)));
var $elm$core$String$fromList = _String_fromList;
var $stil4m$elm_syntax$Combine$Char$char = function (c) {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Maybe$map($stil4m$elm_syntax$Combine$succeed),
			$elm$core$Maybe$withDefault(
				$stil4m$elm_syntax$Combine$fail(
					'expected \'' + ($elm$core$String$fromList(
						_List_fromArray(
							[c])) + '\'')))),
		$stil4m$elm_syntax$Combine$Char$satisfy(
			$elm$core$Basics$eq(c)));
};
var $stil4m$elm_syntax$Combine$map = F2(
	function (f, _v0) {
		var p = _v0.a;
		return $stil4m$elm_syntax$Combine$Parser(
			function (state) {
				return A2(
					$elm$parser$Parser$map,
					function (_v1) {
						var s = _v1.a;
						var a = _v1.b;
						return _Utils_Tuple2(
							s,
							f(a));
					},
					p(state));
			});
	});
var $stil4m$elm_syntax$Combine$continueWith = F2(
	function (target, dropped) {
		return A2(
			$stil4m$elm_syntax$Combine$andMap,
			target,
			A2(
				$stil4m$elm_syntax$Combine$map,
				F2(
					function (_v0, a) {
						return a;
					}),
				dropped));
	});
var $stil4m$elm_syntax$Combine$ignore = F2(
	function (dropped, target) {
		return A2(
			$stil4m$elm_syntax$Combine$andMap,
			dropped,
			A2($stil4m$elm_syntax$Combine$map, $elm$core$Basics$always, target));
	});
var $stil4m$elm_syntax$Combine$or = F2(
	function (_v0, _v1) {
		var lp = _v0.a;
		var rp = _v1.a;
		return $stil4m$elm_syntax$Combine$Parser(
			function (state) {
				return $elm$parser$Parser$oneOf(
					_List_fromArray(
						[
							lp(state),
							rp(state)
						]));
			});
	});
var $elm$parser$Parser$Advanced$chompWhileHelp = F5(
	function (isGood, offset, row, col, s0) {
		chompWhileHelp:
		while (true) {
			var newOffset = A3($elm$parser$Parser$Advanced$isSubChar, isGood, offset, s0.src);
			if (_Utils_eq(newOffset, -1)) {
				return A3(
					$elm$parser$Parser$Advanced$Good,
					_Utils_cmp(s0.offset, offset) < 0,
					_Utils_Tuple0,
					{col: col, context: s0.context, indent: s0.indent, offset: offset, row: row, src: s0.src});
			} else {
				if (_Utils_eq(newOffset, -2)) {
					var $temp$isGood = isGood,
						$temp$offset = offset + 1,
						$temp$row = row + 1,
						$temp$col = 1,
						$temp$s0 = s0;
					isGood = $temp$isGood;
					offset = $temp$offset;
					row = $temp$row;
					col = $temp$col;
					s0 = $temp$s0;
					continue chompWhileHelp;
				} else {
					var $temp$isGood = isGood,
						$temp$offset = newOffset,
						$temp$row = row,
						$temp$col = col + 1,
						$temp$s0 = s0;
					isGood = $temp$isGood;
					offset = $temp$offset;
					row = $temp$row;
					col = $temp$col;
					s0 = $temp$s0;
					continue chompWhileHelp;
				}
			}
		}
	});
var $elm$parser$Parser$Advanced$chompWhile = function (isGood) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			return A5($elm$parser$Parser$Advanced$chompWhileHelp, isGood, s.offset, s.row, s.col, s);
		});
};
var $elm$parser$Parser$chompWhile = $elm$parser$Parser$Advanced$chompWhile;
var $elm$core$Char$fromCode = _Char_fromCode;
var $elm$core$String$cons = _String_cons;
var $elm$core$String$fromChar = function (_char) {
	return A2($elm$core$String$cons, _char, '');
};
var $elm$core$Basics$pow = _Basics_pow;
var $rtfeldman$elm_hex$Hex$fromStringHelp = F3(
	function (position, chars, accumulated) {
		fromStringHelp:
		while (true) {
			if (!chars.b) {
				return $elm$core$Result$Ok(accumulated);
			} else {
				var _char = chars.a;
				var rest = chars.b;
				switch (_char.valueOf()) {
					case '0':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated;
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '1':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + A2($elm$core$Basics$pow, 16, position);
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '2':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (2 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '3':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (3 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '4':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (4 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '5':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (5 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '6':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (6 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '7':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (7 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '8':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (8 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case '9':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (9 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'a':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (10 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'b':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (11 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'c':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (12 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'd':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (13 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'e':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (14 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					case 'f':
						var $temp$position = position - 1,
							$temp$chars = rest,
							$temp$accumulated = accumulated + (15 * A2($elm$core$Basics$pow, 16, position));
						position = $temp$position;
						chars = $temp$chars;
						accumulated = $temp$accumulated;
						continue fromStringHelp;
					default:
						var nonHex = _char;
						return $elm$core$Result$Err(
							$elm$core$String$fromChar(nonHex) + ' is not a valid hexadecimal character.');
				}
			}
		}
	});
var $elm$core$Result$map = F2(
	function (func, ra) {
		if (ra.$ === 'Ok') {
			var a = ra.a;
			return $elm$core$Result$Ok(
				func(a));
		} else {
			var e = ra.a;
			return $elm$core$Result$Err(e);
		}
	});
var $elm$core$Result$mapError = F2(
	function (f, result) {
		if (result.$ === 'Ok') {
			var v = result.a;
			return $elm$core$Result$Ok(v);
		} else {
			var e = result.a;
			return $elm$core$Result$Err(
				f(e));
		}
	});
var $elm$core$List$tail = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(xs);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $rtfeldman$elm_hex$Hex$fromString = function (str) {
	if ($elm$core$String$isEmpty(str)) {
		return $elm$core$Result$Err('Empty strings are not valid hexadecimal strings.');
	} else {
		var result = function () {
			if (A2($elm$core$String$startsWith, '-', str)) {
				var list = A2(
					$elm$core$Maybe$withDefault,
					_List_Nil,
					$elm$core$List$tail(
						$elm$core$String$toList(str)));
				return A2(
					$elm$core$Result$map,
					$elm$core$Basics$negate,
					A3(
						$rtfeldman$elm_hex$Hex$fromStringHelp,
						$elm$core$List$length(list) - 1,
						list,
						0));
			} else {
				return A3(
					$rtfeldman$elm_hex$Hex$fromStringHelp,
					$elm$core$String$length(str) - 1,
					$elm$core$String$toList(str),
					0);
			}
		}();
		var formatError = function (err) {
			return A2(
				$elm$core$String$join,
				' ',
				_List_fromArray(
					['\"' + (str + '\"'), 'is not a valid hexadecimal string because', err]));
		};
		return A2($elm$core$Result$mapError, formatError, result);
	}
};
var $elm$parser$Parser$Advanced$ignorer = F2(
	function (keepParser, ignoreParser) {
		return A3($elm$parser$Parser$Advanced$map2, $elm$core$Basics$always, keepParser, ignoreParser);
	});
var $elm$parser$Parser$ignorer = $elm$parser$Parser$Advanced$ignorer;
var $elm$parser$Parser$ExpectingSymbol = function (a) {
	return {$: 'ExpectingSymbol', a: a};
};
var $elm$parser$Parser$Advanced$symbol = $elm$parser$Parser$Advanced$token;
var $elm$parser$Parser$symbol = function (str) {
	return $elm$parser$Parser$Advanced$symbol(
		A2(
			$elm$parser$Parser$Advanced$Token,
			str,
			$elm$parser$Parser$ExpectingSymbol(str)));
};
var $elm$core$String$toLower = _String_toLower;
var $elm$core$Result$withDefault = F2(
	function (def, result) {
		if (result.$ === 'Ok') {
			var a = result.a;
			return a;
		} else {
			return def;
		}
	});
var $stil4m$elm_syntax$Elm$Parser$Tokens$escapedCharValue = $elm$parser$Parser$oneOf(
	_List_fromArray(
		[
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\'')),
			$elm$parser$Parser$symbol('\'')),
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\"')),
			$elm$parser$Parser$symbol('\"')),
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\n')),
			$elm$parser$Parser$symbol('n')),
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\t')),
			$elm$parser$Parser$symbol('t')),
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\u000D')),
			$elm$parser$Parser$symbol('r')),
			A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				_Utils_chr('\\')),
			$elm$parser$Parser$symbol('\\')),
			A2(
			$elm$parser$Parser$keeper,
			A2(
				$elm$parser$Parser$ignorer,
				A2(
					$elm$parser$Parser$ignorer,
					$elm$parser$Parser$succeed(
						A2(
							$elm$core$Basics$composeR,
							$elm$core$String$toLower,
							A2(
								$elm$core$Basics$composeR,
								$rtfeldman$elm_hex$Hex$fromString,
								A2(
									$elm$core$Basics$composeR,
									$elm$core$Result$withDefault(0),
									$elm$core$Char$fromCode)))),
					$elm$parser$Parser$symbol('u')),
				$elm$parser$Parser$symbol('{')),
			A2(
				$elm$parser$Parser$ignorer,
				$elm$parser$Parser$getChompedString(
					$elm$parser$Parser$chompWhile(
						function (c) {
							return A2(
								$elm$core$String$any,
								$elm$core$Basics$eq(c),
								'0123456789ABCDEFabcdef');
						})),
				$elm$parser$Parser$symbol('}')))
		]));
var $elm$core$List$singleton = function (value) {
	return _List_fromArray(
		[value]);
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$quotedSingleQuote = $stil4m$elm_syntax$Combine$fromCore(
	A2(
		$elm$parser$Parser$keeper,
		A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$succeed(
				A2(
					$elm$core$Basics$composeR,
					$elm$core$String$toList,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$List$head,
						$elm$core$Maybe$withDefault(
							_Utils_chr(' '))))),
			$elm$parser$Parser$symbol('\'')),
		A2(
			$elm$parser$Parser$ignorer,
			$elm$parser$Parser$oneOf(
				_List_fromArray(
					[
						A2(
						$elm$parser$Parser$keeper,
						A2(
							$elm$parser$Parser$ignorer,
							$elm$parser$Parser$succeed(
								A2($elm$core$Basics$composeR, $elm$core$List$singleton, $elm$core$String$fromList)),
							$elm$parser$Parser$symbol('\\')),
						$stil4m$elm_syntax$Elm$Parser$Tokens$escapedCharValue),
						$elm$parser$Parser$getChompedString(
						$elm$parser$Parser$chompIf(
							$elm$core$Basics$always(true)))
					])),
			$elm$parser$Parser$symbol('\''))));
var $stil4m$elm_syntax$Elm$Parser$Tokens$characterLiteral = A2(
	$stil4m$elm_syntax$Combine$or,
	$stil4m$elm_syntax$Elm$Parser$Tokens$quotedSingleQuote,
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$Char$char(
			_Utils_chr('\'')),
		A2(
			$stil4m$elm_syntax$Combine$continueWith,
			$stil4m$elm_syntax$Combine$Char$anyChar,
			$stil4m$elm_syntax$Combine$Char$char(
				_Utils_chr('\'')))));
var $stil4m$elm_syntax$Elm$Parser$Node$asPointerLocation = function (_v0) {
	var line = _v0.line;
	var column = _v0.column;
	return {column: column, row: line};
};
var $stil4m$elm_syntax$Combine$app = function (_v0) {
	var inner = _v0.a;
	return inner;
};
var $elm$parser$Parser$Advanced$getPosition = $elm$parser$Parser$Advanced$Parser(
	function (s) {
		return A3(
			$elm$parser$Parser$Advanced$Good,
			false,
			_Utils_Tuple2(s.row, s.col),
			s);
	});
var $elm$parser$Parser$getPosition = $elm$parser$Parser$Advanced$getPosition;
var $stil4m$elm_syntax$Combine$withLocation = function (f) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$andThen,
				function (loc) {
					return A2(
						$stil4m$elm_syntax$Combine$app,
						f(loc),
						state);
				},
				A2(
					$elm$parser$Parser$map,
					function (_v0) {
						var row = _v0.a;
						var col = _v0.b;
						return {column: col, line: row};
					},
					$elm$parser$Parser$getPosition));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Node$parser = function (p) {
	return $stil4m$elm_syntax$Combine$withLocation(
		function (start) {
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Combine$withLocation(
					function (end) {
						return $stil4m$elm_syntax$Combine$succeed(
							{
								end: $stil4m$elm_syntax$Elm$Parser$Node$asPointerLocation(end),
								start: $stil4m$elm_syntax$Elm$Parser$Node$asPointerLocation(start)
							});
					}),
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					p,
					$stil4m$elm_syntax$Combine$succeed(
						F2(
							function (v, r) {
								return A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, r, v);
							}))));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Declarations$charLiteralExpression = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Expression$CharLiteral, $stil4m$elm_syntax$Elm$Parser$Tokens$characterLiteral));
var $stil4m$elm_syntax$Elm$Parser$Tokens$elseToken = $stil4m$elm_syntax$Combine$string('else');
var $stil4m$elm_syntax$Elm$Parser$State$currentIndent = function (_v0) {
	var indents = _v0.a.indents;
	return A2(
		$elm$core$Maybe$withDefault,
		0,
		$elm$core$List$head(indents));
};
var $stil4m$elm_syntax$Elm$Parser$State$expectedColumn = A2(
	$elm$core$Basics$composeR,
	$stil4m$elm_syntax$Elm$Parser$State$currentIndent,
	$elm$core$Basics$add(1));
var $stil4m$elm_syntax$Elm$Syntax$Pattern$AllPattern = {$: 'AllPattern'};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$AsPattern = F2(
	function (a, b) {
		return {$: 'AsPattern', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Pattern$CharPattern = function (a) {
	return {$: 'CharPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$ListPattern = function (a) {
	return {$: 'ListPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$NamedPattern = F2(
	function (a, b) {
		return {$: 'NamedPattern', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Pattern$ParenthesizedPattern = function (a) {
	return {$: 'ParenthesizedPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$QualifiedNameRef = F2(
	function (moduleName, name) {
		return {moduleName: moduleName, name: name};
	});
var $stil4m$elm_syntax$Elm$Syntax$Pattern$StringPattern = function (a) {
	return {$: 'StringPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$TuplePattern = function (a) {
	return {$: 'TuplePattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$UnConsPattern = F2(
	function (a, b) {
		return {$: 'UnConsPattern', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Pattern$UnitPattern = {$: 'UnitPattern'};
var $stil4m$elm_syntax$Combine$between = F3(
	function (lp, rp, p) {
		return A2(
			$stil4m$elm_syntax$Combine$ignore,
			rp,
			A2($stil4m$elm_syntax$Combine$continueWith, p, lp));
	});
var $elm$core$Set$fromList = function (list) {
	return A3($elm$core$List$foldl, $elm$core$Set$insert, $elm$core$Set$empty, list);
};
var $elm$core$Basics$modBy = _Basics_modBy;
var $miniBill$elm_unicode$Unicode$isAlphaNum = function (c) {
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return l(256) ? ((((((((((A2(r, 48, 57) || A2(r, 65, 90)) || A2(r, 97, 122)) || e(170)) || A2(r, 178, 179)) || e(181)) || A2(r, 185, 186)) || A2(r, 188, 190)) || A2(r, 192, 214)) || A2(r, 216, 246)) || A2(r, 248, 255)) : (l(43761) ? (l(4695) ? (l(2876) ? (l(2383) ? (l(1648) ? (l(930) ? (((((((((((A2(r, 256, 705) || A2(r, 710, 721)) || A2(r, 736, 740)) || A2(r, 880, 884)) || A2(r, 886, 887)) || A2(r, 890, 893)) || e(895)) || e(902)) || A2(r, 904, 906)) || e(908)) || A2(r, 910, 929)) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 748, 750))) : ((((((((((A2(r, 931, 1013) || A2(r, 1015, 1153)) || A2(r, 1162, 1327)) || A2(r, 1329, 1366)) || e(1369)) || A2(r, 1376, 1416)) || A2(r, 1488, 1514)) || A2(r, 1519, 1522)) || A2(r, 1568, 1610)) || A2(r, 1632, 1641)) || A2(r, 1646, 1647))) : (l(2041) ? ((((((((((A2(r, 1649, 1747) || e(1749)) || A2(r, 1765, 1766)) || A2(r, 1774, 1788)) || e(1791)) || e(1808)) || A2(r, 1810, 1839)) || A2(r, 1869, 1957)) || e(1969)) || A2(r, 1984, 2026)) || A2(r, 2036, 2037)) : (((((((((((e(2042) || A2(r, 2048, 2069)) || e(2074)) || e(2084)) || e(2088)) || A2(r, 2112, 2136)) || A2(r, 2144, 2154)) || A2(r, 2160, 2183)) || A2(r, 2185, 2190)) || A2(r, 2208, 2249)) || A2(r, 2308, 2361)) || e(2365)))) : (l(2612) ? (l(2509) ? ((((((((((e(2384) || A2(r, 2392, 2401)) || A2(r, 2406, 2415)) || A2(r, 2417, 2432)) || A2(r, 2437, 2444)) || A2(r, 2447, 2448)) || A2(r, 2451, 2472)) || A2(r, 2474, 2480)) || e(2482)) || A2(r, 2486, 2489)) || e(2493)) : ((((((((((e(2510) || A2(r, 2524, 2525)) || A2(r, 2527, 2529)) || A2(r, 2534, 2545)) || A2(r, 2548, 2553)) || e(2556)) || A2(r, 2565, 2570)) || A2(r, 2575, 2576)) || A2(r, 2579, 2600)) || A2(r, 2602, 2608)) || A2(r, 2610, 2611))) : (l(2740) ? ((((((((((A2(r, 2613, 2614) || A2(r, 2616, 2617)) || A2(r, 2649, 2652)) || e(2654)) || A2(r, 2662, 2671)) || A2(r, 2674, 2676)) || A2(r, 2693, 2701)) || A2(r, 2703, 2705)) || A2(r, 2707, 2728)) || A2(r, 2730, 2736)) || A2(r, 2738, 2739)) : (((((((((((A2(r, 2741, 2745) || e(2749)) || e(2768)) || A2(r, 2784, 2785)) || A2(r, 2790, 2799)) || e(2809)) || A2(r, 2821, 2828)) || A2(r, 2831, 2832)) || A2(r, 2835, 2856)) || A2(r, 2858, 2864)) || A2(r, 2866, 2867)) || A2(r, 2869, 2873))))) : (l(3429) ? (l(3159) ? (l(2973) ? ((((((((((e(2877) || A2(r, 2908, 2909)) || A2(r, 2911, 2913)) || A2(r, 2918, 2927)) || A2(r, 2929, 2935)) || e(2947)) || A2(r, 2949, 2954)) || A2(r, 2958, 2960)) || A2(r, 2962, 2965)) || A2(r, 2969, 2970)) || e(2972)) : ((((((((((A2(r, 2974, 2975) || A2(r, 2979, 2980)) || A2(r, 2984, 2986)) || A2(r, 2990, 3001)) || e(3024)) || A2(r, 3046, 3058)) || A2(r, 3077, 3084)) || A2(r, 3086, 3088)) || A2(r, 3090, 3112)) || A2(r, 3114, 3129)) || e(3133))) : (l(3260) ? ((((((((((A2(r, 3160, 3162) || e(3165)) || A2(r, 3168, 3169)) || A2(r, 3174, 3183)) || A2(r, 3192, 3198)) || e(3200)) || A2(r, 3205, 3212)) || A2(r, 3214, 3216)) || A2(r, 3218, 3240)) || A2(r, 3242, 3251)) || A2(r, 3253, 3257)) : (((((((((((e(3261) || A2(r, 3293, 3294)) || A2(r, 3296, 3297)) || A2(r, 3302, 3311)) || A2(r, 3313, 3314)) || A2(r, 3332, 3340)) || A2(r, 3342, 3344)) || A2(r, 3346, 3386)) || e(3389)) || e(3406)) || A2(r, 3412, 3414)) || A2(r, 3416, 3425)))) : (l(3803) ? (l(3663) ? ((((((((((A2(r, 3430, 3448) || A2(r, 3450, 3455)) || A2(r, 3461, 3478)) || A2(r, 3482, 3505)) || A2(r, 3507, 3515)) || e(3517)) || A2(r, 3520, 3526)) || A2(r, 3558, 3567)) || A2(r, 3585, 3632)) || A2(r, 3634, 3635)) || A2(r, 3648, 3654)) : (((((((((((A2(r, 3664, 3673) || A2(r, 3713, 3714)) || e(3716)) || A2(r, 3718, 3722)) || A2(r, 3724, 3747)) || e(3749)) || A2(r, 3751, 3760)) || A2(r, 3762, 3763)) || e(3773)) || A2(r, 3776, 3780)) || e(3782)) || A2(r, 3792, 3801))) : (l(4196) ? ((((((((((A2(r, 3804, 3807) || e(3840)) || A2(r, 3872, 3891)) || A2(r, 3904, 3911)) || A2(r, 3913, 3948)) || A2(r, 3976, 3980)) || A2(r, 4096, 4138)) || A2(r, 4159, 4169)) || A2(r, 4176, 4181)) || A2(r, 4186, 4189)) || e(4193)) : (((((((((((A2(r, 4197, 4198) || A2(r, 4206, 4208)) || A2(r, 4213, 4225)) || e(4238)) || A2(r, 4240, 4249)) || A2(r, 4256, 4293)) || e(4295)) || e(4301)) || A2(r, 4304, 4346)) || A2(r, 4348, 4680)) || A2(r, 4682, 4685)) || A2(r, 4688, 4694)))))) : (l(8489) ? (l(6687) ? (l(5887) ? (l(4881) ? ((((((((((e(4696) || A2(r, 4698, 4701)) || A2(r, 4704, 4744)) || A2(r, 4746, 4749)) || A2(r, 4752, 4784)) || A2(r, 4786, 4789)) || A2(r, 4792, 4798)) || e(4800)) || A2(r, 4802, 4805)) || A2(r, 4808, 4822)) || A2(r, 4824, 4880)) : ((((((((((A2(r, 4882, 4885) || A2(r, 4888, 4954)) || A2(r, 4969, 4988)) || A2(r, 4992, 5007)) || A2(r, 5024, 5109)) || A2(r, 5112, 5117)) || A2(r, 5121, 5740)) || A2(r, 5743, 5759)) || A2(r, 5761, 5786)) || A2(r, 5792, 5866)) || A2(r, 5870, 5880))) : (l(6175) ? ((((((((((A2(r, 5888, 5905) || A2(r, 5919, 5937)) || A2(r, 5952, 5969)) || A2(r, 5984, 5996)) || A2(r, 5998, 6000)) || A2(r, 6016, 6067)) || e(6103)) || e(6108)) || A2(r, 6112, 6121)) || A2(r, 6128, 6137)) || A2(r, 6160, 6169)) : (((((((((((A2(r, 6176, 6264) || A2(r, 6272, 6276)) || A2(r, 6279, 6312)) || e(6314)) || A2(r, 6320, 6389)) || A2(r, 6400, 6430)) || A2(r, 6470, 6509)) || A2(r, 6512, 6516)) || A2(r, 6528, 6571)) || A2(r, 6576, 6601)) || A2(r, 6608, 6618)) || A2(r, 6656, 6678)))) : (l(7967) ? (l(7244) ? ((((((((((A2(r, 6688, 6740) || A2(r, 6784, 6793)) || A2(r, 6800, 6809)) || e(6823)) || A2(r, 6917, 6963)) || A2(r, 6981, 6988)) || A2(r, 6992, 7001)) || A2(r, 7043, 7072)) || A2(r, 7086, 7141)) || A2(r, 7168, 7203)) || A2(r, 7232, 7241)) : ((((((((((A2(r, 7245, 7293) || A2(r, 7296, 7304)) || A2(r, 7312, 7354)) || A2(r, 7357, 7359)) || A2(r, 7401, 7404)) || A2(r, 7406, 7411)) || A2(r, 7413, 7414)) || e(7418)) || A2(r, 7424, 7615)) || A2(r, 7680, 7957)) || A2(r, 7960, 7965))) : (l(8159) ? (((((((((((A2(r, 7968, 8005) || A2(r, 8008, 8013)) || A2(r, 8016, 8023)) || A2(r, 8032, 8061)) || A2(r, 8064, 8116)) || A2(r, 8118, 8124)) || e(8126)) || A2(r, 8130, 8132)) || A2(r, 8134, 8140)) || A2(r, 8144, 8147)) || A2(r, 8150, 8155)) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 8025, 8031))) : ((((((((((((A2(r, 8160, 8172) || A2(r, 8178, 8180)) || A2(r, 8182, 8188)) || A2(r, 8304, 8305)) || A2(r, 8308, 8313)) || A2(r, 8319, 8329)) || A2(r, 8336, 8348)) || e(8450)) || e(8455)) || A2(r, 8458, 8467)) || e(8469)) || A2(r, 8473, 8477)) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 8484, 8488)))))) : (l(12976) ? (l(11703) ? (l(11505) ? ((((((((((A2(r, 8490, 8493) || A2(r, 8495, 8505)) || A2(r, 8508, 8511)) || A2(r, 8517, 8521)) || e(8526)) || A2(r, 8528, 8585)) || A2(r, 9312, 9371)) || A2(r, 9450, 9471)) || A2(r, 10102, 10131)) || A2(r, 11264, 11492)) || A2(r, 11499, 11502)) : ((((((((((A2(r, 11506, 11507) || e(11517)) || A2(r, 11520, 11557)) || e(11559)) || e(11565)) || A2(r, 11568, 11623)) || e(11631)) || A2(r, 11648, 11670)) || A2(r, 11680, 11686)) || A2(r, 11688, 11694)) || A2(r, 11696, 11702))) : (l(12444) ? ((((((((((A2(r, 11704, 11710) || A2(r, 11712, 11718)) || A2(r, 11720, 11726)) || A2(r, 11728, 11734)) || A2(r, 11736, 11742)) || e(11823)) || A2(r, 12293, 12295)) || A2(r, 12321, 12329)) || A2(r, 12337, 12341)) || A2(r, 12344, 12348)) || A2(r, 12353, 12438)) : (((((((((((A2(r, 12445, 12447) || A2(r, 12449, 12538)) || A2(r, 12540, 12543)) || A2(r, 12549, 12591)) || A2(r, 12593, 12686)) || A2(r, 12690, 12693)) || A2(r, 12704, 12735)) || A2(r, 12784, 12799)) || A2(r, 12832, 12841)) || A2(r, 12872, 12879)) || A2(r, 12881, 12895)) || A2(r, 12928, 12937)))) : (l(43215) ? (l(42774) ? ((((((((((A2(r, 12977, 12991) || e(13312)) || e(19903)) || e(19968)) || A2(r, 40959, 42124)) || A2(r, 42192, 42237)) || A2(r, 42240, 42508)) || A2(r, 42512, 42539)) || A2(r, 42560, 42606)) || A2(r, 42623, 42653)) || A2(r, 42656, 42735)) : ((((((((((((A2(r, 42775, 42783) || A2(r, 42786, 42888)) || A2(r, 42891, 42954)) || A2(r, 42960, 42961)) || A2(r, 42966, 42969)) || A2(r, 42994, 43009)) || A2(r, 43011, 43013)) || A2(r, 43015, 43018)) || A2(r, 43020, 43042)) || A2(r, 43056, 43061)) || A2(r, 43072, 43123)) || A2(r, 43138, 43187)) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 42963, 42965)))) : (l(43519) ? ((((((((((A2(r, 43216, 43225) || A2(r, 43250, 43255)) || e(43259)) || A2(r, 43261, 43262)) || A2(r, 43264, 43301)) || A2(r, 43312, 43334)) || A2(r, 43360, 43388)) || A2(r, 43396, 43442)) || A2(r, 43471, 43481)) || A2(r, 43488, 43492)) || A2(r, 43494, 43518)) : ((((((((((((A2(r, 43520, 43560) || A2(r, 43584, 43586)) || A2(r, 43588, 43595)) || A2(r, 43600, 43609)) || A2(r, 43616, 43638)) || e(43642)) || A2(r, 43646, 43695)) || e(43697)) || A2(r, 43701, 43702)) || A2(r, 43705, 43709)) || A2(r, 43739, 43741)) || A2(r, 43744, 43754)) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 43712, 43714)))))))) : (l(71839) ? (l(67827) ? (l(65615) ? (l(64317) ? (l(55202) ? ((((((((((A2(r, 43762, 43764) || A2(r, 43777, 43782)) || A2(r, 43785, 43790)) || A2(r, 43793, 43798)) || A2(r, 43808, 43814)) || A2(r, 43816, 43822)) || A2(r, 43824, 43866)) || A2(r, 43868, 43881)) || A2(r, 43888, 44002)) || A2(r, 44016, 44025)) || e(44032)) : ((((((((((e(55203) || A2(r, 55216, 55238)) || A2(r, 55243, 55291)) || A2(r, 63744, 64109)) || A2(r, 64112, 64217)) || A2(r, 64256, 64262)) || A2(r, 64275, 64279)) || e(64285)) || A2(r, 64287, 64296)) || A2(r, 64298, 64310)) || A2(r, 64312, 64316))) : (l(65312) ? ((((((((((e(64318) || A2(r, 64320, 64321)) || A2(r, 64323, 64324)) || A2(r, 64326, 64433)) || A2(r, 64467, 64829)) || A2(r, 64848, 64911)) || A2(r, 64914, 64967)) || A2(r, 65008, 65019)) || A2(r, 65136, 65140)) || A2(r, 65142, 65276)) || A2(r, 65296, 65305)) : (((((((((((A2(r, 65313, 65338) || A2(r, 65345, 65370)) || A2(r, 65382, 65470)) || A2(r, 65474, 65479)) || A2(r, 65482, 65487)) || A2(r, 65490, 65495)) || A2(r, 65498, 65500)) || A2(r, 65536, 65547)) || A2(r, 65549, 65574)) || A2(r, 65576, 65594)) || A2(r, 65596, 65597)) || A2(r, 65599, 65613)))) : (l(66939) ? (l(66431) ? ((((((((((A2(r, 65616, 65629) || A2(r, 65664, 65786)) || A2(r, 65799, 65843)) || A2(r, 65856, 65912)) || A2(r, 65930, 65931)) || A2(r, 66176, 66204)) || A2(r, 66208, 66256)) || A2(r, 66273, 66299)) || A2(r, 66304, 66339)) || A2(r, 66349, 66378)) || A2(r, 66384, 66421)) : ((((((((((A2(r, 66432, 66461) || A2(r, 66464, 66499)) || A2(r, 66504, 66511)) || A2(r, 66513, 66517)) || A2(r, 66560, 66717)) || A2(r, 66720, 66729)) || A2(r, 66736, 66771)) || A2(r, 66776, 66811)) || A2(r, 66816, 66855)) || A2(r, 66864, 66915)) || A2(r, 66928, 66938))) : (l(67462) ? ((((((((((A2(r, 66940, 66954) || A2(r, 66956, 66962)) || A2(r, 66964, 66965)) || A2(r, 66967, 66977)) || A2(r, 66979, 66993)) || A2(r, 66995, 67001)) || A2(r, 67003, 67004)) || A2(r, 67072, 67382)) || A2(r, 67392, 67413)) || A2(r, 67424, 67431)) || A2(r, 67456, 67461)) : (((((((((((A2(r, 67463, 67504) || A2(r, 67506, 67514)) || A2(r, 67584, 67589)) || e(67592)) || A2(r, 67594, 67637)) || A2(r, 67639, 67640)) || e(67644)) || A2(r, 67647, 67669)) || A2(r, 67672, 67702)) || A2(r, 67705, 67742)) || A2(r, 67751, 67759)) || A2(r, 67808, 67826))))) : (l(69967) ? (l(68799) ? (l(68223) ? ((((((((((A2(r, 67828, 67829) || A2(r, 67835, 67867)) || A2(r, 67872, 67897)) || A2(r, 67968, 68023)) || A2(r, 68028, 68047)) || A2(r, 68050, 68096)) || A2(r, 68112, 68115)) || A2(r, 68117, 68119)) || A2(r, 68121, 68149)) || A2(r, 68160, 68168)) || A2(r, 68192, 68222)) : ((((((((((A2(r, 68224, 68255) || A2(r, 68288, 68295)) || A2(r, 68297, 68324)) || A2(r, 68331, 68335)) || A2(r, 68352, 68405)) || A2(r, 68416, 68437)) || A2(r, 68440, 68466)) || A2(r, 68472, 68497)) || A2(r, 68521, 68527)) || A2(r, 68608, 68680)) || A2(r, 68736, 68786))) : (l(69599) ? ((((((((((A2(r, 68800, 68850) || A2(r, 68858, 68899)) || A2(r, 68912, 68921)) || A2(r, 69216, 69246)) || A2(r, 69248, 69289)) || A2(r, 69296, 69297)) || A2(r, 69376, 69415)) || A2(r, 69424, 69445)) || A2(r, 69457, 69460)) || A2(r, 69488, 69505)) || A2(r, 69552, 69579)) : (((((((((((A2(r, 69600, 69622) || A2(r, 69635, 69687)) || A2(r, 69714, 69743)) || A2(r, 69745, 69746)) || e(69749)) || A2(r, 69763, 69807)) || A2(r, 69840, 69864)) || A2(r, 69872, 69881)) || A2(r, 69891, 69926)) || A2(r, 69942, 69951)) || e(69956)) || e(69959)))) : (l(70460) ? (l(70279) ? ((((((((((A2(r, 69968, 70002) || e(70006)) || A2(r, 70019, 70066)) || A2(r, 70081, 70084)) || A2(r, 70096, 70106)) || e(70108)) || A2(r, 70113, 70132)) || A2(r, 70144, 70161)) || A2(r, 70163, 70187)) || A2(r, 70207, 70208)) || A2(r, 70272, 70278)) : (((((((((((e(70280) || A2(r, 70282, 70285)) || A2(r, 70287, 70301)) || A2(r, 70303, 70312)) || A2(r, 70320, 70366)) || A2(r, 70384, 70393)) || A2(r, 70405, 70412)) || A2(r, 70415, 70416)) || A2(r, 70419, 70440)) || A2(r, 70442, 70448)) || A2(r, 70450, 70451)) || A2(r, 70453, 70457))) : (l(71039) ? ((((((((((e(70461) || e(70480)) || A2(r, 70493, 70497)) || A2(r, 70656, 70708)) || A2(r, 70727, 70730)) || A2(r, 70736, 70745)) || A2(r, 70751, 70753)) || A2(r, 70784, 70831)) || A2(r, 70852, 70853)) || e(70855)) || A2(r, 70864, 70873)) : (((((((((((A2(r, 71040, 71086) || A2(r, 71128, 71131)) || A2(r, 71168, 71215)) || e(71236)) || A2(r, 71248, 71257)) || A2(r, 71296, 71338)) || e(71352)) || A2(r, 71360, 71369)) || A2(r, 71424, 71450)) || A2(r, 71472, 71483)) || A2(r, 71488, 71494)) || A2(r, 71680, 71723)))))) : (l(119981) ? (l(92159) ? (l(72967) ? (l(72249) ? (((((((((((A2(r, 71840, 71922) || A2(r, 71935, 71942)) || e(71945)) || A2(r, 71948, 71955)) || A2(r, 71957, 71958)) || A2(r, 71960, 71983)) || A2(r, 72016, 72025)) || A2(r, 72096, 72103)) || A2(r, 72106, 72144)) || e(72192)) || A2(r, 72203, 72242)) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && (A2(r, 71999, 72001) || A2(r, 72161, 72163)))) : ((((((((((e(72250) || e(72272)) || A2(r, 72284, 72329)) || e(72349)) || A2(r, 72368, 72440)) || A2(r, 72704, 72712)) || A2(r, 72714, 72750)) || e(72768)) || A2(r, 72784, 72812)) || A2(r, 72818, 72847)) || A2(r, 72960, 72966))) : (l(73475) ? ((((((((((A2(r, 72968, 72969) || A2(r, 72971, 73008)) || e(73030)) || A2(r, 73040, 73049)) || A2(r, 73056, 73061)) || A2(r, 73063, 73064)) || A2(r, 73066, 73097)) || e(73112)) || A2(r, 73120, 73129)) || A2(r, 73440, 73458)) || e(73474)) : (((((((((((A2(r, 73476, 73488) || A2(r, 73490, 73523)) || A2(r, 73552, 73561)) || e(73648)) || A2(r, 73664, 73684)) || A2(r, 73728, 74649)) || A2(r, 74752, 74862)) || A2(r, 74880, 75075)) || A2(r, 77712, 77808)) || A2(r, 77824, 78895)) || A2(r, 78913, 78918)) || A2(r, 82944, 83526)))) : (l(101639) ? (l(93052) ? ((((((((((A2(r, 92160, 92728) || A2(r, 92736, 92766)) || A2(r, 92768, 92777)) || A2(r, 92784, 92862)) || A2(r, 92864, 92873)) || A2(r, 92880, 92909)) || A2(r, 92928, 92975)) || A2(r, 92992, 92995)) || A2(r, 93008, 93017)) || A2(r, 93019, 93025)) || A2(r, 93027, 93047)) : ((((((((((A2(r, 93053, 93071) || A2(r, 93760, 93846)) || A2(r, 93952, 94026)) || e(94032)) || A2(r, 94099, 94111)) || A2(r, 94176, 94177)) || e(94179)) || e(94208)) || e(100343)) || A2(r, 100352, 101589)) || e(101632))) : (l(113775) ? ((((((((((e(101640) || A2(r, 110576, 110579)) || A2(r, 110581, 110587)) || A2(r, 110589, 110590)) || A2(r, 110592, 110882)) || e(110898)) || A2(r, 110928, 110930)) || e(110933)) || A2(r, 110948, 110951)) || A2(r, 110960, 111355)) || A2(r, 113664, 113770)) : (((((((((((A2(r, 113776, 113788) || A2(r, 113792, 113800)) || A2(r, 113808, 113817)) || A2(r, 119488, 119507)) || A2(r, 119520, 119539)) || A2(r, 119648, 119672)) || A2(r, 119808, 119892)) || A2(r, 119894, 119964)) || A2(r, 119966, 119967)) || e(119970)) || A2(r, 119973, 119974)) || A2(r, 119977, 119980))))) : (l(125263) ? (l(120745) ? (l(120137) ? ((((((((((A2(r, 119982, 119993) || e(119995)) || A2(r, 119997, 120003)) || A2(r, 120005, 120069)) || A2(r, 120071, 120074)) || A2(r, 120077, 120084)) || A2(r, 120086, 120092)) || A2(r, 120094, 120121)) || A2(r, 120123, 120126)) || A2(r, 120128, 120132)) || e(120134)) : ((((((((((A2(r, 120138, 120144) || A2(r, 120146, 120485)) || A2(r, 120488, 120512)) || A2(r, 120514, 120538)) || A2(r, 120540, 120570)) || A2(r, 120572, 120596)) || A2(r, 120598, 120628)) || A2(r, 120630, 120654)) || A2(r, 120656, 120686)) || A2(r, 120688, 120712)) || A2(r, 120714, 120744))) : (l(123583) ? ((((((((((A2(r, 120746, 120770) || A2(r, 120772, 120779)) || A2(r, 120782, 120831)) || A2(r, 122624, 122654)) || A2(r, 122661, 122666)) || A2(r, 122928, 122989)) || A2(r, 123136, 123180)) || A2(r, 123191, 123197)) || A2(r, 123200, 123209)) || e(123214)) || A2(r, 123536, 123565)) : (((((((((((A2(r, 123584, 123627) || A2(r, 123632, 123641)) || A2(r, 124112, 124139)) || A2(r, 124144, 124153)) || A2(r, 124896, 124902)) || A2(r, 124904, 124907)) || A2(r, 124909, 124910)) || A2(r, 124912, 124926)) || A2(r, 124928, 125124)) || A2(r, 125127, 125135)) || A2(r, 125184, 125251)) || e(125259)))) : (l(126589) ? (l(126504) ? ((((((((((A2(r, 125264, 125273) || A2(r, 126065, 126123)) || A2(r, 126125, 126127)) || A2(r, 126129, 126132)) || A2(r, 126209, 126253)) || A2(r, 126255, 126269)) || A2(r, 126464, 126467)) || A2(r, 126469, 126495)) || A2(r, 126497, 126498)) || e(126500)) || e(126503)) : ((((((((((((A2(r, 126505, 126514) || A2(r, 126516, 126519)) || e(126530)) || A2(r, 126541, 126543)) || A2(r, 126545, 126546)) || e(126548)) || A2(r, 126561, 126562)) || e(126564)) || A2(r, 126567, 126570)) || A2(r, 126572, 126578)) || A2(r, 126580, 126583)) || A2(r, 126585, 126588)) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && ((A2(r, 126521, 126523) || A2(r, 126535, 126539)) || A2(r, 126551, 126559))))) : (l(177976) ? ((((((((((e(126590) || A2(r, 126592, 126601)) || A2(r, 126603, 126619)) || A2(r, 126625, 126627)) || A2(r, 126629, 126633)) || A2(r, 126635, 126651)) || A2(r, 127232, 127244)) || A2(r, 130032, 130041)) || e(131072)) || e(173791)) || e(173824)) : (((((((((((e(177977) || e(177984)) || e(178205)) || e(178208)) || e(183969)) || e(183984)) || e(191456)) || A2(r, 194560, 195101)) || e(196608)) || e(201546)) || e(201552)) || e(205743))))))));
};
var $elm$core$Char$toLower = _Char_toLower;
var $elm$core$Char$toUpper = _Char_toUpper;
var $miniBill$elm_unicode$Unicode$isLower = function (c) {
	var simple = _Utils_eq(
		$elm$core$Char$toLower(c),
		c) && (!_Utils_eq(
		$elm$core$Char$toUpper(c),
		c));
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return (simple && ((((code <= 836) || A2(r, 838, 8559)) || A2(r, 8576, 9423)) || A2(r, 9450, 983040))) || (l(43001) ? (l(8457) ? (l(590) ? (((((((A2(r, 311, 312) || A2(r, 396, 397)) || A2(r, 409, 411)) || A2(r, 426, 427)) || A2(r, 441, 442)) || A2(r, 445, 447)) || e(545)) || A2(r, 563, 569)) : ((((((((A2(r, 591, 659) || A2(r, 661, 687)) || A2(r, 1019, 1020)) || A2(r, 1376, 1416)) || A2(r, 7424, 7467)) || A2(r, 7531, 7543)) || A2(r, 7545, 7578)) || A2(r, 7829, 7837)) || e(7839))) : (l(11376) ? (((((((e(8458) || A2(r, 8462, 8463)) || e(8467)) || e(8495)) || e(8500)) || e(8505)) || A2(r, 8508, 8509)) || A2(r, 8518, 8521)) : (((((((((e(11377) || A2(r, 11379, 11380)) || A2(r, 11382, 11387)) || A2(r, 11491, 11492)) || A2(r, 42799, 42801)) || A2(r, 42865, 42872)) || e(42894)) || A2(r, 42899, 42901)) || e(42927)) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 42963, 42965))))) : (l(120353) ? (l(119994) ? (((((((e(43002) || A2(r, 43824, 43866)) || A2(r, 43872, 43880)) || A2(r, 119834, 119859)) || A2(r, 119886, 119892)) || A2(r, 119894, 119911)) || A2(r, 119938, 119963)) || A2(r, 119990, 119993)) : ((((((((e(119995) || A2(r, 119997, 120003)) || A2(r, 120005, 120015)) || A2(r, 120042, 120067)) || A2(r, 120094, 120119)) || A2(r, 120146, 120171)) || A2(r, 120198, 120223)) || A2(r, 120250, 120275)) || A2(r, 120302, 120327))) : (l(120655) ? (((((((A2(r, 120354, 120379) || A2(r, 120406, 120431)) || A2(r, 120458, 120485)) || A2(r, 120514, 120538)) || A2(r, 120540, 120545)) || A2(r, 120572, 120596)) || A2(r, 120598, 120603)) || A2(r, 120630, 120654)) : ((((((((A2(r, 120656, 120661) || A2(r, 120688, 120712)) || A2(r, 120714, 120719)) || A2(r, 120746, 120770)) || A2(r, 120772, 120777)) || e(120779)) || A2(r, 122624, 122633)) || A2(r, 122635, 122654)) || A2(r, 122661, 122666)))));
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$reservedList = _List_fromArray(
	['module', 'exposing', 'import', 'as', 'if', 'then', 'else', 'let', 'in', 'case', 'of', 'port', 'type', 'where']);
var $elm$parser$Parser$ExpectingVariable = {$: 'ExpectingVariable'};
var $elm$parser$Parser$Advanced$varHelp = F7(
	function (isGood, offset, row, col, src, indent, context) {
		varHelp:
		while (true) {
			var newOffset = A3($elm$parser$Parser$Advanced$isSubChar, isGood, offset, src);
			if (_Utils_eq(newOffset, -1)) {
				return {col: col, context: context, indent: indent, offset: offset, row: row, src: src};
			} else {
				if (_Utils_eq(newOffset, -2)) {
					var $temp$isGood = isGood,
						$temp$offset = offset + 1,
						$temp$row = row + 1,
						$temp$col = 1,
						$temp$src = src,
						$temp$indent = indent,
						$temp$context = context;
					isGood = $temp$isGood;
					offset = $temp$offset;
					row = $temp$row;
					col = $temp$col;
					src = $temp$src;
					indent = $temp$indent;
					context = $temp$context;
					continue varHelp;
				} else {
					var $temp$isGood = isGood,
						$temp$offset = newOffset,
						$temp$row = row,
						$temp$col = col + 1,
						$temp$src = src,
						$temp$indent = indent,
						$temp$context = context;
					isGood = $temp$isGood;
					offset = $temp$offset;
					row = $temp$row;
					col = $temp$col;
					src = $temp$src;
					indent = $temp$indent;
					context = $temp$context;
					continue varHelp;
				}
			}
		}
	});
var $elm$parser$Parser$Advanced$variable = function (i) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			var firstOffset = A3($elm$parser$Parser$Advanced$isSubChar, i.start, s.offset, s.src);
			if (_Utils_eq(firstOffset, -1)) {
				return A2(
					$elm$parser$Parser$Advanced$Bad,
					false,
					A2($elm$parser$Parser$Advanced$fromState, s, i.expecting));
			} else {
				var s1 = _Utils_eq(firstOffset, -2) ? A7($elm$parser$Parser$Advanced$varHelp, i.inner, s.offset + 1, s.row + 1, 1, s.src, s.indent, s.context) : A7($elm$parser$Parser$Advanced$varHelp, i.inner, firstOffset, s.row, s.col + 1, s.src, s.indent, s.context);
				var name = A3($elm$core$String$slice, s.offset, s1.offset, s.src);
				return A2($elm$core$Set$member, name, i.reserved) ? A2(
					$elm$parser$Parser$Advanced$Bad,
					false,
					A2($elm$parser$Parser$Advanced$fromState, s, i.expecting)) : A3($elm$parser$Parser$Advanced$Good, true, name, s1);
			}
		});
};
var $elm$parser$Parser$variable = function (i) {
	return $elm$parser$Parser$Advanced$variable(
		{expecting: $elm$parser$Parser$ExpectingVariable, inner: i.inner, reserved: i.reserved, start: i.start});
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$functionName = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$variable(
		{
			inner: function (c) {
				return $miniBill$elm_unicode$Unicode$isAlphaNum(c) || _Utils_eq(
					c,
					_Utils_chr('_'));
			},
			reserved: $elm$core$Set$fromList($stil4m$elm_syntax$Elm$Parser$Tokens$reservedList),
			start: $miniBill$elm_unicode$Unicode$isLower
		}));
var $elm$parser$Parser$ExpectingKeyword = function (a) {
	return {$: 'ExpectingKeyword', a: a};
};
var $elm$parser$Parser$Advanced$keyword = function (_v0) {
	var kwd = _v0.a;
	var expecting = _v0.b;
	var progress = !$elm$core$String$isEmpty(kwd);
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			var _v1 = A5($elm$parser$Parser$Advanced$isSubString, kwd, s.offset, s.row, s.col, s.src);
			var newOffset = _v1.a;
			var newRow = _v1.b;
			var newCol = _v1.c;
			return (_Utils_eq(newOffset, -1) || (0 <= A3(
				$elm$parser$Parser$Advanced$isSubChar,
				function (c) {
					return $elm$core$Char$isAlphaNum(c) || _Utils_eq(
						c,
						_Utils_chr('_'));
				},
				newOffset,
				s.src))) ? A2(
				$elm$parser$Parser$Advanced$Bad,
				false,
				A2($elm$parser$Parser$Advanced$fromState, s, expecting)) : A3(
				$elm$parser$Parser$Advanced$Good,
				progress,
				_Utils_Tuple0,
				{col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src});
		});
};
var $elm$parser$Parser$keyword = function (kwd) {
	return $elm$parser$Parser$Advanced$keyword(
		A2(
			$elm$parser$Parser$Advanced$Token,
			kwd,
			$elm$parser$Parser$ExpectingKeyword(kwd)));
};
var $elm$parser$Parser$Advanced$lazy = function (thunk) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			var _v0 = thunk(_Utils_Tuple0);
			var parse = _v0.a;
			return parse(s);
		});
};
var $elm$parser$Parser$lazy = $elm$parser$Parser$Advanced$lazy;
var $stil4m$elm_syntax$Combine$lazy = function (t) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$lazy(
				function (_v0) {
					return function (_v1) {
						var t_ = _v1.a;
						return t_(state);
					}(
						t(_Utils_Tuple0));
				});
		});
};
var $elm$parser$Parser$Nestable = {$: 'Nestable'};
var $elm$parser$Parser$Advanced$findSubString = _Parser_findSubString;
var $elm$parser$Parser$Advanced$fromInfo = F4(
	function (row, col, x, context) {
		return A2(
			$elm$parser$Parser$Advanced$AddRight,
			$elm$parser$Parser$Advanced$Empty,
			A4($elm$parser$Parser$Advanced$DeadEnd, row, col, x, context));
	});
var $elm$parser$Parser$Advanced$chompUntil = function (_v0) {
	var str = _v0.a;
	var expecting = _v0.b;
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			var _v1 = A5($elm$parser$Parser$Advanced$findSubString, str, s.offset, s.row, s.col, s.src);
			var newOffset = _v1.a;
			var newRow = _v1.b;
			var newCol = _v1.c;
			return _Utils_eq(newOffset, -1) ? A2(
				$elm$parser$Parser$Advanced$Bad,
				false,
				A4($elm$parser$Parser$Advanced$fromInfo, newRow, newCol, expecting, s.context)) : A3(
				$elm$parser$Parser$Advanced$Good,
				_Utils_cmp(s.offset, newOffset) < 0,
				_Utils_Tuple0,
				{col: newCol, context: s.context, indent: s.indent, offset: newOffset, row: newRow, src: s.src});
		});
};
var $elm$parser$Parser$Advanced$isChar = function (_char) {
	return true;
};
var $elm$parser$Parser$Advanced$revAlways = F2(
	function (_v0, b) {
		return b;
	});
var $elm$parser$Parser$Advanced$skip = F2(
	function (iParser, kParser) {
		return A3($elm$parser$Parser$Advanced$map2, $elm$parser$Parser$Advanced$revAlways, iParser, kParser);
	});
var $elm$parser$Parser$Advanced$nestableHelp = F5(
	function (isNotRelevant, open, close, expectingClose, nestLevel) {
		return A2(
			$elm$parser$Parser$Advanced$skip,
			$elm$parser$Parser$Advanced$chompWhile(isNotRelevant),
			$elm$parser$Parser$Advanced$oneOf(
				_List_fromArray(
					[
						(nestLevel === 1) ? close : A2(
						$elm$parser$Parser$Advanced$andThen,
						function (_v0) {
							return A5($elm$parser$Parser$Advanced$nestableHelp, isNotRelevant, open, close, expectingClose, nestLevel - 1);
						},
						close),
						A2(
						$elm$parser$Parser$Advanced$andThen,
						function (_v1) {
							return A5($elm$parser$Parser$Advanced$nestableHelp, isNotRelevant, open, close, expectingClose, nestLevel + 1);
						},
						open),
						A2(
						$elm$parser$Parser$Advanced$andThen,
						function (_v2) {
							return A5($elm$parser$Parser$Advanced$nestableHelp, isNotRelevant, open, close, expectingClose, nestLevel);
						},
						A2($elm$parser$Parser$Advanced$chompIf, $elm$parser$Parser$Advanced$isChar, expectingClose))
					])));
	});
var $elm$parser$Parser$Advanced$nestableComment = F2(
	function (open, close) {
		var oStr = open.a;
		var oX = open.b;
		var cStr = close.a;
		var cX = close.b;
		var _v0 = $elm$core$String$uncons(oStr);
		if (_v0.$ === 'Nothing') {
			return $elm$parser$Parser$Advanced$problem(oX);
		} else {
			var _v1 = _v0.a;
			var openChar = _v1.a;
			var _v2 = $elm$core$String$uncons(cStr);
			if (_v2.$ === 'Nothing') {
				return $elm$parser$Parser$Advanced$problem(cX);
			} else {
				var _v3 = _v2.a;
				var closeChar = _v3.a;
				var isNotRelevant = function (_char) {
					return (!_Utils_eq(_char, openChar)) && (!_Utils_eq(_char, closeChar));
				};
				var chompOpen = $elm$parser$Parser$Advanced$token(open);
				return A2(
					$elm$parser$Parser$Advanced$ignorer,
					chompOpen,
					A5(
						$elm$parser$Parser$Advanced$nestableHelp,
						isNotRelevant,
						chompOpen,
						$elm$parser$Parser$Advanced$token(close),
						cX,
						1));
			}
		}
	});
var $elm$parser$Parser$Advanced$multiComment = F3(
	function (open, close, nestable) {
		if (nestable.$ === 'NotNestable') {
			return A2(
				$elm$parser$Parser$Advanced$ignorer,
				$elm$parser$Parser$Advanced$token(open),
				$elm$parser$Parser$Advanced$chompUntil(close));
		} else {
			return A2($elm$parser$Parser$Advanced$nestableComment, open, close);
		}
	});
var $elm$parser$Parser$Advanced$Nestable = {$: 'Nestable'};
var $elm$parser$Parser$Advanced$NotNestable = {$: 'NotNestable'};
var $elm$parser$Parser$toAdvancedNestable = function (nestable) {
	if (nestable.$ === 'NotNestable') {
		return $elm$parser$Parser$Advanced$NotNestable;
	} else {
		return $elm$parser$Parser$Advanced$Nestable;
	}
};
var $elm$parser$Parser$multiComment = F3(
	function (open, close, nestable) {
		return A3(
			$elm$parser$Parser$Advanced$multiComment,
			$elm$parser$Parser$toToken(open),
			$elm$parser$Parser$toToken(close),
			$elm$parser$Parser$toAdvancedNestable(nestable));
	});
var $stil4m$elm_syntax$Elm$Parser$Comments$multilineCommentInner = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$getChompedString(
		A3($elm$parser$Parser$multiComment, '{-', '-}', $elm$parser$Parser$Nestable)));
var $stil4m$elm_syntax$Elm$Parser$State$addComment = F2(
	function (pair, _v0) {
		var s = _v0.a;
		return $stil4m$elm_syntax$Elm$Parser$State$State(
			_Utils_update(
				s,
				{
					comments: A2($elm$core$List$cons, pair, s.comments)
				}));
	});
var $stil4m$elm_syntax$Combine$modifyState = function (f) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$succeed(
				_Utils_Tuple2(
					f(state),
					_Utils_Tuple0));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Comments$addCommentToState = function (p) {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		function (pair) {
			return A2(
				$stil4m$elm_syntax$Combine$continueWith,
				$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0),
				$stil4m$elm_syntax$Combine$modifyState(
					$stil4m$elm_syntax$Elm$Parser$State$addComment(pair)));
		},
		p);
};
var $stil4m$elm_syntax$Elm$Parser$Comments$parseComment = function (commentParser) {
	return $stil4m$elm_syntax$Elm$Parser$Comments$addCommentToState(
		$stil4m$elm_syntax$Elm$Parser$Node$parser(commentParser));
};
var $stil4m$elm_syntax$Elm$Parser$Comments$multilineComment = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Elm$Parser$Comments$parseComment($stil4m$elm_syntax$Elm$Parser$Comments$multilineCommentInner);
	});
var $stil4m$elm_syntax$Elm$Parser$Whitespace$untilNewlineToken = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$getChompedString(
		$elm$parser$Parser$chompWhile(
			function (c) {
				return (!_Utils_eq(
					c,
					_Utils_chr('\u000D'))) && (!_Utils_eq(
					c,
					_Utils_chr('\n')));
			})));
var $stil4m$elm_syntax$Elm$Parser$Comments$singleLineComment = $stil4m$elm_syntax$Elm$Parser$Comments$parseComment(
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Whitespace$untilNewlineToken,
		A2(
			$stil4m$elm_syntax$Combine$andMap,
			$stil4m$elm_syntax$Combine$string('--'),
			$stil4m$elm_syntax$Combine$succeed($elm$core$Basics$append))));
var $stil4m$elm_syntax$Elm$Parser$Layout$anyComment = A2($stil4m$elm_syntax$Combine$or, $stil4m$elm_syntax$Elm$Parser$Comments$singleLineComment, $stil4m$elm_syntax$Elm$Parser$Comments$multilineComment);
var $elm$parser$Parser$Done = function (a) {
	return {$: 'Done', a: a};
};
var $elm$parser$Parser$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $elm$parser$Parser$Advanced$loopHelp = F4(
	function (p, state, callback, s0) {
		loopHelp:
		while (true) {
			var _v0 = callback(state);
			var parse = _v0.a;
			var _v1 = parse(s0);
			if (_v1.$ === 'Good') {
				var p1 = _v1.a;
				var step = _v1.b;
				var s1 = _v1.c;
				if (step.$ === 'Loop') {
					var newState = step.a;
					var $temp$p = p || p1,
						$temp$state = newState,
						$temp$callback = callback,
						$temp$s0 = s1;
					p = $temp$p;
					state = $temp$state;
					callback = $temp$callback;
					s0 = $temp$s0;
					continue loopHelp;
				} else {
					var result = step.a;
					return A3($elm$parser$Parser$Advanced$Good, p || p1, result, s1);
				}
			} else {
				var p1 = _v1.a;
				var x = _v1.b;
				return A2($elm$parser$Parser$Advanced$Bad, p || p1, x);
			}
		}
	});
var $elm$parser$Parser$Advanced$loop = F2(
	function (state, callback) {
		return $elm$parser$Parser$Advanced$Parser(
			function (s) {
				return A4($elm$parser$Parser$Advanced$loopHelp, false, state, callback, s);
			});
	});
var $elm$parser$Parser$Advanced$Done = function (a) {
	return {$: 'Done', a: a};
};
var $elm$parser$Parser$Advanced$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $elm$parser$Parser$toAdvancedStep = function (step) {
	if (step.$ === 'Loop') {
		var s = step.a;
		return $elm$parser$Parser$Advanced$Loop(s);
	} else {
		var a = step.a;
		return $elm$parser$Parser$Advanced$Done(a);
	}
};
var $elm$parser$Parser$loop = F2(
	function (state, callback) {
		return A2(
			$elm$parser$Parser$Advanced$loop,
			state,
			function (s) {
				return A2(
					$elm$parser$Parser$map,
					$elm$parser$Parser$toAdvancedStep,
					callback(s));
			});
	});
var $stil4m$elm_syntax$Combine$many = function (p) {
	var helper = function (_v2) {
		var oldState = _v2.a;
		var items = _v2.b;
		return $elm$parser$Parser$oneOf(
			_List_fromArray(
				[
					A2(
					$elm$parser$Parser$keeper,
					$elm$parser$Parser$succeed(
						function (_v0) {
							var newState = _v0.a;
							var item = _v0.b;
							return $elm$parser$Parser$Loop(
								_Utils_Tuple2(
									newState,
									A2($elm$core$List$cons, item, items)));
						}),
					A2($stil4m$elm_syntax$Combine$app, p, oldState)),
					A2(
					$elm$parser$Parser$map,
					function (_v1) {
						return $elm$parser$Parser$Done(
							_Utils_Tuple2(
								oldState,
								$elm$core$List$reverse(items)));
					},
					$elm$parser$Parser$succeed(_Utils_Tuple0))
				]));
	};
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$loop,
				_Utils_Tuple2(state, _List_Nil),
				helper);
		});
};
var $stil4m$elm_syntax$Combine$many1 = function (p) {
	return A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Combine$many(p),
		A2(
			$stil4m$elm_syntax$Combine$andMap,
			p,
			$stil4m$elm_syntax$Combine$succeed($elm$core$List$cons)));
};
var $stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces = $stil4m$elm_syntax$Combine$fromCore(
	A2(
		$elm$parser$Parser$ignorer,
		$elm$parser$Parser$token(' '),
		$elm$parser$Parser$chompWhile(
			function (c) {
				return _Utils_eq(
					c,
					_Utils_chr(' '));
			})));
var $stil4m$elm_syntax$Elm$Parser$Whitespace$realNewLine = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$getChompedString(
		A2(
			$elm$parser$Parser$ignorer,
			A2(
				$elm$parser$Parser$ignorer,
				$elm$parser$Parser$succeed(_Utils_Tuple0),
				$elm$parser$Parser$oneOf(
					_List_fromArray(
						[
							$elm$parser$Parser$chompIf(
							$elm$core$Basics$eq(
								_Utils_chr('\u000D'))),
							$elm$parser$Parser$succeed(_Utils_Tuple0)
						]))),
			$elm$parser$Parser$symbol('\n'))));
var $stil4m$elm_syntax$Elm$Parser$Layout$verifyIndent = function (f) {
	return $stil4m$elm_syntax$Combine$withState(
		function (s) {
			return $stil4m$elm_syntax$Combine$withLocation(
				function (l) {
					return A2(
						f,
						$stil4m$elm_syntax$Elm$Parser$State$expectedColumn(s),
						l.column) ? $stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0) : $stil4m$elm_syntax$Combine$fail(
						'Expected higher indent than ' + $elm$core$String$fromInt(l.column));
				});
		});
};
var $stil4m$elm_syntax$Elm$Parser$Layout$layout = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Layout$verifyIndent(
		F2(
			function (stateIndent, current) {
				return _Utils_cmp(stateIndent, current) < 0;
			})),
	$stil4m$elm_syntax$Combine$many1(
		$stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					$stil4m$elm_syntax$Elm$Parser$Layout$anyComment,
					A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[$stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces, $stil4m$elm_syntax$Elm$Parser$Layout$anyComment])),
					$stil4m$elm_syntax$Combine$many1($stil4m$elm_syntax$Elm$Parser$Whitespace$realNewLine)),
					$stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces
				]))));
var $stil4m$elm_syntax$Combine$maybe = function (_v0) {
	var p = _v0.a;
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return $elm$parser$Parser$oneOf(
				_List_fromArray(
					[
						A2(
						$elm$parser$Parser$map,
						function (_v1) {
							var c = _v1.a;
							var v = _v1.b;
							return _Utils_Tuple2(
								c,
								$elm$core$Maybe$Just(v));
						},
						p(state)),
						$elm$parser$Parser$succeed(
						_Utils_Tuple2(state, $elm$core$Maybe$Nothing))
					]));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides = function (x) {
	return A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
		A2(
			$stil4m$elm_syntax$Combine$continueWith,
			x,
			$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout)));
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$FloatPattern = function (a) {
	return {$: 'FloatPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$HexPattern = function (a) {
	return {$: 'HexPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Pattern$IntPattern = function (a) {
	return {$: 'IntPattern', a: a};
};
var $elm$parser$Parser$ExpectingBinary = {$: 'ExpectingBinary'};
var $elm$parser$Parser$ExpectingFloat = {$: 'ExpectingFloat'};
var $elm$parser$Parser$ExpectingHex = {$: 'ExpectingHex'};
var $elm$parser$Parser$ExpectingInt = {$: 'ExpectingInt'};
var $elm$parser$Parser$ExpectingNumber = {$: 'ExpectingNumber'};
var $elm$parser$Parser$ExpectingOctal = {$: 'ExpectingOctal'};
var $elm$core$Result$fromMaybe = F2(
	function (err, maybe) {
		if (maybe.$ === 'Just') {
			var v = maybe.a;
			return $elm$core$Result$Ok(v);
		} else {
			return $elm$core$Result$Err(err);
		}
	});
var $elm$parser$Parser$Advanced$consumeBase = _Parser_consumeBase;
var $elm$parser$Parser$Advanced$consumeBase16 = _Parser_consumeBase16;
var $elm$parser$Parser$Advanced$bumpOffset = F2(
	function (newOffset, s) {
		return {col: s.col + (newOffset - s.offset), context: s.context, indent: s.indent, offset: newOffset, row: s.row, src: s.src};
	});
var $elm$parser$Parser$Advanced$chompBase10 = _Parser_chompBase10;
var $elm$parser$Parser$Advanced$isAsciiCode = _Parser_isAsciiCode;
var $elm$parser$Parser$Advanced$consumeExp = F2(
	function (offset, src) {
		if (A3($elm$parser$Parser$Advanced$isAsciiCode, 101, offset, src) || A3($elm$parser$Parser$Advanced$isAsciiCode, 69, offset, src)) {
			var eOffset = offset + 1;
			var expOffset = (A3($elm$parser$Parser$Advanced$isAsciiCode, 43, eOffset, src) || A3($elm$parser$Parser$Advanced$isAsciiCode, 45, eOffset, src)) ? (eOffset + 1) : eOffset;
			var newOffset = A2($elm$parser$Parser$Advanced$chompBase10, expOffset, src);
			return _Utils_eq(expOffset, newOffset) ? (-newOffset) : newOffset;
		} else {
			return offset;
		}
	});
var $elm$parser$Parser$Advanced$consumeDotAndExp = F2(
	function (offset, src) {
		return A3($elm$parser$Parser$Advanced$isAsciiCode, 46, offset, src) ? A2(
			$elm$parser$Parser$Advanced$consumeExp,
			A2($elm$parser$Parser$Advanced$chompBase10, offset + 1, src),
			src) : A2($elm$parser$Parser$Advanced$consumeExp, offset, src);
	});
var $elm$parser$Parser$Advanced$finalizeInt = F5(
	function (invalid, handler, startOffset, _v0, s) {
		var endOffset = _v0.a;
		var n = _v0.b;
		if (handler.$ === 'Err') {
			var x = handler.a;
			return A2(
				$elm$parser$Parser$Advanced$Bad,
				true,
				A2($elm$parser$Parser$Advanced$fromState, s, x));
		} else {
			var toValue = handler.a;
			return _Utils_eq(startOffset, endOffset) ? A2(
				$elm$parser$Parser$Advanced$Bad,
				_Utils_cmp(s.offset, startOffset) < 0,
				A2($elm$parser$Parser$Advanced$fromState, s, invalid)) : A3(
				$elm$parser$Parser$Advanced$Good,
				true,
				toValue(n),
				A2($elm$parser$Parser$Advanced$bumpOffset, endOffset, s));
		}
	});
var $elm$parser$Parser$Advanced$finalizeFloat = F6(
	function (invalid, expecting, intSettings, floatSettings, intPair, s) {
		var intOffset = intPair.a;
		var floatOffset = A2($elm$parser$Parser$Advanced$consumeDotAndExp, intOffset, s.src);
		if (floatOffset < 0) {
			return A2(
				$elm$parser$Parser$Advanced$Bad,
				true,
				A4($elm$parser$Parser$Advanced$fromInfo, s.row, s.col - (floatOffset + s.offset), invalid, s.context));
		} else {
			if (_Utils_eq(s.offset, floatOffset)) {
				return A2(
					$elm$parser$Parser$Advanced$Bad,
					false,
					A2($elm$parser$Parser$Advanced$fromState, s, expecting));
			} else {
				if (_Utils_eq(intOffset, floatOffset)) {
					return A5($elm$parser$Parser$Advanced$finalizeInt, invalid, intSettings, s.offset, intPair, s);
				} else {
					if (floatSettings.$ === 'Err') {
						var x = floatSettings.a;
						return A2(
							$elm$parser$Parser$Advanced$Bad,
							true,
							A2($elm$parser$Parser$Advanced$fromState, s, invalid));
					} else {
						var toValue = floatSettings.a;
						var _v1 = $elm$core$String$toFloat(
							A3($elm$core$String$slice, s.offset, floatOffset, s.src));
						if (_v1.$ === 'Nothing') {
							return A2(
								$elm$parser$Parser$Advanced$Bad,
								true,
								A2($elm$parser$Parser$Advanced$fromState, s, invalid));
						} else {
							var n = _v1.a;
							return A3(
								$elm$parser$Parser$Advanced$Good,
								true,
								toValue(n),
								A2($elm$parser$Parser$Advanced$bumpOffset, floatOffset, s));
						}
					}
				}
			}
		}
	});
var $elm$parser$Parser$Advanced$number = function (c) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			if (A3($elm$parser$Parser$Advanced$isAsciiCode, 48, s.offset, s.src)) {
				var zeroOffset = s.offset + 1;
				var baseOffset = zeroOffset + 1;
				return A3($elm$parser$Parser$Advanced$isAsciiCode, 120, zeroOffset, s.src) ? A5(
					$elm$parser$Parser$Advanced$finalizeInt,
					c.invalid,
					c.hex,
					baseOffset,
					A2($elm$parser$Parser$Advanced$consumeBase16, baseOffset, s.src),
					s) : (A3($elm$parser$Parser$Advanced$isAsciiCode, 111, zeroOffset, s.src) ? A5(
					$elm$parser$Parser$Advanced$finalizeInt,
					c.invalid,
					c.octal,
					baseOffset,
					A3($elm$parser$Parser$Advanced$consumeBase, 8, baseOffset, s.src),
					s) : (A3($elm$parser$Parser$Advanced$isAsciiCode, 98, zeroOffset, s.src) ? A5(
					$elm$parser$Parser$Advanced$finalizeInt,
					c.invalid,
					c.binary,
					baseOffset,
					A3($elm$parser$Parser$Advanced$consumeBase, 2, baseOffset, s.src),
					s) : A6(
					$elm$parser$Parser$Advanced$finalizeFloat,
					c.invalid,
					c.expecting,
					c._int,
					c._float,
					_Utils_Tuple2(zeroOffset, 0),
					s)));
			} else {
				return A6(
					$elm$parser$Parser$Advanced$finalizeFloat,
					c.invalid,
					c.expecting,
					c._int,
					c._float,
					A3($elm$parser$Parser$Advanced$consumeBase, 10, s.offset, s.src),
					s);
			}
		});
};
var $elm$parser$Parser$number = function (i) {
	return $elm$parser$Parser$Advanced$number(
		{
			binary: A2($elm$core$Result$fromMaybe, $elm$parser$Parser$ExpectingBinary, i.binary),
			expecting: $elm$parser$Parser$ExpectingNumber,
			_float: A2($elm$core$Result$fromMaybe, $elm$parser$Parser$ExpectingFloat, i._float),
			hex: A2($elm$core$Result$fromMaybe, $elm$parser$Parser$ExpectingHex, i.hex),
			_int: A2($elm$core$Result$fromMaybe, $elm$parser$Parser$ExpectingInt, i._int),
			invalid: $elm$parser$Parser$ExpectingNumber,
			octal: A2($elm$core$Result$fromMaybe, $elm$parser$Parser$ExpectingOctal, i.octal)
		});
};
var $stil4m$elm_syntax$Elm$Parser$Numbers$raw = F3(
	function (floatf, intf, hexf) {
		return $elm$parser$Parser$number(
			{
				binary: $elm$core$Maybe$Nothing,
				_float: $elm$core$Maybe$Just(floatf),
				hex: $elm$core$Maybe$Just(hexf),
				_int: $elm$core$Maybe$Just(intf),
				octal: $elm$core$Maybe$Nothing
			});
	});
var $stil4m$elm_syntax$Elm$Parser$Numbers$number = F3(
	function (floatf, intf, hexf) {
		return $stil4m$elm_syntax$Combine$fromCore(
			A3($stil4m$elm_syntax$Elm$Parser$Numbers$raw, floatf, intf, hexf));
	});
var $stil4m$elm_syntax$Elm$Parser$Patterns$numberPart = A3($stil4m$elm_syntax$Elm$Parser$Numbers$number, $stil4m$elm_syntax$Elm$Syntax$Pattern$FloatPattern, $stil4m$elm_syntax$Elm$Syntax$Pattern$IntPattern, $stil4m$elm_syntax$Elm$Syntax$Pattern$HexPattern);
var $stil4m$elm_syntax$Combine$parens = A2(
	$stil4m$elm_syntax$Combine$between,
	$stil4m$elm_syntax$Combine$string('('),
	$stil4m$elm_syntax$Combine$string(')'));
var $stil4m$elm_syntax$Elm$Syntax$Pattern$RecordPattern = function (a) {
	return {$: 'RecordPattern', a: a};
};
var $stil4m$elm_syntax$Combine$sepBy1 = F2(
	function (sep, p) {
		return A2(
			$stil4m$elm_syntax$Combine$andMap,
			$stil4m$elm_syntax$Combine$many(
				A2($stil4m$elm_syntax$Combine$continueWith, p, sep)),
			A2(
				$stil4m$elm_syntax$Combine$andMap,
				p,
				$stil4m$elm_syntax$Combine$succeed($elm$core$List$cons)));
	});
var $stil4m$elm_syntax$Combine$sepBy = F2(
	function (sep, p) {
		return A2(
			$stil4m$elm_syntax$Combine$or,
			A2($stil4m$elm_syntax$Combine$sepBy1, sep, p),
			$stil4m$elm_syntax$Combine$succeed(_List_Nil));
	});
var $stil4m$elm_syntax$Elm$Parser$Patterns$recordPattern = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Elm$Parser$Node$parser(
			A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Syntax$Pattern$RecordPattern,
				A3(
					$stil4m$elm_syntax$Combine$between,
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Combine$string('{')),
					$stil4m$elm_syntax$Combine$string('}'),
					A2(
						$stil4m$elm_syntax$Combine$sepBy,
						$stil4m$elm_syntax$Combine$string(','),
						$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
							$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName))))));
	});
var $elm$parser$Parser$Advanced$getOffset = $elm$parser$Parser$Advanced$Parser(
	function (s) {
		return A3($elm$parser$Parser$Advanced$Good, false, s.offset, s);
	});
var $elm$parser$Parser$getOffset = $elm$parser$Parser$Advanced$getOffset;
var $stil4m$elm_syntax$Elm$Parser$Tokens$stringLiteral = function () {
	var helper = function (s) {
		return s.escaped ? A2(
			$elm$parser$Parser$map,
			function (v) {
				return $elm$parser$Parser$Loop(
					{
						escaped: false,
						parts: A2(
							$elm$core$List$cons,
							$elm$core$String$fromList(
								_List_fromArray(
									[v])),
							s.parts)
					});
			},
			$stil4m$elm_syntax$Elm$Parser$Tokens$escapedCharValue) : $elm$parser$Parser$oneOf(
			_List_fromArray(
				[
					A2(
					$elm$parser$Parser$map,
					function (_v0) {
						return $elm$parser$Parser$Done(
							$elm$core$String$concat(
								$elm$core$List$reverse(s.parts)));
					},
					$elm$parser$Parser$symbol('\"')),
					A2(
					$elm$parser$Parser$map,
					function (_v1) {
						return $elm$parser$Parser$Loop(
							{escaped: true, parts: s.parts});
					},
					$elm$parser$Parser$getChompedString(
						$elm$parser$Parser$symbol('\\'))),
					A2(
					$elm$parser$Parser$andThen,
					function (_v2) {
						var start = _v2.a;
						var value = _v2.b;
						var end = _v2.c;
						return _Utils_eq(start, end) ? $elm$parser$Parser$problem('Expected a string character or a double quote') : $elm$parser$Parser$succeed(
							$elm$parser$Parser$Loop(
								{
									escaped: s.escaped,
									parts: A2($elm$core$List$cons, value, s.parts)
								}));
					},
					A2(
						$elm$parser$Parser$keeper,
						A2(
							$elm$parser$Parser$keeper,
							A2(
								$elm$parser$Parser$keeper,
								$elm$parser$Parser$succeed(
									F3(
										function (start, value, end) {
											return _Utils_Tuple3(start, value, end);
										})),
								$elm$parser$Parser$getOffset),
							$elm$parser$Parser$getChompedString(
								$elm$parser$Parser$chompWhile(
									function (c) {
										return (!_Utils_eq(
											c,
											_Utils_chr('\"'))) && (!_Utils_eq(
											c,
											_Utils_chr('\\')));
									}))),
						$elm$parser$Parser$getOffset))
				]));
	};
	return $stil4m$elm_syntax$Combine$fromCore(
		A2(
			$elm$parser$Parser$keeper,
			A2(
				$elm$parser$Parser$ignorer,
				$elm$parser$Parser$succeed($elm$core$Basics$identity),
				$elm$parser$Parser$symbol('\"')),
			A2(
				$elm$parser$Parser$loop,
				{escaped: false, parts: _List_Nil},
				helper)));
}();
var $miniBill$elm_unicode$Unicode$isUpper = function (c) {
	var simple = _Utils_eq(
		$elm$core$Char$toUpper(c),
		c) && (!_Utils_eq(
		$elm$core$Char$toLower(c),
		c));
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return (simple && (((code <= 8543) || A2(r, 8560, 9397)) || A2(r, 9424, 983040))) || (l(120015) ? (l(8509) ? ((((((((((A2(r, 978, 980) || e(8450)) || e(8455)) || A2(r, 8459, 8461)) || A2(r, 8464, 8466)) || e(8469)) || A2(r, 8473, 8477)) || e(8484)) || e(8488)) || A2(r, 8490, 8493)) || A2(r, 8496, 8499)) : ((((((((((A2(r, 8510, 8511) || e(8517)) || A2(r, 119808, 119833)) || A2(r, 119860, 119885)) || A2(r, 119912, 119937)) || e(119964)) || A2(r, 119966, 119967)) || e(119970)) || A2(r, 119973, 119974)) || A2(r, 119977, 119980)) || A2(r, 119982, 119989))) : (l(120223) ? ((((((((((A2(r, 120016, 120041) || A2(r, 120068, 120069)) || A2(r, 120071, 120074)) || A2(r, 120077, 120084)) || A2(r, 120086, 120092)) || A2(r, 120120, 120121)) || A2(r, 120123, 120126)) || A2(r, 120128, 120132)) || e(120134)) || A2(r, 120138, 120144)) || A2(r, 120172, 120197)) : ((((((((((A2(r, 120224, 120249) || A2(r, 120276, 120301)) || A2(r, 120328, 120353)) || A2(r, 120380, 120405)) || A2(r, 120432, 120457)) || A2(r, 120488, 120512)) || A2(r, 120546, 120570)) || A2(r, 120604, 120628)) || A2(r, 120662, 120686)) || A2(r, 120720, 120744)) || e(120778))));
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$typeName = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$variable(
		{
			inner: function (c) {
				return $miniBill$elm_unicode$Unicode$isAlphaNum(c) || _Utils_eq(
					c,
					_Utils_chr('_'));
			},
			reserved: $elm$core$Set$fromList($stil4m$elm_syntax$Elm$Parser$Tokens$reservedList),
			start: $miniBill$elm_unicode$Unicode$isUpper
		}));
var $stil4m$elm_syntax$Elm$Parser$Base$typeIndicator = function () {
	var helper = function (_v0) {
		var n = _v0.a;
		var xs = _v0.b;
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					A2(
					$stil4m$elm_syntax$Combine$andThen,
					function (t) {
						return helper(
							_Utils_Tuple2(
								t,
								A2($elm$core$List$cons, n, xs)));
					},
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Tokens$typeName,
						$stil4m$elm_syntax$Combine$string('.'))),
					$stil4m$elm_syntax$Combine$succeed(
					_Utils_Tuple2(n, xs))
				]));
	};
	return A2(
		$stil4m$elm_syntax$Combine$map,
		function (_v1) {
			var t = _v1.a;
			var xs = _v1.b;
			return _Utils_Tuple2(
				$elm$core$List$reverse(xs),
				t);
		},
		A2(
			$stil4m$elm_syntax$Combine$andThen,
			function (t) {
				return helper(
					_Utils_Tuple2(t, _List_Nil));
			},
			$stil4m$elm_syntax$Elm$Parser$Tokens$typeName));
}();
var $stil4m$elm_syntax$Elm$Syntax$Pattern$VarPattern = function (a) {
	return {$: 'VarPattern', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Patterns$variablePart = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Pattern$VarPattern, $stil4m$elm_syntax$Elm$Parser$Tokens$functionName));
var $stil4m$elm_syntax$Elm$Parser$Patterns$qualifiedPattern = function (consumeArgs) {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		function (_v0) {
			var range = _v0.a;
			var _v1 = _v0.b;
			var mod = _v1.a;
			var name = _v1.b;
			return A2(
				$stil4m$elm_syntax$Combine$map,
				function (args) {
					return A2(
						$stil4m$elm_syntax$Elm$Syntax$Node$Node,
						$stil4m$elm_syntax$Elm$Syntax$Range$combine(
							A2(
								$elm$core$List$cons,
								range,
								A2(
									$elm$core$List$map,
									function (_v2) {
										var r = _v2.a;
										return r;
									},
									args))),
						A2(
							$stil4m$elm_syntax$Elm$Syntax$Pattern$NamedPattern,
							A2($stil4m$elm_syntax$Elm$Syntax$Pattern$QualifiedNameRef, mod, name),
							args));
				},
				consumeArgs ? $stil4m$elm_syntax$Combine$many(
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$qualifiedPatternArg())) : $stil4m$elm_syntax$Combine$succeed(_List_Nil));
		},
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
			$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$typeIndicator)));
};
var $stil4m$elm_syntax$Elm$Parser$Patterns$tryToCompose = function (x) {
	return A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					A2(
					$stil4m$elm_syntax$Combine$map,
					function (y) {
						return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$Pattern$AsPattern, x, y);
					},
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Elm$Parser$Layout$layout,
							$stil4m$elm_syntax$Combine$fromCore(
								$elm$parser$Parser$keyword('as'))))),
					A2(
					$stil4m$elm_syntax$Combine$map,
					function (y) {
						return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$Pattern$UnConsPattern, x, y);
					},
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$fromCore(
								$elm$parser$Parser$symbol('::'))))),
					$stil4m$elm_syntax$Combine$succeed(x)
				])),
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout));
};
function $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern() {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		$stil4m$elm_syntax$Elm$Parser$Patterns$tryToCompose,
		$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$composablePattern());
}
function $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$composablePattern() {
	return $stil4m$elm_syntax$Combine$choice(
		_List_fromArray(
			[
				$stil4m$elm_syntax$Elm$Parser$Patterns$variablePart,
				$stil4m$elm_syntax$Elm$Parser$Patterns$qualifiedPattern(true),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Pattern$StringPattern, $stil4m$elm_syntax$Elm$Parser$Tokens$stringLiteral)),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Pattern$CharPattern, $stil4m$elm_syntax$Elm$Parser$Tokens$characterLiteral)),
				$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Patterns$numberPart),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$map,
					$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$Pattern$UnitPattern),
					$stil4m$elm_syntax$Combine$fromCore(
						$elm$parser$Parser$symbol('()')))),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$map,
					$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$Pattern$AllPattern),
					$stil4m$elm_syntax$Combine$fromCore(
						$elm$parser$Parser$symbol('_')))),
				$stil4m$elm_syntax$Elm$Parser$Patterns$recordPattern,
				$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$listPattern(),
				$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$parensPattern()
			]));
}
function $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$qualifiedPatternArg() {
	return $stil4m$elm_syntax$Combine$choice(
		_List_fromArray(
			[
				$stil4m$elm_syntax$Elm$Parser$Patterns$variablePart,
				$stil4m$elm_syntax$Elm$Parser$Patterns$qualifiedPattern(false),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Pattern$StringPattern, $stil4m$elm_syntax$Elm$Parser$Tokens$stringLiteral)),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Pattern$CharPattern, $stil4m$elm_syntax$Elm$Parser$Tokens$characterLiteral)),
				$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Patterns$numberPart),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$map,
					$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$Pattern$UnitPattern),
					$stil4m$elm_syntax$Combine$fromCore(
						$elm$parser$Parser$symbol('()')))),
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$map,
					$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$Pattern$AllPattern),
					$stil4m$elm_syntax$Combine$fromCore(
						$elm$parser$Parser$symbol('_')))),
				$stil4m$elm_syntax$Elm$Parser$Patterns$recordPattern,
				$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$listPattern(),
				$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$parensPattern()
			]));
}
function $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$listPattern() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v5) {
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A3(
					$stil4m$elm_syntax$Combine$between,
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Combine$string('[')),
					$stil4m$elm_syntax$Combine$string(']'),
					A2(
						$stil4m$elm_syntax$Combine$map,
						$stil4m$elm_syntax$Elm$Syntax$Pattern$ListPattern,
						A2(
							$stil4m$elm_syntax$Combine$sepBy,
							$stil4m$elm_syntax$Combine$string(','),
							$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
								$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern())))));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$parensPattern() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v3) {
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$map,
					function (c) {
						if (c.b && (!c.b.b)) {
							var x = c.a;
							return $stil4m$elm_syntax$Elm$Syntax$Pattern$ParenthesizedPattern(x);
						} else {
							return $stil4m$elm_syntax$Elm$Syntax$Pattern$TuplePattern(c);
						}
					},
					$stil4m$elm_syntax$Combine$parens(
						A2(
							$stil4m$elm_syntax$Combine$sepBy,
							$stil4m$elm_syntax$Combine$string(','),
							$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
								$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern())))));
		});
}
try {
	var $stil4m$elm_syntax$Elm$Parser$Patterns$pattern = $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern();
	$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$pattern = function () {
		return $stil4m$elm_syntax$Elm$Parser$Patterns$pattern;
	};
	var $stil4m$elm_syntax$Elm$Parser$Patterns$composablePattern = $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$composablePattern();
	$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$composablePattern = function () {
		return $stil4m$elm_syntax$Elm$Parser$Patterns$composablePattern;
	};
	var $stil4m$elm_syntax$Elm$Parser$Patterns$qualifiedPatternArg = $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$qualifiedPatternArg();
	$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$qualifiedPatternArg = function () {
		return $stil4m$elm_syntax$Elm$Parser$Patterns$qualifiedPatternArg;
	};
	var $stil4m$elm_syntax$Elm$Parser$Patterns$listPattern = $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$listPattern();
	$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$listPattern = function () {
		return $stil4m$elm_syntax$Elm$Parser$Patterns$listPattern;
	};
	var $stil4m$elm_syntax$Elm$Parser$Patterns$parensPattern = $stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$parensPattern();
	$stil4m$elm_syntax$Elm$Parser$Patterns$cyclic$parensPattern = function () {
		return $stil4m$elm_syntax$Elm$Parser$Patterns$parensPattern;
	};
} catch ($) {
	throw 'Some top-level definitions from `Elm.Parser.Patterns` are causing infinite recursion:\n\n  \n      pattern\n       \n      composablePattern\n       \n      qualifiedPatternArg\n       \n      listPattern\n       \n      parensPattern\n       \n      qualifiedPattern\n       \n      tryToCompose\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $stil4m$elm_syntax$Elm$Parser$Declarations$functionArgument = $stil4m$elm_syntax$Elm$Parser$Patterns$pattern;
var $stil4m$elm_syntax$Elm$Syntax$Node$range = function (_v0) {
	var r = _v0.a;
	return r;
};
var $stil4m$elm_syntax$Elm$Syntax$Node$value = function (_v0) {
	var v = _v0.b;
	return v;
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$functionRange = function (_function) {
	return $stil4m$elm_syntax$Elm$Syntax$Range$combine(
		_List_fromArray(
			[
				function () {
				var _v0 = _function.documentation;
				if (_v0.$ === 'Just') {
					var documentation = _v0.a;
					return $stil4m$elm_syntax$Elm$Syntax$Node$range(documentation);
				} else {
					return A2(
						$elm$core$Maybe$withDefault,
						function (_v3) {
							var r = _v3.a;
							return r;
						}(
							$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).name),
						A2(
							$elm$core$Maybe$map,
							function (_v1) {
								var value = _v1.b;
								var _v2 = value.name;
								var r = _v2.a;
								return r;
							},
							_function.signature));
				}
			}(),
				function (_v4) {
				var r = _v4.a;
				return r;
			}(
				$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression)
			]));
};
var $stil4m$elm_syntax$Elm$Syntax$Signature$Signature = F2(
	function (name, typeAnnotation) {
		return {name: name, typeAnnotation: typeAnnotation};
	});
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$Eager = {$: 'Eager'};
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation = F2(
	function (a, b) {
		return {$: 'FunctionTypeAnnotation', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$GenericRecord = F2(
	function (a, b) {
		return {$: 'GenericRecord', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$Lazy = {$: 'Lazy'};
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Record = function (a) {
	return {$: 'Record', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Typed = F2(
	function (a, b) {
		return {$: 'Typed', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Unit = {$: 'Unit'};
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Tupled = function (a) {
	return {$: 'Tupled', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$asTypeAnnotation = F2(
	function (x, xs) {
		var value = x.b;
		if (!xs.b) {
			return value;
		} else {
			return $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Tupled(
				A2($elm$core$List$cons, x, xs));
		}
	});
var $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$GenericType = function (a) {
	return {$: 'GenericType', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$genericTypeAnnotation = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Elm$Parser$Node$parser(
			A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$GenericType, $stil4m$elm_syntax$Elm$Parser$Tokens$functionName));
	});
var $stil4m$elm_syntax$Elm$Parser$Layout$Indented = {$: 'Indented'};
var $stil4m$elm_syntax$Elm$Parser$Layout$Strict = {$: 'Strict'};
var $elm$core$List$member = F2(
	function (x, xs) {
		return A2(
			$elm$core$List$any,
			function (a) {
				return _Utils_eq(a, x);
			},
			xs);
	});
var $stil4m$elm_syntax$Elm$Parser$State$storedColumns = function (_v0) {
	var indents = _v0.a.indents;
	return A2(
		$elm$core$List$map,
		$elm$core$Basics$add(1),
		indents);
};
var $stil4m$elm_syntax$Elm$Parser$Layout$compute = $stil4m$elm_syntax$Combine$withState(
	function (s) {
		return $stil4m$elm_syntax$Combine$withLocation(
			function (l) {
				var known = A2(
					$elm$core$List$cons,
					1,
					$stil4m$elm_syntax$Elm$Parser$State$storedColumns(s));
				return A2($elm$core$List$member, l.column, known) ? $stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Parser$Layout$Strict) : $stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Parser$Layout$Indented);
			});
	});
var $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Layout$compute,
	$stil4m$elm_syntax$Combine$many(
		$stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					$stil4m$elm_syntax$Elm$Parser$Layout$anyComment,
					A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								$stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces,
								$stil4m$elm_syntax$Elm$Parser$Layout$anyComment,
								$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0)
							])),
					$stil4m$elm_syntax$Combine$many1($stil4m$elm_syntax$Elm$Parser$Whitespace$realNewLine)),
					$stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces
				]))));
var $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith = F2(
	function (onStrict, onIndented) {
		return A2(
			$stil4m$elm_syntax$Combine$andThen,
			function (ind) {
				if (ind.$ === 'Strict') {
					return onStrict(_Utils_Tuple0);
				} else {
					return onIndented(_Utils_Tuple0);
				}
			},
			$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout);
	});
var $elm$core$Tuple$pair = F2(
	function (a, b) {
		return _Utils_Tuple2(a, b);
	});
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotationNoFn = function (mode) {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v7) {
			return $stil4m$elm_syntax$Combine$choice(
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation(),
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typedTypeAnnotation(mode),
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$genericTypeAnnotation,
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation()
					]));
		});
};
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typedTypeAnnotation = function (mode) {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v0) {
			var nodeRanges = $elm$core$List$map(
				function (_v6) {
					var r = _v6.a;
					return r;
				});
			var genericHelper = function (items) {
				return A2(
					$stil4m$elm_syntax$Combine$or,
					A2(
						$stil4m$elm_syntax$Combine$andThen,
						function (next) {
							return A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								A2(
									$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
									function (_v1) {
										return $stil4m$elm_syntax$Combine$succeed(
											$elm$core$List$reverse(
												A2($elm$core$List$cons, next, items)));
									},
									function (_v2) {
										return genericHelper(
											A2($elm$core$List$cons, next, items));
									}));
						},
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotationNoFn($stil4m$elm_syntax$Elm$Parser$TypeAnnotation$Lazy)),
					$stil4m$elm_syntax$Combine$succeed(
						$elm$core$List$reverse(items)));
			};
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (original) {
					var tir = original.a;
					return A2(
						$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
						function (_v3) {
							return $stil4m$elm_syntax$Combine$succeed(
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Node$Node,
									tir,
									A2($stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Typed, original, _List_Nil)));
						},
						function (_v4) {
							if (mode.$ === 'Eager') {
								return A2(
									$stil4m$elm_syntax$Combine$map,
									function (args) {
										return A2(
											$stil4m$elm_syntax$Elm$Syntax$Node$Node,
											$stil4m$elm_syntax$Elm$Syntax$Range$combine(
												A2(
													$elm$core$List$cons,
													tir,
													nodeRanges(args))),
											A2($stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Typed, original, args));
									},
									genericHelper(_List_Nil));
							} else {
								return $stil4m$elm_syntax$Combine$succeed(
									A2(
										$stil4m$elm_syntax$Elm$Syntax$Node$Node,
										tir,
										A2($stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Typed, original, _List_Nil)));
							}
						});
				},
				$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$typeIndicator));
		});
};
function $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v14) {
			var commaSep = $stil4m$elm_syntax$Combine$many(
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$string(',')))));
			var nested = A2(
				$stil4m$elm_syntax$Combine$andMap,
				commaSep,
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Parser$TypeAnnotation$asTypeAnnotation)))));
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$map,
								$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Unit),
								$stil4m$elm_syntax$Combine$string(')')),
								A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$string(')'),
								nested)
							])),
					$stil4m$elm_syntax$Combine$string('(')));
		});
}
function $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v13) {
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(),
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Combine$string(':'),
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout)))),
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout)),
					$stil4m$elm_syntax$Combine$succeed($elm$core$Tuple$pair)));
		});
}
function $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v12) {
			return A2(
				$stil4m$elm_syntax$Combine$sepBy1,
				$stil4m$elm_syntax$Combine$string(','),
				$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
					$stil4m$elm_syntax$Elm$Parser$Node$parser(
						$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition())));
		});
}
function $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v11) {
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$continueWith,
								$stil4m$elm_syntax$Combine$succeed(
									$stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Record(_List_Nil)),
								$stil4m$elm_syntax$Combine$string('}')),
								A2(
								$stil4m$elm_syntax$Combine$andThen,
								function (fname) {
									return $stil4m$elm_syntax$Combine$choice(
										_List_fromArray(
											[
												A2(
												$stil4m$elm_syntax$Combine$ignore,
												$stil4m$elm_syntax$Combine$string('}'),
												A2(
													$stil4m$elm_syntax$Combine$andMap,
													$stil4m$elm_syntax$Elm$Parser$Node$parser(
														$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation()),
													A2(
														$stil4m$elm_syntax$Combine$ignore,
														$stil4m$elm_syntax$Combine$string('|'),
														$stil4m$elm_syntax$Combine$succeed(
															$stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$GenericRecord(fname))))),
												A2(
												$stil4m$elm_syntax$Combine$andThen,
												function (ta) {
													return A2(
														$stil4m$elm_syntax$Combine$map,
														function (rest) {
															return $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$Record(
																A2(
																	$elm$core$List$cons,
																	A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $elm$core$Tuple$pair, fname, ta),
																	rest));
														},
														A2(
															$stil4m$elm_syntax$Combine$ignore,
															$stil4m$elm_syntax$Combine$string('}'),
															$stil4m$elm_syntax$Combine$choice(
																_List_fromArray(
																	[
																		A2(
																		$stil4m$elm_syntax$Combine$continueWith,
																		$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation(),
																		$stil4m$elm_syntax$Combine$string(',')),
																		$stil4m$elm_syntax$Combine$succeed(_List_Nil)
																	]))));
												},
												A2(
													$stil4m$elm_syntax$Combine$ignore,
													$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
													A2(
														$stil4m$elm_syntax$Combine$continueWith,
														$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(),
														A2(
															$stil4m$elm_syntax$Combine$ignore,
															$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
															$stil4m$elm_syntax$Combine$string(':')))))
											]));
								},
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName)))
							])),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Combine$string('{'))));
		});
}
function $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v8) {
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (typeRef) {
					return A2(
						$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
						function (_v9) {
							return $stil4m$elm_syntax$Combine$succeed(typeRef);
						},
						function (_v10) {
							return A2(
								$stil4m$elm_syntax$Combine$or,
								A2(
									$stil4m$elm_syntax$Combine$map,
									function (ta) {
										return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation, typeRef, ta);
									},
									A2(
										$stil4m$elm_syntax$Combine$continueWith,
										$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(),
										A2(
											$stil4m$elm_syntax$Combine$ignore,
											$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
											$stil4m$elm_syntax$Combine$string('->')))),
								$stil4m$elm_syntax$Combine$succeed(typeRef));
						});
				},
				$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotationNoFn($stil4m$elm_syntax$Elm$Parser$TypeAnnotation$Eager));
		});
}
try {
	var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$parensTypeAnnotation = $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation();
	$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation = function () {
		return $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$parensTypeAnnotation;
	};
	var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordFieldDefinition = $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition();
	$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition = function () {
		return $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordFieldDefinition;
	};
	var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordFieldsTypeAnnotation = $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation();
	$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation = function () {
		return $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordFieldsTypeAnnotation;
	};
	var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordTypeAnnotation = $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation();
	$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation = function () {
		return $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordTypeAnnotation;
	};
	var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotation = $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation();
	$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation = function () {
		return $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotation;
	};
} catch ($) {
	throw 'Some top-level definitions from `Elm.Parser.TypeAnnotation` are causing infinite recursion:\n\n  \n      parensTypeAnnotation\n       \n      recordFieldDefinition\n       \n      recordFieldsTypeAnnotation\n       \n      recordTypeAnnotation\n       \n      typeAnnotation\n       \n      typeAnnotationNoFn\n       \n      typedTypeAnnotation\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $stil4m$elm_syntax$Elm$Parser$Declarations$functionSignatureFromVarPointer = function (varPointer) {
	return A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotation,
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
			A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Combine$string(':'),
				$stil4m$elm_syntax$Combine$succeed(
					function (ta) {
						return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$Signature$Signature, varPointer, ta);
					}))));
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$GLSLExpression = function (a) {
	return {$: 'GLSLExpression', a: a};
};
var $elm$parser$Parser$NotNestable = {$: 'NotNestable'};
var $elm$core$String$dropLeft = F2(
	function (n, string) {
		return (n < 1) ? string : A3(
			$elm$core$String$slice,
			n,
			$elm$core$String$length(string),
			string);
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$glslExpression = function () {
	var start = '[glsl|';
	var end = '|]';
	return $stil4m$elm_syntax$Elm$Parser$Node$parser(
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$string(end),
			A2(
				$stil4m$elm_syntax$Combine$map,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$String$dropLeft(
						$elm$core$String$length(start)),
					$stil4m$elm_syntax$Elm$Syntax$Expression$GLSLExpression),
				$stil4m$elm_syntax$Combine$fromCore(
					$elm$parser$Parser$getChompedString(
						A3($elm$parser$Parser$multiComment, start, end, $elm$parser$Parser$NotNestable))))));
}();
var $stil4m$elm_syntax$Elm$Parser$Tokens$ifToken = $stil4m$elm_syntax$Combine$string('if');
var $stil4m$elm_syntax$Elm$Parser$Tokens$allowedOperatorTokens = _List_fromArray(
	[
		_Utils_chr('+'),
		_Utils_chr('-'),
		_Utils_chr(':'),
		_Utils_chr('/'),
		_Utils_chr('*'),
		_Utils_chr('>'),
		_Utils_chr('<'),
		_Utils_chr('='),
		_Utils_chr('/'),
		_Utils_chr('&'),
		_Utils_chr('^'),
		_Utils_chr('%'),
		_Utils_chr('|'),
		_Utils_chr('!'),
		_Utils_chr('.'),
		_Utils_chr('#'),
		_Utils_chr('$'),
		_Utils_chr(''),
		_Utils_chr('~'),
		_Utils_chr('?'),
		_Utils_chr('@')
	]);
var $stil4m$elm_syntax$Elm$Parser$Tokens$excludedOperators = _List_fromArray(
	[':', '->', '--', '=']);
var $stil4m$elm_syntax$Combine$Char$oneOf = function (cs) {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Maybe$map($stil4m$elm_syntax$Combine$succeed),
			$elm$core$Maybe$withDefault(
				$stil4m$elm_syntax$Combine$fail(
					'expected one of \'' + ($elm$core$String$fromList(cs) + '\'')))),
		$stil4m$elm_syntax$Combine$Char$satisfy(
			function (a) {
				return A2($elm$core$List$member, a, cs);
			}));
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$operatorTokenFromList = function (allowedChars) {
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		function (m) {
			return A2($elm$core$List$member, m, $stil4m$elm_syntax$Elm$Parser$Tokens$excludedOperators) ? $stil4m$elm_syntax$Combine$fail('operator is not allowed') : $stil4m$elm_syntax$Combine$succeed(m);
		},
		A2(
			$stil4m$elm_syntax$Combine$map,
			$elm$core$String$fromList,
			$stil4m$elm_syntax$Combine$many1(
				$stil4m$elm_syntax$Combine$Char$oneOf(allowedChars))));
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$infixOperatorToken = $stil4m$elm_syntax$Elm$Parser$Tokens$operatorTokenFromList($stil4m$elm_syntax$Elm$Parser$Tokens$allowedOperatorTokens);
var $stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Layout$verifyIndent(
		F2(
			function (stateIndent, current) {
				return _Utils_eq(stateIndent, current);
			})),
	$stil4m$elm_syntax$Combine$many1(
		$stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					$stil4m$elm_syntax$Elm$Parser$Layout$anyComment,
					A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0),
					$stil4m$elm_syntax$Combine$many1($stil4m$elm_syntax$Elm$Parser$Whitespace$realNewLine)),
					$stil4m$elm_syntax$Elm$Parser$Whitespace$many1Spaces
				]))));
var $stil4m$elm_syntax$Elm$Syntax$Expression$RecordAccess = F2(
	function (a, b) {
		return {$: 'RecordAccess', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$liftRecordAccess = function (e) {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v0) {
			return A2(
				$stil4m$elm_syntax$Combine$or,
				A2(
					$stil4m$elm_syntax$Combine$andThen,
					$stil4m$elm_syntax$Elm$Parser$Declarations$liftRecordAccess,
					A2(
						$stil4m$elm_syntax$Combine$map,
						function (f) {
							return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$Expression$RecordAccess, e, f);
						},
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
							$stil4m$elm_syntax$Combine$string('.')))),
				$stil4m$elm_syntax$Combine$succeed(e));
		});
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Literal = function (a) {
	return {$: 'Literal', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$multiLineStringLiteral = function () {
	var helper = function (s) {
		return s.escaped ? A2(
			$elm$parser$Parser$map,
			function (v) {
				return $elm$parser$Parser$Loop(
					{
						counter: s.counter,
						escaped: false,
						parts: A2(
							$elm$core$List$cons,
							$elm$core$String$fromChar(v),
							s.parts)
					});
			},
			$stil4m$elm_syntax$Elm$Parser$Tokens$escapedCharValue) : $elm$parser$Parser$oneOf(
			_List_fromArray(
				[
					A2(
					$elm$parser$Parser$map,
					function (_v0) {
						return $elm$parser$Parser$Done(
							$elm$core$String$concat(
								$elm$core$List$reverse(s.parts)));
					},
					$elm$parser$Parser$symbol('\"\"\"')),
					A2(
					$elm$parser$Parser$map,
					function (v) {
						return $elm$parser$Parser$Loop(
							{
								counter: s.counter + 1,
								escaped: s.escaped,
								parts: A2($elm$core$List$cons, v, s.parts)
							});
					},
					$elm$parser$Parser$getChompedString(
						$elm$parser$Parser$symbol('\"'))),
					A2(
					$elm$parser$Parser$map,
					function (_v1) {
						return $elm$parser$Parser$Loop(
							{counter: s.counter + 1, escaped: true, parts: s.parts});
					},
					$elm$parser$Parser$getChompedString(
						$elm$parser$Parser$symbol('\\'))),
					A2(
					$elm$parser$Parser$andThen,
					function (_v2) {
						var start = _v2.a;
						var value = _v2.b;
						var end = _v2.c;
						return _Utils_eq(start, end) ? $elm$parser$Parser$problem('Expected a string character or a triple double quote') : $elm$parser$Parser$succeed(
							$elm$parser$Parser$Loop(
								{
									counter: s.counter + 1,
									escaped: s.escaped,
									parts: A2($elm$core$List$cons, value, s.parts)
								}));
					},
					A2(
						$elm$parser$Parser$keeper,
						A2(
							$elm$parser$Parser$keeper,
							A2(
								$elm$parser$Parser$keeper,
								$elm$parser$Parser$succeed(
									F3(
										function (start, value, end) {
											return _Utils_Tuple3(start, value, end);
										})),
								$elm$parser$Parser$getOffset),
							$elm$parser$Parser$getChompedString(
								$elm$parser$Parser$chompWhile(
									function (c) {
										return (!_Utils_eq(
											c,
											_Utils_chr('\"'))) && (!_Utils_eq(
											c,
											_Utils_chr('\\')));
									}))),
						$elm$parser$Parser$getOffset))
				]));
	};
	return $stil4m$elm_syntax$Combine$fromCore(
		A2(
			$elm$parser$Parser$keeper,
			A2(
				$elm$parser$Parser$ignorer,
				$elm$parser$Parser$succeed($elm$core$Basics$identity),
				$elm$parser$Parser$symbol('\"\"\"')),
			A2(
				$elm$parser$Parser$loop,
				{counter: 0, escaped: false, parts: _List_Nil},
				helper)));
}();
var $stil4m$elm_syntax$Elm$Parser$Declarations$literalExpression = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Elm$Parser$Node$parser(
			A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Syntax$Expression$Literal,
				A2($stil4m$elm_syntax$Combine$or, $stil4m$elm_syntax$Elm$Parser$Tokens$multiLineStringLiteral, $stil4m$elm_syntax$Elm$Parser$Tokens$stringLiteral)));
	});
var $stil4m$elm_syntax$Combine$loop = F2(
	function (init, stepper) {
		var wrapper = function (_v3) {
			var oldState = _v3.a;
			var v = _v3.b;
			var _v0 = stepper(v);
			var p = _v0.a;
			return A2(
				$elm$parser$Parser$map,
				function (_v1) {
					var newState = _v1.a;
					var r = _v1.b;
					if (r.$ === 'Loop') {
						var l = r.a;
						return $elm$parser$Parser$Loop(
							_Utils_Tuple2(newState, l));
					} else {
						var d = r.a;
						return $elm$parser$Parser$Done(
							_Utils_Tuple2(newState, d));
					}
				},
				p(oldState));
		};
		return $stil4m$elm_syntax$Combine$Parser(
			function (state) {
				return A2(
					$elm$parser$Parser$loop,
					_Utils_Tuple2(state, init),
					wrapper);
			});
	});
var $stil4m$elm_syntax$Elm$Parser$Whitespace$manySpaces = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$chompWhile(
		function (c) {
			return _Utils_eq(
				c,
				_Utils_chr(' '));
		}));
var $stil4m$elm_syntax$Elm$Syntax$Expression$Floatable = function (a) {
	return {$: 'Floatable', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Hex = function (a) {
	return {$: 'Hex', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Expression$Integer = function (a) {
	return {$: 'Integer', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Numbers$forgivingNumber = F3(
	function (floatf, intf, hexf) {
		return $stil4m$elm_syntax$Combine$fromCore(
			$elm$parser$Parser$backtrackable(
				A3($stil4m$elm_syntax$Elm$Parser$Numbers$raw, floatf, intf, hexf)));
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$numberExpression = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A3($stil4m$elm_syntax$Elm$Parser$Numbers$forgivingNumber, $stil4m$elm_syntax$Elm$Syntax$Expression$Floatable, $stil4m$elm_syntax$Elm$Syntax$Expression$Integer, $stil4m$elm_syntax$Elm$Syntax$Expression$Hex));
var $stil4m$elm_syntax$Elm$Parser$Tokens$ofToken = $stil4m$elm_syntax$Combine$string('of');
var $stil4m$elm_syntax$Elm$Parser$Tokens$allowedPrefixOperatorTokens = A2(
	$elm$core$List$cons,
	_Utils_chr(','),
	$stil4m$elm_syntax$Elm$Parser$Tokens$allowedOperatorTokens);
var $stil4m$elm_syntax$Elm$Parser$Tokens$prefixOperatorToken = $stil4m$elm_syntax$Elm$Parser$Tokens$operatorTokenFromList($stil4m$elm_syntax$Elm$Parser$Tokens$allowedPrefixOperatorTokens);
var $stil4m$elm_syntax$Elm$Syntax$Expression$RecordAccessFunction = function (a) {
	return {$: 'RecordAccessFunction', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Declarations$recordAccessFunctionExpression = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A2(
		$stil4m$elm_syntax$Combine$map,
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Basics$append('.'),
			$stil4m$elm_syntax$Elm$Syntax$Expression$RecordAccessFunction),
		A2(
			$stil4m$elm_syntax$Combine$continueWith,
			$stil4m$elm_syntax$Elm$Parser$Tokens$functionName,
			$stil4m$elm_syntax$Combine$string('.'))));
var $stil4m$elm_syntax$Elm$Syntax$Expression$FunctionOrValue = F2(
	function (a, b) {
		return {$: 'FunctionOrValue', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$reference = function () {
	var justFunction = A2(
		$stil4m$elm_syntax$Combine$map,
		function (v) {
			return _Utils_Tuple2(_List_Nil, v);
		},
		$stil4m$elm_syntax$Elm$Parser$Tokens$functionName);
	var helper = function (_v0) {
		var n = _v0.a;
		var xs = _v0.b;
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$andThen,
								function (t) {
									return helper(
										_Utils_Tuple2(
											t,
											A2($elm$core$List$cons, n, xs)));
								},
								$stil4m$elm_syntax$Elm$Parser$Tokens$typeName),
								A2(
								$stil4m$elm_syntax$Combine$map,
								function (t) {
									return _Utils_Tuple2(
										t,
										A2($elm$core$List$cons, n, xs));
								},
								$stil4m$elm_syntax$Elm$Parser$Tokens$functionName)
							])),
					$stil4m$elm_syntax$Combine$string('.')),
					$stil4m$elm_syntax$Combine$succeed(
					_Utils_Tuple2(n, xs))
				]));
	};
	var recurring = A2(
		$stil4m$elm_syntax$Combine$map,
		function (_v1) {
			var t = _v1.a;
			var xs = _v1.b;
			return _Utils_Tuple2(
				$elm$core$List$reverse(xs),
				t);
		},
		A2(
			$stil4m$elm_syntax$Combine$andThen,
			function (t) {
				return helper(
					_Utils_Tuple2(t, _List_Nil));
			},
			$stil4m$elm_syntax$Elm$Parser$Tokens$typeName));
	return $stil4m$elm_syntax$Combine$choice(
		_List_fromArray(
			[recurring, justFunction]));
}();
var $stil4m$elm_syntax$Elm$Parser$Declarations$referenceExpression = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A2(
		$stil4m$elm_syntax$Combine$map,
		function (_v0) {
			var xs = _v0.a;
			var x = _v0.b;
			return A2($stil4m$elm_syntax$Elm$Syntax$Expression$FunctionOrValue, xs, x);
		},
		$stil4m$elm_syntax$Elm$Parser$Declarations$reference));
var $elm$core$Tuple$second = function (_v0) {
	var y = _v0.b;
	return y;
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$thenToken = $stil4m$elm_syntax$Combine$string('then');
var $stil4m$elm_syntax$Elm$Parser$Ranges$asPointerLocation = function (_v0) {
	var line = _v0.line;
	var column = _v0.column;
	return {column: column, row: line};
};
var $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint = function (p) {
	return $stil4m$elm_syntax$Combine$withLocation(
		function (start) {
			var k = $stil4m$elm_syntax$Elm$Parser$Ranges$asPointerLocation(start);
			return p(
				{end: k, start: k});
		});
};
var $elm$core$List$drop = F2(
	function (n, list) {
		drop:
		while (true) {
			if (n <= 0) {
				return list;
			} else {
				if (!list.b) {
					return list;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs;
					n = $temp$n;
					list = $temp$list;
					continue drop;
				}
			}
		}
	});
var $stil4m$elm_syntax$Elm$Parser$State$popIndent = function (_v0) {
	var s = _v0.a;
	return $stil4m$elm_syntax$Elm$Parser$State$State(
		_Utils_update(
			s,
			{
				indents: A2($elm$core$List$drop, 1, s.indents)
			}));
};
var $stil4m$elm_syntax$Elm$Parser$State$pushIndent = F2(
	function (x, _v0) {
		var s = _v0.a;
		return $stil4m$elm_syntax$Elm$Parser$State$State(
			_Utils_update(
				s,
				{
					indents: A2($elm$core$List$cons, x, s.indents)
				}));
	});
var $stil4m$elm_syntax$Elm$Parser$State$pushColumn = F2(
	function (col, state) {
		return A2($stil4m$elm_syntax$Elm$Parser$State$pushIndent, col - 1, state);
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$withIndentedState = function (p) {
	return $stil4m$elm_syntax$Combine$withLocation(
		function (location) {
			return A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Combine$modifyState($stil4m$elm_syntax$Elm$Parser$State$popIndent),
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					p,
					$stil4m$elm_syntax$Combine$modifyState(
						$stil4m$elm_syntax$Elm$Parser$State$pushColumn(location.column))));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Declarations$functionWithNameNode = function (pointer) {
	var functionImplementationFromVarPointer = function (varPointer) {
		return A2(
			$stil4m$elm_syntax$Combine$andMap,
			$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
			A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$string('='),
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Combine$many(
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								$stil4m$elm_syntax$Elm$Parser$Declarations$functionArgument)),
						$stil4m$elm_syntax$Combine$succeed(
							F2(
								function (args, expr) {
									return A2(
										$stil4m$elm_syntax$Elm$Syntax$Node$Node,
										$stil4m$elm_syntax$Elm$Syntax$Range$combine(
											_List_fromArray(
												[
													$stil4m$elm_syntax$Elm$Syntax$Node$range(varPointer),
													$stil4m$elm_syntax$Elm$Syntax$Node$range(expr)
												])),
										A3($stil4m$elm_syntax$Elm$Syntax$Expression$FunctionImplementation, varPointer, args, expr));
								}))))));
	};
	var functionWithoutSignature = function (varPointer) {
		return A2(
			$stil4m$elm_syntax$Combine$map,
			A2($stil4m$elm_syntax$Elm$Syntax$Expression$Function, $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing),
			functionImplementationFromVarPointer(varPointer));
	};
	var fromParts = F2(
		function (sig, decl) {
			return {
				declaration: decl,
				documentation: $elm$core$Maybe$Nothing,
				signature: $elm$core$Maybe$Just(sig)
			};
		});
	var functionWithSignature = function (varPointer) {
		return A2(
			$stil4m$elm_syntax$Combine$andThen,
			function (sig) {
				return A2(
					$stil4m$elm_syntax$Combine$map,
					fromParts(sig),
					A2(
						$stil4m$elm_syntax$Combine$andThen,
						functionImplementationFromVarPointer,
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							A2(
								$stil4m$elm_syntax$Combine$continueWith,
								$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict)))));
			},
			$stil4m$elm_syntax$Elm$Parser$Declarations$functionSignatureFromVarPointer(varPointer));
	};
	return $stil4m$elm_syntax$Combine$choice(
		_List_fromArray(
			[
				functionWithSignature(pointer),
				functionWithoutSignature(pointer)
			]));
};
var $stil4m$elm_syntax$Elm$Parser$Declarations$letDestructuringDeclarationWithPattern = function (p) {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v7) {
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$string('='),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$succeed(
								$stil4m$elm_syntax$Elm$Syntax$Expression$LetDestructuring(p))))));
		});
};
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseBlock() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v28) {
			return A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Elm$Parser$Tokens$ofToken,
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
					A2($stil4m$elm_syntax$Combine$continueWith, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Tokens$caseToken)));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseExpression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v26) {
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (_v27) {
					var start = _v27.a;
					return A2(
						$stil4m$elm_syntax$Combine$map,
						function (cb) {
							return A2(
								$stil4m$elm_syntax$Elm$Syntax$Node$Node,
								$stil4m$elm_syntax$Elm$Syntax$Range$combine(
									A2(
										$elm$core$List$cons,
										start,
										A2(
											$elm$core$List$map,
											A2($elm$core$Basics$composeR, $elm$core$Tuple$second, $stil4m$elm_syntax$Elm$Syntax$Node$range),
											cb.cases))),
								$stil4m$elm_syntax$Elm$Syntax$Expression$CaseExpression(cb));
						},
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							A2(
								$stil4m$elm_syntax$Combine$continueWith,
								$stil4m$elm_syntax$Elm$Parser$Declarations$withIndentedState(
									$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatements()),
								$stil4m$elm_syntax$Elm$Parser$Layout$layout),
							A2(
								$stil4m$elm_syntax$Combine$andMap,
								$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseBlock(),
								$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Expression$CaseBlock))));
				},
				$stil4m$elm_syntax$Elm$Parser$Node$parser(
					$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0)));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatement() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v25) {
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Combine$string('->'),
							$stil4m$elm_syntax$Combine$maybe(
								A2($stil4m$elm_syntax$Combine$or, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict))))),
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					$stil4m$elm_syntax$Elm$Parser$Patterns$pattern,
					$stil4m$elm_syntax$Combine$succeed($elm$core$Tuple$pair)));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatements() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v24) {
			var helper = function (last) {
				return $stil4m$elm_syntax$Combine$withState(
					function (s) {
						return $stil4m$elm_syntax$Combine$withLocation(
							function (l) {
								return _Utils_eq(
									$stil4m$elm_syntax$Elm$Parser$State$expectedColumn(s),
									l.column) ? $stil4m$elm_syntax$Combine$choice(
									_List_fromArray(
										[
											A2(
											$stil4m$elm_syntax$Combine$map,
											function (c) {
												return $stil4m$elm_syntax$Combine$Loop(
													A2($elm$core$List$cons, c, last));
											},
											$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatement()),
											$stil4m$elm_syntax$Combine$succeed(
											$stil4m$elm_syntax$Combine$Done(
												$elm$core$List$reverse(last)))
										])) : $stil4m$elm_syntax$Combine$succeed(
									$stil4m$elm_syntax$Combine$Done(
										$elm$core$List$reverse(last)));
							});
					});
			};
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (v) {
					return A2($stil4m$elm_syntax$Combine$loop, v, helper);
				},
				A2(
					$stil4m$elm_syntax$Combine$map,
					$elm$core$List$singleton,
					$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatement()));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v18) {
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (first) {
					var complete = function (rest) {
						if (!rest.b) {
							return $stil4m$elm_syntax$Combine$succeed(first);
						} else {
							if (rest.a.b.$ === 'Operator') {
								var _v23 = rest.a;
								return $stil4m$elm_syntax$Combine$fail('Expression should not end with an operator');
							} else {
								return $stil4m$elm_syntax$Combine$succeed(
									A2(
										$stil4m$elm_syntax$Elm$Syntax$Node$Node,
										$stil4m$elm_syntax$Elm$Syntax$Range$combine(
											A2(
												$elm$core$List$cons,
												$stil4m$elm_syntax$Elm$Syntax$Node$range(first),
												A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, rest))),
										$stil4m$elm_syntax$Elm$Syntax$Expression$Application(
											A2(
												$elm$core$List$cons,
												first,
												$elm$core$List$reverse(rest)))));
							}
						}
					};
					var promoter = function (rest) {
						return A2(
							$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
							function (_v19) {
								return complete(rest);
							},
							function (_v20) {
								return A2(
									$stil4m$elm_syntax$Combine$or,
									A2(
										$stil4m$elm_syntax$Combine$andThen,
										function (next) {
											return promoter(
												A2($elm$core$List$cons, next, rest));
										},
										$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expressionNotApplication()),
									complete(rest));
							});
					};
					if (first.b.$ === 'Operator') {
						return $stil4m$elm_syntax$Combine$fail('Expression should not start with an operator');
					} else {
						return promoter(_List_Nil);
					}
				},
				$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expressionNotApplication());
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expressionNotApplication() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v17) {
			return A2(
				$stil4m$elm_syntax$Combine$andThen,
				$stil4m$elm_syntax$Elm$Parser$Declarations$liftRecordAccess,
				$stil4m$elm_syntax$Combine$choice(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Parser$Declarations$numberExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$referenceExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$ifBlockExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$tupledExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$recordAccessFunctionExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$operatorExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$lambdaExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$literalExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$charLiteralExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$recordExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$glslExpression,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$listExpression(),
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseExpression()
						])));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$ifBlockExpression() {
	return $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
		function (current) {
			return A2(
				$stil4m$elm_syntax$Combine$continueWith,
				$stil4m$elm_syntax$Combine$lazy(
					function (_v16) {
						return A2(
							$stil4m$elm_syntax$Combine$andMap,
							A2(
								$stil4m$elm_syntax$Combine$continueWith,
								$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
								A2($stil4m$elm_syntax$Combine$continueWith, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Tokens$elseToken)),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								A2(
									$stil4m$elm_syntax$Combine$andMap,
									$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
									A2(
										$stil4m$elm_syntax$Combine$ignore,
										$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
										A2(
											$stil4m$elm_syntax$Combine$ignore,
											$stil4m$elm_syntax$Elm$Parser$Tokens$thenToken,
											A2(
												$stil4m$elm_syntax$Combine$ignore,
												$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
												A2(
													$stil4m$elm_syntax$Combine$andMap,
													$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
													A2(
														$stil4m$elm_syntax$Combine$ignore,
														$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
														$stil4m$elm_syntax$Combine$succeed(
															F3(
																function (condition, ifTrue, ifFalse) {
																	return A2(
																		$stil4m$elm_syntax$Elm$Syntax$Node$Node,
																		{
																			end: $stil4m$elm_syntax$Elm$Syntax$Node$range(ifFalse).end,
																			start: current.start
																		},
																		A3($stil4m$elm_syntax$Elm$Syntax$Expression$IfBlock, condition, ifTrue, ifFalse));
																}))))))))));
					}),
				$stil4m$elm_syntax$Elm$Parser$Tokens$ifToken);
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$lambdaExpression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v15) {
			return $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
				function (current) {
					return A2(
						$stil4m$elm_syntax$Combine$andMap,
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
							$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
								$stil4m$elm_syntax$Combine$string('->'))),
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							A2(
								$stil4m$elm_syntax$Combine$sepBy1,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								$stil4m$elm_syntax$Elm$Parser$Declarations$functionArgument),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$string('\\'),
									$stil4m$elm_syntax$Combine$succeed(
										F2(
											function (args, expr) {
												return A2(
													$stil4m$elm_syntax$Elm$Syntax$Node$Node,
													{
														end: $stil4m$elm_syntax$Elm$Syntax$Node$range(expr).end,
														start: current.start
													},
													$stil4m$elm_syntax$Elm$Syntax$Expression$LambdaExpression(
														A2($stil4m$elm_syntax$Elm$Syntax$Expression$Lambda, args, expr)));
											}))))));
				});
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBlock() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v14) {
			return A2(
				$stil4m$elm_syntax$Combine$ignore,
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$string('in'),
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[$stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Whitespace$manySpaces]))),
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Elm$Parser$Declarations$withIndentedState(
						$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBody()),
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Layout$layout,
						$stil4m$elm_syntax$Combine$string('let'))));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBody() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v8) {
			var blockElement = A2(
				$stil4m$elm_syntax$Combine$andThen,
				function (_v12) {
					var r = _v12.a;
					var p = _v12.b;
					if (p.$ === 'VarPattern') {
						var v = p.a;
						return A2(
							$stil4m$elm_syntax$Combine$map,
							$stil4m$elm_syntax$Elm$Syntax$Expression$LetFunction,
							$stil4m$elm_syntax$Elm$Parser$Declarations$functionWithNameNode(
								A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, r, v)));
					} else {
						return $stil4m$elm_syntax$Elm$Parser$Declarations$letDestructuringDeclarationWithPattern(
							A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, r, p));
					}
				},
				$stil4m$elm_syntax$Elm$Parser$Patterns$pattern);
			var addRange = function (letDeclaration) {
				return A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$Node,
					function () {
						if (letDeclaration.$ === 'LetFunction') {
							var letFunction = letDeclaration.a;
							return $stil4m$elm_syntax$Elm$Syntax$Expression$functionRange(letFunction);
						} else {
							var _v10 = letDeclaration.a;
							var patternRange = _v10.a;
							var _v11 = letDeclaration.b;
							var expressionRange = _v11.a;
							return $stil4m$elm_syntax$Elm$Syntax$Range$combine(
								_List_fromArray(
									[patternRange, expressionRange]));
						}
					}(),
					letDeclaration);
			};
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Combine$many(
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2($stil4m$elm_syntax$Combine$map, addRange, blockElement))),
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					A2($stil4m$elm_syntax$Combine$map, addRange, blockElement),
					$stil4m$elm_syntax$Combine$succeed($elm$core$List$cons)));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letExpression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v6) {
			return $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
				function (current) {
					return A2(
						$stil4m$elm_syntax$Combine$andMap,
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
							$stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBlock(),
							$stil4m$elm_syntax$Combine$succeed(
								F2(
									function (decls, expr) {
										return A2(
											$stil4m$elm_syntax$Elm$Syntax$Node$Node,
											{
												end: $stil4m$elm_syntax$Elm$Syntax$Node$range(expr).end,
												start: current.start
											},
											$stil4m$elm_syntax$Elm$Syntax$Expression$LetExpression(
												A2($stil4m$elm_syntax$Elm$Syntax$Expression$LetBlock, decls, expr)));
									}))));
				});
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$listExpression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v5) {
			var innerExpressions = A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Syntax$Expression$ListExpr,
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					$stil4m$elm_syntax$Combine$many(
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								$stil4m$elm_syntax$Combine$string(',')))),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
							$stil4m$elm_syntax$Combine$succeed($elm$core$List$cons)))));
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$map,
								$elm$core$Basics$always(
									$stil4m$elm_syntax$Elm$Syntax$Expression$ListExpr(_List_Nil)),
								$stil4m$elm_syntax$Combine$string(']')),
								A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$string(']'),
								innerExpressions)
							])),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Combine$string('['))));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$operatorExpression() {
	var negationExpression = $stil4m$elm_syntax$Combine$lazy(
		function (_v4) {
			return A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Syntax$Expression$Negation,
				A2(
					$stil4m$elm_syntax$Combine$andThen,
					$stil4m$elm_syntax$Elm$Parser$Declarations$liftRecordAccess,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								$stil4m$elm_syntax$Elm$Parser$Declarations$referenceExpression,
								$stil4m$elm_syntax$Elm$Parser$Declarations$numberExpression,
								$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$tupledExpression()
							]))));
		});
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v3) {
			return $stil4m$elm_syntax$Combine$choice(
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Parser$Node$parser(
						A2(
							$stil4m$elm_syntax$Combine$continueWith,
							$stil4m$elm_syntax$Combine$choice(
								_List_fromArray(
									[
										negationExpression,
										A2(
										$stil4m$elm_syntax$Combine$ignore,
										$stil4m$elm_syntax$Elm$Parser$Layout$layout,
										$stil4m$elm_syntax$Combine$succeed(
											$stil4m$elm_syntax$Elm$Syntax$Expression$Operator('-')))
									])),
							$stil4m$elm_syntax$Combine$string('-'))),
						$stil4m$elm_syntax$Elm$Parser$Node$parser(
						A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Expression$Operator, $stil4m$elm_syntax$Elm$Parser$Tokens$infixOperatorToken))
					]));
		});
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$recordExpression() {
	return $stil4m$elm_syntax$Elm$Parser$Node$parser(
		$stil4m$elm_syntax$Combine$lazy(
			function (_v2) {
				var recordField = $stil4m$elm_syntax$Elm$Parser$Node$parser(
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$string('='),
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									A2(
										$stil4m$elm_syntax$Combine$andMap,
										$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
										$stil4m$elm_syntax$Combine$succeed($elm$core$Tuple$pair)))))));
				var recordFields = A2(
					$stil4m$elm_syntax$Combine$andMap,
					$stil4m$elm_syntax$Combine$many(
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							A2(
								$stil4m$elm_syntax$Combine$continueWith,
								recordField,
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									$stil4m$elm_syntax$Combine$string(','))))),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							recordField,
							$stil4m$elm_syntax$Combine$succeed($elm$core$List$cons))));
				var recordUpdateSyntaxParser = function (fname) {
					return A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$string('}'),
						A2(
							$stil4m$elm_syntax$Combine$map,
							function (e) {
								return A2($stil4m$elm_syntax$Elm$Syntax$Expression$RecordUpdateExpression, fname, e);
							},
							A2(
								$stil4m$elm_syntax$Combine$continueWith,
								recordFields,
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									$stil4m$elm_syntax$Combine$string('|')))));
				};
				var recordContents = A2(
					$stil4m$elm_syntax$Combine$andThen,
					function (fname) {
						return $stil4m$elm_syntax$Combine$choice(
							_List_fromArray(
								[
									recordUpdateSyntaxParser(fname),
									A2(
									$stil4m$elm_syntax$Combine$andThen,
									function (fieldUpdate) {
										return $stil4m$elm_syntax$Combine$choice(
											_List_fromArray(
												[
													A2(
													$stil4m$elm_syntax$Combine$map,
													$elm$core$Basics$always(
														$stil4m$elm_syntax$Elm$Syntax$Expression$RecordExpr(
															_List_fromArray(
																[fieldUpdate]))),
													$stil4m$elm_syntax$Combine$string('}')),
													A2(
													$stil4m$elm_syntax$Combine$ignore,
													$stil4m$elm_syntax$Combine$string('}'),
													A2(
														$stil4m$elm_syntax$Combine$map,
														function (fieldUpdates) {
															return $stil4m$elm_syntax$Elm$Syntax$Expression$RecordExpr(
																A2($elm$core$List$cons, fieldUpdate, fieldUpdates));
														},
														A2(
															$stil4m$elm_syntax$Combine$continueWith,
															recordFields,
															A2(
																$stil4m$elm_syntax$Combine$ignore,
																$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
																$stil4m$elm_syntax$Combine$string(',')))))
												]));
									},
									A2(
										$stil4m$elm_syntax$Combine$ignore,
										$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
										A2(
											$stil4m$elm_syntax$Combine$continueWith,
											A2(
												$stil4m$elm_syntax$Combine$map,
												function (e) {
													return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $elm$core$Tuple$pair, fname, e);
												},
												$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression()),
											A2(
												$stil4m$elm_syntax$Combine$ignore,
												$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
												$stil4m$elm_syntax$Combine$string('=')))))
								]));
					},
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName)));
				return A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$map,
								$elm$core$Basics$always(
									$stil4m$elm_syntax$Elm$Syntax$Expression$RecordExpr(_List_Nil)),
								$stil4m$elm_syntax$Combine$string('}')),
								recordContents
							])),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
						$stil4m$elm_syntax$Combine$string('{')));
			}));
}
function $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$tupledExpression() {
	return $stil4m$elm_syntax$Combine$lazy(
		function (_v0) {
			var commaSep = $stil4m$elm_syntax$Combine$many(
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					A2(
						$stil4m$elm_syntax$Combine$continueWith,
						$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$string(',')))));
			var closingParen = $stil4m$elm_syntax$Combine$fromCore(
				$elm$parser$Parser$symbol(')'));
			var asExpression = F2(
				function (x, xs) {
					if (!xs.b) {
						return $stil4m$elm_syntax$Elm$Syntax$Expression$ParenthesizedExpression(x);
					} else {
						return $stil4m$elm_syntax$Elm$Syntax$Expression$TupledExpression(
							A2($elm$core$List$cons, x, xs));
					}
				});
			var nested = A2(
				$stil4m$elm_syntax$Combine$andMap,
				commaSep,
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression(),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
							$stil4m$elm_syntax$Combine$succeed(asExpression)))));
			return $stil4m$elm_syntax$Elm$Parser$Node$parser(
				A2(
					$stil4m$elm_syntax$Combine$continueWith,
					$stil4m$elm_syntax$Combine$choice(
						_List_fromArray(
							[
								A2(
								$stil4m$elm_syntax$Combine$map,
								$elm$core$Basics$always($stil4m$elm_syntax$Elm$Syntax$Expression$UnitExpr),
								closingParen),
								$stil4m$elm_syntax$Combine$backtrackable(
								A2(
									$stil4m$elm_syntax$Combine$map,
									$stil4m$elm_syntax$Elm$Syntax$Expression$PrefixOperator,
									A2($stil4m$elm_syntax$Combine$ignore, closingParen, $stil4m$elm_syntax$Elm$Parser$Tokens$prefixOperatorToken))),
								A2($stil4m$elm_syntax$Combine$ignore, closingParen, nested)
							])),
					$stil4m$elm_syntax$Combine$fromCore(
						$elm$parser$Parser$symbol('('))));
		});
}
try {
	var $stil4m$elm_syntax$Elm$Parser$Declarations$caseBlock = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseBlock();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseBlock = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$caseBlock;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$caseExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$caseExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$caseStatement = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatement();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatement = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$caseStatement;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$caseStatements = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatements();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$caseStatements = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$caseStatements;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$expression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$expression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$expressionNotApplication = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expressionNotApplication();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$expressionNotApplication = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$expressionNotApplication;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$ifBlockExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$ifBlockExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$ifBlockExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$ifBlockExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$lambdaExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$lambdaExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$lambdaExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$lambdaExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$letBlock = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBlock();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBlock = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$letBlock;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$letBody = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBody();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letBody = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$letBody;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$letExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$letExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$letExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$listExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$listExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$listExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$listExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$operatorExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$operatorExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$operatorExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$operatorExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$recordExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$recordExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$recordExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$recordExpression;
	};
	var $stil4m$elm_syntax$Elm$Parser$Declarations$tupledExpression = $stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$tupledExpression();
	$stil4m$elm_syntax$Elm$Parser$Declarations$cyclic$tupledExpression = function () {
		return $stil4m$elm_syntax$Elm$Parser$Declarations$tupledExpression;
	};
} catch ($) {
	throw 'Some top-level definitions from `Elm.Parser.Declarations` are causing infinite recursion:\n\n  \n      caseBlock\n       \n      caseExpression\n       \n      caseStatement\n       \n      caseStatements\n       \n      expression\n       \n      expressionNotApplication\n       \n      functionWithNameNode\n       \n      ifBlockExpression\n       \n      lambdaExpression\n       \n      letBlock\n       \n      letBody\n       \n      letDestructuringDeclarationWithPattern\n       \n      letExpression\n       \n      listExpression\n       \n      operatorExpression\n       \n      recordExpression\n       \n      tupledExpression\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $stil4m$elm_syntax$Elm$Parser$Declarations$destructuringDeclaration = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return A2(
			$stil4m$elm_syntax$Combine$andMap,
			$stil4m$elm_syntax$Elm$Parser$Declarations$expression,
			A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Elm$Parser$Layout$layout,
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$string('='),
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Elm$Parser$Patterns$pattern,
						$stil4m$elm_syntax$Combine$succeed(
							F2(
								function (x, y) {
									return A3($stil4m$elm_syntax$Elm$Syntax$Node$combine, $stil4m$elm_syntax$Elm$Syntax$Declaration$Destructuring, x, y);
								}))))));
	});
var $stil4m$elm_syntax$Elm$Syntax$Declaration$FunctionDeclaration = function (a) {
	return {$: 'FunctionDeclaration', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Declarations$function = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return A2(
			$stil4m$elm_syntax$Combine$map,
			function (f) {
				return A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$Node,
					$stil4m$elm_syntax$Elm$Syntax$Expression$functionRange(f),
					$stil4m$elm_syntax$Elm$Syntax$Declaration$FunctionDeclaration(f));
			},
			A2(
				$stil4m$elm_syntax$Combine$andThen,
				$stil4m$elm_syntax$Elm$Parser$Declarations$functionWithNameNode,
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
					$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName))));
	});
var $stil4m$elm_syntax$Elm$Syntax$Declaration$InfixDeclaration = function (a) {
	return {$: 'InfixDeclaration', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Infix$Infix = F4(
	function (direction, precedence, operator, _function) {
		return {direction: direction, _function: _function, operator: operator, precedence: precedence};
	});
var $stil4m$elm_syntax$Elm$Syntax$Infix$Left = {$: 'Left'};
var $stil4m$elm_syntax$Elm$Syntax$Infix$Non = {$: 'Non'};
var $stil4m$elm_syntax$Elm$Syntax$Infix$Right = {$: 'Right'};
var $stil4m$elm_syntax$Elm$Parser$Infix$infixDirection = $stil4m$elm_syntax$Combine$choice(
	_List_fromArray(
		[
			A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$string('right'),
			$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Infix$Right)),
			A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$string('left'),
			$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Infix$Left)),
			A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$string('non'),
			$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Infix$Non))
		]));
var $elm$parser$Parser$Advanced$int = F2(
	function (expecting, invalid) {
		return $elm$parser$Parser$Advanced$number(
			{
				binary: $elm$core$Result$Err(invalid),
				expecting: expecting,
				_float: $elm$core$Result$Err(invalid),
				hex: $elm$core$Result$Err(invalid),
				_int: $elm$core$Result$Ok($elm$core$Basics$identity),
				invalid: invalid,
				octal: $elm$core$Result$Err(invalid)
			});
	});
var $elm$parser$Parser$int = A2($elm$parser$Parser$Advanced$int, $elm$parser$Parser$ExpectingInt, $elm$parser$Parser$ExpectingInt);
var $stil4m$elm_syntax$Combine$Num$int = $stil4m$elm_syntax$Combine$fromCore($elm$parser$Parser$int);
var $stil4m$elm_syntax$Elm$Parser$Infix$infixDefinition = A2(
	$stil4m$elm_syntax$Combine$andMap,
	$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Elm$Parser$Layout$layout,
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Combine$string('='),
			A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Elm$Parser$Layout$layout,
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					$stil4m$elm_syntax$Elm$Parser$Node$parser(
						$stil4m$elm_syntax$Combine$parens($stil4m$elm_syntax$Elm$Parser$Tokens$prefixOperatorToken)),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Elm$Parser$Layout$layout,
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Combine$Num$int),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Elm$Parser$Layout$layout,
								A2(
									$stil4m$elm_syntax$Combine$andMap,
									$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Infix$infixDirection),
									A2(
										$stil4m$elm_syntax$Combine$ignore,
										$stil4m$elm_syntax$Elm$Parser$Layout$layout,
										A2(
											$stil4m$elm_syntax$Combine$ignore,
											$stil4m$elm_syntax$Combine$fromCore(
												$elm$parser$Parser$keyword('infix')),
											$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Infix$Infix))))))))))));
var $stil4m$elm_syntax$Elm$Parser$Declarations$infixDeclaration = $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
	function (current) {
		return A2(
			$stil4m$elm_syntax$Combine$map,
			function (inf) {
				return A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$Node,
					$stil4m$elm_syntax$Elm$Syntax$Range$combine(
						_List_fromArray(
							[
								current,
								$stil4m$elm_syntax$Elm$Syntax$Node$range(inf._function)
							])),
					$stil4m$elm_syntax$Elm$Syntax$Declaration$InfixDeclaration(inf));
			},
			$stil4m$elm_syntax$Elm$Parser$Infix$infixDefinition);
	});
var $stil4m$elm_syntax$Elm$Syntax$Declaration$PortDeclaration = function (a) {
	return {$: 'PortDeclaration', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Tokens$portToken = $stil4m$elm_syntax$Combine$string('port');
var $stil4m$elm_syntax$Elm$Parser$Declarations$signature = A2(
	$stil4m$elm_syntax$Combine$andMap,
	A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotation,
		A2(
			$stil4m$elm_syntax$Combine$continueWith,
			$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
			$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
				$stil4m$elm_syntax$Combine$string(':')))),
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName),
		$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Signature$Signature)));
var $stil4m$elm_syntax$Elm$Parser$Declarations$portDeclaration = $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
	function (current) {
		return A2(
			$stil4m$elm_syntax$Combine$map,
			function (sig) {
				return A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$Node,
					$stil4m$elm_syntax$Elm$Syntax$Range$combine(
						_List_fromArray(
							[
								current,
								function (_v0) {
								var r = _v0.a;
								return r;
							}(sig.typeAnnotation)
							])),
					$stil4m$elm_syntax$Elm$Syntax$Declaration$PortDeclaration(sig));
			},
			A2(
				$stil4m$elm_syntax$Combine$continueWith,
				$stil4m$elm_syntax$Elm$Parser$Declarations$signature,
				A2($stil4m$elm_syntax$Combine$ignore, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Tokens$portToken)));
	});
var $stil4m$elm_syntax$Elm$Parser$Typings$DefinedAlias = F2(
	function (a, b) {
		return {$: 'DefinedAlias', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Parser$Typings$DefinedType = F2(
	function (a, b) {
		return {$: 'DefinedType', a: a, b: b};
	});
var $stil4m$elm_syntax$Elm$Syntax$Type$Type = F4(
	function (documentation, name, generics, constructors) {
		return {constructors: constructors, documentation: documentation, generics: generics, name: name};
	});
var $stil4m$elm_syntax$Elm$Syntax$TypeAlias$TypeAlias = F4(
	function (documentation, name, generics, typeAnnotation) {
		return {documentation: documentation, generics: generics, name: name, typeAnnotation: typeAnnotation};
	});
var $stil4m$elm_syntax$Elm$Parser$Typings$genericList = $stil4m$elm_syntax$Combine$many(
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$functionName)));
var $stil4m$elm_syntax$Elm$Parser$Typings$typePrefix = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Layout$layout,
	$stil4m$elm_syntax$Combine$string('type'));
var $stil4m$elm_syntax$Elm$Syntax$Type$ValueConstructor = F2(
	function (name, _arguments) {
		return {_arguments: _arguments, name: name};
	});
var $stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotationNonGreedy = $stil4m$elm_syntax$Combine$choice(
	_List_fromArray(
		[
			$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$parensTypeAnnotation,
			$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typedTypeAnnotation($stil4m$elm_syntax$Elm$Parser$TypeAnnotation$Lazy),
			$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$genericTypeAnnotation,
			$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$recordTypeAnnotation
		]));
var $stil4m$elm_syntax$Elm$Parser$Typings$valueConstructor = A2(
	$stil4m$elm_syntax$Combine$andThen,
	function (tnn) {
		var range = tnn.a;
		var complete = function (args) {
			return $stil4m$elm_syntax$Combine$succeed(
				A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$Node,
					$stil4m$elm_syntax$Elm$Syntax$Range$combine(
						A2(
							$elm$core$List$cons,
							range,
							A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, args))),
					A2($stil4m$elm_syntax$Elm$Syntax$Type$ValueConstructor, tnn, args)));
		};
		var argHelper = function (xs) {
			return A2(
				$stil4m$elm_syntax$Combine$continueWith,
				$stil4m$elm_syntax$Combine$choice(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Combine$andThen,
							function (ta) {
								return A2(
									$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
									function (_v0) {
										return $stil4m$elm_syntax$Combine$succeed(
											$elm$core$List$reverse(
												A2($elm$core$List$cons, ta, xs)));
									},
									function (_v1) {
										return argHelper(
											A2($elm$core$List$cons, ta, xs));
									});
							},
							$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotationNonGreedy),
							$stil4m$elm_syntax$Combine$succeed(
							$elm$core$List$reverse(xs))
						])),
				$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0));
		};
		return A2(
			$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayoutWith,
			function (_v2) {
				return complete(_List_Nil);
			},
			function (_v3) {
				return A2(
					$stil4m$elm_syntax$Combine$andThen,
					complete,
					argHelper(_List_Nil));
			});
	},
	A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$typeName),
		$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Type$ValueConstructor)));
var $stil4m$elm_syntax$Elm$Parser$Typings$valueConstructors = A2(
	$stil4m$elm_syntax$Combine$sepBy1,
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
		$stil4m$elm_syntax$Combine$string('|')),
	$stil4m$elm_syntax$Elm$Parser$Typings$valueConstructor);
var $stil4m$elm_syntax$Elm$Parser$Typings$typeDefinition = $stil4m$elm_syntax$Elm$Parser$Ranges$withCurrentPoint(
	function (start) {
		return A2(
			$stil4m$elm_syntax$Combine$continueWith,
			$stil4m$elm_syntax$Combine$choice(
				_List_fromArray(
					[
						A2(
						$stil4m$elm_syntax$Combine$map,
						function (typeAlias) {
							return A2(
								$stil4m$elm_syntax$Elm$Parser$Typings$DefinedAlias,
								$stil4m$elm_syntax$Elm$Syntax$Range$combine(
									_List_fromArray(
										[
											start,
											$stil4m$elm_syntax$Elm$Syntax$Node$range(typeAlias.typeAnnotation)
										])),
								typeAlias);
						},
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$TypeAnnotation$typeAnnotation,
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$string('='),
									A2(
										$stil4m$elm_syntax$Combine$andMap,
										$stil4m$elm_syntax$Elm$Parser$Typings$genericList,
										A2(
											$stil4m$elm_syntax$Combine$ignore,
											$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
											A2(
												$stil4m$elm_syntax$Combine$andMap,
												A2(
													$stil4m$elm_syntax$Combine$ignore,
													$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
													$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$typeName)),
												A2(
													$stil4m$elm_syntax$Combine$ignore,
													A2(
														$stil4m$elm_syntax$Combine$continueWith,
														$stil4m$elm_syntax$Elm$Parser$Layout$layout,
														$stil4m$elm_syntax$Combine$string('alias')),
													$stil4m$elm_syntax$Combine$succeed(
														$stil4m$elm_syntax$Elm$Syntax$TypeAlias$TypeAlias($elm$core$Maybe$Nothing)))))))))),
						A2(
						$stil4m$elm_syntax$Combine$map,
						function (tipe) {
							return A2(
								$stil4m$elm_syntax$Elm$Parser$Typings$DefinedType,
								$stil4m$elm_syntax$Elm$Syntax$Range$combine(
									A2(
										$elm$core$List$cons,
										start,
										A2(
											$elm$core$List$map,
											function (_v0) {
												var r = _v0.a;
												return r;
											},
											tipe.constructors))),
								tipe);
						},
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$Typings$valueConstructors,
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									$stil4m$elm_syntax$Combine$string('=')),
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
									A2(
										$stil4m$elm_syntax$Combine$andMap,
										$stil4m$elm_syntax$Elm$Parser$Typings$genericList,
										A2(
											$stil4m$elm_syntax$Combine$ignore,
											$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
											A2(
												$stil4m$elm_syntax$Combine$andMap,
												$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$typeName),
												$stil4m$elm_syntax$Combine$succeed(
													$stil4m$elm_syntax$Elm$Syntax$Type$Type($elm$core$Maybe$Nothing)))))))))
					])),
			$stil4m$elm_syntax$Elm$Parser$Typings$typePrefix);
	});
var $stil4m$elm_syntax$Elm$Parser$Declarations$declaration = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					$stil4m$elm_syntax$Elm$Parser$Declarations$infixDeclaration,
					$stil4m$elm_syntax$Elm$Parser$Declarations$function,
					A2(
					$stil4m$elm_syntax$Combine$map,
					function (v) {
						if (v.$ === 'DefinedType') {
							var r = v.a;
							var t = v.b;
							return A2(
								$stil4m$elm_syntax$Elm$Syntax$Node$Node,
								r,
								$stil4m$elm_syntax$Elm$Syntax$Declaration$CustomTypeDeclaration(t));
						} else {
							var r = v.a;
							var a = v.b;
							return A2(
								$stil4m$elm_syntax$Elm$Syntax$Node$Node,
								r,
								$stil4m$elm_syntax$Elm$Syntax$Declaration$AliasDeclaration(a));
						}
					},
					$stil4m$elm_syntax$Elm$Parser$Typings$typeDefinition),
					$stil4m$elm_syntax$Elm$Parser$Declarations$portDeclaration,
					$stil4m$elm_syntax$Elm$Parser$Declarations$destructuringDeclaration
				]));
	});
var $stil4m$elm_syntax$Elm$Parser$File$fileDeclarations = $stil4m$elm_syntax$Combine$many(
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict),
		$stil4m$elm_syntax$Elm$Parser$Declarations$declaration));
var $stil4m$elm_syntax$Elm$Syntax$Import$Import = F3(
	function (moduleName, moduleAlias, exposingList) {
		return {exposingList: exposingList, moduleAlias: moduleAlias, moduleName: moduleName};
	});
var $stil4m$elm_syntax$Elm$Parser$Tokens$asToken = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$keyword('as'));
var $stil4m$elm_syntax$Elm$Syntax$Exposing$All = function (a) {
	return {$: 'All', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit = function (a) {
	return {$: 'Explicit', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Exposing$FunctionExpose = function (a) {
	return {$: 'FunctionExpose', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Expose$functionExpose = $stil4m$elm_syntax$Elm$Parser$Node$parser(
	A2($stil4m$elm_syntax$Combine$map, $stil4m$elm_syntax$Elm$Syntax$Exposing$FunctionExpose, $stil4m$elm_syntax$Elm$Parser$Tokens$functionName));
var $stil4m$elm_syntax$Elm$Syntax$Exposing$InfixExpose = function (a) {
	return {$: 'InfixExpose', a: a};
};
var $stil4m$elm_syntax$Combine$while = function (pred) {
	return $stil4m$elm_syntax$Combine$Parser(
		function (state) {
			return A2(
				$elm$parser$Parser$map,
				function (x) {
					return _Utils_Tuple2(state, x);
				},
				$elm$parser$Parser$getChompedString(
					$elm$parser$Parser$chompWhile(pred)));
		});
};
var $stil4m$elm_syntax$Elm$Parser$Expose$infixExpose = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Elm$Parser$Node$parser(
			A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$InfixExpose,
				$stil4m$elm_syntax$Combine$parens(
					$stil4m$elm_syntax$Combine$while(
						$elm$core$Basics$neq(
							_Utils_chr(')'))))));
	});
var $stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType = F2(
	function (name, open) {
		return {name: name, open: open};
	});
var $stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose = function (a) {
	return {$: 'TypeExpose', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Exposing$TypeOrAliasExpose = function (a) {
	return {$: 'TypeOrAliasExpose', a: a};
};
var $stil4m$elm_syntax$Elm$Syntax$Node$map = F2(
	function (f, _v0) {
		var r = _v0.a;
		var a = _v0.b;
		return A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			r,
			f(a));
	});
var $stil4m$elm_syntax$Elm$Parser$Expose$typeExpose = A2(
	$stil4m$elm_syntax$Combine$andThen,
	function (tipe) {
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					A2(
					$stil4m$elm_syntax$Combine$map,
					function (openRange) {
						return A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$combine(
								_List_fromArray(
									[
										$stil4m$elm_syntax$Elm$Syntax$Node$range(tipe),
										openRange
									])),
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(tipe),
									$elm$core$Maybe$Just(openRange))));
					},
					A2(
						$stil4m$elm_syntax$Combine$map,
						$stil4m$elm_syntax$Elm$Syntax$Node$range,
						$stil4m$elm_syntax$Elm$Parser$Node$parser(
							$stil4m$elm_syntax$Combine$parens(
								$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
									$stil4m$elm_syntax$Combine$string('..')))))),
					$stil4m$elm_syntax$Combine$succeed(
					A2($stil4m$elm_syntax$Elm$Syntax$Node$map, $stil4m$elm_syntax$Elm$Syntax$Exposing$TypeOrAliasExpose, tipe))
				]));
	},
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$typeName)));
var $stil4m$elm_syntax$Elm$Parser$Expose$exposable = $stil4m$elm_syntax$Combine$lazy(
	function (_v0) {
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[$stil4m$elm_syntax$Elm$Parser$Expose$typeExpose, $stil4m$elm_syntax$Elm$Parser$Expose$infixExpose, $stil4m$elm_syntax$Elm$Parser$Expose$functionExpose]));
	});
var $stil4m$elm_syntax$Elm$Parser$Ranges$withRange = function (p) {
	return $stil4m$elm_syntax$Combine$withLocation(
		function (start) {
			return A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Combine$withLocation(
					function (end) {
						return $stil4m$elm_syntax$Combine$succeed(
							{
								end: $stil4m$elm_syntax$Elm$Parser$Ranges$asPointerLocation(end),
								start: $stil4m$elm_syntax$Elm$Parser$Ranges$asPointerLocation(start)
							});
					}),
				p);
		});
};
var $stil4m$elm_syntax$Elm$Parser$Expose$exposingListInner = A2(
	$stil4m$elm_syntax$Combine$or,
	$stil4m$elm_syntax$Elm$Parser$Ranges$withRange(
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
				$stil4m$elm_syntax$Combine$string('..')),
			$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Exposing$All))),
	A2(
		$stil4m$elm_syntax$Combine$map,
		$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit,
		A2(
			$stil4m$elm_syntax$Combine$sepBy,
			$stil4m$elm_syntax$Combine$Char$char(
				_Utils_chr(',')),
			$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides($stil4m$elm_syntax$Elm$Parser$Expose$exposable))));
var $stil4m$elm_syntax$Elm$Parser$Expose$exposeListWith = $stil4m$elm_syntax$Combine$parens(
	A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout,
		A2($stil4m$elm_syntax$Combine$continueWith, $stil4m$elm_syntax$Elm$Parser$Expose$exposingListInner, $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout)));
var $stil4m$elm_syntax$Elm$Parser$Tokens$exposingToken = $stil4m$elm_syntax$Combine$string('exposing');
var $stil4m$elm_syntax$Elm$Parser$Expose$exposeDefinition = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Expose$exposeListWith,
	A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layout),
		$stil4m$elm_syntax$Elm$Parser$Tokens$exposingToken));
var $stil4m$elm_syntax$Elm$Parser$Tokens$importToken = $stil4m$elm_syntax$Combine$fromCore(
	$elm$parser$Parser$keyword('import'));
var $stil4m$elm_syntax$Elm$Parser$Base$moduleName = A2(
	$stil4m$elm_syntax$Combine$sepBy1,
	$stil4m$elm_syntax$Combine$string('.'),
	$stil4m$elm_syntax$Elm$Parser$Tokens$typeName);
var $elm$core$List$maybeCons = F3(
	function (f, mx, xs) {
		var _v0 = f(mx);
		if (_v0.$ === 'Just') {
			var x = _v0.a;
			return A2($elm$core$List$cons, x, xs);
		} else {
			return xs;
		}
	});
var $elm$core$List$filterMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			$elm$core$List$maybeCons(f),
			_List_Nil,
			xs);
	});
var $stil4m$elm_syntax$Elm$Parser$Imports$setupNode = F2(
	function (start, imp) {
		var allRanges = _List_fromArray(
			[
				$elm$core$Maybe$Just(start),
				$elm$core$Maybe$Just(
				$stil4m$elm_syntax$Elm$Syntax$Node$range(imp.moduleName)),
				A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, imp.exposingList),
				A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, imp.moduleAlias)
			]);
		return A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$combine(
				A2($elm$core$List$filterMap, $elm$core$Basics$identity, allRanges)),
			imp);
	});
var $stil4m$elm_syntax$Elm$Parser$Imports$importDefinition = function () {
	var parseExposingDefinition = F2(
		function (mod, asDef) {
			return $stil4m$elm_syntax$Combine$choice(
				_List_fromArray(
					[
						A2(
						$stil4m$elm_syntax$Combine$map,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Maybe$Just,
							A2($stil4m$elm_syntax$Elm$Syntax$Import$Import, mod, asDef)),
						$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Expose$exposeDefinition)),
						$stil4m$elm_syntax$Combine$succeed(
						A3($stil4m$elm_syntax$Elm$Syntax$Import$Import, mod, asDef, $elm$core$Maybe$Nothing))
					]));
		});
	var importAndModuleName = A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$moduleName),
		A2($stil4m$elm_syntax$Combine$continueWith, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Tokens$importToken));
	var asDefinition = A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$moduleName),
		A2($stil4m$elm_syntax$Combine$continueWith, $stil4m$elm_syntax$Elm$Parser$Layout$layout, $stil4m$elm_syntax$Elm$Parser$Tokens$asToken));
	var parseAsDefinition = function (mod) {
		return $stil4m$elm_syntax$Combine$choice(
			_List_fromArray(
				[
					A2(
					$stil4m$elm_syntax$Combine$andThen,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$Maybe$Just,
						parseExposingDefinition(mod)),
					A2($stil4m$elm_syntax$Combine$ignore, $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout, asDefinition)),
					A2(parseExposingDefinition, mod, $elm$core$Maybe$Nothing)
				]));
	};
	return A2(
		$stil4m$elm_syntax$Combine$andThen,
		function (_v0) {
			var start = _v0.a;
			return A2(
				$stil4m$elm_syntax$Combine$map,
				$stil4m$elm_syntax$Elm$Parser$Imports$setupNode(start),
				A2(
					$stil4m$elm_syntax$Combine$andThen,
					parseAsDefinition,
					A2($stil4m$elm_syntax$Combine$ignore, $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout, importAndModuleName)));
		},
		$stil4m$elm_syntax$Elm$Parser$Node$parser(
			$stil4m$elm_syntax$Combine$succeed(_Utils_Tuple0)));
}();
var $stil4m$elm_syntax$Elm$Syntax$Module$EffectModule = function (a) {
	return {$: 'EffectModule', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Modules$effectWhereClause = A2(
	$stil4m$elm_syntax$Combine$andMap,
	A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Tokens$typeName),
		$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides(
			$stil4m$elm_syntax$Combine$string('='))),
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Tokens$functionName,
		$stil4m$elm_syntax$Combine$succeed($elm$core$Tuple$pair)));
var $elm$core$List$filter = F2(
	function (isGood, list) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, xs) {
					return isGood(x) ? A2($elm$core$List$cons, x, xs) : xs;
				}),
			_List_Nil,
			list);
	});
var $stil4m$elm_syntax$Elm$Parser$Modules$whereBlock = A2(
	$stil4m$elm_syntax$Combine$map,
	function (pairs) {
		return {
			command: A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$second,
				$elm$core$List$head(
					A2(
						$elm$core$List$filter,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Tuple$first,
							$elm$core$Basics$eq('command')),
						pairs))),
			subscription: A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$second,
				$elm$core$List$head(
					A2(
						$elm$core$List$filter,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Tuple$first,
							$elm$core$Basics$eq('subscription')),
						pairs)))
		};
	},
	A3(
		$stil4m$elm_syntax$Combine$between,
		$stil4m$elm_syntax$Combine$string('{'),
		$stil4m$elm_syntax$Combine$string('}'),
		A2(
			$stil4m$elm_syntax$Combine$sepBy1,
			$stil4m$elm_syntax$Combine$string(','),
			$stil4m$elm_syntax$Elm$Parser$Layout$maybeAroundBothSides($stil4m$elm_syntax$Elm$Parser$Modules$effectWhereClause))));
var $stil4m$elm_syntax$Elm$Parser$Modules$effectWhereClauses = A2(
	$stil4m$elm_syntax$Combine$continueWith,
	$stil4m$elm_syntax$Elm$Parser$Modules$whereBlock,
	A2(
		$stil4m$elm_syntax$Combine$continueWith,
		$stil4m$elm_syntax$Elm$Parser$Layout$layout,
		$stil4m$elm_syntax$Combine$string('where')));
var $stil4m$elm_syntax$Elm$Parser$Tokens$moduleToken = $stil4m$elm_syntax$Combine$string('module');
var $stil4m$elm_syntax$Elm$Parser$Modules$effectModuleDefinition = function () {
	var createEffectModule = F3(
		function (name, whereClauses, exp) {
			return $stil4m$elm_syntax$Elm$Syntax$Module$EffectModule(
				{command: whereClauses.command, exposingList: exp, moduleName: name, subscription: whereClauses.subscription});
		});
	return A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Expose$exposeDefinition),
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Elm$Parser$Layout$layout,
			A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Elm$Parser$Modules$effectWhereClauses,
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Elm$Parser$Layout$layout,
					A2(
						$stil4m$elm_syntax$Combine$andMap,
						$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$moduleName),
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Elm$Parser$Layout$layout,
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Elm$Parser$Tokens$moduleToken,
								A2(
									$stil4m$elm_syntax$Combine$ignore,
									$stil4m$elm_syntax$Elm$Parser$Layout$layout,
									A2(
										$stil4m$elm_syntax$Combine$ignore,
										$stil4m$elm_syntax$Combine$string('effect'),
										$stil4m$elm_syntax$Combine$succeed(createEffectModule))))))))));
}();
var $stil4m$elm_syntax$Elm$Syntax$Module$DefaultModuleData = F2(
	function (moduleName, exposingList) {
		return {exposingList: exposingList, moduleName: moduleName};
	});
var $stil4m$elm_syntax$Elm$Syntax$Module$NormalModule = function (a) {
	return {$: 'NormalModule', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Modules$normalModuleDefinition = A2(
	$stil4m$elm_syntax$Combine$map,
	$stil4m$elm_syntax$Elm$Syntax$Module$NormalModule,
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Expose$exposeDefinition),
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Elm$Parser$Layout$layout,
			A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$moduleName),
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Elm$Parser$Layout$layout,
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Elm$Parser$Tokens$moduleToken,
						$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Module$DefaultModuleData)))))));
var $stil4m$elm_syntax$Elm$Syntax$Module$PortModule = function (a) {
	return {$: 'PortModule', a: a};
};
var $stil4m$elm_syntax$Elm$Parser$Modules$portModuleDefinition = A2(
	$stil4m$elm_syntax$Combine$map,
	$stil4m$elm_syntax$Elm$Syntax$Module$PortModule,
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Expose$exposeDefinition),
		A2(
			$stil4m$elm_syntax$Combine$ignore,
			$stil4m$elm_syntax$Elm$Parser$Layout$layout,
			A2(
				$stil4m$elm_syntax$Combine$andMap,
				$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Base$moduleName),
				A2(
					$stil4m$elm_syntax$Combine$ignore,
					$stil4m$elm_syntax$Elm$Parser$Layout$layout,
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Elm$Parser$Tokens$moduleToken,
						A2(
							$stil4m$elm_syntax$Combine$ignore,
							$stil4m$elm_syntax$Elm$Parser$Layout$layout,
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Elm$Parser$Tokens$portToken,
								$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$Module$DefaultModuleData)))))))));
var $stil4m$elm_syntax$Elm$Parser$Modules$moduleDefinition = $stil4m$elm_syntax$Combine$choice(
	_List_fromArray(
		[$stil4m$elm_syntax$Elm$Parser$Modules$normalModuleDefinition, $stil4m$elm_syntax$Elm$Parser$Modules$portModuleDefinition, $stil4m$elm_syntax$Elm$Parser$Modules$effectModuleDefinition]));
var $stil4m$elm_syntax$Elm$Parser$File$file = A2(
	$stil4m$elm_syntax$Combine$ignore,
	$stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout,
	A2(
		$stil4m$elm_syntax$Combine$andMap,
		$stil4m$elm_syntax$Elm$Parser$File$collectComments,
		A2(
			$stil4m$elm_syntax$Combine$andMap,
			$stil4m$elm_syntax$Elm$Parser$File$fileDeclarations,
			A2(
				$stil4m$elm_syntax$Combine$ignore,
				$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict),
				A2(
					$stil4m$elm_syntax$Combine$andMap,
					$stil4m$elm_syntax$Combine$many(
						A2($stil4m$elm_syntax$Combine$ignore, $stil4m$elm_syntax$Elm$Parser$Layout$optimisticLayout, $stil4m$elm_syntax$Elm$Parser$Imports$importDefinition)),
					A2(
						$stil4m$elm_syntax$Combine$ignore,
						$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict),
						A2(
							$stil4m$elm_syntax$Combine$andMap,
							$stil4m$elm_syntax$Elm$Parser$Node$parser($stil4m$elm_syntax$Elm$Parser$Modules$moduleDefinition),
							A2(
								$stil4m$elm_syntax$Combine$ignore,
								$stil4m$elm_syntax$Combine$maybe($stil4m$elm_syntax$Elm$Parser$Layout$layoutStrict),
								$stil4m$elm_syntax$Combine$succeed($stil4m$elm_syntax$Elm$Syntax$File$File)))))))));
var $stil4m$elm_syntax$Elm$Internal$RawFile$Raw = function (a) {
	return {$: 'Raw', a: a};
};
var $stil4m$elm_syntax$Elm$Internal$RawFile$fromFile = $stil4m$elm_syntax$Elm$Internal$RawFile$Raw;
var $elm$parser$Parser$DeadEnd = F3(
	function (row, col, problem) {
		return {col: col, problem: problem, row: row};
	});
var $elm$parser$Parser$problemToDeadEnd = function (p) {
	return A3($elm$parser$Parser$DeadEnd, p.row, p.col, p.problem);
};
var $elm$parser$Parser$Advanced$bagToList = F2(
	function (bag, list) {
		bagToList:
		while (true) {
			switch (bag.$) {
				case 'Empty':
					return list;
				case 'AddRight':
					var bag1 = bag.a;
					var x = bag.b;
					var $temp$bag = bag1,
						$temp$list = A2($elm$core$List$cons, x, list);
					bag = $temp$bag;
					list = $temp$list;
					continue bagToList;
				default:
					var bag1 = bag.a;
					var bag2 = bag.b;
					var $temp$bag = bag1,
						$temp$list = A2($elm$parser$Parser$Advanced$bagToList, bag2, list);
					bag = $temp$bag;
					list = $temp$list;
					continue bagToList;
			}
		}
	});
var $elm$parser$Parser$Advanced$run = F2(
	function (_v0, src) {
		var parse = _v0.a;
		var _v1 = parse(
			{col: 1, context: _List_Nil, indent: 1, offset: 0, row: 1, src: src});
		if (_v1.$ === 'Good') {
			var value = _v1.b;
			return $elm$core$Result$Ok(value);
		} else {
			var bag = _v1.b;
			return $elm$core$Result$Err(
				A2($elm$parser$Parser$Advanced$bagToList, bag, _List_Nil));
		}
	});
var $elm$parser$Parser$run = F2(
	function (parser, source) {
		var _v0 = A2($elm$parser$Parser$Advanced$run, parser, source);
		if (_v0.$ === 'Ok') {
			var a = _v0.a;
			return $elm$core$Result$Ok(a);
		} else {
			var problems = _v0.a;
			return $elm$core$Result$Err(
				A2($elm$core$List$map, $elm$parser$Parser$problemToDeadEnd, problems));
		}
	});
var $stil4m$elm_syntax$Combine$runParser = F3(
	function (_v0, st, s) {
		var p = _v0.a;
		return A2(
			$elm$parser$Parser$run,
			p(st),
			s);
	});
var $elm$parser$Parser$ExpectingEnd = {$: 'ExpectingEnd'};
var $elm$parser$Parser$Advanced$end = function (x) {
	return $elm$parser$Parser$Advanced$Parser(
		function (s) {
			return _Utils_eq(
				$elm$core$String$length(s.src),
				s.offset) ? A3($elm$parser$Parser$Advanced$Good, false, _Utils_Tuple0, s) : A2(
				$elm$parser$Parser$Advanced$Bad,
				false,
				A2($elm$parser$Parser$Advanced$fromState, s, x));
		});
};
var $elm$parser$Parser$end = $elm$parser$Parser$Advanced$end($elm$parser$Parser$ExpectingEnd);
var $stil4m$elm_syntax$Combine$end = $stil4m$elm_syntax$Combine$Parser(
	function (state) {
		return A2(
			$elm$parser$Parser$map,
			function (x) {
				return _Utils_Tuple2(state, x);
			},
			$elm$parser$Parser$end);
	});
var $stil4m$elm_syntax$Elm$Parser$withEnd = function (p) {
	return A2(
		$stil4m$elm_syntax$Combine$ignore,
		$stil4m$elm_syntax$Combine$withLocation(
			function (_v0) {
				return $stil4m$elm_syntax$Combine$end;
			}),
		p);
};
var $stil4m$elm_syntax$Elm$Parser$parse = function (input) {
	var _v0 = A3(
		$stil4m$elm_syntax$Combine$runParser,
		$stil4m$elm_syntax$Elm$Parser$withEnd($stil4m$elm_syntax$Elm$Parser$File$file),
		$stil4m$elm_syntax$Elm$Parser$State$emptyState,
		input + '\n');
	if (_v0.$ === 'Ok') {
		var _v1 = _v0.a;
		var r = _v1.b;
		return $elm$core$Result$Ok(
			$stil4m$elm_syntax$Elm$Internal$RawFile$fromFile(r));
	} else {
		var s = _v0.a;
		return $elm$core$Result$Err(s);
	}
};
var $elm$core$Result$toMaybe = function (result) {
	if (result.$ === 'Ok') {
		var v = result.a;
		return $elm$core$Maybe$Just(v);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $jfmengels$elm_review$Review$Fix$HasCollisionsInFixRanges = {$: 'HasCollisionsInFixRanges'};
var $jfmengels$elm_review$Review$Fix$SourceCodeIsNotValid = function (a) {
	return {$: 'SourceCodeIsNotValid', a: a};
};
var $jfmengels$elm_review$Review$Fix$Successful = function (a) {
	return {$: 'Successful', a: a};
};
var $jfmengels$elm_review$Unicode$dropLeft = F2(
	function (n, string) {
		return $elm$core$String$fromList(
			A2(
				$elm$core$List$drop,
				n,
				$elm$core$String$toList(string)));
	});
var $elm$core$Array$fromListHelp = F3(
	function (list, nodeList, nodeListSize) {
		fromListHelp:
		while (true) {
			var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, list);
			var jsArray = _v0.a;
			var remainingItems = _v0.b;
			if (_Utils_cmp(
				$elm$core$Elm$JsArray$length(jsArray),
				$elm$core$Array$branchFactor) < 0) {
				return A2(
					$elm$core$Array$builderToArray,
					true,
					{nodeList: nodeList, nodeListSize: nodeListSize, tail: jsArray});
			} else {
				var $temp$list = remainingItems,
					$temp$nodeList = A2(
					$elm$core$List$cons,
					$elm$core$Array$Leaf(jsArray),
					nodeList),
					$temp$nodeListSize = nodeListSize + 1;
				list = $temp$list;
				nodeList = $temp$nodeList;
				nodeListSize = $temp$nodeListSize;
				continue fromListHelp;
			}
		}
	});
var $elm$core$Array$fromList = function (list) {
	if (!list.b) {
		return $elm$core$Array$empty;
	} else {
		return A3($elm$core$Array$fromListHelp, list, _List_Nil, 0);
	}
};
var $elm$core$Bitwise$and = _Bitwise_and;
var $elm$core$Bitwise$shiftRightZfBy = _Bitwise_shiftRightZfBy;
var $elm$core$Array$bitMask = 4294967295 >>> (32 - $elm$core$Array$shiftStep);
var $elm$core$Elm$JsArray$unsafeGet = _JsArray_unsafeGet;
var $elm$core$Array$getHelp = F3(
	function (shift, index, tree) {
		getHelp:
		while (true) {
			var pos = $elm$core$Array$bitMask & (index >>> shift);
			var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
			if (_v0.$ === 'SubTree') {
				var subTree = _v0.a;
				var $temp$shift = shift - $elm$core$Array$shiftStep,
					$temp$index = index,
					$temp$tree = subTree;
				shift = $temp$shift;
				index = $temp$index;
				tree = $temp$tree;
				continue getHelp;
			} else {
				var values = _v0.a;
				return A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, values);
			}
		}
	});
var $elm$core$Bitwise$shiftLeftBy = _Bitwise_shiftLeftBy;
var $elm$core$Array$tailIndex = function (len) {
	return (len >>> 5) << 5;
};
var $elm$core$Array$get = F2(
	function (index, _v0) {
		var len = _v0.a;
		var startShift = _v0.b;
		var tree = _v0.c;
		var tail = _v0.d;
		return ((index < 0) || (_Utils_cmp(index, len) > -1)) ? $elm$core$Maybe$Nothing : ((_Utils_cmp(
			index,
			$elm$core$Array$tailIndex(len)) > -1) ? $elm$core$Maybe$Just(
			A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, tail)) : $elm$core$Maybe$Just(
			A3($elm$core$Array$getHelp, startShift, index, tree)));
	});
var $jfmengels$elm_review$Review$Fix$Internal$getRowAtLine = F2(
	function (lines, rowIndex) {
		var _v0 = A2(
			$elm$core$Array$get,
			rowIndex,
			$elm$core$Array$fromList(lines));
		if (_v0.$ === 'Just') {
			var line = _v0.a;
			return ($elm$core$String$trim(line) !== '') ? line : '';
		} else {
			return '';
		}
	});
var $elm$core$List$takeReverse = F3(
	function (n, list, kept) {
		takeReverse:
		while (true) {
			if (n <= 0) {
				return kept;
			} else {
				if (!list.b) {
					return kept;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs,
						$temp$kept = A2($elm$core$List$cons, x, kept);
					n = $temp$n;
					list = $temp$list;
					kept = $temp$kept;
					continue takeReverse;
				}
			}
		}
	});
var $elm$core$List$takeTailRec = F2(
	function (n, list) {
		return $elm$core$List$reverse(
			A3($elm$core$List$takeReverse, n, list, _List_Nil));
	});
var $elm$core$List$takeFast = F3(
	function (ctr, n, list) {
		if (n <= 0) {
			return _List_Nil;
		} else {
			var _v0 = _Utils_Tuple2(n, list);
			_v0$1:
			while (true) {
				_v0$5:
				while (true) {
					if (!_v0.b.b) {
						return list;
					} else {
						if (_v0.b.b.b) {
							switch (_v0.a) {
								case 1:
									break _v0$1;
								case 2:
									var _v2 = _v0.b;
									var x = _v2.a;
									var _v3 = _v2.b;
									var y = _v3.a;
									return _List_fromArray(
										[x, y]);
								case 3:
									if (_v0.b.b.b.b) {
										var _v4 = _v0.b;
										var x = _v4.a;
										var _v5 = _v4.b;
										var y = _v5.a;
										var _v6 = _v5.b;
										var z = _v6.a;
										return _List_fromArray(
											[x, y, z]);
									} else {
										break _v0$5;
									}
								default:
									if (_v0.b.b.b.b && _v0.b.b.b.b.b) {
										var _v7 = _v0.b;
										var x = _v7.a;
										var _v8 = _v7.b;
										var y = _v8.a;
										var _v9 = _v8.b;
										var z = _v9.a;
										var _v10 = _v9.b;
										var w = _v10.a;
										var tl = _v10.b;
										return (ctr > 1000) ? A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A2($elm$core$List$takeTailRec, n - 4, tl))))) : A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A3($elm$core$List$takeFast, ctr + 1, n - 4, tl)))));
									} else {
										break _v0$5;
									}
							}
						} else {
							if (_v0.a === 1) {
								break _v0$1;
							} else {
								break _v0$5;
							}
						}
					}
				}
				return list;
			}
			var _v1 = _v0.b;
			var x = _v1.a;
			return _List_fromArray(
				[x]);
		}
	});
var $elm$core$List$take = F2(
	function (n, list) {
		return A3($elm$core$List$takeFast, 0, n, list);
	});
var $jfmengels$elm_review$Unicode$left = F2(
	function (n, string) {
		return $elm$core$String$fromList(
			A2(
				$elm$core$List$take,
				n,
				$elm$core$String$toList(string)));
	});
var $elm$core$String$lines = _String_lines;
var $jfmengels$elm_review$Review$Fix$Internal$applyReplace = F3(
	function (range, replacement, lines) {
		var startLine = A2(
			$jfmengels$elm_review$Unicode$left,
			range.start.column - 1,
			A2($jfmengels$elm_review$Review$Fix$Internal$getRowAtLine, lines, range.start.row - 1));
		var linesBefore = A2($elm$core$List$take, range.start.row - 1, lines);
		var linesAfter = A2($elm$core$List$drop, range.end.row, lines);
		var endLine = A2(
			$jfmengels$elm_review$Unicode$dropLeft,
			range.end.column - 1,
			A2($jfmengels$elm_review$Review$Fix$Internal$getRowAtLine, lines, range.end.row - 1));
		return $elm$core$List$concat(
			_List_fromArray(
				[
					linesBefore,
					$elm$core$String$lines(
					_Utils_ap(
						startLine,
						_Utils_ap(replacement, endLine))),
					linesAfter
				]));
	});
var $jfmengels$elm_review$Review$Fix$Internal$applyFix = F2(
	function (fix_, lines) {
		switch (fix_.$) {
			case 'Replacement':
				var range = fix_.a;
				var replacement = fix_.b;
				return A3($jfmengels$elm_review$Review$Fix$Internal$applyReplace, range, replacement, lines);
			case 'Removal':
				var range = fix_.a;
				return A3($jfmengels$elm_review$Review$Fix$Internal$applyReplace, range, '', lines);
			default:
				var position = fix_.a;
				var insertion = fix_.b;
				return A3(
					$jfmengels$elm_review$Review$Fix$Internal$applyReplace,
					{end: position, start: position},
					insertion,
					lines);
		}
	});
var $jfmengels$elm_review$Vendor$ListExtra$anyCombination = F2(
	function (predicate, xs) {
		anyCombination:
		while (true) {
			if (!xs.b) {
				return false;
			} else {
				var x = xs.a;
				var xs_ = xs.b;
				if (A2(
					$elm$core$List$any,
					function (y) {
						return A2(predicate, x, y);
					},
					xs_)) {
					return true;
				} else {
					var $temp$predicate = predicate,
						$temp$xs = xs_;
					predicate = $temp$predicate;
					xs = $temp$xs;
					continue anyCombination;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$comparePosition = F2(
	function (a, b) {
		var _v0 = A2($elm$core$Basics$compare, a.row, b.row);
		if (_v0.$ === 'EQ') {
			return A2($elm$core$Basics$compare, a.column, b.column);
		} else {
			var order = _v0;
			return order;
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$collide = F2(
	function (a, b) {
		var _v0 = A2($jfmengels$elm_review$Review$Fix$Internal$comparePosition, a.end, b.start);
		switch (_v0.$) {
			case 'LT':
				return false;
			case 'EQ':
				return false;
			default:
				var _v1 = A2($jfmengels$elm_review$Review$Fix$Internal$comparePosition, b.end, a.start);
				switch (_v1.$) {
					case 'LT':
						return false;
					case 'EQ':
						return false;
					default:
						return true;
				}
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$getFixRange = function (fix_) {
	switch (fix_.$) {
		case 'Replacement':
			var range = fix_.a;
			return range;
		case 'Removal':
			var range = fix_.a;
			return range;
		default:
			var position = fix_.a;
			return {end: position, start: position};
	}
};
var $jfmengels$elm_review$Review$Fix$Internal$containRangeCollisions = function (fixes) {
	return A2(
		$jfmengels$elm_review$Vendor$ListExtra$anyCombination,
		$jfmengels$elm_review$Review$Fix$Internal$collide,
		A2($elm$core$List$map, $jfmengels$elm_review$Review$Fix$Internal$getFixRange, fixes));
};
var $jfmengels$elm_review$Review$Fix$Internal$positionAsInt = function (_v0) {
	var row = _v0.row;
	var column = _v0.column;
	return (row * 1000000) + column;
};
var $jfmengels$elm_review$Review$Fix$Internal$rangePosition = function (fix_) {
	return $jfmengels$elm_review$Review$Fix$Internal$positionAsInt(
		function () {
			switch (fix_.$) {
				case 'Replacement':
					var range = fix_.a;
					return range.start;
				case 'Removal':
					var range = fix_.a;
					return range.start;
				default:
					var position = fix_.a;
					return position;
			}
		}());
};
var $elm$core$List$sortBy = _List_sortBy;
var $jfmengels$elm_review$Review$Fix$tryToApplyFix = F3(
	function (fixes, sourceCode, isValidSourceCode) {
		if ($jfmengels$elm_review$Review$Fix$Internal$containRangeCollisions(fixes)) {
			return $jfmengels$elm_review$Review$Fix$Errored($jfmengels$elm_review$Review$Fix$HasCollisionsInFixRanges);
		} else {
			var resultAfterFix = A2(
				$elm$core$String$join,
				'\n',
				A3(
					$elm$core$List$foldl,
					$jfmengels$elm_review$Review$Fix$Internal$applyFix,
					$elm$core$String$lines(sourceCode),
					A2(
						$elm$core$List$sortBy,
						A2($elm$core$Basics$composeR, $jfmengels$elm_review$Review$Fix$Internal$rangePosition, $elm$core$Basics$negate),
						fixes)));
			return _Utils_eq(sourceCode, resultAfterFix) ? $jfmengels$elm_review$Review$Fix$Errored($jfmengels$elm_review$Review$Fix$Unchanged) : (isValidSourceCode(resultAfterFix) ? $jfmengels$elm_review$Review$Fix$Successful(resultAfterFix) : $jfmengels$elm_review$Review$Fix$Errored(
				$jfmengels$elm_review$Review$Fix$SourceCodeIsNotValid(resultAfterFix)));
		}
	});
var $jfmengels$elm_review$Review$Fix$fix = F3(
	function (target, fixes, sourceCode) {
		switch (target.$) {
			case 'Module':
				return A3(
					$jfmengels$elm_review$Review$Fix$tryToApplyFix,
					fixes,
					sourceCode,
					function (resultAfterFix) {
						return !_Utils_eq(
							$elm$core$Result$toMaybe(
								$stil4m$elm_syntax$Elm$Parser$parse(resultAfterFix)),
							$elm$core$Maybe$Nothing);
					});
			case 'Readme':
				return A3(
					$jfmengels$elm_review$Review$Fix$tryToApplyFix,
					fixes,
					sourceCode,
					$elm$core$Basics$always(true));
			case 'ElmJson':
				return A3(
					$jfmengels$elm_review$Review$Fix$tryToApplyFix,
					fixes,
					sourceCode,
					function (resultAfterFix) {
						return !_Utils_eq(
							$elm$core$Result$toMaybe(
								A2($elm$json$Json$Decode$decodeString, $elm$project_metadata_utils$Elm$Project$decoder, resultAfterFix)),
							$elm$core$Maybe$Nothing);
					});
			case 'Global':
				return $jfmengels$elm_review$Review$Fix$Errored($jfmengels$elm_review$Review$Fix$Unchanged);
			default:
				return $jfmengels$elm_review$Review$Fix$Errored($jfmengels$elm_review$Review$Fix$Unchanged);
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$wrapInTripleQuotes = function (str) {
	return '```\n' + (str + '\n  ```');
};
var $jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCodeWithFormatter = F2(
	function (formatter, lines) {
		return ($elm$core$List$length(lines) === 1) ? $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			A2(
				$elm$core$String$join,
				'\n',
				formatter(lines))) : $jfmengels$elm_review$Review$Test$FailureMessage$wrapInTripleQuotes(
			A2(
				$elm$core$String$join,
				'\n',
				A2(
					$elm$core$List$map,
					function (str) {
						return (str === '') ? '' : ('    ' + str);
					},
					formatter(lines))));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode = function (string) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCodeWithFormatter,
		$elm$core$Basics$identity,
		$elm$core$String$lines(string));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$fixedCodeMismatch = F3(
	function (resultingSourceCode, expectedSourceCode, error) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'FIXED CODE MISMATCH',
			'I found a different fixed source code than expected for the error with the\nfollowing message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nI expected the following result after the fixes have been applied:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(expectedSourceCode) + ('\n\nbut I found:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(resultingSourceCode))))));
	});
var $jfmengels$elm_review$Ansi$noBackgroundColor = '\u001B[0m';
var $jfmengels$elm_review$Ansi$applyBackgroundColor = F2(
	function (color, string) {
		return $elm$core$String$concat(
			_List_fromArray(
				['\u001B[' + (color + 'm'), string, $jfmengels$elm_review$Ansi$noBackgroundColor]));
	});
var $jfmengels$elm_review$Ansi$backgroundRed = $jfmengels$elm_review$Ansi$applyBackgroundColor('41');
var $elm$core$Array$length = function (_v0) {
	var len = _v0.a;
	return len;
};
var $jfmengels$elm_review$Vendor$Diff$Added = function (a) {
	return {$: 'Added', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$CannotGetA = function (a) {
	return {$: 'CannotGetA', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$CannotGetB = function (a) {
	return {$: 'CannotGetB', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$NoChange = function (a) {
	return {$: 'NoChange', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$Removed = function (a) {
	return {$: 'Removed', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$UnexpectedPath = F2(
	function (a, b) {
		return {$: 'UnexpectedPath', a: a, b: b};
	});
var $jfmengels$elm_review$Vendor$Diff$makeChangesHelp = F5(
	function (changes, getA, getB, _v0, path) {
		makeChangesHelp:
		while (true) {
			var x = _v0.a;
			var y = _v0.b;
			if (!path.b) {
				return $elm$core$Result$Ok(changes);
			} else {
				var _v2 = path.a;
				var prevX = _v2.a;
				var prevY = _v2.b;
				var tail = path.b;
				var change = function () {
					if (_Utils_eq(x - 1, prevX) && _Utils_eq(y - 1, prevY)) {
						var _v4 = getA(x);
						if (_v4.$ === 'Just') {
							var a = _v4.a;
							return $elm$core$Result$Ok(
								$jfmengels$elm_review$Vendor$Diff$NoChange(a));
						} else {
							return $elm$core$Result$Err(
								$jfmengels$elm_review$Vendor$Diff$CannotGetA(x));
						}
					} else {
						if (_Utils_eq(x, prevX)) {
							var _v5 = getB(y);
							if (_v5.$ === 'Just') {
								var b = _v5.a;
								return $elm$core$Result$Ok(
									$jfmengels$elm_review$Vendor$Diff$Added(b));
							} else {
								return $elm$core$Result$Err(
									$jfmengels$elm_review$Vendor$Diff$CannotGetB(y));
							}
						} else {
							if (_Utils_eq(y, prevY)) {
								var _v6 = getA(x);
								if (_v6.$ === 'Just') {
									var a = _v6.a;
									return $elm$core$Result$Ok(
										$jfmengels$elm_review$Vendor$Diff$Removed(a));
								} else {
									return $elm$core$Result$Err(
										$jfmengels$elm_review$Vendor$Diff$CannotGetA(x));
								}
							} else {
								return $elm$core$Result$Err(
									A2(
										$jfmengels$elm_review$Vendor$Diff$UnexpectedPath,
										_Utils_Tuple2(x, y),
										path));
							}
						}
					}
				}();
				if (change.$ === 'Ok') {
					var c = change.a;
					var $temp$changes = A2($elm$core$List$cons, c, changes),
						$temp$getA = getA,
						$temp$getB = getB,
						$temp$_v0 = _Utils_Tuple2(prevX, prevY),
						$temp$path = tail;
					changes = $temp$changes;
					getA = $temp$getA;
					getB = $temp$getB;
					_v0 = $temp$_v0;
					path = $temp$path;
					continue makeChangesHelp;
				} else {
					var e = change.a;
					return $elm$core$Result$Err(e);
				}
			}
		}
	});
var $jfmengels$elm_review$Vendor$Diff$makeChanges = F3(
	function (getA, getB, path) {
		if (!path.b) {
			return $elm$core$Result$Ok(_List_Nil);
		} else {
			var latest = path.a;
			var tail = path.b;
			return A5($jfmengels$elm_review$Vendor$Diff$makeChangesHelp, _List_Nil, getA, getB, latest, tail);
		}
	});
var $jfmengels$elm_review$Vendor$Diff$Continue = function (a) {
	return {$: 'Continue', a: a};
};
var $jfmengels$elm_review$Vendor$Diff$Found = function (a) {
	return {$: 'Found', a: a};
};
var $elm$core$Elm$JsArray$unsafeSet = _JsArray_unsafeSet;
var $elm$core$Array$setHelp = F4(
	function (shift, index, value, tree) {
		var pos = $elm$core$Array$bitMask & (index >>> shift);
		var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
		if (_v0.$ === 'SubTree') {
			var subTree = _v0.a;
			var newSub = A4($elm$core$Array$setHelp, shift - $elm$core$Array$shiftStep, index, value, subTree);
			return A3(
				$elm$core$Elm$JsArray$unsafeSet,
				pos,
				$elm$core$Array$SubTree(newSub),
				tree);
		} else {
			var values = _v0.a;
			var newLeaf = A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, values);
			return A3(
				$elm$core$Elm$JsArray$unsafeSet,
				pos,
				$elm$core$Array$Leaf(newLeaf),
				tree);
		}
	});
var $elm$core$Array$set = F3(
	function (index, value, array) {
		var len = array.a;
		var startShift = array.b;
		var tree = array.c;
		var tail = array.d;
		return ((index < 0) || (_Utils_cmp(index, len) > -1)) ? array : ((_Utils_cmp(
			index,
			$elm$core$Array$tailIndex(len)) > -1) ? A4(
			$elm$core$Array$Array_elm_builtin,
			len,
			startShift,
			tree,
			A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, tail)) : A4(
			$elm$core$Array$Array_elm_builtin,
			len,
			startShift,
			A4($elm$core$Array$setHelp, startShift, index, value, tree),
			tail));
	});
var $jfmengels$elm_review$Vendor$Diff$step = F4(
	function (snake_, offset, k, v) {
		var fromTop = A2(
			$elm$core$Maybe$withDefault,
			_List_Nil,
			A2($elm$core$Array$get, (k + 1) + offset, v));
		var fromLeft = A2(
			$elm$core$Maybe$withDefault,
			_List_Nil,
			A2($elm$core$Array$get, (k - 1) + offset, v));
		var _v0 = function () {
			var _v2 = _Utils_Tuple2(fromLeft, fromTop);
			if (!_v2.a.b) {
				if (!_v2.b.b) {
					return _Utils_Tuple2(
						_List_Nil,
						_Utils_Tuple2(0, 0));
				} else {
					var _v3 = _v2.b;
					var _v4 = _v3.a;
					var topX = _v4.a;
					var topY = _v4.b;
					return _Utils_Tuple2(
						fromTop,
						_Utils_Tuple2(topX + 1, topY));
				}
			} else {
				if (!_v2.b.b) {
					var _v5 = _v2.a;
					var _v6 = _v5.a;
					var leftX = _v6.a;
					var leftY = _v6.b;
					return _Utils_Tuple2(
						fromLeft,
						_Utils_Tuple2(leftX, leftY + 1));
				} else {
					var _v7 = _v2.a;
					var _v8 = _v7.a;
					var leftX = _v8.a;
					var leftY = _v8.b;
					var _v9 = _v2.b;
					var _v10 = _v9.a;
					var topX = _v10.a;
					var topY = _v10.b;
					return (_Utils_cmp(leftY + 1, topY) > -1) ? _Utils_Tuple2(
						fromLeft,
						_Utils_Tuple2(leftX, leftY + 1)) : _Utils_Tuple2(
						fromTop,
						_Utils_Tuple2(topX + 1, topY));
				}
			}
		}();
		var path = _v0.a;
		var _v1 = _v0.b;
		var x = _v1.a;
		var y = _v1.b;
		var _v11 = A3(
			snake_,
			x + 1,
			y + 1,
			A2(
				$elm$core$List$cons,
				_Utils_Tuple2(x, y),
				path));
		var newPath = _v11.a;
		var goal = _v11.b;
		return goal ? $jfmengels$elm_review$Vendor$Diff$Found(newPath) : $jfmengels$elm_review$Vendor$Diff$Continue(
			A3($elm$core$Array$set, k + offset, newPath, v));
	});
var $jfmengels$elm_review$Vendor$Diff$onpLoopK = F4(
	function (snake_, offset, ks, v) {
		onpLoopK:
		while (true) {
			if (!ks.b) {
				return $jfmengels$elm_review$Vendor$Diff$Continue(v);
			} else {
				var k = ks.a;
				var ks_ = ks.b;
				var _v1 = A4($jfmengels$elm_review$Vendor$Diff$step, snake_, offset, k, v);
				if (_v1.$ === 'Found') {
					var path = _v1.a;
					return $jfmengels$elm_review$Vendor$Diff$Found(path);
				} else {
					var v_ = _v1.a;
					var $temp$snake_ = snake_,
						$temp$offset = offset,
						$temp$ks = ks_,
						$temp$v = v_;
					snake_ = $temp$snake_;
					offset = $temp$offset;
					ks = $temp$ks;
					v = $temp$v;
					continue onpLoopK;
				}
			}
		}
	});
var $jfmengels$elm_review$Vendor$Diff$onpLoopP = F5(
	function (snake_, delta, offset, p, v) {
		onpLoopP:
		while (true) {
			var ks = (delta > 0) ? _Utils_ap(
				$elm$core$List$reverse(
					A2($elm$core$List$range, delta + 1, delta + p)),
				A2($elm$core$List$range, -p, delta)) : _Utils_ap(
				$elm$core$List$reverse(
					A2($elm$core$List$range, delta + 1, p)),
				A2($elm$core$List$range, (-p) + delta, delta));
			var _v0 = A4($jfmengels$elm_review$Vendor$Diff$onpLoopK, snake_, offset, ks, v);
			if (_v0.$ === 'Found') {
				var path = _v0.a;
				return path;
			} else {
				var v_ = _v0.a;
				var $temp$snake_ = snake_,
					$temp$delta = delta,
					$temp$offset = offset,
					$temp$p = p + 1,
					$temp$v = v_;
				snake_ = $temp$snake_;
				delta = $temp$delta;
				offset = $temp$offset;
				p = $temp$p;
				v = $temp$v;
				continue onpLoopP;
			}
		}
	});
var $jfmengels$elm_review$Vendor$Diff$snake = F5(
	function (getA, getB, nextX, nextY, path) {
		snake:
		while (true) {
			var _v0 = _Utils_Tuple2(
				getA(nextX),
				getB(nextY));
			_v0$2:
			while (true) {
				if (_v0.a.$ === 'Just') {
					if (_v0.b.$ === 'Just') {
						var a = _v0.a.a;
						var b = _v0.b.a;
						if (_Utils_eq(a, b)) {
							var $temp$getA = getA,
								$temp$getB = getB,
								$temp$nextX = nextX + 1,
								$temp$nextY = nextY + 1,
								$temp$path = A2(
								$elm$core$List$cons,
								_Utils_Tuple2(nextX, nextY),
								path);
							getA = $temp$getA;
							getB = $temp$getB;
							nextX = $temp$nextX;
							nextY = $temp$nextY;
							path = $temp$path;
							continue snake;
						} else {
							return _Utils_Tuple2(path, false);
						}
					} else {
						break _v0$2;
					}
				} else {
					if (_v0.b.$ === 'Nothing') {
						var _v1 = _v0.a;
						var _v2 = _v0.b;
						return _Utils_Tuple2(path, true);
					} else {
						break _v0$2;
					}
				}
			}
			return _Utils_Tuple2(path, false);
		}
	});
var $jfmengels$elm_review$Vendor$Diff$onp = F4(
	function (getA, getB, m, n) {
		var v = A2(
			$elm$core$Array$initialize,
			(m + n) + 1,
			$elm$core$Basics$always(_List_Nil));
		var delta = n - m;
		return A5(
			$jfmengels$elm_review$Vendor$Diff$onpLoopP,
			A2($jfmengels$elm_review$Vendor$Diff$snake, getA, getB),
			delta,
			m,
			0,
			v);
	});
var $jfmengels$elm_review$Vendor$Diff$testDiff = F2(
	function (a, b) {
		var arrB = $elm$core$Array$fromList(b);
		var getB = function (y) {
			return A2($elm$core$Array$get, y - 1, arrB);
		};
		var n = $elm$core$Array$length(arrB);
		var arrA = $elm$core$Array$fromList(a);
		var getA = function (x) {
			return A2($elm$core$Array$get, x - 1, arrA);
		};
		var m = $elm$core$Array$length(arrA);
		var path = A4($jfmengels$elm_review$Vendor$Diff$onp, getA, getB, m, n);
		return A3($jfmengels$elm_review$Vendor$Diff$makeChanges, getA, getB, path);
	});
var $jfmengels$elm_review$Vendor$Diff$diff = F2(
	function (a, b) {
		var _v0 = A2($jfmengels$elm_review$Vendor$Diff$testDiff, a, b);
		if (_v0.$ === 'Ok') {
			var changes = _v0.a;
			return changes;
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$highlightWhiteSpaceDifferences = F2(
	function (aString, bString) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (change, _v0) {
					var a = _v0.a;
					var b = _v0.b;
					switch (change.$) {
						case 'NoChange':
							var str = change.a;
							return _Utils_Tuple2(
								_Utils_ap(
									a,
									$elm$core$String$fromChar(str)),
								_Utils_ap(
									b,
									$elm$core$String$fromChar(str)));
						case 'Added':
							if ('\n' === change.a.valueOf()) {
								return _Utils_Tuple2(
									a + ($jfmengels$elm_review$Ansi$backgroundRed('') + '\n'),
									b);
							} else {
								var str = change.a;
								return _Utils_Tuple2(
									_Utils_ap(
										a,
										$jfmengels$elm_review$Ansi$backgroundRed(
											$elm$core$String$fromChar(str))),
									b);
							}
						default:
							if ('\n' === change.a.valueOf()) {
								return _Utils_Tuple2(
									a,
									b + ($jfmengels$elm_review$Ansi$backgroundRed('') + '\n'));
							} else {
								var str = change.a;
								return _Utils_Tuple2(
									a,
									_Utils_ap(
										b,
										$jfmengels$elm_review$Ansi$backgroundRed(
											$elm$core$String$fromChar(str))));
							}
					}
				}),
			_Utils_Tuple2('', ''),
			A2(
				$jfmengels$elm_review$Vendor$Diff$diff,
				$elm$core$String$toList(aString),
				$elm$core$String$toList(bString)));
	});
var $jfmengels$elm_review$Ansi$cyan = $jfmengels$elm_review$Ansi$applyColor('36');
var $elm$core$String$replace = F3(
	function (before, after, string) {
		return A2(
			$elm$core$String$join,
			after,
			A2($elm$core$String$split, before, string));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$replaceWhitespace = function (lines) {
	return A2(
		$elm$core$String$split,
		'\n',
		A2(
			$elm$core$String$join,
			$jfmengels$elm_review$Ansi$cyan('\n'),
			A2(
				$elm$core$List$map,
				A2(
					$elm$core$String$replace,
					' ',
					$jfmengels$elm_review$Ansi$cyan('')),
				lines)));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$highlightDifferencesInSourceCodes = F2(
	function (a, b) {
		var _v0 = A2($jfmengels$elm_review$Review$Test$FailureMessage$highlightWhiteSpaceDifferences, a, b);
		var resA = _v0.a;
		var resB = _v0.b;
		return _Utils_Tuple2(
			A2(
				$jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCodeWithFormatter,
				$jfmengels$elm_review$Review$Test$FailureMessage$replaceWhitespace,
				$elm$core$String$lines(resA)),
			A2(
				$jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCodeWithFormatter,
				$jfmengels$elm_review$Review$Test$FailureMessage$replaceWhitespace,
				$elm$core$String$lines(resB)));
	});
var $jfmengels$elm_review$Ansi$yellow = $jfmengels$elm_review$Ansi$applyColor('33');
var $jfmengels$elm_review$Review$Test$FailureMessage$fixedCodeWhitespaceMismatch = F3(
	function (resultingSourceCode, expectedSourceCode, error) {
		var _v0 = A2($jfmengels$elm_review$Review$Test$FailureMessage$highlightDifferencesInSourceCodes, resultingSourceCode, expectedSourceCode);
		var expected = _v0.a;
		var resulting = _v0.b;
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'FIXED CODE MISMATCH (WHITESPACE ISSUE)',
			'I found a different fixed source code than expected for the error with the\nfollowing message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nThe problem is related to ' + (A2($elm$core$Basics$composeR, $jfmengels$elm_review$Ansi$bold, $jfmengels$elm_review$Ansi$yellow)('WHITESPACE!') + ('\nI expected the following result after the fixes have been applied:\n\n  ' + (expected + ('\n\nbut I found:\n\n  ' + resulting)))))));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$hasCollisionsInFixRanges = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'FOUND COLLISIONS IN FIX RANGES',
		'I got something unexpected when applying the fixes provided by the error\nwith the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			$jfmengels$elm_review$Review$Rule$errorMessage(error)) + '\n\nI found that some fixes were targeting (partially or completely) the same\nsection of code. The problem with that is that I can\'t determine which fix\nto apply first, and the result will be different and potentially invalid\nbased on the order in which I apply these fixes.\n\nFor this reason, I require that the ranges (for replacing and removing) and\nthe positions (for inserting) of every fix to be mutually exclusive.\n\nHint: Maybe you duplicated a fix, or you targeted the wrong node for one\nof your fixes.'));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$invalidSourceAfterFix = F2(
	function (error, resultingSourceCode) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'INVALID SOURCE AFTER FIX',
			'I got something unexpected when applying the fixes provided by the error\nwith the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nI was unable to parse the source code after applying the fixes. Here is\nthe result of the automatic fixing:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(resultingSourceCode) + '\n\nThis is problematic because fixes are meant to help the user, and applying\nthis fix will give them more work to do. After the fix has been applied,\nthe problem should be solved and the user should not have to think about it\nanymore. If a fix can not be applied fully, it should not be applied at\nall.'))));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$missingFixes = function (expectedError) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'MISSING FIXES',
		'I expected that the error with the following message\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(expectedError.message) + '\n\nwould provide some fixes, but I didn\'t find any.\n\nHint: Maybe you forgot to call a function like `Rule.errorWithFix` or maybe\nthe list of provided fixes was empty.'));
};
var $jfmengels$elm_review$Review$Test$removeWhitespace = A2(
	$elm$core$Basics$composeR,
	A2($elm$core$String$replace, ' ', ''),
	A2($elm$core$String$replace, '\n', ''));
var $jfmengels$elm_review$Review$Test$FailureMessage$ruleNotMarkedAsFixableError = A2($jfmengels$elm_review$Review$Test$FailureMessage$failureMessage, 'RULE WAS NOT MARKED AS FIXABLE', 'I expected that the rule would use either\n`Rule.providesFixesForModuleRule` or `Rule.providesFixesForProjectRule` to\nindicate that it may provide fixes. This is valuable for improving the\nperformance of running `elm-review` in fix mode.');
var $jfmengels$elm_review$Review$Test$FailureMessage$unchangedSourceAfterFix = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'UNCHANGED SOURCE AFTER FIX',
		'I got something unexpected when applying the fixes provided by the error\nwith the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			$jfmengels$elm_review$Review$Rule$errorMessage(error)) + '\n\nI expected the fix to make some changes to the source code, but it resulted\nin the same source code as before the fixes.\n\nThis is problematic because I will tell the user that this rule provides an\nautomatic fix, but I will have to disappoint them when I later find out it\ndoesn\'t do anything.\n\nHint: Maybe you inserted an empty string into the source code.'));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$unexpectedFixes = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'UNEXPECTED FIXES',
		'I expected that the error with the following message\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			$jfmengels$elm_review$Review$Rule$errorMessage(error)) + '\n\nwould not have any fixes, but it provided some.\n\nBecause the error provides fixes, I require providing the expected result\nof the automatic fix. Otherwise, there is no way to know whether the fix\nwill result in a correct and in the intended result.\n\nTo fix this, you can call `Review.Test.whenFixed` on your error:\n\n  Review.Test.error\n      { message = "<message>"\n      , details = "<details>"\n      , under = "<under>"\n      }\n      |> Review.Test.whenFixed "<source code>\"'));
};
var $jfmengels$elm_review$Review$Test$checkFixesAreCorrect = F4(
	function (_v0, codeInspector, error_, expectedError) {
		var ruleCanProvideFixes = _v0.a;
		var err = error_.a;
		var expectedError_ = expectedError.a;
		var _v1 = _Utils_Tuple2(expectedError_.fixedSource, err.fixes);
		if (_v1.a.$ === 'Nothing') {
			if (_v1.b.$ === 'Nothing') {
				var _v2 = _v1.a;
				var _v3 = _v1.b;
				return $elm_explorations$test$Expect$pass;
			} else {
				var _v5 = _v1.a;
				return $elm_explorations$test$Expect$fail(
					$jfmengels$elm_review$Review$Test$FailureMessage$unexpectedFixes(error_));
			}
		} else {
			if (_v1.b.$ === 'Nothing') {
				var _v4 = _v1.b;
				return $elm_explorations$test$Expect$fail(
					$jfmengels$elm_review$Review$Test$FailureMessage$missingFixes(
						$jfmengels$elm_review$Review$Test$extractExpectedErrorData(expectedError)));
			} else {
				var expectedFixedSource = _v1.a.a;
				var fixes = _v1.b.a;
				var _v6 = A3($jfmengels$elm_review$Review$Fix$fix, err.target, fixes, codeInspector.source);
				if (_v6.$ === 'Successful') {
					var fixedSource = _v6.a;
					return _Utils_eq(fixedSource, expectedFixedSource) ? (ruleCanProvideFixes ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Expect$fail($jfmengels$elm_review$Review$Test$FailureMessage$ruleNotMarkedAsFixableError)) : (_Utils_eq(
						$jfmengels$elm_review$Review$Test$removeWhitespace(fixedSource),
						$jfmengels$elm_review$Review$Test$removeWhitespace(expectedFixedSource)) ? $elm_explorations$test$Expect$fail(
						A3($jfmengels$elm_review$Review$Test$FailureMessage$fixedCodeWhitespaceMismatch, fixedSource, expectedFixedSource, error_)) : $elm_explorations$test$Expect$fail(
						A3($jfmengels$elm_review$Review$Test$FailureMessage$fixedCodeMismatch, fixedSource, expectedFixedSource, error_)));
				} else {
					switch (_v6.a.$) {
						case 'Unchanged':
							var _v7 = _v6.a;
							return $elm_explorations$test$Expect$fail(
								$jfmengels$elm_review$Review$Test$FailureMessage$unchangedSourceAfterFix(error_));
						case 'SourceCodeIsNotValid':
							var sourceCode = _v6.a.a;
							return $elm_explorations$test$Expect$fail(
								A2($jfmengels$elm_review$Review$Test$FailureMessage$invalidSourceAfterFix, error_, sourceCode));
						default:
							var _v8 = _v6.a;
							return $elm_explorations$test$Expect$fail(
								$jfmengels$elm_review$Review$Test$FailureMessage$hasCollisionsInFixRanges(error_));
					}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Error$UserGlobal = {$: 'UserGlobal'};
var $jfmengels$elm_review$Review$Rule$errorRange = function (_v0) {
	var err = _v0.a;
	return err.range;
};
var $jfmengels$elm_review$Review$Rule$errorTarget = function (_v0) {
	var err = _v0.a;
	return err.target;
};
var $jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString = function (_v0) {
	var start = _v0.start;
	var end = _v0.end;
	return '{ start = { row = ' + ($elm$core$String$fromInt(start.row) + (', column = ' + ($elm$core$String$fromInt(start.column) + (' }, end = { row = ' + ($elm$core$String$fromInt(end.row) + (', column = ' + ($elm$core$String$fromInt(end.column) + ' } }')))))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$locationNotFound = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'COULD NOT FIND LOCATION FOR ERROR',
		'I was looking for the error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nand I found it, but the code it points to does not lead to anything:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString(
			$jfmengels$elm_review$Review$Rule$errorRange(error)) + '\n\nPlease try to have the error under the smallest region that makes sense.\nThis will be the most helpful for the person who reads the error message.'))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$underMayNotBeEmpty = function (_v0) {
	var message = _v0.message;
	var codeAtLocation = _v0.codeAtLocation;
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'COULD NOT FIND LOCATION FOR ERROR',
		'I was looking for the error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(message) + ('\n\nand I found it, but the expected error has an empty string for `under`. I\nneed to point somewhere, so as to best help the people who encounter this\nerror.\n\nIf this helps, this is where I found the error:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(codeAtLocation))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$underMismatch = F2(
	function (error, _v0) {
		var under = _v0.under;
		var codeAtLocation = _v0.codeAtLocation;
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED ERROR LOCATION',
			'I found an error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nand I was expecting it to be under:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(under) + ('\n\nbut I found it under:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(codeAtLocation) + '\n\nHint: Maybe you\'re passing the `Range` of a wrong node when\ncalling `Rule.error`.'))))));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$wrongLocation = F3(
	function (error, range, under) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED ERROR LOCATION',
			'I was looking for the error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nunder the following code:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(under) + ('\n\nand I found it, but the exact location you specified is not the one I found.\n\nI was expecting the error at:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString(range) + ('\n\nbut I found it at:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString(
				$jfmengels$elm_review$Review$Rule$errorRange(error)))))))));
	});
var $jfmengels$elm_review$Review$Test$checkMessageAppearsUnder = F3(
	function (codeInspector, error_, _v0) {
		var expectedError = _v0.a;
		if (_Utils_eq(
			$jfmengels$elm_review$Review$Rule$errorTarget(error_),
			$jfmengels$elm_review$Review$Error$UserGlobal)) {
			return function (_v1) {
				return $elm_explorations$test$Expect$pass;
			};
		} else {
			var _v2 = codeInspector.getCodeAtLocation(
				$jfmengels$elm_review$Review$Rule$errorRange(error_));
			if (_v2.$ === 'Just') {
				var codeAtLocation = _v2.a;
				var _v3 = expectedError.under;
				if (_v3.$ === 'Under') {
					var under = _v3.a;
					return $elm_explorations$test$Expect$all(
						_List_fromArray(
							[
								function (_v4) {
								if (under === '') {
									return $elm_explorations$test$Expect$fail(
										$jfmengels$elm_review$Review$Test$FailureMessage$underMayNotBeEmpty(
											{codeAtLocation: codeAtLocation, message: expectedError.message}));
								} else {
									return $elm_explorations$test$Expect$pass;
								}
							},
								function (_v6) {
								return A2(
									$elm_explorations$test$Expect$onFail,
									A2(
										$jfmengels$elm_review$Review$Test$FailureMessage$underMismatch,
										error_,
										{codeAtLocation: codeAtLocation, under: under}),
									A2($elm_explorations$test$Expect$equal, under, codeAtLocation));
							},
								function (_v7) {
								return A2(codeInspector.checkIfLocationIsAmbiguous, error_, under);
							}
							]));
				} else {
					var under = _v3.a;
					var range = _v3.b;
					return $elm_explorations$test$Expect$all(
						_List_fromArray(
							[
								function (_v8) {
								return A2(
									$elm_explorations$test$Expect$onFail,
									A2(
										$jfmengels$elm_review$Review$Test$FailureMessage$underMismatch,
										error_,
										{codeAtLocation: codeAtLocation, under: under}),
									A2($elm_explorations$test$Expect$equal, under, codeAtLocation));
							},
								function (_v9) {
								return A2(
									$elm_explorations$test$Expect$onFail,
									A3($jfmengels$elm_review$Review$Test$FailureMessage$wrongLocation, error_, range, under),
									A2(
										$elm_explorations$test$Expect$equal,
										range,
										$jfmengels$elm_review$Review$Rule$errorRange(error_)));
							}
							]));
				}
			} else {
				return function (_v10) {
					return $elm_explorations$test$Expect$fail(
						$jfmengels$elm_review$Review$Test$FailureMessage$locationNotFound(error_));
				};
			}
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$messageMismatch = F2(
	function (expectedError, error) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED ERROR MESSAGE',
			'I was looking for the error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(expectedError.message) + ('\n\nbut I found the following error message:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)))));
	});
var $jfmengels$elm_review$Review$Test$checkErrorMatch = F4(
	function (ruleCanProvideFixes, codeInspector, expectedError, error_) {
		var expectedError_ = expectedError.a;
		return $elm_explorations$test$Expect$all(
			_List_fromArray(
				[
					function (_v0) {
					return A2(
						$elm_explorations$test$Expect$onFail,
						A2(
							$jfmengels$elm_review$Review$Test$FailureMessage$messageMismatch,
							$jfmengels$elm_review$Review$Test$extractExpectedErrorData(expectedError),
							error_),
						A2(
							$elm_explorations$test$Expect$equal,
							expectedError_.message,
							$jfmengels$elm_review$Review$Rule$errorMessage(error_)));
				},
					A3($jfmengels$elm_review$Review$Test$checkMessageAppearsUnder, codeInspector, error_, expectedError),
					A2($jfmengels$elm_review$Review$Test$checkDetailsAreCorrect, error_, expectedError),
					function (_v1) {
					return A4($jfmengels$elm_review$Review$Test$checkFixesAreCorrect, ruleCanProvideFixes, codeInspector, error_, expectedError);
				}
				]));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$expectedErrorToString = function (expectedError) {
	return '  - ' + $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(expectedError.message);
};
var $jfmengels$elm_review$Review$Test$FailureMessage$expectedMoreErrors = F3(
	function (moduleName, expectedNumberOfErrors, missingExpectedErrors) {
		var numberOfErrors = $elm$core$List$length(missingExpectedErrors);
		return _Utils_ap(
			A2(
				$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
				'RULE REPORTED LESS ERRORS THAN EXPECTED',
				'I expected to see ' + ($elm$core$String$fromInt(expectedNumberOfErrors) + (' errors for module `' + (moduleName + ('` but only found ' + ($elm$core$String$fromInt(expectedNumberOfErrors - numberOfErrors) + ('.\nHere are the ' + ($elm$core$String$fromInt(numberOfErrors) + ' I could not find:\n\n')))))))),
			A2(
				$elm$core$String$join,
				'\n',
				A2($elm$core$List$map, $jfmengels$elm_review$Review$Test$FailureMessage$expectedErrorToString, missingExpectedErrors)));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$errorMessageAndPosition = function (error) {
	return '  - ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
		$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n    at ' + $jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString(
		$jfmengels$elm_review$Review$Rule$errorRange(error))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessagesAndPositions = function (errors) {
	return A2(
		$elm$core$String$join,
		'\n',
		A2($elm$core$List$map, $jfmengels$elm_review$Review$Test$FailureMessage$errorMessageAndPosition, errors));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$pluralizeErrors = function (n) {
	return (n === 1) ? 'error' : 'errors';
};
var $jfmengels$elm_review$Review$Test$FailureMessage$tooManyErrors = F2(
	function (moduleName, extraErrors) {
		var numberOfErrors = $elm$core$List$length(extraErrors);
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'RULE REPORTED MORE ERRORS THAN EXPECTED',
			'I found ' + (($elm$core$String$fromInt(numberOfErrors) + (' ' + ($jfmengels$elm_review$Review$Test$FailureMessage$pluralizeErrors(numberOfErrors) + (' too many for module `' + (moduleName + '`:\n\n'))))) + $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessagesAndPositions(extraErrors)));
	});
var $jfmengels$elm_review$Review$Test$checkErrorsMatch = F5(
	function (ruleCanProvideFixes, runResult, expectedErrors, expectedNumberOfErrors, errors) {
		var _v0 = _Utils_Tuple2(expectedErrors, errors);
		if (_v0.a.b) {
			if (_v0.b.b) {
				var _v1 = _v0.a;
				var expected = _v1.a;
				var restOfExpectedErrors = _v1.b;
				var _v2 = _v0.b;
				var error_ = _v2.a;
				var restOfErrors = _v2.b;
				return A2(
					$elm$core$List$cons,
					A4($jfmengels$elm_review$Review$Test$checkErrorMatch, ruleCanProvideFixes, runResult.inspector, expected, error_),
					A5($jfmengels$elm_review$Review$Test$checkErrorsMatch, ruleCanProvideFixes, runResult, restOfExpectedErrors, expectedNumberOfErrors, restOfErrors));
			} else {
				var _v3 = _v0.a;
				var expected = _v3.a;
				var restOfExpectedErrors = _v3.b;
				return _List_fromArray(
					[
						function (_v4) {
						return $elm_explorations$test$Expect$fail(
							A3(
								$jfmengels$elm_review$Review$Test$FailureMessage$expectedMoreErrors,
								runResult.moduleName,
								expectedNumberOfErrors,
								A2(
									$elm$core$List$map,
									$jfmengels$elm_review$Review$Test$extractExpectedErrorData,
									A2($elm$core$List$cons, expected, restOfExpectedErrors))));
					}
					]);
			}
		} else {
			if (!_v0.b.b) {
				return _List_fromArray(
					[
						$elm$core$Basics$always($elm_explorations$test$Expect$pass)
					]);
			} else {
				var _v5 = _v0.b;
				var error_ = _v5.a;
				var restOfErrors = _v5.b;
				return _List_fromArray(
					[
						function (_v6) {
						return $elm_explorations$test$Expect$fail(
							A2(
								$jfmengels$elm_review$Review$Test$FailureMessage$tooManyErrors,
								runResult.moduleName,
								A2($elm$core$List$cons, error_, restOfErrors)));
					}
					]);
			}
		}
	});
var $jfmengels$elm_review$Review$Test$matchingConfidenceLevel = F3(
	function (codeInspector, expectedErrorDetails, reviewError) {
		if (!_Utils_eq(
			expectedErrorDetails.message,
			$jfmengels$elm_review$Review$Rule$errorMessage(reviewError))) {
			return 0;
		} else {
			var _v0 = expectedErrorDetails.under;
			if (_v0.$ === 'Under') {
				var under = _v0.a;
				return (!_Utils_eq(
					codeInspector.getCodeAtLocation(
						$jfmengels$elm_review$Review$Rule$errorRange(reviewError)),
					$elm$core$Maybe$Just(under))) ? 1 : 2;
			} else {
				var under = _v0.a;
				var range = _v0.b;
				return (!_Utils_eq(
					codeInspector.getCodeAtLocation(
						$jfmengels$elm_review$Review$Rule$errorRange(reviewError)),
					$elm$core$Maybe$Just(under))) ? 1 : ((!_Utils_eq(
					range,
					$jfmengels$elm_review$Review$Rule$errorRange(reviewError))) ? 2 : 3);
			}
		}
	});
var $jfmengels$elm_review$Review$Test$findBestMatchingReviewError = F4(
	function (codeInspector, expectedErrorDetails, reviewErrors, bestMatch) {
		findBestMatchingReviewError:
		while (true) {
			if (!reviewErrors.b) {
				return bestMatch.error;
			} else {
				var reviewError = reviewErrors.a;
				var restOfReviewErrors = reviewErrors.b;
				var confidenceLevel = A3($jfmengels$elm_review$Review$Test$matchingConfidenceLevel, codeInspector, expectedErrorDetails, reviewError);
				if (_Utils_cmp(confidenceLevel, bestMatch.confidenceLevel) > 0) {
					var $temp$codeInspector = codeInspector,
						$temp$expectedErrorDetails = expectedErrorDetails,
						$temp$reviewErrors = restOfReviewErrors,
						$temp$bestMatch = {
						confidenceLevel: confidenceLevel,
						error: $elm$core$Maybe$Just(reviewError)
					};
					codeInspector = $temp$codeInspector;
					expectedErrorDetails = $temp$expectedErrorDetails;
					reviewErrors = $temp$reviewErrors;
					bestMatch = $temp$bestMatch;
					continue findBestMatchingReviewError;
				} else {
					var $temp$codeInspector = codeInspector,
						$temp$expectedErrorDetails = expectedErrorDetails,
						$temp$reviewErrors = restOfReviewErrors,
						$temp$bestMatch = bestMatch;
					codeInspector = $temp$codeInspector;
					expectedErrorDetails = $temp$expectedErrorDetails;
					reviewErrors = $temp$reviewErrors;
					bestMatch = $temp$bestMatch;
					continue findBestMatchingReviewError;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$removeFirstOccurrence = F2(
	function (elementToRemove, list) {
		if (!list.b) {
			return _List_Nil;
		} else {
			var x = list.a;
			var xs = list.b;
			return _Utils_eq(x, elementToRemove) ? xs : A2(
				$elm$core$List$cons,
				x,
				A2($jfmengels$elm_review$Review$Test$removeFirstOccurrence, elementToRemove, xs));
		}
	});
var $jfmengels$elm_review$Review$Test$reorderErrors = F2(
	function (codeInspector, reorderState) {
		reorderErrors:
		while (true) {
			var _v0 = reorderState.expectedErrors;
			if (!_v0.b) {
				return _Utils_Tuple2(
					$elm$core$List$reverse(
						_Utils_ap(
							reorderState.expectedErrorsWithNoMatch,
							A2($elm$core$List$map, $elm$core$Tuple$first, reorderState.pairs))),
					$elm$core$List$reverse(
						_Utils_ap(
							reorderState.reviewErrors,
							A2($elm$core$List$map, $elm$core$Tuple$second, reorderState.pairs))));
			} else {
				var expectedError = _v0.a;
				var expectedErrorDetails = expectedError.a;
				var restOfExpectedErrors = _v0.b;
				var _v1 = A4(
					$jfmengels$elm_review$Review$Test$findBestMatchingReviewError,
					codeInspector,
					expectedErrorDetails,
					reorderState.reviewErrors,
					{confidenceLevel: 0, error: $elm$core$Maybe$Nothing});
				if (_v1.$ === 'Just') {
					var reviewError = _v1.a;
					var $temp$codeInspector = codeInspector,
						$temp$reorderState = _Utils_update(
						reorderState,
						{
							expectedErrors: restOfExpectedErrors,
							pairs: A2(
								$elm$core$List$cons,
								_Utils_Tuple2(expectedError, reviewError),
								reorderState.pairs),
							reviewErrors: A2($jfmengels$elm_review$Review$Test$removeFirstOccurrence, reviewError, reorderState.reviewErrors)
						});
					codeInspector = $temp$codeInspector;
					reorderState = $temp$reorderState;
					continue reorderErrors;
				} else {
					var $temp$codeInspector = codeInspector,
						$temp$reorderState = _Utils_update(
						reorderState,
						{
							expectedErrors: restOfExpectedErrors,
							expectedErrorsWithNoMatch: A2($elm$core$List$cons, expectedError, reorderState.expectedErrorsWithNoMatch)
						});
					codeInspector = $temp$codeInspector;
					reorderState = $temp$reorderState;
					continue reorderErrors;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$checkAllErrorsMatch = F3(
	function (ruleCanProvideFixes, runResult, unorderedExpectedErrors) {
		var _v0 = A2(
			$jfmengels$elm_review$Review$Test$reorderErrors,
			runResult.inspector,
			{expectedErrors: unorderedExpectedErrors, expectedErrorsWithNoMatch: _List_Nil, pairs: _List_Nil, reviewErrors: runResult.errors});
		var expectedErrors = _v0.a;
		var reviewErrors = _v0.b;
		return A2(
			$elm_explorations$test$Expect$all,
			$elm$core$List$reverse(
				A5(
					$jfmengels$elm_review$Review$Test$checkErrorsMatch,
					ruleCanProvideFixes,
					runResult,
					expectedErrors,
					$elm$core$List$length(expectedErrors),
					reviewErrors)),
			_Utils_Tuple0);
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$expectedMoreGlobalErrors = F2(
	function (expectedNumberOfErrors, missingExpectedErrors) {
		var numberOfErrors = $elm$core$List$length(missingExpectedErrors);
		return _Utils_ap(
			A2(
				$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
				'RULE REPORTED LESS GLOBAL ERRORS THAN EXPECTED',
				'I expected to see ' + ($elm$core$String$fromInt(expectedNumberOfErrors) + (' global errors but only found ' + ($elm$core$String$fromInt(expectedNumberOfErrors - numberOfErrors) + ('.\nHere are the ' + ($elm$core$String$fromInt(numberOfErrors) + ' I could not find:\n\n')))))),
			A2(
				$elm$core$String$join,
				'\n',
				A2($elm$core$List$map, $jfmengels$elm_review$Review$Test$FailureMessage$expectedErrorToString, missingExpectedErrors)));
	});
var $jfmengels$elm_review$Vendor$ListExtra$find = F2(
	function (predicate, list) {
		find:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var first = list.a;
				var rest = list.b;
				if (predicate(first)) {
					return $elm$core$Maybe$Just(first);
				} else {
					var $temp$predicate = predicate,
						$temp$list = rest;
					predicate = $temp$predicate;
					list = $temp$list;
					continue find;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$messageMismatchForGlobalError = F2(
	function (expectedError, error) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED GLOBAL ERROR MESSAGE',
			'I was looking for the global error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(expectedError.message) + ('\n\nbut I found the following error message:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(error.message))));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$unexpectedGlobalErrorDetails = F2(
	function (expectedDetails, error) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'UNEXPECTED GLOBAL ERROR DETAILS',
			'I found a global error with the following message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(error.message) + ('\n\nand I was expecting its details to be:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(expectedDetails) + ('\n\nbut I found these details:\n\n  ' + $jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(error.details))))));
	});
var $jfmengels$elm_review$Review$Test$failBecauseExpectedErrorCouldNotBeFound = F2(
	function (expectedError, _v0) {
		var firstActual = _v0.a;
		var restOfActual = _v0.b;
		var _v1 = A2(
			$jfmengels$elm_review$Vendor$ListExtra$find,
			function (e) {
				return _Utils_eq(e.message, expectedError.message);
			},
			A2($elm$core$List$cons, firstActual, restOfActual));
		if (_v1.$ === 'Just') {
			var actualErrorWithTheSameMessage = _v1.a;
			return $elm_explorations$test$Expect$fail(
				A2($jfmengels$elm_review$Review$Test$FailureMessage$unexpectedGlobalErrorDetails, expectedError.details, actualErrorWithTheSameMessage));
		} else {
			return $elm_explorations$test$Expect$fail(
				A2($jfmengels$elm_review$Review$Test$FailureMessage$messageMismatchForGlobalError, expectedError, firstActual));
		}
	});
var $jfmengels$elm_review$Review$Test$findAndRemoveHelp = F3(
	function (element, previous, list) {
		findAndRemoveHelp:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var head = list.a;
				var rest = list.b;
				if (_Utils_eq(element, head)) {
					return $elm$core$Maybe$Just(
						_Utils_ap(
							$elm$core$List$reverse(previous),
							rest));
				} else {
					var $temp$element = element,
						$temp$previous = A2($elm$core$List$cons, head, previous),
						$temp$list = rest;
					element = $temp$element;
					previous = $temp$previous;
					list = $temp$list;
					continue findAndRemoveHelp;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$findAndRemove = F2(
	function (element, list) {
		return A3($jfmengels$elm_review$Review$Test$findAndRemoveHelp, element, _List_Nil, list);
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessages = function (errors) {
	return A2(
		$elm$core$String$join,
		'\n',
		A2(
			$elm$core$List$map,
			function (error) {
				return '  - ' + $jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(error.message);
			},
			errors));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$tooManyGlobalErrors = function (extraErrors) {
	var numberOfErrors = $elm$core$List$length(extraErrors);
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'RULE REPORTED MORE GLOBAL ERRORS THAN EXPECTED',
		'I found ' + (($elm$core$String$fromInt(numberOfErrors) + (' global ' + ($jfmengels$elm_review$Review$Test$FailureMessage$pluralizeErrors(numberOfErrors) + ' too many:\n\n'))) + $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessages(extraErrors)));
};
var $jfmengels$elm_review$Review$Test$checkGlobalErrorsMatch = F2(
	function (originalNumberOfExpectedErrors, params) {
		checkGlobalErrorsMatch:
		while (true) {
			var _v0 = params.expected;
			if (_v0.b) {
				var head = _v0.a;
				var rest = _v0.b;
				var _v1 = A2($jfmengels$elm_review$Review$Test$findAndRemove, head, params.actual);
				if (_v1.$ === 'Just') {
					var newActual = _v1.a;
					if ($elm$core$List$isEmpty(head.details)) {
						return $elm_explorations$test$Expect$fail(
							$jfmengels$elm_review$Review$Test$FailureMessage$emptyDetails(head.message));
					} else {
						var $temp$originalNumberOfExpectedErrors = originalNumberOfExpectedErrors,
							$temp$params = {actual: newActual, expected: rest, needSecondPass: params.needSecondPass};
						originalNumberOfExpectedErrors = $temp$originalNumberOfExpectedErrors;
						params = $temp$params;
						continue checkGlobalErrorsMatch;
					}
				} else {
					var $temp$originalNumberOfExpectedErrors = originalNumberOfExpectedErrors,
						$temp$params = {
						actual: params.actual,
						expected: rest,
						needSecondPass: A2($elm$core$List$cons, head, params.needSecondPass)
					};
					originalNumberOfExpectedErrors = $temp$originalNumberOfExpectedErrors;
					params = $temp$params;
					continue checkGlobalErrorsMatch;
				}
			} else {
				var _v2 = params.actual;
				if (_v2.b) {
					var firstActual = _v2.a;
					var restOfActual = _v2.b;
					var _v3 = $elm$core$List$head(
						$elm$core$List$reverse(params.needSecondPass));
					if (_v3.$ === 'Just') {
						var notFoundError = _v3.a;
						return A2(
							$jfmengels$elm_review$Review$Test$failBecauseExpectedErrorCouldNotBeFound,
							notFoundError,
							_Utils_Tuple2(firstActual, restOfActual));
					} else {
						return $elm_explorations$test$Expect$fail(
							$jfmengels$elm_review$Review$Test$FailureMessage$tooManyGlobalErrors(params.actual));
					}
				} else {
					return $elm$core$List$isEmpty(params.needSecondPass) ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Expect$fail(
						A2($jfmengels$elm_review$Review$Test$FailureMessage$expectedMoreGlobalErrors, originalNumberOfExpectedErrors, params.needSecondPass));
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$checkAllGlobalErrorsMatch = F2(
	function (expectedErrorToString, params) {
		return A2(
			$jfmengels$elm_review$Review$Test$checkGlobalErrorsMatch,
			expectedErrorToString,
			{actual: params.actual, expected: params.expected, needSecondPass: _List_Nil});
	});
var $jfmengels$elm_review$Review$Test$allCombinationsHelp = function (list) {
	if (!list.b) {
		return _List_Nil;
	} else {
		var first = list.a;
		var rest = list.b;
		var addFirst = F2(
			function (subList, acc) {
				return A2(
					$elm$core$List$cons,
					subList,
					A2(
						$elm$core$List$cons,
						A2($elm$core$List$cons, first, subList),
						acc));
			});
		return A2(
			$elm$core$List$cons,
			_List_fromArray(
				[first]),
			A3(
				$elm$core$List$foldr,
				addFirst,
				_List_Nil,
				$jfmengels$elm_review$Review$Test$allCombinationsHelp(rest)));
	}
};
var $jfmengels$elm_review$Review$Test$allCombinations = function (list) {
	if (!list.b) {
		return _List_Nil;
	} else {
		if (!list.b.b) {
			return _List_Nil;
		} else {
			return $jfmengels$elm_review$Review$Test$allCombinationsHelp(list);
		}
	}
};
var $jfmengels$elm_review$Review$Options$Internal$Disabled = {$: 'Disabled'};
var $jfmengels$elm_review$Review$Options$Internal$ReviewOptionsInternal = function (a) {
	return {$: 'ReviewOptionsInternal', a: a};
};
var $jfmengels$elm_review$Review$Logger$Logger = function (a) {
	return {$: 'Logger', a: a};
};
var $jfmengels$elm_review$Review$Logger$none = $jfmengels$elm_review$Review$Logger$Logger($elm$core$Basics$identity);
var $jfmengels$elm_review$Review$Options$defaults = $jfmengels$elm_review$Review$Options$Internal$ReviewOptionsInternal(
	{
		extract: false,
		fixMode: $jfmengels$elm_review$Review$Options$Internal$Disabled,
		ignoreFix: $elm$core$Basics$always(false),
		logger: $jfmengels$elm_review$Review$Logger$none,
		suppressions: $elm$core$Dict$empty
	});
var $jfmengels$elm_review$Review$Rule$Rule = function (a) {
	return {$: 'Rule', a: a};
};
var $jfmengels$elm_review$Review$Exceptions$Exceptions = function (a) {
	return {$: 'Exceptions', a: a};
};
var $jfmengels$elm_review$Review$Exceptions$addFilter = F2(
	function (condition, _v0) {
		var conditions = _v0.a;
		return $jfmengels$elm_review$Review$Exceptions$Exceptions(
			A2($elm$core$List$cons, condition, conditions));
	});
var $jfmengels$elm_review$Path$makeOSAgnostic = function (path) {
	return A3($elm$core$String$replace, '\\', '/', path);
};
var $jfmengels$elm_review$Review$Exceptions$addFiles = function (files) {
	var cleanedFiles = $elm$core$Set$fromList(
		A2($elm$core$List$map, $jfmengels$elm_review$Path$makeOSAgnostic, files));
	return $jfmengels$elm_review$Review$Exceptions$addFilter(
		function (file) {
			return !A2($elm$core$Set$member, file, cleanedFiles);
		});
};
var $jfmengels$elm_review$Review$Rule$ignoreErrorsForFiles = F2(
	function (files, _v0) {
		var rule = _v0.a;
		return $jfmengels$elm_review$Review$Rule$Rule(
			{
				configurationError: rule.configurationError,
				exceptions: A2($jfmengels$elm_review$Review$Exceptions$addFiles, files, rule.exceptions),
				extractsData: rule.extractsData,
				id: rule.id,
				name: rule.name,
				providesFixes: rule.providesFixes,
				requestedData: rule.requestedData,
				ruleImplementation: rule.ruleImplementation
			});
	});
var $jfmengels$elm_review$Review$Rule$errorFilePath = function (_v0) {
	var err = _v0.a;
	return err.filePath;
};
var $jfmengels$elm_review$Review$Test$removeErrorsForIgnoredFiles = F2(
	function (filesToIgnore, errors) {
		return A2(
			$elm$core$List$filter,
			function (err) {
				return !A2(
					$elm$core$List$member,
					$jfmengels$elm_review$Review$Rule$errorFilePath(err),
					filesToIgnore);
			},
			errors);
	});
var $jfmengels$elm_review$Review$Test$removeFirst = F3(
	function (a, list, prev) {
		removeFirst:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var x = list.a;
				var xs = list.b;
				if (_Utils_eq(x, a)) {
					return $elm$core$Maybe$Just(
						_Utils_ap(prev, xs));
				} else {
					var $temp$a = a,
						$temp$list = xs,
						$temp$prev = A2($elm$core$List$cons, x, prev);
					a = $temp$a;
					list = $temp$list;
					prev = $temp$prev;
					continue removeFirst;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$removeInCommon = F3(
	function (expected, excessFromActual, actual) {
		removeInCommon:
		while (true) {
			if (!actual.b) {
				return _Utils_Tuple2(expected, excessFromActual);
			} else {
				var first = actual.a;
				var restOfActual = actual.b;
				var _v1 = A3($jfmengels$elm_review$Review$Test$removeFirst, first, expected, _List_Nil);
				if (_v1.$ === 'Just') {
					var newExpected = _v1.a;
					var $temp$expected = newExpected,
						$temp$excessFromActual = excessFromActual,
						$temp$actual = restOfActual;
					expected = $temp$expected;
					excessFromActual = $temp$excessFromActual;
					actual = $temp$actual;
					continue removeInCommon;
				} else {
					var $temp$expected = expected,
						$temp$excessFromActual = A2($elm$core$List$cons, first, excessFromActual),
						$temp$actual = restOfActual;
					expected = $temp$expected;
					excessFromActual = $temp$excessFromActual;
					actual = $temp$actual;
					continue removeInCommon;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$wrapInDoubleQuotes = function (string) {
	return '\"' + (string + '\"');
};
var $jfmengels$elm_review$Review$Test$FailureMessage$formatDetailsForDescription = function (error) {
	return '[' + (A2(
		$elm$core$String$join,
		', ',
		A2(
			$elm$core$List$map,
			$jfmengels$elm_review$Review$Test$FailureMessage$wrapInDoubleQuotes,
			$jfmengels$elm_review$Review$Rule$errorDetails(error))) + ']');
};
var $jfmengels$elm_review$Review$Rule$errorFixes = function (_v0) {
	var err = _v0.a;
	return err.fixes;
};
var $jfmengels$elm_review$Review$Test$FailureMessage$hasFixes = function (error) {
	var _v0 = $jfmengels$elm_review$Review$Rule$errorFixes(error);
	if (_v0.$ === 'Nothing') {
		return 'false';
	} else {
		if (!_v0.a.b) {
			return 'false';
		} else {
			return 'true';
		}
	}
};
var $jfmengels$elm_review$Review$Test$FailureMessage$rangeAsStringOnMultipleLines = function (_v0) {
	var start = _v0.start;
	var end = _v0.end;
	return '{ start = { row = ' + ($elm$core$String$fromInt(start.row) + (', column = ' + ($elm$core$String$fromInt(start.column) + (' }\n              , end = { row = ' + ($elm$core$String$fromInt(end.row) + (', column = ' + ($elm$core$String$fromInt(end.column) + ' }\n              }')))))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$describeError = function (error) {
	return '\n    { message = ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInDoubleQuotes(
		$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n    , filePath = ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInDoubleQuotes(
		$jfmengels$elm_review$Review$Rule$errorFilePath(error)) + ('\n    , details = ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatDetailsForDescription(error) + ('\n    , range = ' + ($jfmengels$elm_review$Review$Test$FailureMessage$rangeAsStringOnMultipleLines(
		$jfmengels$elm_review$Review$Rule$errorRange(error)) + ('\n    , fixes = ' + ($jfmengels$elm_review$Review$Test$FailureMessage$hasFixes(error) + '\n    }')))))))));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$summarizeErrors = function (errors) {
	return '\n' + A2(
		$elm$core$String$join,
		'\n\n',
		A2($elm$core$List$map, $jfmengels$elm_review$Review$Test$FailureMessage$describeError, errors));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$resultsAreDifferentWhenFilesAreIgnored = function (_v0) {
	var ignoredFiles = _v0.ignoredFiles;
	var missing = _v0.missing;
	var unexpected = _v0.unexpected;
	var files = A2(
		$elm$core$String$join,
		'\n',
		A2(
			$elm$core$List$map,
			function (file) {
				return '  - ' + file;
			},
			ignoredFiles));
	var difference = A2(
		$elm$core$String$join,
		'\n\nand ',
		A2(
			$elm$core$List$filterMap,
			$elm$core$Basics$identity,
			_List_fromArray(
				[
					$elm$core$List$isEmpty(missing) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
					'the following errors could not be found anymore:' + $jfmengels$elm_review$Review$Test$FailureMessage$summarizeErrors(missing)),
					$elm$core$List$isEmpty(unexpected) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
					'the following errors start appearing:' + $jfmengels$elm_review$Review$Test$FailureMessage$summarizeErrors(unexpected))
				])));
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'GOT DIFFERENT RESULTS WHEN IGNORING FILES',
		'This rule is using `Review.Rule.withIsFileIgnored`, which gives it the\ninformation of which files are ignored.\n\nWithout further information, I assume that this information is used solely\nto improve performance of the rule, not to change the behavior in any way.\nIf this is not the case for your rule, then please indicate so in your test\nusing the `Review.Test.ignoredFilesImpactResults` function.\n\nWith that in mind, I tried re-running the test while ignoring some files\nand I got different results than before.\n\nWhen I ignore these files:\n' + (files + ('\n\nthen ' + $elm$core$String$trim(difference))));
};
var $elm$core$Result$andThen = F2(
	function (callback, result) {
		if (result.$ === 'Ok') {
			var value = result.a;
			return callback(value);
		} else {
			var msg = result.a;
			return $elm$core$Result$Err(msg);
		}
	});
var $jfmengels$elm_review$Review$Error$Global = {$: 'Global'};
var $jfmengels$elm_review$Review$Error$ReviewError = function (a) {
	return {$: 'ReviewError', a: a};
};
var $jfmengels$elm_review$Review$Rule$getConfigurationError = function (_v0) {
	var rule = _v0.a;
	return rule.configurationError;
};
var $jfmengels$elm_review$Review$Rule$ruleName = function (_v0) {
	var rule = _v0.a;
	return rule.name;
};
var $jfmengels$elm_review$Review$Rule$checkForConfigurationErrors = function (rules) {
	var errors = A2(
		$elm$core$List$filterMap,
		function (rule) {
			return A2(
				$elm$core$Maybe$map,
				function (_v0) {
					var message = _v0.message;
					var details = _v0.details;
					return $jfmengels$elm_review$Review$Error$ReviewError(
						{
							details: details,
							filePath: 'CONFIGURATION ERROR',
							fixes: $elm$core$Maybe$Nothing,
							message: message,
							preventsExtract: false,
							range: $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							ruleName: $jfmengels$elm_review$Review$Rule$ruleName(rule),
							target: $jfmengels$elm_review$Review$Error$Global
						});
				},
				$jfmengels$elm_review$Review$Rule$getConfigurationError(rule));
		},
		rules);
	return $elm$core$List$isEmpty(errors) ? $elm$core$Result$Ok(_Utils_Tuple0) : $elm$core$Result$Err(errors);
};
var $jfmengels$elm_review$Review$Rule$Error = function (a) {
	return {$: 'Error', a: a};
};
var $jfmengels$elm_review$Review$Rule$elmReviewGlobalError = function (_v0) {
	var message = _v0.message;
	var details = _v0.details;
	return $jfmengels$elm_review$Review$Rule$Error(
		{details: details, filePath: 'GLOBAL ERROR', fixes: $elm$core$Maybe$Nothing, message: message, preventsExtract: false, range: $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, ruleName: '', target: $jfmengels$elm_review$Review$Error$Global});
};
var $jfmengels$elm_review$Review$Rule$errorToReviewError = function (_v0) {
	var err = _v0.a;
	return $jfmengels$elm_review$Review$Error$ReviewError(err);
};
var $elm$core$List$sort = function (xs) {
	return A2($elm$core$List$sortBy, $elm$core$Basics$identity, xs);
};
var $jfmengels$elm_review$Review$Rule$duplicateModulesGlobalError = function (duplicate) {
	var paths = $elm$core$String$concat(
		A2(
			$elm$core$List$map,
			function (s) {
				return '\n  - ' + s;
			},
			$elm$core$List$sort(duplicate.paths)));
	return $jfmengels$elm_review$Review$Rule$errorToReviewError(
		$jfmengels$elm_review$Review$Rule$elmReviewGlobalError(
			{
				details: _List_fromArray(
					[
						'I found several modules with the name `' + (A2($elm$core$String$join, '.', duplicate.moduleName) + '`. Depending on how I choose to resolve this, I might give you different reports. Since this is a compiler error anyway, I require this problem to be solved. Please fix this then try running `elm-review` again.'),
						'Here are the paths to some of the files that share a module name:' + paths,
						'It is possible that you requested me to look at several projects, and that modules from each project share the same name. I don\'t recommend reviewing several projects at the same time, as I can only handle one `elm.json`. I instead suggest running `elm-review` twice, once for each project.'
					]),
				message: 'Found several modules named `' + (A2($elm$core$String$join, '.', duplicate.moduleName) + '`')
			}));
};
var $jfmengels$elm_review$Review$ImportCycle$wrapInCycle = function (string) {
	return '    \n        ' + (string + '\n    ');
};
var $jfmengels$elm_review$Review$ImportCycle$printCycle = function (moduleNames) {
	return $jfmengels$elm_review$Review$ImportCycle$wrapInCycle(
		A2(
			$elm$core$String$join,
			'\n         \n        ',
			A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$String$join('.'),
					$jfmengels$elm_review$Ansi$yellow),
				moduleNames)));
};
var $jfmengels$elm_review$Review$ImportCycle$error = function (cycle) {
	return {
		details: _List_fromArray(
			[
				$jfmengels$elm_review$Review$ImportCycle$printCycle(cycle),
				'Learn more about why this is disallowed and how to break cycles here:<https://elm-lang.org/0.19.1/import-cycles>'
			]),
		message: 'Your module imports form a cycle'
	};
};
var $jfmengels$elm_review$Review$Rule$mapInternalError = F2(
	function (fn, _v0) {
		var err = _v0.a;
		return $jfmengels$elm_review$Review$Rule$Error(
			fn(err));
	});
var $jfmengels$elm_review$Review$Rule$setRuleName = F2(
	function (ruleName_, error_) {
		return A2(
			$jfmengels$elm_review$Review$Rule$mapInternalError,
			function (err) {
				return _Utils_update(
					err,
					{ruleName: ruleName_});
			},
			error_);
	});
var $jfmengels$elm_review$Review$Rule$importCycleError = function (cycle) {
	return $jfmengels$elm_review$Review$Rule$errorToReviewError(
		A2(
			$jfmengels$elm_review$Review$Rule$setRuleName,
			'Incorrect project',
			$jfmengels$elm_review$Review$Rule$elmReviewGlobalError(
				$jfmengels$elm_review$Review$ImportCycle$error(cycle))));
};
var $jfmengels$elm_review$Review$Project$InvalidProjectError$DuplicateModuleNames = function (a) {
	return {$: 'DuplicateModuleNames', a: a};
};
var $jfmengels$elm_review$Review$Project$InvalidProjectError$ImportCycleError = function (a) {
	return {$: 'ImportCycleError', a: a};
};
var $jfmengels$elm_review$Review$Project$InvalidProjectError$NoModulesError = {$: 'NoModulesError'};
var $jfmengels$elm_review$Review$Project$InvalidProjectError$SomeModulesFailedToParse = function (a) {
	return {$: 'SomeModulesFailedToParse', a: a};
};
var $elm$core$Dict$foldl = F3(
	function (func, acc, dict) {
		foldl:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldl, func, acc, left)),
					$temp$dict = right;
				func = $temp$func;
				acc = $temp$acc;
				dict = $temp$dict;
				continue foldl;
			}
		}
	});
var $jfmengels$elm_review$Vendor$Graph$Graph = function (a) {
	return {$: 'Graph', a: a};
};
var $jfmengels$elm_review$Vendor$Graph$NodeContext = F3(
	function (node, incoming, outgoing) {
		return {incoming: incoming, node: node, outgoing: outgoing};
	});
var $jfmengels$elm_review$Vendor$IntDict$Empty = {$: 'Empty'};
var $jfmengels$elm_review$Vendor$IntDict$empty = $jfmengels$elm_review$Vendor$IntDict$Empty;
var $jfmengels$elm_review$Vendor$IntDict$Inner = function (a) {
	return {$: 'Inner', a: a};
};
var $jfmengels$elm_review$Vendor$IntDict$size = function (dict) {
	switch (dict.$) {
		case 'Empty':
			return 0;
		case 'Leaf':
			return 1;
		default:
			var i = dict.a;
			return i.size;
	}
};
var $jfmengels$elm_review$Vendor$IntDict$inner = F3(
	function (p, l, r) {
		var _v0 = _Utils_Tuple2(l, r);
		if (_v0.a.$ === 'Empty') {
			var _v1 = _v0.a;
			return r;
		} else {
			if (_v0.b.$ === 'Empty') {
				var _v2 = _v0.b;
				return l;
			} else {
				return $jfmengels$elm_review$Vendor$IntDict$Inner(
					{
						left: l,
						prefix: p,
						right: r,
						size: $jfmengels$elm_review$Vendor$IntDict$size(l) + $jfmengels$elm_review$Vendor$IntDict$size(r)
					});
			}
		}
	});
var $elm$core$Bitwise$complement = _Bitwise_complement;
var $elm$core$Bitwise$or = _Bitwise_or;
var $jfmengels$elm_review$Vendor$IntDict$highestBitSet = function (n) {
	var shiftOr = F2(
		function (i, shift) {
			return i | (i >>> shift);
		});
	var n1 = A2(shiftOr, n, 1);
	var n2 = A2(shiftOr, n1, 2);
	var n3 = A2(shiftOr, n2, 4);
	var n4 = A2(shiftOr, n3, 8);
	var n5 = A2(shiftOr, n4, 16);
	return n5 & (~(n5 >>> 1));
};
var $jfmengels$elm_review$Vendor$IntDict$signBit = $jfmengels$elm_review$Vendor$IntDict$highestBitSet(-1);
var $elm$core$Bitwise$xor = _Bitwise_xor;
var $jfmengels$elm_review$Vendor$IntDict$isBranchingBitSet = function (p) {
	return A2(
		$elm$core$Basics$composeR,
		$elm$core$Bitwise$xor($jfmengels$elm_review$Vendor$IntDict$signBit),
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Bitwise$and(p.branchingBit),
			$elm$core$Basics$neq(0)));
};
var $jfmengels$elm_review$Vendor$IntDict$higherBitMask = function (branchingBit) {
	return branchingBit ^ (~(branchingBit - 1));
};
var $jfmengels$elm_review$Vendor$IntDict$lcp = F2(
	function (x, y) {
		var branchingBit = $jfmengels$elm_review$Vendor$IntDict$highestBitSet(x ^ y);
		var mask = $jfmengels$elm_review$Vendor$IntDict$higherBitMask(branchingBit);
		var prefixBits = x & mask;
		return {branchingBit: branchingBit, prefixBits: prefixBits};
	});
var $jfmengels$elm_review$Vendor$IntDict$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $jfmengels$elm_review$Vendor$IntDict$leaf = F2(
	function (k, v) {
		return $jfmengels$elm_review$Vendor$IntDict$Leaf(
			{key: k, value: v});
	});
var $jfmengels$elm_review$Vendor$IntDict$prefixMatches = F2(
	function (p, n) {
		return _Utils_eq(
			n & $jfmengels$elm_review$Vendor$IntDict$higherBitMask(p.branchingBit),
			p.prefixBits);
	});
var $jfmengels$elm_review$Vendor$IntDict$update = F3(
	function (key, alter, dict) {
		var join = F2(
			function (_v2, _v3) {
				var k1 = _v2.a;
				var l = _v2.b;
				var k2 = _v3.a;
				var r = _v3.b;
				var prefix = A2($jfmengels$elm_review$Vendor$IntDict$lcp, k1, k2);
				return A2($jfmengels$elm_review$Vendor$IntDict$isBranchingBitSet, prefix, k2) ? A3($jfmengels$elm_review$Vendor$IntDict$inner, prefix, l, r) : A3($jfmengels$elm_review$Vendor$IntDict$inner, prefix, r, l);
			});
		var alteredNode = function (mv) {
			var _v1 = alter(mv);
			if (_v1.$ === 'Just') {
				var v = _v1.a;
				return A2($jfmengels$elm_review$Vendor$IntDict$leaf, key, v);
			} else {
				return $jfmengels$elm_review$Vendor$IntDict$empty;
			}
		};
		switch (dict.$) {
			case 'Empty':
				return alteredNode($elm$core$Maybe$Nothing);
			case 'Leaf':
				var l = dict.a;
				return _Utils_eq(l.key, key) ? alteredNode(
					$elm$core$Maybe$Just(l.value)) : A2(
					join,
					_Utils_Tuple2(
						key,
						alteredNode($elm$core$Maybe$Nothing)),
					_Utils_Tuple2(l.key, dict));
			default:
				var i = dict.a;
				return A2($jfmengels$elm_review$Vendor$IntDict$prefixMatches, i.prefix, key) ? (A2($jfmengels$elm_review$Vendor$IntDict$isBranchingBitSet, i.prefix, key) ? A3(
					$jfmengels$elm_review$Vendor$IntDict$inner,
					i.prefix,
					i.left,
					A3($jfmengels$elm_review$Vendor$IntDict$update, key, alter, i.right)) : A3(
					$jfmengels$elm_review$Vendor$IntDict$inner,
					i.prefix,
					A3($jfmengels$elm_review$Vendor$IntDict$update, key, alter, i.left),
					i.right)) : A2(
					join,
					_Utils_Tuple2(
						key,
						alteredNode($elm$core$Maybe$Nothing)),
					_Utils_Tuple2(i.prefix.prefixBits, dict));
		}
	});
var $jfmengels$elm_review$Vendor$IntDict$insert = F3(
	function (key, value, dict) {
		return A3(
			$jfmengels$elm_review$Vendor$IntDict$update,
			key,
			$elm$core$Basics$always(
				$elm$core$Maybe$Just(value)),
			dict);
	});
var $jfmengels$elm_review$Vendor$IntDict$get = F2(
	function (key, dict) {
		get:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return $elm$core$Maybe$Nothing;
				case 'Leaf':
					var l = dict.a;
					return _Utils_eq(l.key, key) ? $elm$core$Maybe$Just(l.value) : $elm$core$Maybe$Nothing;
				default:
					var i = dict.a;
					if (!A2($jfmengels$elm_review$Vendor$IntDict$prefixMatches, i.prefix, key)) {
						return $elm$core$Maybe$Nothing;
					} else {
						if (A2($jfmengels$elm_review$Vendor$IntDict$isBranchingBitSet, i.prefix, key)) {
							var $temp$key = key,
								$temp$dict = i.right;
							key = $temp$key;
							dict = $temp$dict;
							continue get;
						} else {
							var $temp$key = key,
								$temp$dict = i.left;
							key = $temp$key;
							dict = $temp$dict;
							continue get;
						}
					}
			}
		}
	});
var $jfmengels$elm_review$Vendor$IntDict$member = F2(
	function (key, dict) {
		var _v0 = A2($jfmengels$elm_review$Vendor$IntDict$get, key, dict);
		if (_v0.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var $jfmengels$elm_review$Vendor$Graph$fromNodesAndEdges = F2(
	function (nodes_, edges_) {
		var nodeRep = A3(
			$elm$core$List$foldl,
			function (n) {
				return A2(
					$jfmengels$elm_review$Vendor$IntDict$insert,
					n.id,
					A3($jfmengels$elm_review$Vendor$Graph$NodeContext, n, $jfmengels$elm_review$Vendor$IntDict$empty, $jfmengels$elm_review$Vendor$IntDict$empty));
			},
			$jfmengels$elm_review$Vendor$IntDict$empty,
			nodes_);
		var addEdge = F2(
			function (edge, rep) {
				var updateOutgoing = function (ctx) {
					return _Utils_update(
						ctx,
						{
							outgoing: A3($jfmengels$elm_review$Vendor$IntDict$insert, edge.to, edge.label, ctx.outgoing)
						});
				};
				var updateIncoming = function (ctx) {
					return _Utils_update(
						ctx,
						{
							incoming: A3($jfmengels$elm_review$Vendor$IntDict$insert, edge.from, edge.label, ctx.incoming)
						});
				};
				return A3(
					$jfmengels$elm_review$Vendor$IntDict$update,
					edge.to,
					$elm$core$Maybe$map(updateIncoming),
					A3(
						$jfmengels$elm_review$Vendor$IntDict$update,
						edge.from,
						$elm$core$Maybe$map(updateOutgoing),
						rep));
			});
		var addEdgeIfValid = F2(
			function (edge, rep) {
				return (A2($jfmengels$elm_review$Vendor$IntDict$member, edge.from, rep) && A2($jfmengels$elm_review$Vendor$IntDict$member, edge.to, rep)) ? A2(addEdge, edge, rep) : rep;
			});
		return $jfmengels$elm_review$Vendor$Graph$Graph(
			A3($elm$core$List$foldl, addEdgeIfValid, nodeRep, edges_));
	});
var $stil4m$elm_syntax$Elm$Syntax$Module$moduleName = function (m) {
	switch (m.$) {
		case 'NormalModule':
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.moduleName);
		case 'PortModule':
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.moduleName);
		default:
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.moduleName);
	}
};
var $jfmengels$elm_review$Review$Project$Valid$getModuleName = function (module_) {
	return $stil4m$elm_syntax$Elm$Syntax$Module$moduleName(
		$stil4m$elm_syntax$Elm$Syntax$Node$value(module_.ast.moduleDefinition));
};
var $jfmengels$elm_review$Vendor$Graph$Edge = F3(
	function (from, to, label) {
		return {from: from, label: label, to: to};
	});
var $jfmengels$elm_review$Vendor$Graph$Node = F2(
	function (id, label) {
		return {id: id, label: label};
	});
var $jfmengels$elm_review$Review$Project$Valid$importedModules = function (module_) {
	return A2(
		$elm$core$List$map,
		A2(
			$elm$core$Basics$composeR,
			$stil4m$elm_syntax$Elm$Syntax$Node$value,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.moduleName;
				},
				$stil4m$elm_syntax$Elm$Syntax$Node$value)),
		module_.ast.imports);
};
var $jfmengels$elm_review$Review$Project$Valid$nodesAndEdges = F3(
	function (getModuleId, module_, moduleId) {
		return _Utils_Tuple2(
			A2($jfmengels$elm_review$Vendor$Graph$Node, moduleId, module_.path),
			A2(
				$elm$core$List$map,
				function (importedModuleId) {
					return A3($jfmengels$elm_review$Vendor$Graph$Edge, importedModuleId, moduleId, _Utils_Tuple0);
				},
				A2(
					$elm$core$List$filterMap,
					getModuleId,
					$jfmengels$elm_review$Review$Project$Valid$importedModules(module_))));
	});
var $jfmengels$elm_review$Review$Project$Valid$buildModuleGraph = function (mods) {
	var moduleIds = A3(
		$elm$core$Dict$foldl,
		F3(
			function (_v5, module_, _v6) {
				var index = _v6.a;
				var dict = _v6.b;
				return _Utils_Tuple2(
					index + 1,
					A3(
						$elm$core$Dict$insert,
						$jfmengels$elm_review$Review$Project$Valid$getModuleName(module_),
						index,
						dict));
			}),
		_Utils_Tuple2(0, $elm$core$Dict$empty),
		mods).b;
	var getModuleId = function (moduleName) {
		getModuleId:
		while (true) {
			var _v0 = A2($elm$core$Dict$get, moduleName, moduleIds);
			if (_v0.$ === 'Just') {
				var moduleId = _v0.a;
				return moduleId;
			} else {
				var $temp$moduleName = moduleName;
				moduleName = $temp$moduleName;
				continue getModuleId;
			}
		}
	};
	var _v1 = A3(
		$elm$core$Dict$foldl,
		F3(
			function (_v2, module_, _v3) {
				var resNodes = _v3.a;
				var resEdges = _v3.b;
				var _v4 = A3(
					$jfmengels$elm_review$Review$Project$Valid$nodesAndEdges,
					function (moduleName) {
						return A2($elm$core$Dict$get, moduleName, moduleIds);
					},
					module_,
					getModuleId(
						$jfmengels$elm_review$Review$Project$Valid$getModuleName(module_)));
				var moduleNode = _v4.a;
				var modulesEdges = _v4.b;
				return _Utils_Tuple2(
					A2($elm$core$List$cons, moduleNode, resNodes),
					_Utils_ap(modulesEdges, resEdges));
			}),
		_Utils_Tuple2(_List_Nil, _List_Nil),
		mods);
	var nodes = _v1.a;
	var edges = _v1.b;
	return A2($jfmengels$elm_review$Vendor$Graph$fromNodesAndEdges, nodes, edges);
};
var $jfmengels$elm_review$Vendor$Graph$AcyclicGraph = F2(
	function (a, b) {
		return {$: 'AcyclicGraph', a: a, b: b};
	});
var $jfmengels$elm_review$Vendor$IntDict$findMin = function (dict) {
	findMin:
	while (true) {
		switch (dict.$) {
			case 'Empty':
				return $elm$core$Maybe$Nothing;
			case 'Leaf':
				var l = dict.a;
				return $elm$core$Maybe$Just(
					_Utils_Tuple2(l.key, l.value));
			default:
				var i = dict.a;
				var $temp$dict = i.left;
				dict = $temp$dict;
				continue findMin;
		}
	}
};
var $jfmengels$elm_review$Vendor$IntDict$Disjunct = F2(
	function (a, b) {
		return {$: 'Disjunct', a: a, b: b};
	});
var $jfmengels$elm_review$Vendor$IntDict$Left = {$: 'Left'};
var $jfmengels$elm_review$Vendor$IntDict$Parent = F2(
	function (a, b) {
		return {$: 'Parent', a: a, b: b};
	});
var $jfmengels$elm_review$Vendor$IntDict$Right = {$: 'Right'};
var $jfmengels$elm_review$Vendor$IntDict$SamePrefix = {$: 'SamePrefix'};
var $jfmengels$elm_review$Vendor$IntDict$combineBits = F3(
	function (a, b, mask) {
		return (a & (~mask)) | (b & mask);
	});
var $jfmengels$elm_review$Vendor$IntDict$mostSignificantBranchingBit = F2(
	function (a, b) {
		return (_Utils_eq(a, $jfmengels$elm_review$Vendor$IntDict$signBit) || _Utils_eq(b, $jfmengels$elm_review$Vendor$IntDict$signBit)) ? $jfmengels$elm_review$Vendor$IntDict$signBit : A2($elm$core$Basics$max, a, b);
	});
var $jfmengels$elm_review$Vendor$IntDict$determineBranchRelation = F2(
	function (l, r) {
		var rp = r.prefix;
		var lp = l.prefix;
		var mask = $jfmengels$elm_review$Vendor$IntDict$highestBitSet(
			A2($jfmengels$elm_review$Vendor$IntDict$mostSignificantBranchingBit, lp.branchingBit, rp.branchingBit));
		var modifiedRightPrefix = A3($jfmengels$elm_review$Vendor$IntDict$combineBits, rp.prefixBits, ~lp.prefixBits, mask);
		var prefix = A2($jfmengels$elm_review$Vendor$IntDict$lcp, lp.prefixBits, modifiedRightPrefix);
		var childEdge = F2(
			function (branchPrefix, c) {
				return A2($jfmengels$elm_review$Vendor$IntDict$isBranchingBitSet, branchPrefix, c.prefix.prefixBits) ? $jfmengels$elm_review$Vendor$IntDict$Right : $jfmengels$elm_review$Vendor$IntDict$Left;
			});
		return _Utils_eq(lp, rp) ? $jfmengels$elm_review$Vendor$IntDict$SamePrefix : (_Utils_eq(prefix, lp) ? A2(
			$jfmengels$elm_review$Vendor$IntDict$Parent,
			$jfmengels$elm_review$Vendor$IntDict$Left,
			A2(childEdge, l.prefix, r)) : (_Utils_eq(prefix, rp) ? A2(
			$jfmengels$elm_review$Vendor$IntDict$Parent,
			$jfmengels$elm_review$Vendor$IntDict$Right,
			A2(childEdge, r.prefix, l)) : A2(
			$jfmengels$elm_review$Vendor$IntDict$Disjunct,
			prefix,
			A2(childEdge, prefix, l))));
	});
var $jfmengels$elm_review$Vendor$IntDict$intersect = F2(
	function (l, r) {
		intersect:
		while (true) {
			var _v0 = _Utils_Tuple2(l, r);
			_v0$1:
			while (true) {
				_v0$2:
				while (true) {
					switch (_v0.a.$) {
						case 'Empty':
							var _v1 = _v0.a;
							return $jfmengels$elm_review$Vendor$IntDict$Empty;
						case 'Leaf':
							switch (_v0.b.$) {
								case 'Empty':
									break _v0$1;
								case 'Leaf':
									break _v0$2;
								default:
									break _v0$2;
							}
						default:
							switch (_v0.b.$) {
								case 'Empty':
									break _v0$1;
								case 'Leaf':
									var lr = _v0.b.a;
									var _v3 = A2($jfmengels$elm_review$Vendor$IntDict$get, lr.key, l);
									if (_v3.$ === 'Just') {
										var v = _v3.a;
										return A2($jfmengels$elm_review$Vendor$IntDict$leaf, lr.key, v);
									} else {
										return $jfmengels$elm_review$Vendor$IntDict$Empty;
									}
								default:
									var il = _v0.a.a;
									var ir = _v0.b.a;
									var _v4 = A2($jfmengels$elm_review$Vendor$IntDict$determineBranchRelation, il, ir);
									switch (_v4.$) {
										case 'SamePrefix':
											return A3(
												$jfmengels$elm_review$Vendor$IntDict$inner,
												il.prefix,
												A2($jfmengels$elm_review$Vendor$IntDict$intersect, il.left, ir.left),
												A2($jfmengels$elm_review$Vendor$IntDict$intersect, il.right, ir.right));
										case 'Parent':
											if (_v4.a.$ === 'Left') {
												if (_v4.b.$ === 'Right') {
													var _v5 = _v4.a;
													var _v6 = _v4.b;
													var $temp$l = il.right,
														$temp$r = r;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												} else {
													var _v9 = _v4.a;
													var _v10 = _v4.b;
													var $temp$l = il.left,
														$temp$r = r;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												}
											} else {
												if (_v4.b.$ === 'Right') {
													var _v7 = _v4.a;
													var _v8 = _v4.b;
													var $temp$l = l,
														$temp$r = ir.right;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												} else {
													var _v11 = _v4.a;
													var _v12 = _v4.b;
													var $temp$l = l,
														$temp$r = ir.left;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												}
											}
										default:
											return $jfmengels$elm_review$Vendor$IntDict$Empty;
									}
							}
					}
				}
				var ll = _v0.a.a;
				return A2($jfmengels$elm_review$Vendor$IntDict$member, ll.key, r) ? l : $jfmengels$elm_review$Vendor$IntDict$Empty;
			}
			var _v2 = _v0.b;
			return $jfmengels$elm_review$Vendor$IntDict$Empty;
		}
	});
var $jfmengels$elm_review$Vendor$Graph$crashHack = function (msg) {
	crashHack:
	while (true) {
		var $temp$msg = msg;
		msg = $temp$msg;
		continue crashHack;
	}
};
var $jfmengels$elm_review$Vendor$Graph$unGraph = function (graph) {
	var rep = graph.a;
	return rep;
};
var $jfmengels$elm_review$Vendor$Graph$get = function (nodeId) {
	return A2(
		$elm$core$Basics$composeR,
		$jfmengels$elm_review$Vendor$Graph$unGraph,
		$jfmengels$elm_review$Vendor$IntDict$get(nodeId));
};
var $jfmengels$elm_review$Vendor$Graph$unsafeGet = F3(
	function (msg, id, graph) {
		var _v0 = A2($jfmengels$elm_review$Vendor$Graph$get, id, graph);
		if (_v0.$ === 'Nothing') {
			return $jfmengels$elm_review$Vendor$Graph$crashHack(msg);
		} else {
			var ctx = _v0.a;
			return ctx;
		}
	});
var $jfmengels$elm_review$Vendor$Graph$checkForBackEdges = F2(
	function (ordering, graph) {
		var success = function (_v3) {
			return A2($jfmengels$elm_review$Vendor$Graph$AcyclicGraph, graph, ordering);
		};
		var check = F2(
			function (id, _v2) {
				var backSet = _v2.a;
				var error = 'Graph.checkForBackEdges: `ordering` didn\'t contain `id`';
				var ctx = A3($jfmengels$elm_review$Vendor$Graph$unsafeGet, error, id, graph);
				var backSetWithId = A3($jfmengels$elm_review$Vendor$IntDict$insert, id, _Utils_Tuple0, backSet);
				var backEdges = A2($jfmengels$elm_review$Vendor$IntDict$intersect, ctx.outgoing, backSetWithId);
				var _v0 = $jfmengels$elm_review$Vendor$IntDict$findMin(backEdges);
				if (_v0.$ === 'Nothing') {
					return $elm$core$Result$Ok(
						_Utils_Tuple2(backSetWithId, _Utils_Tuple0));
				} else {
					var _v1 = _v0.a;
					var to = _v1.a;
					var label = _v1.b;
					return $elm$core$Result$Err(
						A3($jfmengels$elm_review$Vendor$Graph$Edge, id, to, label));
				}
			});
		return A2(
			$elm$core$Result$map,
			success,
			A3(
				$elm$core$List$foldl,
				F2(
					function (id, res) {
						return A2(
							$elm$core$Result$andThen,
							check(id),
							res);
					}),
				$elm$core$Result$Ok(
					_Utils_Tuple2($jfmengels$elm_review$Vendor$IntDict$empty, _Utils_Tuple0)),
				ordering));
	});
var $jfmengels$elm_review$Vendor$IntDict$foldr = F3(
	function (f, acc, dict) {
		foldr:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return acc;
				case 'Leaf':
					var l = dict.a;
					return A3(f, l.key, l.value, acc);
				default:
					var i = dict.a;
					var $temp$f = f,
						$temp$acc = A3($jfmengels$elm_review$Vendor$IntDict$foldr, f, acc, i.right),
						$temp$dict = i.left;
					f = $temp$f;
					acc = $temp$acc;
					dict = $temp$dict;
					continue foldr;
			}
		}
	});
var $jfmengels$elm_review$Vendor$IntDict$keys = function (dict) {
	return A3(
		$jfmengels$elm_review$Vendor$IntDict$foldr,
		F3(
			function (key, value, keyList) {
				return A2($elm$core$List$cons, key, keyList);
			}),
		_List_Nil,
		dict);
};
var $jfmengels$elm_review$Vendor$Graph$alongOutgoingEdges = function (ctx) {
	return $jfmengels$elm_review$Vendor$IntDict$keys(ctx.outgoing);
};
var $jfmengels$elm_review$Vendor$IntDict$foldl = F3(
	function (f, acc, dict) {
		foldl:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return acc;
				case 'Leaf':
					var l = dict.a;
					return A3(f, l.key, l.value, acc);
				default:
					var i = dict.a;
					var $temp$f = f,
						$temp$acc = A3($jfmengels$elm_review$Vendor$IntDict$foldl, f, acc, i.left),
						$temp$dict = i.right;
					f = $temp$f;
					acc = $temp$acc;
					dict = $temp$dict;
					continue foldl;
			}
		}
	});
var $jfmengels$elm_review$Vendor$Graph$applyEdgeDiff = F3(
	function (nodeId, diff, graphRep) {
		var updateOutgoingEdge = F2(
			function (upd, node) {
				return _Utils_update(
					node,
					{
						outgoing: A3($jfmengels$elm_review$Vendor$IntDict$update, nodeId, upd, node.outgoing)
					});
			});
		var updateIncomingEdge = F2(
			function (upd, node) {
				return _Utils_update(
					node,
					{
						incoming: A3($jfmengels$elm_review$Vendor$IntDict$update, nodeId, upd, node.incoming)
					});
			});
		var flippedFoldl = F3(
			function (f, dict, acc) {
				return A3($jfmengels$elm_review$Vendor$IntDict$foldl, f, acc, dict);
			});
		var edgeUpdateToMaybe = function (edgeUpdate) {
			if (edgeUpdate.$ === 'Insert') {
				var lbl = edgeUpdate.a;
				return $elm$core$Maybe$Just(lbl);
			} else {
				return $elm$core$Maybe$Nothing;
			}
		};
		var updateAdjacency = F3(
			function (updateEdge, updatedId, edgeUpdate) {
				var updateLbl = updateEdge(
					$elm$core$Basics$always(
						edgeUpdateToMaybe(edgeUpdate)));
				return A2(
					$jfmengels$elm_review$Vendor$IntDict$update,
					updatedId,
					$elm$core$Maybe$map(updateLbl));
			});
		return A3(
			flippedFoldl,
			updateAdjacency(updateOutgoingEdge),
			diff.outgoing,
			A3(
				flippedFoldl,
				updateAdjacency(updateIncomingEdge),
				diff.incoming,
				graphRep));
	});
var $jfmengels$elm_review$Vendor$Graph$Insert = function (a) {
	return {$: 'Insert', a: a};
};
var $jfmengels$elm_review$Vendor$Graph$Remove = function (a) {
	return {$: 'Remove', a: a};
};
var $jfmengels$elm_review$Vendor$Graph$emptyDiff = {incoming: $jfmengels$elm_review$Vendor$IntDict$empty, outgoing: $jfmengels$elm_review$Vendor$IntDict$empty};
var $jfmengels$elm_review$Vendor$Graph$computeEdgeDiff = F2(
	function (old, _new) {
		var collectUpdates = F3(
			function (edgeUpdate, updatedId, label) {
				var replaceUpdate = function (old_) {
					var _v5 = _Utils_Tuple2(
						old_,
						edgeUpdate(label));
					if (_v5.a.$ === 'Just') {
						if (_v5.a.a.$ === 'Remove') {
							if (_v5.b.$ === 'Insert') {
								var oldLbl = _v5.a.a.a;
								var newLbl = _v5.b.a;
								return _Utils_eq(oldLbl, newLbl) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
									$jfmengels$elm_review$Vendor$Graph$Insert(newLbl));
							} else {
								return $jfmengels$elm_review$Vendor$Graph$crashHack('Graph.computeEdgeDiff: Collected two removals for the same edge. This is an error in the implementation of Graph and you should file a bug report!');
							}
						} else {
							return $jfmengels$elm_review$Vendor$Graph$crashHack('Graph.computeEdgeDiff: Collected inserts before removals. This is an error in the implementation of Graph and you should file a bug report!');
						}
					} else {
						var _v6 = _v5.a;
						var eu = _v5.b;
						return $elm$core$Maybe$Just(eu);
					}
				};
				return A2($jfmengels$elm_review$Vendor$IntDict$update, updatedId, replaceUpdate);
			});
		var collect = F3(
			function (edgeUpdate, adj, updates) {
				return A3(
					$jfmengels$elm_review$Vendor$IntDict$foldl,
					collectUpdates(edgeUpdate),
					updates,
					adj);
			});
		var _v0 = _Utils_Tuple2(old, _new);
		if (_v0.a.$ === 'Nothing') {
			if (_v0.b.$ === 'Nothing') {
				var _v1 = _v0.a;
				var _v2 = _v0.b;
				return $jfmengels$elm_review$Vendor$Graph$emptyDiff;
			} else {
				var _v4 = _v0.a;
				var ins = _v0.b.a;
				return {
					incoming: A3(collect, $jfmengels$elm_review$Vendor$Graph$Insert, ins.outgoing, $jfmengels$elm_review$Vendor$IntDict$empty),
					outgoing: A3(collect, $jfmengels$elm_review$Vendor$Graph$Insert, ins.incoming, $jfmengels$elm_review$Vendor$IntDict$empty)
				};
			}
		} else {
			if (_v0.b.$ === 'Nothing') {
				var rem = _v0.a.a;
				var _v3 = _v0.b;
				return {
					incoming: A3(collect, $jfmengels$elm_review$Vendor$Graph$Remove, rem.outgoing, $jfmengels$elm_review$Vendor$IntDict$empty),
					outgoing: A3(collect, $jfmengels$elm_review$Vendor$Graph$Remove, rem.incoming, $jfmengels$elm_review$Vendor$IntDict$empty)
				};
			} else {
				var rem = _v0.a.a;
				var ins = _v0.b.a;
				return _Utils_eq(rem, ins) ? $jfmengels$elm_review$Vendor$Graph$emptyDiff : {
					incoming: A3(
						collect,
						$jfmengels$elm_review$Vendor$Graph$Insert,
						ins.outgoing,
						A3(collect, $jfmengels$elm_review$Vendor$Graph$Remove, rem.outgoing, $jfmengels$elm_review$Vendor$IntDict$empty)),
					outgoing: A3(
						collect,
						$jfmengels$elm_review$Vendor$Graph$Insert,
						ins.incoming,
						A3(collect, $jfmengels$elm_review$Vendor$Graph$Remove, rem.incoming, $jfmengels$elm_review$Vendor$IntDict$empty))
				};
			}
		}
	});
var $jfmengels$elm_review$Vendor$IntDict$filter = F2(
	function (predicate, dict) {
		var add = F3(
			function (k, v, d) {
				return A2(predicate, k, v) ? A3($jfmengels$elm_review$Vendor$IntDict$insert, k, v, d) : d;
			});
		return A3($jfmengels$elm_review$Vendor$IntDict$foldl, add, $jfmengels$elm_review$Vendor$IntDict$empty, dict);
	});
var $jfmengels$elm_review$Vendor$Graph$update = F2(
	function (nodeId, updater) {
		var wrappedUpdater = function (rep) {
			var old = A2($jfmengels$elm_review$Vendor$IntDict$get, nodeId, rep);
			var filterInvalidEdges = function (ctx) {
				return $jfmengels$elm_review$Vendor$IntDict$filter(
					F2(
						function (id, _v0) {
							return _Utils_eq(id, ctx.node.id) || A2($jfmengels$elm_review$Vendor$IntDict$member, id, rep);
						}));
			};
			var cleanUpEdges = function (ctx) {
				return _Utils_update(
					ctx,
					{
						incoming: A2(filterInvalidEdges, ctx, ctx.incoming),
						outgoing: A2(filterInvalidEdges, ctx, ctx.outgoing)
					});
			};
			var _new = A2(
				$elm$core$Maybe$map,
				cleanUpEdges,
				updater(old));
			var diff = A2($jfmengels$elm_review$Vendor$Graph$computeEdgeDiff, old, _new);
			return A3(
				$jfmengels$elm_review$Vendor$IntDict$update,
				nodeId,
				$elm$core$Basics$always(_new),
				A3($jfmengels$elm_review$Vendor$Graph$applyEdgeDiff, nodeId, diff, rep));
		};
		return A2(
			$elm$core$Basics$composeR,
			$jfmengels$elm_review$Vendor$Graph$unGraph,
			A2($elm$core$Basics$composeR, wrappedUpdater, $jfmengels$elm_review$Vendor$Graph$Graph));
	});
var $jfmengels$elm_review$Vendor$Graph$remove = F2(
	function (nodeId, graph) {
		return A3(
			$jfmengels$elm_review$Vendor$Graph$update,
			nodeId,
			$elm$core$Basics$always($elm$core$Maybe$Nothing),
			graph);
	});
var $jfmengels$elm_review$Vendor$Graph$guidedDfs = F5(
	function (selectNeighbors, visitNode, startingSeeds, startingAcc, startingGraph) {
		var go = F3(
			function (seeds, acc, graph) {
				go:
				while (true) {
					if (!seeds.b) {
						return _Utils_Tuple2(acc, graph);
					} else {
						var next = seeds.a;
						var seeds1 = seeds.b;
						var _v1 = A2($jfmengels$elm_review$Vendor$Graph$get, next, graph);
						if (_v1.$ === 'Nothing') {
							var $temp$seeds = seeds1,
								$temp$acc = acc,
								$temp$graph = graph;
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						} else {
							var ctx = _v1.a;
							var _v2 = A2(visitNode, ctx, acc);
							var accAfterDiscovery = _v2.a;
							var finishNode = _v2.b;
							var _v3 = A3(
								go,
								selectNeighbors(ctx),
								accAfterDiscovery,
								A2($jfmengels$elm_review$Vendor$Graph$remove, next, graph));
							var accBeforeFinish = _v3.a;
							var graph1 = _v3.b;
							var accAfterFinish = finishNode(accBeforeFinish);
							var $temp$seeds = seeds1,
								$temp$acc = accAfterFinish,
								$temp$graph = graph1;
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						}
					}
				}
			});
		return A3(go, startingSeeds, startingAcc, startingGraph);
	});
var $jfmengels$elm_review$Vendor$Graph$nodeIds = A2($elm$core$Basics$composeR, $jfmengels$elm_review$Vendor$Graph$unGraph, $jfmengels$elm_review$Vendor$IntDict$keys);
var $jfmengels$elm_review$Vendor$Graph$dfs = F3(
	function (visitNode, acc, graph) {
		return A5(
			$jfmengels$elm_review$Vendor$Graph$guidedDfs,
			$jfmengels$elm_review$Vendor$Graph$alongOutgoingEdges,
			visitNode,
			$jfmengels$elm_review$Vendor$Graph$nodeIds(graph),
			acc,
			graph).a;
	});
var $jfmengels$elm_review$Vendor$Graph$onFinish = F3(
	function (visitor, ctx, acc) {
		return _Utils_Tuple2(
			acc,
			visitor(ctx));
	});
var $jfmengels$elm_review$Vendor$Graph$checkAcyclic = function (graph) {
	var reversePostOrder = A3(
		$jfmengels$elm_review$Vendor$Graph$dfs,
		$jfmengels$elm_review$Vendor$Graph$onFinish(
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.node;
				},
				A2(
					$elm$core$Basics$composeR,
					function ($) {
						return $.id;
					},
					$elm$core$List$cons))),
		_List_Nil,
		graph);
	return A2($jfmengels$elm_review$Vendor$Graph$checkForBackEdges, reversePostOrder, graph);
};
var $jfmengels$elm_review$Review$Project$Valid$duplicateModuleNames = F2(
	function (visitedModules, projectModules) {
		duplicateModuleNames:
		while (true) {
			if (!projectModules.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var projectModule = projectModules.a;
				var restOfModules = projectModules.b;
				var moduleName = $jfmengels$elm_review$Review$Project$Valid$getModuleName(projectModule);
				var _v1 = A2($elm$core$Dict$get, moduleName, visitedModules);
				if (_v1.$ === 'Nothing') {
					var $temp$visitedModules = A3($elm$core$Dict$insert, moduleName, projectModule.path, visitedModules),
						$temp$projectModules = restOfModules;
					visitedModules = $temp$visitedModules;
					projectModules = $temp$projectModules;
					continue duplicateModuleNames;
				} else {
					var path = _v1.a;
					return $elm$core$Maybe$Just(
						{
							moduleName: moduleName,
							paths: A2(
								$elm$core$List$cons,
								path,
								A2(
									$elm$core$List$cons,
									projectModule.path,
									A2(
										$elm$core$List$map,
										function ($) {
											return $.path;
										},
										A2(
											$elm$core$List$filter,
											function (p) {
												return _Utils_eq(
													$jfmengels$elm_review$Review$Project$Valid$getModuleName(p),
													moduleName);
											},
											restOfModules))))
						});
				}
			}
		}
	});
var $jfmengels$elm_review$Vendor$Graph$alongIncomingEdges = function (ctx) {
	return $jfmengels$elm_review$Vendor$IntDict$keys(ctx.incoming);
};
var $jfmengels$elm_review$Vendor$Fifo$Fifo = F2(
	function (a, b) {
		return {$: 'Fifo', a: a, b: b};
	});
var $jfmengels$elm_review$Vendor$Fifo$empty = A2($jfmengels$elm_review$Vendor$Fifo$Fifo, _List_Nil, _List_Nil);
var $jfmengels$elm_review$Vendor$Fifo$insert = F2(
	function (a, _v0) {
		var front = _v0.a;
		var back = _v0.b;
		return A2(
			$jfmengels$elm_review$Vendor$Fifo$Fifo,
			front,
			A2($elm$core$List$cons, a, back));
	});
var $jfmengels$elm_review$Vendor$Fifo$remove = function (fifo) {
	if (!fifo.a.b) {
		if (!fifo.b.b) {
			return _Utils_Tuple2($elm$core$Maybe$Nothing, $jfmengels$elm_review$Vendor$Fifo$empty);
		} else {
			var back = fifo.b;
			return $jfmengels$elm_review$Vendor$Fifo$remove(
				A2(
					$jfmengels$elm_review$Vendor$Fifo$Fifo,
					$elm$core$List$reverse(back),
					_List_Nil));
		}
	} else {
		var _v1 = fifo.a;
		var next = _v1.a;
		var rest = _v1.b;
		var back = fifo.b;
		return _Utils_Tuple2(
			$elm$core$Maybe$Just(next),
			A2($jfmengels$elm_review$Vendor$Fifo$Fifo, rest, back));
	}
};
var $jfmengels$elm_review$Vendor$Graph$guidedBfs = F5(
	function (selectNeighbors, visitNode, startingSeeds, startingAcc, startingGraph) {
		var enqueueMany = F4(
			function (distance, parentPath, nodeIds_, queue) {
				return A3(
					$elm$core$List$foldl,
					$jfmengels$elm_review$Vendor$Fifo$insert,
					queue,
					A2(
						$elm$core$List$map,
						function (id) {
							return _Utils_Tuple3(id, parentPath, distance);
						},
						nodeIds_));
			});
		var go = F3(
			function (seeds, acc, graph) {
				go:
				while (true) {
					var _v0 = $jfmengels$elm_review$Vendor$Fifo$remove(seeds);
					if (_v0.a.$ === 'Nothing') {
						var _v1 = _v0.a;
						return _Utils_Tuple2(acc, graph);
					} else {
						var _v2 = _v0.a.a;
						var next = _v2.a;
						var parentPath = _v2.b;
						var distance = _v2.c;
						var seeds1 = _v0.b;
						var _v3 = A2($jfmengels$elm_review$Vendor$Graph$get, next, graph);
						if (_v3.$ === 'Nothing') {
							var $temp$seeds = seeds1,
								$temp$acc = acc,
								$temp$graph = graph;
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						} else {
							var ctx = _v3.a;
							var path = A2($elm$core$List$cons, ctx, parentPath);
							var seeds2 = A4(
								enqueueMany,
								distance + 1,
								path,
								selectNeighbors(ctx),
								seeds1);
							var accAfterVisit = A3(visitNode, path, distance, acc);
							var $temp$seeds = seeds2,
								$temp$acc = accAfterVisit,
								$temp$graph = A2($jfmengels$elm_review$Vendor$Graph$remove, next, graph);
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						}
					}
				}
			});
		return A3(
			go,
			A4(enqueueMany, 0, _List_Nil, startingSeeds, $jfmengels$elm_review$Vendor$Fifo$empty),
			startingAcc,
			startingGraph);
	});
var $jfmengels$elm_review$Review$ImportCycle$reachedTarget = F2(
	function (targetNode, path) {
		var _v0 = $elm$core$List$head(path);
		if (_v0.$ === 'Just') {
			var node = _v0.a;
			return _Utils_eq(node.node.id, targetNode);
		} else {
			return false;
		}
	});
var $jfmengels$elm_review$Review$ImportCycle$visitorDiscoverCycle = F4(
	function (targetNode, path, distance, acc) {
		if ($elm$core$List$isEmpty(acc)) {
			if (!distance) {
				var _v0 = $elm$core$List$head(path);
				if (_v0.$ === 'Just') {
					var head = _v0.a;
					return A2($jfmengels$elm_review$Vendor$IntDict$member, head.node.id, head.incoming) ? _List_fromArray(
						[head.node]) : acc;
				} else {
					return acc;
				}
			} else {
				if (A2($jfmengels$elm_review$Review$ImportCycle$reachedTarget, targetNode, path)) {
					return A2(
						$elm$core$List$map,
						function ($) {
							return $.node;
						},
						path);
				} else {
					return _List_Nil;
				}
			}
		} else {
			return acc;
		}
	});
var $jfmengels$elm_review$Review$ImportCycle$findSmallerCycle = F3(
	function (graph, currentBest, nodesToVisit) {
		findSmallerCycle:
		while (true) {
			if (!nodesToVisit.b) {
				return currentBest;
			} else {
				var startingNode = nodesToVisit.a;
				var restOfNodes = nodesToVisit.b;
				var cycle = A5(
					$jfmengels$elm_review$Vendor$Graph$guidedBfs,
					$jfmengels$elm_review$Vendor$Graph$alongIncomingEdges,
					$jfmengels$elm_review$Review$ImportCycle$visitorDiscoverCycle(startingNode.id),
					_List_fromArray(
						[startingNode.id]),
					_List_Nil,
					graph).a;
				var newBest = (($elm$core$List$length(cycle) > 0) && (_Utils_cmp(
					$elm$core$List$length(cycle),
					$elm$core$List$length(currentBest)) < 0)) ? cycle : currentBest;
				if ($elm$core$List$length(newBest) === 1) {
					return newBest;
				} else {
					var $temp$graph = graph,
						$temp$currentBest = newBest,
						$temp$nodesToVisit = restOfNodes;
					graph = $temp$graph;
					currentBest = $temp$currentBest;
					nodesToVisit = $temp$nodesToVisit;
					continue findSmallerCycle;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$ImportCycle$findCycle = F2(
	function (graph, edge) {
		var initialCycle = A5(
			$jfmengels$elm_review$Vendor$Graph$guidedBfs,
			$jfmengels$elm_review$Vendor$Graph$alongIncomingEdges,
			$jfmengels$elm_review$Review$ImportCycle$visitorDiscoverCycle(edge.to),
			_List_fromArray(
				[edge.from]),
			_List_Nil,
			graph).a;
		return A2(
			$elm$core$List$map,
			function ($) {
				return $.label;
			},
			A3($jfmengels$elm_review$Review$ImportCycle$findSmallerCycle, graph, initialCycle, initialCycle));
	});
var $jfmengels$elm_review$Vendor$NonEmpty$fromList = function (xs) {
	if (xs.b) {
		var h = xs.a;
		var t = xs.b;
		return $elm$core$Maybe$Just(
			_Utils_Tuple2(h, t));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $jfmengels$elm_review$Vendor$Zipper$Zipper = F3(
	function (a, b, c) {
		return {$: 'Zipper', a: a, b: b, c: c};
	});
var $jfmengels$elm_review$Vendor$Zipper$fromNonEmpty = function (_v0) {
	var h = _v0.a;
	var t = _v0.b;
	return A3($jfmengels$elm_review$Vendor$Zipper$Zipper, _List_Nil, h, t);
};
var $jfmengels$elm_review$Vendor$Zipper$fromList = A2(
	$elm$core$Basics$composeL,
	$elm$core$Maybe$map($jfmengels$elm_review$Vendor$Zipper$fromNonEmpty),
	$jfmengels$elm_review$Vendor$NonEmpty$fromList);
var $jfmengels$elm_review$Review$Project$Valid$ValidProject = function (a) {
	return {$: 'ValidProject', a: a};
};
var $jfmengels$elm_review$Review$Project$Dependency$modules = function (_v0) {
	var dependency = _v0.a;
	return dependency.modules;
};
var $jfmengels$elm_review$Review$Project$Valid$computeDependencyModules = function (directDependencies_) {
	return A3(
		$elm$core$Dict$foldl,
		F3(
			function (_v0, v, acc) {
				return A3(
					$elm$core$List$foldl,
					F2(
						function (mod, subAcc) {
							return A2(
								$elm$core$Set$insert,
								A2($elm$core$String$split, '.', mod.name),
								subAcc);
						}),
					acc,
					$jfmengels$elm_review$Review$Project$Dependency$modules(v));
			}),
		$elm$core$Set$empty,
		directDependencies_);
};
var $elm$core$Dict$filter = F2(
	function (isGood, dict) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, d) {
					return A2(isGood, k, v) ? A3($elm$core$Dict$insert, k, v, d) : d;
				}),
			$elm$core$Dict$empty,
			dict);
	});
var $elm$project_metadata_utils$Elm$Package$toString = function (_v0) {
	var user = _v0.a;
	var project = _v0.b;
	return user + ('/' + project);
};
var $jfmengels$elm_review$Review$Project$Valid$computeDirectDependencies = function (project) {
	var _v0 = A2(
		$elm$core$Maybe$map,
		function (_v1) {
			var elmJson_ = _v1.a;
			return elmJson_.project;
		},
		project.elmJson);
	if (_v0.$ === 'Just') {
		if (_v0.a.$ === 'Application') {
			var depsDirect = _v0.a.a.depsDirect;
			var testDepsDirect = _v0.a.a.testDepsDirect;
			var allDeps = A2(
				$elm$core$List$map,
				function (_v3) {
					var name = _v3.a;
					return $elm$project_metadata_utils$Elm$Package$toString(name);
				},
				_Utils_ap(depsDirect, testDepsDirect));
			return A2(
				$elm$core$Dict$filter,
				F2(
					function (depName, _v2) {
						return A2($elm$core$List$member, depName, allDeps);
					}),
				project.dependencies);
		} else {
			var deps = _v0.a.a.deps;
			var testDeps = _v0.a.a.testDeps;
			var allDeps = A2(
				$elm$core$List$map,
				function (_v5) {
					var name = _v5.a;
					return $elm$project_metadata_utils$Elm$Package$toString(name);
				},
				_Utils_ap(deps, testDeps));
			return A2(
				$elm$core$Dict$filter,
				F2(
					function (depName, _v4) {
						return A2($elm$core$List$member, depName, allDeps);
					}),
				project.dependencies);
		}
	} else {
		return project.dependencies;
	}
};
var $jfmengels$elm_review$Review$Project$Valid$computeModulesByModuleName = function (modules) {
	return A3(
		$elm$core$Dict$foldl,
		F3(
			function (_v0, module_, acc) {
				return A3(
					$elm$core$Dict$insert,
					$jfmengels$elm_review$Review$Project$Valid$getModuleName(module_),
					module_,
					acc);
			}),
		$elm$core$Dict$empty,
		modules);
};
var $jfmengels$elm_review$Vendor$Graph$topologicalSort = function (_v0) {
	var graph = _v0.a;
	var ordering = _v0.b;
	var error = 'Graph.topologicalSort: Invalid `AcyclicGraph`, where the ordering contained nodes not present in the graph';
	return A2(
		$elm$core$List$map,
		function (id) {
			return A3($jfmengels$elm_review$Vendor$Graph$unsafeGet, error, id, graph);
		},
		ordering);
};
var $jfmengels$elm_review$Review$Project$Valid$fromProjectAndGraph = F3(
	function (moduleGraph_, acyclicGraph, _v0) {
		var project = _v0.a;
		var directDependencies_ = $jfmengels$elm_review$Review$Project$Valid$computeDirectDependencies(project);
		return $jfmengels$elm_review$Review$Project$Valid$ValidProject(
			{
				dependencies: project.dependencies,
				dependencyModules: $jfmengels$elm_review$Review$Project$Valid$computeDependencyModules(directDependencies_),
				directDependencies: directDependencies_,
				elmJson: project.elmJson,
				moduleGraph: moduleGraph_,
				modulesByModuleName: $jfmengels$elm_review$Review$Project$Valid$computeModulesByModuleName(project.modules),
				modulesByPath: project.modules,
				projectCache: project.cache,
				readme: project.readme,
				sortedModules: $jfmengels$elm_review$Vendor$Graph$topologicalSort(acyclicGraph),
				sourceDirectories: project.sourceDirectories
			});
	});
var $elm$core$Dict$values = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, valueList) {
				return A2($elm$core$List$cons, value, valueList);
			}),
		_List_Nil,
		dict);
};
var $jfmengels$elm_review$Review$Project$Valid$parse = function (project) {
	var p = project.a;
	if (!$elm$core$List$isEmpty(p.modulesThatFailedToParse)) {
		return $elm$core$Result$Err(
			$jfmengels$elm_review$Review$Project$InvalidProjectError$SomeModulesFailedToParse(
				A2(
					$elm$core$List$map,
					function ($) {
						return $.path;
					},
					p.modulesThatFailedToParse)));
	} else {
		if ($elm$core$Dict$isEmpty(p.modules)) {
			return $elm$core$Result$Err($jfmengels$elm_review$Review$Project$InvalidProjectError$NoModulesError);
		} else {
			var projectModules = $elm$core$Dict$values(p.modules);
			var _v0 = A2($jfmengels$elm_review$Review$Project$Valid$duplicateModuleNames, $elm$core$Dict$empty, projectModules);
			if (_v0.$ === 'Just') {
				var duplicate = _v0.a;
				return $elm$core$Result$Err(
					$jfmengels$elm_review$Review$Project$InvalidProjectError$DuplicateModuleNames(duplicate));
			} else {
				var graph = $jfmengels$elm_review$Review$Project$Valid$buildModuleGraph(p.modules);
				var _v1 = $jfmengels$elm_review$Vendor$Graph$checkAcyclic(graph);
				if (_v1.$ === 'Err') {
					var edge = _v1.a;
					return $elm$core$Result$Err(
						$jfmengels$elm_review$Review$Project$InvalidProjectError$ImportCycleError(
							A2(
								$elm$core$List$filterMap,
								function (path) {
									return A2(
										$elm$core$Maybe$map,
										$jfmengels$elm_review$Review$Project$Valid$getModuleName,
										A2($elm$core$Dict$get, path, p.modules));
								},
								A2($jfmengels$elm_review$Review$ImportCycle$findCycle, graph, edge))));
				} else {
					var acyclicGraph = _v1.a;
					var _v2 = $jfmengels$elm_review$Vendor$Zipper$fromList(
						$jfmengels$elm_review$Vendor$Graph$topologicalSort(acyclicGraph));
					if (_v2.$ === 'Nothing') {
						return $elm$core$Result$Err($jfmengels$elm_review$Review$Project$InvalidProjectError$NoModulesError);
					} else {
						var zipper = _v2.a;
						return $elm$core$Result$Ok(
							_Utils_Tuple2(
								A3($jfmengels$elm_review$Review$Project$Valid$fromProjectAndGraph, graph, acyclicGraph, project),
								zipper));
					}
				}
			}
		}
	}
};
var $jfmengels$elm_review$Review$Error$Module = {$: 'Module'};
var $jfmengels$elm_review$Review$Rule$parsingError = function (path) {
	return $jfmengels$elm_review$Review$Error$ReviewError(
		{
			details: _List_fromArray(
				['I could not understand the content of this file, and this prevents me from analyzing it. It is highly likely that the contents of the file is not correct Elm code.', 'I need this file to be fixed before analyzing the rest of the project. If I didn\'t, I would potentially report incorrect things.', 'Hint: Try running `elm make`. The compiler should give you better hints on how to resolve the problem.']),
			filePath: path,
			fixes: $elm$core$Maybe$Nothing,
			message: path + ' is not a correct Elm module',
			preventsExtract: false,
			range: $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			ruleName: 'ParsingError',
			target: $jfmengels$elm_review$Review$Error$Module
		});
};
var $jfmengels$elm_review$Review$Rule$getModulesSortedByImport = function (project) {
	var _v0 = $jfmengels$elm_review$Review$Project$Valid$parse(project);
	if (_v0.$ === 'Err') {
		switch (_v0.a.$) {
			case 'SomeModulesFailedToParse':
				var pathsThatFailedToParse = _v0.a.a;
				return $elm$core$Result$Err(
					A2($elm$core$List$map, $jfmengels$elm_review$Review$Rule$parsingError, pathsThatFailedToParse));
			case 'DuplicateModuleNames':
				var duplicate = _v0.a.a;
				return $elm$core$Result$Err(
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Rule$duplicateModulesGlobalError(duplicate)
						]));
			case 'ImportCycleError':
				var cycle = _v0.a.a;
				return $elm$core$Result$Err(
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Rule$importCycleError(cycle)
						]));
			default:
				var _v1 = _v0.a;
				return $elm$core$Result$Err(
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Rule$errorToReviewError(
							A2(
								$jfmengels$elm_review$Review$Rule$setRuleName,
								'Incorrect project',
								$jfmengels$elm_review$Review$Rule$elmReviewGlobalError(
									{
										details: _List_fromArray(
											['I need to look at some Elm modules. Maybe you have specified folders that do not exist?']),
										message: 'This project does not contain any Elm modules'
									})))
						]));
		}
	} else {
		var result = _v0.a;
		return $elm$core$Result$Ok(result);
	}
};
var $jfmengels$elm_review$Review$Fix$FixedErrors$FixedErrors = F2(
	function (a, b) {
		return {$: 'FixedErrors', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Fix$FixedErrors$empty = A2($jfmengels$elm_review$Review$Fix$FixedErrors$FixedErrors, 0, $elm$core$Dict$empty);
var $jfmengels$elm_review$Review$Rule$moveFixableRulesFirst = function (rules) {
	return A2(
		$elm$core$List$sortBy,
		function (_v0) {
			var rule = _v0.a;
			return (rule.name === 'NoUnused.Variables') ? 0 : ((rule.name === 'NoUnused.Exports') ? 1 : (rule.providesFixes ? 2 : 3));
		},
		rules);
};
var $jfmengels$elm_review$Review$Fix$FixedErrors$hasChanged = F2(
	function (_v0, _v1) {
		var beforeCount = _v0.a;
		var afterCount = _v1.a;
		return !_Utils_eq(beforeCount, afterCount);
	});
var $jfmengels$elm_review$Vendor$ListExtra$orderIndependentMapAppend = F3(
	function (fn, left, right) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (element, acc) {
					return A2(
						$elm$core$List$cons,
						fn(element),
						acc);
				}),
			right,
			left);
	});
var $jfmengels$elm_review$Review$Fix$FixedErrors$count = function (_v0) {
	var fixCount = _v0.a;
	return fixCount;
};
var $jfmengels$elm_review$Review$Options$Internal$shouldAbort = F2(
	function (reviewOptionsData, fixedErrors) {
		var _v0 = reviewOptionsData.fixMode;
		if (_v0.$ === 'Enabled') {
			if (_v0.a.$ === 'Just') {
				var fixLimit = _v0.a.a;
				return _Utils_cmp(
					fixLimit,
					$jfmengels$elm_review$Review$Fix$FixedErrors$count(fixedErrors)) < 1;
			} else {
				var _v1 = _v0.a;
				return false;
			}
		} else {
			return false;
		}
	});
var $jfmengels$elm_review$Review$Rule$runRulesHelp = F3(
	function (reviewOptions, remainingRules, acc) {
		runRulesHelp:
		while (true) {
			if (!remainingRules.b) {
				return acc;
			} else {
				var name = remainingRules.a.a.name;
				var id = remainingRules.a.a.id;
				var exceptions = remainingRules.a.a.exceptions;
				var ruleImplementation = remainingRules.a.a.ruleImplementation;
				var restOfRules = remainingRules.b;
				var result = A5(ruleImplementation, reviewOptions, id, exceptions, acc.fixedErrors, acc.project);
				var errors = A3($jfmengels$elm_review$Vendor$ListExtra$orderIndependentMapAppend, $jfmengels$elm_review$Review$Rule$errorToReviewError, result.errors, acc.errors);
				if (A2($jfmengels$elm_review$Review$Options$Internal$shouldAbort, reviewOptions, result.fixedErrors)) {
					return {
						errors: errors,
						extracts: acc.extracts,
						fixedErrors: result.fixedErrors,
						project: result.project,
						rules: _Utils_ap(
							restOfRules,
							A2($elm$core$List$cons, result.rule, acc.rules))
					};
				} else {
					if (A2($jfmengels$elm_review$Review$Fix$FixedErrors$hasChanged, result.fixedErrors, acc.fixedErrors)) {
						var $temp$reviewOptions = reviewOptions,
							$temp$remainingRules = _Utils_ap(
							$elm$core$List$reverse(acc.rules),
							restOfRules),
							$temp$acc = {
							errors: errors,
							extracts: acc.extracts,
							fixedErrors: result.fixedErrors,
							project: result.project,
							rules: _List_fromArray(
								[result.rule])
						};
						reviewOptions = $temp$reviewOptions;
						remainingRules = $temp$remainingRules;
						acc = $temp$acc;
						continue runRulesHelp;
					} else {
						var $temp$reviewOptions = reviewOptions,
							$temp$remainingRules = restOfRules,
							$temp$acc = {
							errors: errors,
							extracts: function () {
								var _v1 = result.extract;
								if (_v1.$ === 'Just') {
									var extract = _v1.a.a;
									return A3($elm$core$Dict$insert, name, extract, acc.extracts);
								} else {
									return acc.extracts;
								}
							}(),
							fixedErrors: result.fixedErrors,
							project: result.project,
							rules: A2($elm$core$List$cons, result.rule, acc.rules)
						};
						reviewOptions = $temp$reviewOptions;
						remainingRules = $temp$remainingRules;
						acc = $temp$acc;
						continue runRulesHelp;
					}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$runRules = F3(
	function (_v0, rules, project) {
		var reviewOptions = _v0.a;
		return A3(
			$jfmengels$elm_review$Review$Rule$runRulesHelp,
			reviewOptions,
			$jfmengels$elm_review$Review$Rule$moveFixableRulesFirst(rules),
			{errors: _List_Nil, extracts: $elm$core$Dict$empty, fixedErrors: $jfmengels$elm_review$Review$Fix$FixedErrors$empty, project: project, rules: _List_Nil});
	});
var $jfmengels$elm_review$Review$Fix$FixedErrors$toDict = function (_v0) {
	var dict = _v0.b;
	return dict;
};
var $jfmengels$elm_review$Review$Project$Internal$Project = function (a) {
	return {$: 'Project', a: a};
};
var $jfmengels$elm_review$Review$Project$Valid$toRegularProject = function (_v0) {
	var validProject = _v0.a;
	return $jfmengels$elm_review$Review$Project$Internal$Project(
		{
			cache: validProject.projectCache,
			dependencies: validProject.dependencies,
			elmJson: validProject.elmJson,
			moduleGraph: $elm$core$Maybe$Just(validProject.moduleGraph),
			modules: validProject.modulesByPath,
			modulesThatFailedToParse: _List_Nil,
			readme: validProject.readme,
			sourceDirectories: validProject.sourceDirectories
		});
};
var $jfmengels$elm_review$Review$Rule$reviewV3 = F3(
	function (reviewOptions, rules, project) {
		var _v0 = A2(
			$elm$core$Result$andThen,
			function (_v1) {
				return $jfmengels$elm_review$Review$Rule$getModulesSortedByImport(project);
			},
			$jfmengels$elm_review$Review$Rule$checkForConfigurationErrors(rules));
		if (_v0.$ === 'Ok') {
			var _v2 = _v0.a;
			var validProject = _v2.a;
			var result = A3($jfmengels$elm_review$Review$Rule$runRules, reviewOptions, rules, validProject);
			return {
				errors: result.errors,
				extracts: result.extracts,
				fixedErrors: $jfmengels$elm_review$Review$Fix$FixedErrors$toDict(result.fixedErrors),
				project: $jfmengels$elm_review$Review$Project$Valid$toRegularProject(result.project),
				rules: result.rules
			};
		} else {
			var errors = _v0.a;
			return {errors: errors, extracts: $elm$core$Dict$empty, fixedErrors: $elm$core$Dict$empty, project: project, rules: rules};
		}
	});
var $jfmengels$elm_review$Review$Options$withDataExtraction = F2(
	function (extract, _v0) {
		var reviewOptions = _v0.a;
		return $jfmengels$elm_review$Review$Options$Internal$ReviewOptionsInternal(
			_Utils_update(
				reviewOptions,
				{extract: extract}));
	});
var $jfmengels$elm_review$Review$Test$checkResultsAreTheSameWhenIgnoringFilesHelp = F4(
	function (rule, project, allErrors, filesToIgnore) {
		var _v0 = A3(
			$jfmengels$elm_review$Review$Test$removeInCommon,
			A2($jfmengels$elm_review$Review$Test$removeErrorsForIgnoredFiles, filesToIgnore, allErrors),
			_List_Nil,
			A3(
				$jfmengels$elm_review$Review$Rule$reviewV3,
				A2($jfmengels$elm_review$Review$Options$withDataExtraction, false, $jfmengels$elm_review$Review$Options$defaults),
				_List_fromArray(
					[
						A2($jfmengels$elm_review$Review$Rule$ignoreErrorsForFiles, filesToIgnore, rule)
					]),
				project).errors);
		var missing = _v0.a;
		var unexpected = _v0.b;
		return ($elm$core$List$isEmpty(missing) && $elm$core$List$isEmpty(unexpected)) ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Expect$fail(
			$jfmengels$elm_review$Review$Test$FailureMessage$resultsAreDifferentWhenFilesAreIgnored(
				{ignoredFiles: filesToIgnore, missing: missing, unexpected: unexpected}));
	});
var $jfmengels$elm_review$Review$Project$elmJson = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$first, project.elmJson);
};
var $jfmengels$elm_review$Review$Test$maybeCons = F3(
	function (mapper, maybe, list) {
		if (maybe.$ === 'Just') {
			var b = maybe.a;
			return A2(
				$elm$core$List$cons,
				mapper(b),
				list);
		} else {
			return list;
		}
	});
var $jfmengels$elm_review$Review$Project$modules = function (_v0) {
	var project = _v0.a;
	return $elm$core$Dict$values(project.modules);
};
var $jfmengels$elm_review$Review$Project$readme = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$first, project.readme);
};
var $jfmengels$elm_review$Review$Test$doCheckResultsAreTheSameWhenIgnoringFiles = F3(
	function (allErrors, rule, project) {
		var filePaths = A3(
			$jfmengels$elm_review$Review$Test$maybeCons,
			function ($) {
				return $.path;
			},
			$jfmengels$elm_review$Review$Project$readme(project),
			A3(
				$jfmengels$elm_review$Review$Test$maybeCons,
				function ($) {
					return $.path;
				},
				$jfmengels$elm_review$Review$Project$elmJson(project),
				A2(
					$elm$core$List$map,
					function ($) {
						return $.path;
					},
					$jfmengels$elm_review$Review$Project$modules(project))));
		var combinationsOfFilesToIgnore = $jfmengels$elm_review$Review$Test$allCombinations(filePaths);
		return $elm$core$List$isEmpty(combinationsOfFilesToIgnore) ? $elm_explorations$test$Expect$pass : A2(
			$elm_explorations$test$Expect$all,
			A2(
				$elm$core$List$map,
				F2(
					function (filesToIgnore, _v0) {
						return A4($jfmengels$elm_review$Review$Test$checkResultsAreTheSameWhenIgnoringFilesHelp, rule, project, allErrors, filesToIgnore);
					}),
				combinationsOfFilesToIgnore),
			_Utils_Tuple0);
	});
var $jfmengels$elm_review$Review$Rule$ruleKnowsAboutIgnoredFiles = function (_v0) {
	var rule = _v0.a;
	var _v1 = rule.requestedData;
	var requestedData = _v1.a;
	return requestedData.ignoredFiles;
};
var $jfmengels$elm_review$Review$Test$checkResultsAreTheSameWhenIgnoringFiles = F2(
	function (allErrors, reRun) {
		if (reRun.$ === 'AttemptReRun') {
			var rule = reRun.a;
			var project = reRun.b;
			return (!$jfmengels$elm_review$Review$Rule$ruleKnowsAboutIgnoredFiles(rule)) ? $elm_explorations$test$Expect$pass : A3($jfmengels$elm_review$Review$Test$doCheckResultsAreTheSameWhenIgnoringFiles, allErrors, rule, project);
		} else {
			return $elm_explorations$test$Expect$pass;
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$formatJson = function (value) {
	return A2($elm$json$Json$Encode$encode, 2, value);
};
var $jfmengels$elm_review$Review$Test$FailureMessage$unexpectedExtract = function (value) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'UNEXPECTED EXTRACT',
		'This rule returned an extract but I did not expect one.\n\nYou should use `Review.Test.expectDataExtract` or\n`Review.Test.expect`+`Review.Test.dataExtract` to assert that the extract\nfits what you expected.\n\n' + $jfmengels$elm_review$Review$Test$FailureMessage$formatJson(value));
};
var $jfmengels$elm_review$Review$Test$expectNoDataExtract = function (maybeExtract) {
	if (maybeExtract.$ === 'Just') {
		var extract = maybeExtract.a;
		return $elm_explorations$test$Expect$fail(
			$jfmengels$elm_review$Review$Test$FailureMessage$unexpectedExtract(extract));
	} else {
		return $elm_explorations$test$Expect$pass;
	}
};
var $jfmengels$elm_review$Review$Test$FailureMessage$didNotExpectGlobalErrors = function (errors) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'DID NOT EXPECT GLOBAL ERRORS',
		'I expected no global errors but found:\n\n' + $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessages(errors));
};
var $jfmengels$elm_review$Review$Test$expectNoGlobalErrors = function (foundGlobalErrors) {
	return $elm$core$List$isEmpty(foundGlobalErrors) ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Expect$fail(
		$jfmengels$elm_review$Review$Test$FailureMessage$didNotExpectGlobalErrors(foundGlobalErrors));
};
var $jfmengels$elm_review$Review$Test$FailureMessage$didNotExpectErrors = F2(
	function (moduleName, errors) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'DID NOT EXPECT ERRORS',
			'I expected no errors for module `' + (moduleName + ('` but found:\n\n' + $jfmengels$elm_review$Review$Test$FailureMessage$listErrorMessagesAndPositions(errors))));
	});
var $jfmengels$elm_review$Review$Test$expectNoErrorForModuleRunResult = function (_v0) {
	var moduleName = _v0.moduleName;
	var errors = _v0.errors;
	return $elm$core$List$isEmpty(errors) ? $elm_explorations$test$Expect$pass : $elm_explorations$test$Expect$fail(
		A2($jfmengels$elm_review$Review$Test$FailureMessage$didNotExpectErrors, moduleName, errors));
};
var $jfmengels$elm_review$Review$Test$expectNoModuleErrors = function (runResults) {
	return A2(
		$elm_explorations$test$Expect$all,
		A2(
			$elm$core$List$map,
			A2($elm$core$Basics$composeR, $jfmengels$elm_review$Review$Test$expectNoErrorForModuleRunResult, $elm$core$Basics$always),
			runResults),
		_Utils_Tuple0);
};
var $jfmengels$elm_review$Review$Test$FailureMessage$needToUsedExpectErrorsForModules = A2($jfmengels$elm_review$Review$Test$FailureMessage$failureMessage, 'AMBIGUOUS MODULE FOR ERROR', 'You gave me several modules, and you expect some errors. I need to know for\nwhich module you expect these errors to be reported.\n\nYou should use `Review.Test.expectErrorsForModules` to do this:\n\n  test "..." <|\n    \\() ->\n      [ \"\"\"\nmodule A exposing (..)\n-- someCode\n\"\"\", \"\"\"\nmodule B exposing (..)\n-- someCode\n\"\"\" ]\n      |> Review.Test.runOnModules rule\n      |> Review.Test.expectErrorsForModules\n          [ ( "B", [ Review.Test.error someError ] )\n          ]');
var $jfmengels$elm_review$Review$Test$FailureMessage$unexpectedConfigurationError = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'UNEXPECTED CONFIGURATION ERROR',
		'I found a configuration error for this test:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(error.message) + ('\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(error.details) + '\n\nYou should use `Review.Test.expectConfigurationError` to expect this\nconfiguration error.'))));
};
var $jfmengels$elm_review$Review$Test$expectGlobalAndLocalErrors = F2(
	function (_v0, reviewResult) {
		var global = _v0.global;
		var local = _v0.local;
		switch (reviewResult.$) {
			case 'ConfigurationError':
				var configurationError = reviewResult.a;
				return $elm_explorations$test$Expect$fail(
					$jfmengels$elm_review$Review$Test$FailureMessage$unexpectedConfigurationError(configurationError));
			case 'FailedRun':
				var errorMessage = reviewResult.a;
				return $elm_explorations$test$Expect$fail(errorMessage);
			default:
				var ruleCanProvideFixes = reviewResult.a.ruleCanProvideFixes;
				var foundGlobalErrors = reviewResult.a.foundGlobalErrors;
				var runResults = reviewResult.a.runResults;
				var extract = reviewResult.a.extract;
				var allErrors = reviewResult.a.allErrors;
				var reRun = reviewResult.b;
				return A2(
					$elm_explorations$test$Expect$all,
					_List_fromArray(
						[
							function (_v2) {
							return $elm$core$List$isEmpty(global) ? $jfmengels$elm_review$Review$Test$expectNoGlobalErrors(foundGlobalErrors) : A2(
								$jfmengels$elm_review$Review$Test$checkAllGlobalErrorsMatch,
								$elm$core$List$length(global),
								{actual: foundGlobalErrors, expected: global});
						},
							function (_v3) {
							if ($elm$core$List$isEmpty(local)) {
								return $jfmengels$elm_review$Review$Test$expectNoModuleErrors(runResults);
							} else {
								if (runResults.b && (!runResults.b.b)) {
									var runResult = runResults.a;
									return A3($jfmengels$elm_review$Review$Test$checkAllErrorsMatch, ruleCanProvideFixes, runResult, local);
								} else {
									return $elm_explorations$test$Expect$fail($jfmengels$elm_review$Review$Test$FailureMessage$needToUsedExpectErrorsForModules);
								}
							}
						},
							function (_v5) {
							return $jfmengels$elm_review$Review$Test$expectNoDataExtract(extract);
						},
							function (_v6) {
							return A2($jfmengels$elm_review$Review$Test$checkResultsAreTheSameWhenIgnoringFiles, allErrors, reRun);
						}
						]),
					_Utils_Tuple0);
		}
	});
var $jfmengels$elm_review$Review$Test$expectErrors = F2(
	function (expectedErrors, reviewResult) {
		return A2(
			$jfmengels$elm_review$Review$Test$expectGlobalAndLocalErrors,
			{global: _List_Nil, local: expectedErrors},
			reviewResult);
	});
var $jfmengels$elm_review$Review$Test$expectNoErrors = function (reviewResult) {
	return A2(
		$jfmengels$elm_review$Review$Test$expectGlobalAndLocalErrors,
		{global: _List_Nil, local: _List_Nil},
		reviewResult);
};
var $author$project$NoUnsortedCases$DoNotSort = {$: 'DoNotSort'};
var $elm_community$list_extra$List$Extra$stableSortWith = F2(
	function (pred, list) {
		var predWithIndex = F2(
			function (_v1, _v2) {
				var a1 = _v1.a;
				var i1 = _v1.b;
				var a2 = _v2.a;
				var i2 = _v2.b;
				var result = A2(pred, a1, a2);
				if (result.$ === 'EQ') {
					return A2($elm$core$Basics$compare, i1, i2);
				} else {
					return result;
				}
			});
		var listWithIndex = A2(
			$elm$core$List$indexedMap,
			F2(
				function (i, a) {
					return _Utils_Tuple2(a, i);
				}),
			list);
		return A2(
			$elm$core$List$map,
			$elm$core$Tuple$first,
			A2($elm$core$List$sortWith, predWithIndex, listWithIndex));
	});
var $elm$core$Dict$union = F2(
	function (t1, t2) {
		return A3($elm$core$Dict$foldl, $elm$core$Dict$insert, t2, t1);
	});
var $author$project$NoUnsortedCases$dependencyVisitor = F3(
	function (_v0, deps, context) {
		var config = _v0.a;
		var docToEntry = F2(
			function (moduleName, _v5) {
				var name = _v5.name;
				var tags = _v5.tags;
				var constructors = A2($elm$core$List$map, $elm$core$Tuple$first, tags);
				var _v3 = _Utils_Tuple2(
					A2(config.sortablePredicate, moduleName, name),
					config.sortTypesFromDependencies);
				if (_v3.a) {
					if (_v3.b.$ === 'AlphabeticalOrder') {
						var _v4 = _v3.b;
						return $elm$core$Maybe$Just(
							_Utils_Tuple2(
								name,
								{
									constructors: $elm$core$Set$fromList(constructors),
									declarationOrder: A2($elm_community$list_extra$List$Extra$stableSortWith, $elm$core$Basics$compare, constructors)
								}));
					} else {
						return $elm$core$Maybe$Just(
							_Utils_Tuple2(
								name,
								{
									constructors: $elm$core$Set$fromList(constructors),
									declarationOrder: constructors
								}));
					}
				} else {
					return $elm$core$Maybe$Nothing;
				}
			});
		return (!_Utils_eq(config.sortTypesFromDependencies, $author$project$NoUnsortedCases$DoNotSort)) ? A3(
			$elm$core$Dict$foldl,
			F3(
				function (_v1, dep, acc) {
					return function (types) {
						return _Utils_update(
							acc,
							{
								customTypes: A2($elm$core$Dict$union, types, acc.customTypes)
							});
					}(
						$elm$core$Dict$fromList(
							A2(
								$elm$core$List$filterMap,
								function (_v2) {
									var name = _v2.name;
									var unions = _v2.unions;
									return A2(
										$elm$core$Maybe$map,
										$elm$core$Tuple$pair(
											A2($elm$core$String$split, '.', name)),
										function (ts) {
											return $elm$core$Dict$isEmpty(ts) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(ts);
										}(
											$elm$core$Dict$fromList(
												A2(
													$elm$core$List$filterMap,
													docToEntry(name),
													unions))));
								},
								$jfmengels$elm_review$Review$Project$Dependency$modules(dep))));
				}),
			context,
			deps) : context;
	});
var $author$project$NoUnsortedCases$foldProjectContexts = F2(
	function (newContext, prevContext) {
		return {
			customTypes: A2($elm$core$Dict$union, newContext.customTypes, prevContext.customTypes)
		};
	});
var $jfmengels$elm_review$Review$Rule$ContextCreator = F2(
	function (a, b) {
		return {$: 'ContextCreator', a: a, b: b};
	});
var $jfmengels$elm_review$Review$RequestedData$RequestedData = function (a) {
	return {$: 'RequestedData', a: a};
};
var $jfmengels$elm_review$Review$RequestedData$none = $jfmengels$elm_review$Review$RequestedData$RequestedData(
	{ignoredFiles: false, moduleNameLookupTable: false, sourceCodeExtractor: false});
var $jfmengels$elm_review$Review$Rule$initContextCreator = function (fromProjectToModule) {
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		$elm$core$Basics$always(fromProjectToModule),
		$jfmengels$elm_review$Review$RequestedData$none);
};
var $elm$core$Dict$singleton = F2(
	function (key, value) {
		return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
	});
var $jfmengels$elm_review$Review$Rule$moduleNameNode = function (node) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
	switch (_v0.$) {
		case 'NormalModule':
			var data = _v0.a;
			return data.moduleName;
		case 'PortModule':
			var data = _v0.a;
			return data.moduleName;
		default:
			var data = _v0.a;
			return data.moduleName;
	}
};
var $jfmengels$elm_review$Review$Rule$withModuleName = function (_v0) {
	var fn = _v0.a;
	var requestedData = _v0.b;
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		function (data) {
			return A2(
				fn,
				data,
				$stil4m$elm_syntax$Elm$Syntax$Node$value(
					$jfmengels$elm_review$Review$Rule$moduleNameNode(data.ast.moduleDefinition)));
		},
		requestedData);
};
var $author$project$NoUnsortedCases$fromModuleToProject = $jfmengels$elm_review$Review$Rule$withModuleName(
	$jfmengels$elm_review$Review$Rule$initContextCreator(
		F2(
			function (moduleName, _v0) {
				var exposedCustomTypes = _v0.exposedCustomTypes;
				return {
					customTypes: $elm$core$Dict$isEmpty(exposedCustomTypes) ? $elm$core$Dict$empty : A2($elm$core$Dict$singleton, moduleName, exposedCustomTypes)
				};
			})));
var $jfmengels$elm_review$Review$RequestedData$combineJust = F2(
	function (_v0, _v1) {
		var a = _v0.a;
		var b = _v1.a;
		return $jfmengels$elm_review$Review$RequestedData$RequestedData(
			{ignoredFiles: a.ignoredFiles || b.ignoredFiles, moduleNameLookupTable: a.moduleNameLookupTable || b.moduleNameLookupTable, sourceCodeExtractor: a.sourceCodeExtractor || b.sourceCodeExtractor});
	});
var $jfmengels$elm_review$Review$RequestedData$combine = F2(
	function (maybeA, maybeB) {
		if (maybeA.$ === 'Nothing') {
			return A2($elm$core$Maybe$withDefault, $jfmengels$elm_review$Review$RequestedData$none, maybeB);
		} else {
			var a = maybeA.a;
			if (maybeB.$ === 'Just') {
				var b = maybeB.a;
				return A2($jfmengels$elm_review$Review$RequestedData$combineJust, a, b);
			} else {
				return a;
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$emptyCache = {dependencies: $elm$core$Maybe$Nothing, elmJson: $elm$core$Maybe$Nothing, extract: $elm$core$Maybe$Nothing, finalEvaluationErrors: $elm$core$Maybe$Nothing, moduleContexts: $elm$core$Dict$empty, readme: $elm$core$Maybe$Nothing};
var $jfmengels$elm_review$Review$Rule$TraverseAllModulesInParallel = function (a) {
	return {$: 'TraverseAllModulesInParallel', a: a};
};
var $jfmengels$elm_review$Review$Rule$TraverseImportedModulesFirst = function (a) {
	return {$: 'TraverseImportedModulesFirst', a: a};
};
var $jfmengels$elm_review$Review$Rule$ModuleKey = function (a) {
	return {$: 'ModuleKey', a: a};
};
var $jfmengels$elm_review$Review$Rule$ModuleRuleSchema = function (a) {
	return {$: 'ModuleRuleSchema', a: a};
};
var $jfmengels$elm_review$Review$Rule$applyContextCreator = F3(
	function (data, _v0, from) {
		var fn = _v0.a;
		return A2(fn, data, from);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$ModuleNameLookupTable = F2(
	function (a, b) {
		return {$: 'ModuleNameLookupTable', a: a, b: b};
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$empty = function (currentModuleName) {
	return A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$ModuleNameLookupTable, currentModuleName, $elm$core$Dict$empty);
};
var $jfmengels$elm_review$Review$Rule$functionToExpression = function (_function) {
	return $stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression;
};
var $jfmengels$elm_review$Review$Rule$expressionChildren = function (node) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
	switch (_v0.$) {
		case 'Application':
			var expressions = _v0.a;
			return expressions;
		case 'ListExpr':
			var elements = _v0.a;
			return elements;
		case 'RecordExpr':
			var fields = _v0.a;
			return A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$stil4m$elm_syntax$Elm$Syntax$Node$value,
					function (_v1) {
						var expr = _v1.b;
						return expr;
					}),
				fields);
		case 'RecordUpdateExpression':
			var setters = _v0.b;
			return A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$stil4m$elm_syntax$Elm$Syntax$Node$value,
					function (_v2) {
						var expr = _v2.b;
						return expr;
					}),
				setters);
		case 'ParenthesizedExpression':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		case 'OperatorApplication':
			var direction = _v0.b;
			var left = _v0.c;
			var right = _v0.d;
			switch (direction.$) {
				case 'Left':
					return _List_fromArray(
						[left, right]);
				case 'Right':
					return _List_fromArray(
						[right, left]);
				default:
					return _List_fromArray(
						[left, right]);
			}
		case 'IfBlock':
			var cond = _v0.a;
			var then_ = _v0.b;
			var else_ = _v0.c;
			return _List_fromArray(
				[cond, then_, else_]);
		case 'LetExpression':
			var expression = _v0.a.expression;
			var declarations = _v0.a.declarations;
			return A3(
				$elm$core$List$foldr,
				F2(
					function (declaration, acc) {
						var _v4 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
						if (_v4.$ === 'LetFunction') {
							var _function = _v4.a;
							return A2(
								$elm$core$List$cons,
								$jfmengels$elm_review$Review$Rule$functionToExpression(_function),
								acc);
						} else {
							var expr = _v4.b;
							return A2($elm$core$List$cons, expr, acc);
						}
					}),
				_List_fromArray(
					[expression]),
				declarations);
		case 'CaseExpression':
			var expression = _v0.a.expression;
			var cases = _v0.a.cases;
			return A2(
				$elm$core$List$cons,
				expression,
				A2(
					$elm$core$List$map,
					function (_v5) {
						var caseExpression = _v5.b;
						return caseExpression;
					},
					cases));
		case 'LambdaExpression':
			var expression = _v0.a.expression;
			return _List_fromArray(
				[expression]);
		case 'TupledExpression':
			var expressions = _v0.a;
			return expressions;
		case 'Negation':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		case 'RecordAccess':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		default:
			return _List_Nil;
	}
};
var $jfmengels$elm_review$Review$Rule$accumulate = F2(
	function (visitor, _v0) {
		var previousErrors = _v0.a;
		var previousContext = _v0.b;
		var _v1 = visitor(previousContext);
		var newErrors = _v1.a;
		var newContext = _v1.b;
		return _Utils_Tuple2(
			A2($elm$core$List$append, newErrors, previousErrors),
			newContext);
	});
var $jfmengels$elm_review$Review$Rule$visitWithListOfVisitors = F3(
	function (visitors, a, initialErrorsAndContext) {
		return A3(
			$elm$core$List$foldl,
			function (visitor) {
				return $jfmengels$elm_review$Review$Rule$accumulate(
					visitor(a));
			},
			initialErrorsAndContext,
			visitors);
	});
var $jfmengels$elm_review$Review$Rule$visitWithListOfVisitors2 = F4(
	function (visitors, a, b, initialErrorsAndContext) {
		return A3(
			$elm$core$List$foldl,
			function (visitor) {
				return $jfmengels$elm_review$Review$Rule$accumulate(
					A2(visitor, a, b));
			},
			initialErrorsAndContext,
			visitors);
	});
var $jfmengels$elm_review$Review$Rule$visitCaseBranch = F4(
	function (expressionRelatedVisitors, caseBlockWithRange, caseBranch, errorsAndContext) {
		var caseExpression = caseBranch.b;
		return A4(
			$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors2,
			expressionRelatedVisitors.caseBranchVisitorsOnExit,
			caseBlockWithRange,
			caseBranch,
			A3(
				$jfmengels$elm_review$Review$Rule$visitExpression,
				expressionRelatedVisitors,
				caseExpression,
				A4($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors2, expressionRelatedVisitors.caseBranchVisitorsOnEnter, caseBlockWithRange, caseBranch, errorsAndContext)));
	});
var $jfmengels$elm_review$Review$Rule$visitExpression = F3(
	function (expressionRelatedVisitors, node, errorsAndContext) {
		var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v1.$) {
			case 'LetExpression':
				var letBlock = _v1.a;
				return A3(
					$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
					expressionRelatedVisitors.expressionVisitorsOnExit,
					node,
					A3(
						$jfmengels$elm_review$Review$Rule$visitExpression,
						expressionRelatedVisitors,
						letBlock.expression,
						function (errorsAndContext_) {
							return A3(
								$elm$core$List$foldl,
								A2(
									$jfmengels$elm_review$Review$Rule$visitLetDeclaration,
									expressionRelatedVisitors,
									A2(
										$stil4m$elm_syntax$Elm$Syntax$Node$Node,
										$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
										letBlock)),
								errorsAndContext_,
								letBlock.declarations);
						}(
							A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, expressionRelatedVisitors.expressionVisitorsOnEnter, node, errorsAndContext))));
			case 'CaseExpression':
				var caseBlock = _v1.a;
				return A3(
					$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
					expressionRelatedVisitors.expressionVisitorsOnExit,
					node,
					function (errorsAndContext_) {
						return A3(
							$elm$core$List$foldl,
							A2(
								$jfmengels$elm_review$Review$Rule$visitCaseBranch,
								expressionRelatedVisitors,
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Node$Node,
									$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
									caseBlock)),
							errorsAndContext_,
							caseBlock.cases);
					}(
						A3(
							$jfmengels$elm_review$Review$Rule$visitExpression,
							expressionRelatedVisitors,
							caseBlock.expression,
							A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, expressionRelatedVisitors.expressionVisitorsOnEnter, node, errorsAndContext))));
			default:
				return A3(
					$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
					expressionRelatedVisitors.expressionVisitorsOnExit,
					node,
					function (errorsAndContext_) {
						return A3(
							$elm$core$List$foldl,
							$jfmengels$elm_review$Review$Rule$visitExpression(expressionRelatedVisitors),
							errorsAndContext_,
							$jfmengels$elm_review$Review$Rule$expressionChildren(node));
					}(
						A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, expressionRelatedVisitors.expressionVisitorsOnEnter, node, errorsAndContext)));
		}
	});
var $jfmengels$elm_review$Review$Rule$visitLetDeclaration = F4(
	function (expressionRelatedVisitors, letBlockWithRange, letDeclarationWithRange, errorsAndContext) {
		var letDeclaration = letDeclarationWithRange.b;
		var expressionNode = function () {
			if (letDeclaration.$ === 'LetFunction') {
				var _function = letDeclaration.a;
				return $jfmengels$elm_review$Review$Rule$functionToExpression(_function);
			} else {
				var expr = letDeclaration.b;
				return expr;
			}
		}();
		return A4(
			$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors2,
			expressionRelatedVisitors.letDeclarationVisitorsOnExit,
			letBlockWithRange,
			letDeclarationWithRange,
			A3(
				$jfmengels$elm_review$Review$Rule$visitExpression,
				expressionRelatedVisitors,
				expressionNode,
				A4($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors2, expressionRelatedVisitors.letDeclarationVisitorsOnEnter, letBlockWithRange, letDeclarationWithRange, errorsAndContext)));
	});
var $jfmengels$elm_review$Review$Rule$visitOnlyExpressions = F4(
	function (expressionVisitorsOnEnter, expressionVisitorsOnExit, node, errorsAndContext) {
		return A3(
			$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
			expressionVisitorsOnExit,
			node,
			function (errorsAndContext_) {
				return A3(
					$elm$core$List$foldl,
					A2($jfmengels$elm_review$Review$Rule$visitOnlyExpressions, expressionVisitorsOnEnter, expressionVisitorsOnExit),
					errorsAndContext_,
					$jfmengels$elm_review$Review$Rule$expressionChildren(node));
			}(
				A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, expressionVisitorsOnEnter, node, errorsAndContext)));
	});
var $jfmengels$elm_review$Review$Rule$expressionChildrenTCO = F2(
	function (nodesToVisit, acc) {
		expressionChildrenTCO:
		while (true) {
			if (!nodesToVisit.b) {
				return $elm$core$List$reverse(acc);
			} else {
				var head = nodesToVisit.a;
				var rest = nodesToVisit.b;
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(head);
				switch (_v1.$) {
					case 'Application':
						var expressions = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$append, expressions, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'ListExpr':
						var expressions = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$append, expressions, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'RecordExpr':
						var fields = _v1.a;
						var $temp$nodesToVisit = A3(
							$elm$core$List$foldl,
							F2(
								function (_v2, toVisitAcc) {
									var _v3 = _v2.b;
									var expr = _v3.b;
									return A2($elm$core$List$cons, expr, toVisitAcc);
								}),
							rest,
							fields),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'RecordUpdateExpression':
						var setters = _v1.b;
						var $temp$nodesToVisit = A3(
							$elm$core$List$foldl,
							F2(
								function (_v4, toVisitAcc) {
									var _v5 = _v4.b;
									var expr = _v5.b;
									return A2($elm$core$List$cons, expr, toVisitAcc);
								}),
							rest,
							setters),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'ParenthesizedExpression':
						var expr = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$cons, expr, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'OperatorApplication':
						var direction = _v1.b;
						var left = _v1.c;
						var right = _v1.d;
						var nodeStack = function () {
							switch (direction.$) {
								case 'Left':
									return A2(
										$elm$core$List$cons,
										left,
										A2($elm$core$List$cons, right, rest));
								case 'Right':
									return A2(
										$elm$core$List$cons,
										right,
										A2($elm$core$List$cons, left, rest));
								default:
									return A2(
										$elm$core$List$cons,
										left,
										A2($elm$core$List$cons, right, rest));
							}
						}();
						var $temp$nodesToVisit = nodeStack,
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'IfBlock':
						var cond = _v1.a;
						var then_ = _v1.b;
						var else_ = _v1.c;
						var $temp$nodesToVisit = A2(
							$elm$core$List$cons,
							cond,
							A2(
								$elm$core$List$cons,
								then_,
								A2($elm$core$List$cons, else_, rest))),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'LetExpression':
						var expression = _v1.a.expression;
						var declarations = _v1.a.declarations;
						var $temp$nodesToVisit = A3(
							$elm$core$List$foldl,
							F2(
								function (declaration, toVisitAcc) {
									var _v7 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
									if (_v7.$ === 'LetFunction') {
										var _function = _v7.a;
										return A2(
											$elm$core$List$cons,
											$jfmengels$elm_review$Review$Rule$functionToExpression(_function),
											toVisitAcc);
									} else {
										var expr = _v7.b;
										return A2($elm$core$List$cons, expr, toVisitAcc);
									}
								}),
							A2($elm$core$List$cons, expression, rest),
							declarations),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'CaseExpression':
						var expression = _v1.a.expression;
						var cases = _v1.a.cases;
						var $temp$nodesToVisit = A2(
							$elm$core$List$cons,
							expression,
							A3(
								$elm$core$List$foldl,
								F2(
									function (_v8, toVisitAcc) {
										var caseExpression = _v8.b;
										return A2($elm$core$List$cons, caseExpression, toVisitAcc);
									}),
								rest,
								cases)),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'LambdaExpression':
						var expression = _v1.a.expression;
						var $temp$nodesToVisit = A2($elm$core$List$cons, expression, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'TupledExpression':
						var expressions = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$append, expressions, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'Negation':
						var expression = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$cons, expression, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					case 'RecordAccess':
						var expression = _v1.a;
						var $temp$nodesToVisit = A2($elm$core$List$cons, expression, rest),
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
					default:
						var $temp$nodesToVisit = rest,
							$temp$acc = A2($elm$core$List$cons, head, acc);
						nodesToVisit = $temp$nodesToVisit;
						acc = $temp$acc;
						continue expressionChildrenTCO;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$visitOnlyExpressionsOnlyOnEnter = F3(
	function (expressionVisitorsOnEnter, node, errorsAndContext) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (exprNode, acc) {
					return A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, expressionVisitorsOnEnter, exprNode, acc);
				}),
			errorsAndContext,
			A2(
				$jfmengels$elm_review$Review$Rule$expressionChildrenTCO,
				_List_fromArray(
					[node]),
				_List_Nil));
	});
var $jfmengels$elm_review$Review$Rule$createExpressionVisitor = function (schema) {
	if ((!$elm$core$List$isEmpty(schema.letDeclarationVisitorsOnEnter)) || ((!$elm$core$List$isEmpty(schema.letDeclarationVisitorsOnExit)) || ((!$elm$core$List$isEmpty(schema.caseBranchVisitorsOnEnter)) || (!$elm$core$List$isEmpty(schema.caseBranchVisitorsOnExit))))) {
		var expressionRelatedVisitors = {
			caseBranchVisitorsOnEnter: $elm$core$List$reverse(schema.caseBranchVisitorsOnEnter),
			caseBranchVisitorsOnExit: schema.caseBranchVisitorsOnExit,
			expressionVisitorsOnEnter: $elm$core$List$reverse(schema.expressionVisitorsOnEnter),
			expressionVisitorsOnExit: schema.expressionVisitorsOnExit,
			letDeclarationVisitorsOnEnter: $elm$core$List$reverse(schema.letDeclarationVisitorsOnEnter),
			letDeclarationVisitorsOnExit: schema.letDeclarationVisitorsOnExit
		};
		return $elm$core$Maybe$Just(
			$jfmengels$elm_review$Review$Rule$visitExpression(expressionRelatedVisitors));
	} else {
		if (!$elm$core$List$isEmpty(schema.expressionVisitorsOnExit)) {
			var exitVisitors = schema.expressionVisitorsOnExit;
			var enterVisitors = $elm$core$List$reverse(schema.expressionVisitorsOnEnter);
			return $elm$core$Maybe$Just(
				A2($jfmengels$elm_review$Review$Rule$visitOnlyExpressions, enterVisitors, exitVisitors));
		} else {
			if (!$elm$core$List$isEmpty(schema.expressionVisitorsOnEnter)) {
				return $elm$core$Maybe$Just(
					$jfmengels$elm_review$Review$Rule$visitOnlyExpressionsOnlyOnEnter(
						$elm$core$List$reverse(schema.expressionVisitorsOnEnter)));
			} else {
				return $elm$core$Maybe$Nothing;
			}
		}
	}
};
var $jfmengels$elm_review$Review$Rule$shouldVisitDeclarations = function (schema) {
	return (!$elm$core$List$isEmpty(schema.declarationVisitorsOnEnter)) || (!$elm$core$List$isEmpty(schema.declarationVisitorsOnExit));
};
var $jfmengels$elm_review$Review$Rule$visitOnlyDeclaration = F4(
	function (declarationVisitorsOnEnter, declarationVisitorsOnExit, node, errorsAndContext) {
		return A3(
			$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
			declarationVisitorsOnExit,
			node,
			A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, declarationVisitorsOnEnter, node, errorsAndContext));
	});
var $jfmengels$elm_review$Review$Rule$visitDeclaration = F5(
	function (declarationVisitorsOnEnter, declarationVisitorsOnExit, expressionVisitor, node, errorsAndContext) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		if (_v0.$ === 'FunctionDeclaration') {
			var _function = _v0.a;
			return A3(
				$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors,
				declarationVisitorsOnExit,
				node,
				A2(
					expressionVisitor,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression,
					A3($jfmengels$elm_review$Review$Rule$visitWithListOfVisitors, declarationVisitorsOnEnter, node, errorsAndContext)));
		} else {
			return A4($jfmengels$elm_review$Review$Rule$visitOnlyDeclaration, declarationVisitorsOnEnter, declarationVisitorsOnExit, node, errorsAndContext);
		}
	});
var $jfmengels$elm_review$Review$Rule$visitDeclarationButOnlyExpressions = F3(
	function (expressionVisitor, node, errorsAndContext) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		if (_v0.$ === 'FunctionDeclaration') {
			var _function = _v0.a;
			return A2(
				expressionVisitor,
				$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression,
				errorsAndContext);
		} else {
			return errorsAndContext;
		}
	});
var $jfmengels$elm_review$Review$Rule$createDeclarationAndExpressionVisitor = function (schema) {
	if ($jfmengels$elm_review$Review$Rule$shouldVisitDeclarations(schema)) {
		var declarationVisitorsOnEnter = $elm$core$List$reverse(schema.declarationVisitorsOnEnter);
		var _v0 = $jfmengels$elm_review$Review$Rule$createExpressionVisitor(schema);
		if (_v0.$ === 'Just') {
			var expressionVisitor = _v0.a;
			return F2(
				function (nodes, initialErrorsAndContext) {
					return A3(
						$elm$core$List$foldl,
						A3($jfmengels$elm_review$Review$Rule$visitDeclaration, declarationVisitorsOnEnter, schema.declarationVisitorsOnExit, expressionVisitor),
						initialErrorsAndContext,
						nodes);
				});
		} else {
			var visitor = A2($jfmengels$elm_review$Review$Rule$visitOnlyDeclaration, declarationVisitorsOnEnter, schema.declarationVisitorsOnExit);
			return F2(
				function (nodes, initialErrorsAndContext) {
					return A3($elm$core$List$foldl, visitor, initialErrorsAndContext, nodes);
				});
		}
	} else {
		var _v1 = $jfmengels$elm_review$Review$Rule$createExpressionVisitor(schema);
		if (_v1.$ === 'Just') {
			var expressionVisitor = _v1.a;
			return F2(
				function (nodes, initialErrorsAndContext) {
					return A3(
						$elm$core$List$foldl,
						$jfmengels$elm_review$Review$Rule$visitDeclarationButOnlyExpressions(expressionVisitor),
						initialErrorsAndContext,
						nodes);
				});
		} else {
			return F2(
				function (_v2, errorsAndContext) {
					return errorsAndContext;
				});
		}
	}
};
var $jfmengels$elm_review$Review$Rule$fromModuleRuleSchemaToRunnableModuleVisitor = function (_v0) {
	var schema = _v0.a;
	return {
		commentsVisitors: $elm$core$List$reverse(schema.commentsVisitors),
		declarationAndExpressionVisitor: $jfmengels$elm_review$Review$Rule$createDeclarationAndExpressionVisitor(schema),
		declarationListVisitors: $elm$core$List$reverse(schema.declarationListVisitors),
		finalEvaluationFns: $elm$core$List$reverse(schema.finalEvaluationFns),
		importVisitors: $elm$core$List$reverse(schema.importVisitors),
		moduleDefinitionVisitors: $elm$core$List$reverse(schema.moduleDefinitionVisitors),
		moduleDocumentationVisitors: $elm$core$List$reverse(schema.moduleDocumentationVisitors)
	};
};
var $jfmengels$elm_review$Review$Rule$mergeModuleVisitorsHelp = F3(
	function (initialProjectContext, moduleContextCreator, visitors) {
		var dummyAst = {
			comments: _List_Nil,
			declarations: _List_Nil,
			imports: _List_Nil,
			moduleDefinition: A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Module$NormalModule(
					{
						exposingList: A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(_List_Nil)),
						moduleName: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, _List_Nil)
					}))
		};
		var dummyAvailableData = {
			ast: dummyAst,
			extractSourceCode: $elm$core$Basics$always('dummy'),
			filePath: 'dummy file path',
			isFileIgnored: false,
			isInSourceDirectories: true,
			moduleKey: $jfmengels$elm_review$Review$Rule$ModuleKey('dummy'),
			moduleNameLookupTable: $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$empty(_List_Nil)
		};
		var initialModuleContext = A3($jfmengels$elm_review$Review$Rule$applyContextCreator, dummyAvailableData, moduleContextCreator, initialProjectContext);
		var emptyModuleVisitor = $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			{
				caseBranchVisitorsOnEnter: _List_Nil,
				caseBranchVisitorsOnExit: _List_Nil,
				commentsVisitors: _List_Nil,
				declarationListVisitors: _List_Nil,
				declarationVisitorsOnEnter: _List_Nil,
				declarationVisitorsOnExit: _List_Nil,
				dependenciesVisitors: _List_Nil,
				directDependenciesVisitors: _List_Nil,
				elmJsonVisitors: _List_Nil,
				expressionVisitorsOnEnter: _List_Nil,
				expressionVisitorsOnExit: _List_Nil,
				finalEvaluationFns: _List_Nil,
				importVisitors: _List_Nil,
				initialModuleContext: $elm$core$Maybe$Just(initialModuleContext),
				letDeclarationVisitorsOnEnter: _List_Nil,
				letDeclarationVisitorsOnExit: _List_Nil,
				moduleContextCreator: $jfmengels$elm_review$Review$Rule$initContextCreator(
					$elm$core$Basics$always(initialModuleContext)),
				moduleDefinitionVisitors: _List_Nil,
				moduleDocumentationVisitors: _List_Nil,
				name: '',
				providesFixes: false,
				readmeVisitors: _List_Nil
			});
		return _Utils_Tuple2(
			$jfmengels$elm_review$Review$Rule$fromModuleRuleSchemaToRunnableModuleVisitor(
				A3(
					$elm$core$List$foldl,
					F2(
						function (addVisitors, _v0) {
							var moduleVisitorSchema = _v0.a;
							return addVisitors(
								$jfmengels$elm_review$Review$Rule$ModuleRuleSchema(moduleVisitorSchema));
						}),
					emptyModuleVisitor,
					visitors)),
			moduleContextCreator);
	});
var $jfmengels$elm_review$Review$Rule$mergeModuleVisitors = F3(
	function (initialProjectContext, maybeModuleContextCreator, visitors) {
		if (maybeModuleContextCreator.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var moduleContextCreator = maybeModuleContextCreator.a;
			return $elm$core$List$isEmpty(visitors) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
				A3($jfmengels$elm_review$Review$Rule$mergeModuleVisitorsHelp, initialProjectContext, moduleContextCreator, visitors));
		}
	});
var $jfmengels$elm_review$Review$Rule$fromProjectRuleSchemaToRunnableProjectVisitor = function (_v0) {
	var schema = _v0.a;
	return {
		dataExtractor: schema.dataExtractor,
		dependenciesVisitors: $elm$core$List$reverse(schema.dependenciesVisitors),
		directDependenciesVisitors: $elm$core$List$reverse(schema.directDependenciesVisitors),
		elmJsonVisitors: $elm$core$List$reverse(schema.elmJsonVisitors),
		finalEvaluationFns: $elm$core$List$reverse(schema.finalEvaluationFns),
		initialProjectContext: schema.initialProjectContext,
		moduleVisitor: A3($jfmengels$elm_review$Review$Rule$mergeModuleVisitors, schema.initialProjectContext, schema.moduleContextCreator, schema.moduleVisitors),
		name: schema.name,
		providesFixes: schema.providesFixes,
		readmeVisitors: $elm$core$List$reverse(schema.readmeVisitors),
		requestedData: function () {
			var _v1 = schema.moduleContextCreator;
			if (_v1.$ === 'Just') {
				var _v2 = _v1.a;
				var requestedData = _v2.b;
				return requestedData;
			} else {
				return $jfmengels$elm_review$Review$RequestedData$none;
			}
		}(),
		traversalAndFolder: function () {
			var _v3 = _Utils_Tuple2(schema.traversalType, schema.folder);
			if (_v3.a.$ === 'AllModulesInParallel') {
				var _v4 = _v3.a;
				return $jfmengels$elm_review$Review$Rule$TraverseAllModulesInParallel(schema.folder);
			} else {
				if (_v3.b.$ === 'Just') {
					var _v5 = _v3.a;
					var folder = _v3.b.a;
					return $jfmengels$elm_review$Review$Rule$TraverseImportedModulesFirst(folder);
				} else {
					var _v6 = _v3.a;
					var _v7 = _v3.b;
					return $jfmengels$elm_review$Review$Rule$TraverseAllModulesInParallel($elm$core$Maybe$Nothing);
				}
			}
		}()
	};
};
var $jfmengels$elm_review$Review$Exceptions$init = $jfmengels$elm_review$Review$Exceptions$Exceptions(_List_Nil);
var $jfmengels$elm_review$Review$Rule$initialCacheMarker = F3(
	function (_v0, _v1, cache) {
		return cache;
	});
var $jfmengels$elm_review$Review$Project$Valid$doesModuleExist = F2(
	function (path, _v0) {
		var project = _v0.a;
		return A2($elm$core$Dict$member, path, project.modulesByPath);
	});
var $jfmengels$elm_review$Review$Rule$removeUnknownModulesFromInitialCache = F2(
	function (validProject, projectRuleCache) {
		return _Utils_update(
			projectRuleCache,
			{
				moduleContexts: A2(
					$elm$core$Dict$filter,
					F2(
						function (path, _v0) {
							return A2($jfmengels$elm_review$Review$Project$Valid$doesModuleExist, path, validProject);
						}),
					projectRuleCache.moduleContexts)
			});
	});
var $jfmengels$elm_review$Review$Rule$requestedDataFromContextCreator = function (_v0) {
	var requestedData = _v0.b;
	return requestedData;
};
var $jfmengels$elm_review$Review$Rule$ElmJson = function (a) {
	return {$: 'ElmJson', a: a};
};
var $jfmengels$elm_review$Review$Rule$FinalProjectEvaluation = function (a) {
	return {$: 'FinalProjectEvaluation', a: a};
};
var $jfmengels$elm_review$Review$Rule$Abort = {$: 'Abort'};
var $jfmengels$elm_review$Review$Rule$Modules = F2(
	function (a, b) {
		return {$: 'Modules', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Rule$Readme = function (a) {
	return {$: 'Readme', a: a};
};
var $jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors = F3(
	function (visitors, element, initialErrorsAndContext) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (visitor, errorsAndContext) {
					return A2(
						$jfmengels$elm_review$Review$Rule$accumulate,
						visitor(element),
						errorsAndContext);
				}),
			initialErrorsAndContext,
			visitors);
	});
var $jfmengels$elm_review$Review$Cache$ContextHash$ContextHash = function (a) {
	return {$: 'ContextHash', a: a};
};
var $jfmengels$elm_review$Review$Cache$ContextHash$createContextHashMarker = function (context) {
	return context;
};
var $jfmengels$elm_review$Review$Cache$ContextHash$create = function (context) {
	return $jfmengels$elm_review$Review$Cache$ContextHash$ContextHash(
		$jfmengels$elm_review$Review$Cache$ContextHash$createContextHashMarker(context));
};
var $jfmengels$elm_review$Review$Cache$EntryMaybe = function (a) {
	return {$: 'EntryMaybe', a: a};
};
var $jfmengels$elm_review$Review$Cache$createEntryMaybe = function (entry) {
	return $jfmengels$elm_review$Review$Cache$EntryMaybe(
		{
			contentHash: entry.contentHash,
			errors: entry.errors,
			inputContext: $jfmengels$elm_review$Review$Cache$ContextHash$create(entry.inputContext),
			outputContext: entry.outputContext
		});
};
var $jfmengels$elm_review$Review$Project$Valid$dependencies = function (_v0) {
	var project = _v0.a;
	return project.dependencies;
};
var $jfmengels$elm_review$Review$Project$Valid$elmJsonHash = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$second, project.elmJson);
};
var $jfmengels$elm_review$Review$Project$Valid$dependenciesHash = $jfmengels$elm_review$Review$Project$Valid$elmJsonHash;
var $jfmengels$elm_review$Review$Project$Valid$directDependencies = function (_v0) {
	var project = _v0.a;
	return project.directDependencies;
};
var $jfmengels$elm_review$Review$Rule$errorFilePathInternal = function (_v0) {
	var err = _v0.a;
	return err.filePath;
};
var $jfmengels$elm_review$Review$Exceptions$isFileWeWantReportsFor = F2(
	function (_v0, filePath) {
		var conditions = _v0.a;
		var allConditions = function (path) {
			return A2(
				$elm$core$List$all,
				function (condition) {
					return condition(path);
				},
				conditions);
		};
		return allConditions(
			$jfmengels$elm_review$Path$makeOSAgnostic(filePath));
	});
var $jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName = F3(
	function (exceptions, name, errors) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (error_, acc) {
					return A2(
						$jfmengels$elm_review$Review$Exceptions$isFileWeWantReportsFor,
						exceptions,
						$jfmengels$elm_review$Review$Rule$errorFilePathInternal(error_)) ? A2(
						$elm$core$List$cons,
						A2($jfmengels$elm_review$Review$Rule$setRuleName, name, error_),
						acc) : acc;
				}),
			_List_Nil,
			errors);
	});
var $jfmengels$elm_review$Review$Rule$ShouldAbort = function (a) {
	return {$: 'ShouldAbort', a: a};
};
var $jfmengels$elm_review$Review$Rule$ShouldContinue = function (a) {
	return {$: 'ShouldContinue', a: a};
};
var $jfmengels$elm_review$Review$Rule$FixedElmJson = {$: 'FixedElmJson'};
var $jfmengels$elm_review$Review$Rule$FixedElmModule = F2(
	function (a, b) {
		return {$: 'FixedElmModule', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Rule$FixedReadme = {$: 'FixedReadme'};
var $jfmengels$elm_review$Review$Project$Valid$areDependenciesUnchanged = function (_v0) {
	var before = _v0.before;
	var after = _v0.after;
	var _v1 = _Utils_Tuple2(before, after);
	_v1$2:
	while (true) {
		if (_v1.a.$ === 'Application') {
			if (_v1.b.$ === 'Application') {
				var beforeApp = _v1.a.a;
				var afterApp = _v1.b.a;
				return _Utils_eq(beforeApp.depsDirect, afterApp.depsDirect) && (_Utils_eq(beforeApp.depsIndirect, afterApp.depsIndirect) && (_Utils_eq(beforeApp.testDepsDirect, afterApp.testDepsDirect) && _Utils_eq(beforeApp.testDepsIndirect, afterApp.testDepsIndirect)));
			} else {
				break _v1$2;
			}
		} else {
			if (_v1.b.$ === 'Package') {
				var beforePkg = _v1.a.a;
				var afterPkg = _v1.b.a;
				return _Utils_eq(beforePkg.deps, afterPkg.deps) && _Utils_eq(beforePkg.testDeps, afterPkg.testDeps);
			} else {
				break _v1$2;
			}
		}
	}
	return false;
};
var $jfmengels$elm_review$Review$Cache$ContentHash$ContentHash = function (a) {
	return {$: 'ContentHash', a: a};
};
var $jfmengels$elm_review$Vendor$Murmur3$HashData = F4(
	function (shift, seed, hash, charsProcessed) {
		return {charsProcessed: charsProcessed, hash: hash, seed: seed, shift: shift};
	});
var $jfmengels$elm_review$Vendor$Murmur3$c1 = 3432918353;
var $jfmengels$elm_review$Vendor$Murmur3$c2 = 461845907;
var $jfmengels$elm_review$Vendor$Murmur3$multiplyBy = F2(
	function (b, a) {
		return ((a & 65535) * b) + ((((a >>> 16) * b) & 65535) << 16);
	});
var $jfmengels$elm_review$Vendor$Murmur3$rotlBy = F2(
	function (b, a) {
		return (a << b) | (a >>> (32 - b));
	});
var $jfmengels$elm_review$Vendor$Murmur3$finalize = function (data) {
	var acc = (!(!data.hash)) ? (data.seed ^ A2(
		$jfmengels$elm_review$Vendor$Murmur3$multiplyBy,
		$jfmengels$elm_review$Vendor$Murmur3$c2,
		A2(
			$jfmengels$elm_review$Vendor$Murmur3$rotlBy,
			15,
			A2($jfmengels$elm_review$Vendor$Murmur3$multiplyBy, $jfmengels$elm_review$Vendor$Murmur3$c1, data.hash)))) : data.seed;
	var h0 = acc ^ data.charsProcessed;
	var h1 = A2($jfmengels$elm_review$Vendor$Murmur3$multiplyBy, 2246822507, h0 ^ (h0 >>> 16));
	var h2 = A2($jfmengels$elm_review$Vendor$Murmur3$multiplyBy, 3266489909, h1 ^ (h1 >>> 13));
	return (h2 ^ (h2 >>> 16)) >>> 0;
};
var $elm$core$String$foldl = _String_foldl;
var $jfmengels$elm_review$Vendor$Murmur3$mix = F2(
	function (h1, k1) {
		return A2(
			$jfmengels$elm_review$Vendor$Murmur3$multiplyBy,
			5,
			A2(
				$jfmengels$elm_review$Vendor$Murmur3$rotlBy,
				13,
				h1 ^ A2(
					$jfmengels$elm_review$Vendor$Murmur3$multiplyBy,
					$jfmengels$elm_review$Vendor$Murmur3$c2,
					A2(
						$jfmengels$elm_review$Vendor$Murmur3$rotlBy,
						15,
						A2($jfmengels$elm_review$Vendor$Murmur3$multiplyBy, $jfmengels$elm_review$Vendor$Murmur3$c1, k1))))) + 3864292196;
	});
var $jfmengels$elm_review$Vendor$Murmur3$hashFold = F2(
	function (c, data) {
		var res = data.hash | ((255 & $elm$core$Char$toCode(c)) << data.shift);
		var _v0 = data.shift;
		if (_v0 === 24) {
			return {
				charsProcessed: data.charsProcessed + 1,
				hash: 0,
				seed: A2($jfmengels$elm_review$Vendor$Murmur3$mix, data.seed, res),
				shift: 0
			};
		} else {
			return {charsProcessed: data.charsProcessed + 1, hash: res, seed: data.seed, shift: data.shift + 8};
		}
	});
var $jfmengels$elm_review$Vendor$Murmur3$hashString = F2(
	function (seed, str) {
		return $jfmengels$elm_review$Vendor$Murmur3$finalize(
			A3(
				$elm$core$String$foldl,
				$jfmengels$elm_review$Vendor$Murmur3$hashFold,
				A4($jfmengels$elm_review$Vendor$Murmur3$HashData, 0, seed, 0, 0),
				str));
	});
var $jfmengels$elm_review$Review$Cache$ContentHash$hash = function (source) {
	return $jfmengels$elm_review$Review$Cache$ContentHash$ContentHash(
		A2($jfmengels$elm_review$Vendor$Murmur3$hashString, 0, source));
};
var $jfmengels$elm_review$Review$Project$Valid$computeUpdatedDependencies = F3(
	function (previousElmJsonProject, newElmJson, project) {
		if ($jfmengels$elm_review$Review$Project$Valid$areDependenciesUnchanged(
			{after: newElmJson.project, before: previousElmJsonProject})) {
			return $elm$core$Maybe$Just(
				{dependencies: project.dependencies, dependencyModules: project.dependencyModules, directDependencies: project.directDependencies});
		} else {
			var newDependencies = project.dependencies;
			var directDependencies_ = $jfmengels$elm_review$Review$Project$Valid$computeDirectDependencies(
				{
					dependencies: newDependencies,
					elmJson: $elm$core$Maybe$Just(
						_Utils_Tuple2(
							newElmJson,
							$jfmengels$elm_review$Review$Cache$ContentHash$hash(newElmJson.raw)))
				});
			return $elm$core$Maybe$Just(
				{
					dependencies: newDependencies,
					dependencyModules: $jfmengels$elm_review$Review$Project$Valid$computeDependencyModules(directDependencies_),
					directDependencies: directDependencies_
				});
		}
	});
var $elm$core$String$endsWith = _String_endsWith;
var $jfmengels$elm_review$Review$Project$Internal$endWithSlash = function (dir) {
	return A2($elm$core$String$endsWith, '/', dir) ? dir : (dir + '/');
};
var $jfmengels$elm_review$Review$Project$Internal$removeDotSlashAtBeginning = function (dir) {
	return A2($elm$core$String$startsWith, './', dir) ? A2($elm$core$String$dropLeft, 2, dir) : dir;
};
var $jfmengels$elm_review$Review$Project$Internal$sourceDirectoriesForProject = function (elmJson_) {
	if (elmJson_.$ === 'Application') {
		var dirs = elmJson_.a.dirs;
		return A2(
			$elm$core$List$map,
			A2(
				$elm$core$Basics$composeR,
				$jfmengels$elm_review$Review$Project$Internal$removeDotSlashAtBeginning,
				A2($elm$core$Basics$composeR, $jfmengels$elm_review$Path$makeOSAgnostic, $jfmengels$elm_review$Review$Project$Internal$endWithSlash)),
			dirs);
	} else {
		return _List_fromArray(
			['src/']);
	}
};
var $jfmengels$elm_review$Review$Project$Valid$addElmJson = F2(
	function (elmJson_, _v0) {
		var project = _v0.a;
		var _v1 = A2(
			$elm$core$Maybe$map,
			function (_v2) {
				var e = _v2.a;
				return e.project;
			},
			project.elmJson);
		if (_v1.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var previousElmJson = _v1.a;
			var sourceDirectories = $jfmengels$elm_review$Review$Project$Internal$sourceDirectoriesForProject(elmJson_.project);
			return (!_Utils_eq(
				sourceDirectories,
				$jfmengels$elm_review$Review$Project$Internal$sourceDirectoriesForProject(previousElmJson))) ? $elm$core$Maybe$Nothing : A2(
				$elm$core$Maybe$map,
				function (updatedDependencies) {
					return $jfmengels$elm_review$Review$Project$Valid$ValidProject(
						_Utils_update(
							project,
							{
								dependencies: updatedDependencies.dependencies,
								dependencyModules: updatedDependencies.dependencyModules,
								directDependencies: updatedDependencies.directDependencies,
								elmJson: $elm$core$Maybe$Just(
									_Utils_Tuple2(
										elmJson_,
										$jfmengels$elm_review$Review$Cache$ContentHash$hash(elmJson_.raw))),
								sourceDirectories: sourceDirectories
							}));
				},
				A3($jfmengels$elm_review$Review$Project$Valid$computeUpdatedDependencies, previousElmJson, elmJson_, project));
		}
	});
var $jfmengels$elm_review$Vendor$Zipper$current = function (_v0) {
	var f = _v0.b;
	return f;
};
var $jfmengels$elm_review$Vendor$Zipper$next = function (_v0) {
	var p = _v0.a;
	var f = _v0.b;
	var n = _v0.c;
	if (!n.b) {
		return $elm$core$Maybe$Nothing;
	} else {
		var h = n.a;
		var t = n.b;
		return $elm$core$Maybe$Just(
			A3(
				$jfmengels$elm_review$Vendor$Zipper$Zipper,
				A2($elm$core$List$cons, f, p),
				h,
				t));
	}
};
var $jfmengels$elm_review$Review$Project$Valid$advanceZipper = F3(
	function (path, oldZipper, newZipper) {
		advanceZipper:
		while (true) {
			var current = $jfmengels$elm_review$Vendor$Zipper$current(newZipper).node.label;
			if (_Utils_eq(current, path) || (!_Utils_eq(
				current,
				$jfmengels$elm_review$Vendor$Zipper$current(oldZipper).node.label))) {
				return newZipper;
			} else {
				var _v0 = A3(
					$elm$core$Maybe$map2,
					$elm$core$Tuple$pair,
					$jfmengels$elm_review$Vendor$Zipper$next(oldZipper),
					$jfmengels$elm_review$Vendor$Zipper$next(newZipper));
				if (_v0.$ === 'Just') {
					var _v1 = _v0.a;
					var old = _v1.a;
					var _new = _v1.b;
					var $temp$path = path,
						$temp$oldZipper = old,
						$temp$newZipper = _new;
					path = $temp$path;
					oldZipper = $temp$oldZipper;
					newZipper = $temp$newZipper;
					continue advanceZipper;
				} else {
					return newZipper;
				}
			}
		}
	});
var $jfmengels$elm_review$Vendor$Zipper$focusr = F2(
	function (fc, zipper) {
		focusr:
		while (true) {
			if (fc(
				$jfmengels$elm_review$Vendor$Zipper$current(zipper))) {
				return $elm$core$Maybe$Just(zipper);
			} else {
				var _v0 = $jfmengels$elm_review$Vendor$Zipper$next(zipper);
				if (_v0.$ === 'Just') {
					var z = _v0.a;
					var $temp$fc = fc,
						$temp$zipper = z;
					fc = $temp$fc;
					zipper = $temp$zipper;
					continue focusr;
				} else {
					return $elm$core$Maybe$Nothing;
				}
			}
		}
	});
var $elm$core$Dict$getMin = function (dict) {
	getMin:
	while (true) {
		if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
			var left = dict.d;
			var $temp$dict = left;
			dict = $temp$dict;
			continue getMin;
		} else {
			return dict;
		}
	}
};
var $elm$core$Dict$moveRedLeft = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.e.d.$ === 'RBNode_elm_builtin') && (dict.e.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var lLeft = _v1.d;
			var lRight = _v1.e;
			var _v2 = dict.e;
			var rClr = _v2.a;
			var rK = _v2.b;
			var rV = _v2.c;
			var rLeft = _v2.d;
			var _v3 = rLeft.a;
			var rlK = rLeft.b;
			var rlV = rLeft.c;
			var rlL = rLeft.d;
			var rlR = rLeft.e;
			var rRight = _v2.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				rlK,
				rlV,
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					rlL),
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rlR, rRight));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v4 = dict.d;
			var lClr = _v4.a;
			var lK = _v4.b;
			var lV = _v4.c;
			var lLeft = _v4.d;
			var lRight = _v4.e;
			var _v5 = dict.e;
			var rClr = _v5.a;
			var rK = _v5.b;
			var rV = _v5.c;
			var rLeft = _v5.d;
			var rRight = _v5.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$moveRedRight = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.d.d.$ === 'RBNode_elm_builtin') && (dict.d.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var _v2 = _v1.d;
			var _v3 = _v2.a;
			var llK = _v2.b;
			var llV = _v2.c;
			var llLeft = _v2.d;
			var llRight = _v2.e;
			var lRight = _v1.e;
			var _v4 = dict.e;
			var rClr = _v4.a;
			var rK = _v4.b;
			var rV = _v4.c;
			var rLeft = _v4.d;
			var rRight = _v4.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				lK,
				lV,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					lRight,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v5 = dict.d;
			var lClr = _v5.a;
			var lK = _v5.b;
			var lV = _v5.c;
			var lLeft = _v5.d;
			var lRight = _v5.e;
			var _v6 = dict.e;
			var rClr = _v6.a;
			var rK = _v6.b;
			var rV = _v6.c;
			var rLeft = _v6.d;
			var rRight = _v6.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$removeHelpPrepEQGT = F7(
	function (targetKey, dict, color, key, value, left, right) {
		if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
			var _v1 = left.a;
			var lK = left.b;
			var lV = left.c;
			var lLeft = left.d;
			var lRight = left.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				lK,
				lV,
				lLeft,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, lRight, right));
		} else {
			_v2$2:
			while (true) {
				if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Black')) {
					if (right.d.$ === 'RBNode_elm_builtin') {
						if (right.d.a.$ === 'Black') {
							var _v3 = right.a;
							var _v4 = right.d;
							var _v5 = _v4.a;
							return $elm$core$Dict$moveRedRight(dict);
						} else {
							break _v2$2;
						}
					} else {
						var _v6 = right.a;
						var _v7 = right.d;
						return $elm$core$Dict$moveRedRight(dict);
					}
				} else {
					break _v2$2;
				}
			}
			return dict;
		}
	});
var $elm$core$Dict$removeMin = function (dict) {
	if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
		var color = dict.a;
		var key = dict.b;
		var value = dict.c;
		var left = dict.d;
		var lColor = left.a;
		var lLeft = left.d;
		var right = dict.e;
		if (lColor.$ === 'Black') {
			if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
				var _v3 = lLeft.a;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					key,
					value,
					$elm$core$Dict$removeMin(left),
					right);
			} else {
				var _v4 = $elm$core$Dict$moveRedLeft(dict);
				if (_v4.$ === 'RBNode_elm_builtin') {
					var nColor = _v4.a;
					var nKey = _v4.b;
					var nValue = _v4.c;
					var nLeft = _v4.d;
					var nRight = _v4.e;
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						$elm$core$Dict$removeMin(nLeft),
						nRight);
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			}
		} else {
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				value,
				$elm$core$Dict$removeMin(left),
				right);
		}
	} else {
		return $elm$core$Dict$RBEmpty_elm_builtin;
	}
};
var $elm$core$Dict$removeHelp = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_cmp(targetKey, key) < 0) {
				if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Black')) {
					var _v4 = left.a;
					var lLeft = left.d;
					if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
						var _v6 = lLeft.a;
						return A5(
							$elm$core$Dict$RBNode_elm_builtin,
							color,
							key,
							value,
							A2($elm$core$Dict$removeHelp, targetKey, left),
							right);
					} else {
						var _v7 = $elm$core$Dict$moveRedLeft(dict);
						if (_v7.$ === 'RBNode_elm_builtin') {
							var nColor = _v7.a;
							var nKey = _v7.b;
							var nValue = _v7.c;
							var nLeft = _v7.d;
							var nRight = _v7.e;
							return A5(
								$elm$core$Dict$balance,
								nColor,
								nKey,
								nValue,
								A2($elm$core$Dict$removeHelp, targetKey, nLeft),
								nRight);
						} else {
							return $elm$core$Dict$RBEmpty_elm_builtin;
						}
					}
				} else {
					return A5(
						$elm$core$Dict$RBNode_elm_builtin,
						color,
						key,
						value,
						A2($elm$core$Dict$removeHelp, targetKey, left),
						right);
				}
			} else {
				return A2(
					$elm$core$Dict$removeHelpEQGT,
					targetKey,
					A7($elm$core$Dict$removeHelpPrepEQGT, targetKey, dict, color, key, value, left, right));
			}
		}
	});
var $elm$core$Dict$removeHelpEQGT = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBNode_elm_builtin') {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_eq(targetKey, key)) {
				var _v1 = $elm$core$Dict$getMin(right);
				if (_v1.$ === 'RBNode_elm_builtin') {
					var minKey = _v1.b;
					var minValue = _v1.c;
					return A5(
						$elm$core$Dict$balance,
						color,
						minKey,
						minValue,
						left,
						$elm$core$Dict$removeMin(right));
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			} else {
				return A5(
					$elm$core$Dict$balance,
					color,
					key,
					value,
					left,
					A2($elm$core$Dict$removeHelp, targetKey, right));
			}
		} else {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		}
	});
var $elm$core$Dict$remove = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$removeHelp, key, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $elm$core$Dict$diff = F2(
	function (t1, t2) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, t) {
					return A2($elm$core$Dict$remove, k, t);
				}),
			t1,
			t2);
	});
var $elm$core$Set$diff = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$diff, dict1, dict2));
	});
var $jfmengels$elm_review$Review$Project$Valid$importedModulesSet = F2(
	function (ast, dependencyModules) {
		return A2(
			$elm$core$Set$diff,
			A3(
				$elm$core$List$foldl,
				F2(
					function (import_, set) {
						return A2(
							$elm$core$Set$insert,
							$stil4m$elm_syntax$Elm$Syntax$Node$value(
								$stil4m$elm_syntax$Elm$Syntax$Node$value(import_).moduleName),
							set);
					}),
				$elm$core$Set$empty,
				ast.imports),
			dependencyModules);
	});
var $jfmengels$elm_review$Review$Project$Internal$positionAsInt = function (_v0) {
	var row = _v0.row;
	var column = _v0.column;
	return (row * 1000000) + column;
};
var $jfmengels$elm_review$Review$Project$Internal$sanitizeModule = function (ast) {
	return _Utils_update(
		ast,
		{
			comments: A2(
				$elm$core$List$sortBy,
				function (_v0) {
					var range = _v0.a;
					return $jfmengels$elm_review$Review$Project$Internal$positionAsInt(range.start);
				},
				ast.comments)
		});
};
var $jfmengels$elm_review$Vendor$Zipper$prev = function (_v0) {
	var p = _v0.a;
	var f = _v0.b;
	var n = _v0.c;
	if (!p.b) {
		return $elm$core$Maybe$Nothing;
	} else {
		var h = p.a;
		var t = p.b;
		return $elm$core$Maybe$Just(
			A3(
				$jfmengels$elm_review$Vendor$Zipper$Zipper,
				t,
				h,
				A2($elm$core$List$cons, f, n)));
	}
};
var $jfmengels$elm_review$Vendor$Zipper$toEndHelper = F2(
	function (f, acc) {
		toEndHelper:
		while (true) {
			var _v0 = f(acc);
			if (_v0.$ === 'Just') {
				var val = _v0.a;
				var $temp$f = f,
					$temp$acc = val;
				f = $temp$f;
				acc = $temp$acc;
				continue toEndHelper;
			} else {
				return acc;
			}
		}
	});
var $jfmengels$elm_review$Vendor$Zipper$start = $jfmengels$elm_review$Vendor$Zipper$toEndHelper($jfmengels$elm_review$Vendor$Zipper$prev);
var $jfmengels$elm_review$Review$Project$Valid$unsafeCreateZipper = function (sortedModules) {
	unsafeCreateZipper:
	while (true) {
		var _v0 = $jfmengels$elm_review$Vendor$Zipper$fromList(sortedModules);
		if (_v0.$ === 'Just') {
			var zipper = _v0.a;
			return zipper;
		} else {
			var $temp$sortedModules = sortedModules;
			sortedModules = $temp$sortedModules;
			continue unsafeCreateZipper;
		}
	}
};
var $jfmengels$elm_review$Review$Project$Valid$addParsedModule = F3(
	function (_v0, maybeModuleZipper, _v1) {
		var path = _v0.path;
		var source = _v0.source;
		var ast = _v0.ast;
		var project = _v1.a;
		var _v2 = A2($elm$core$Dict$get, path, project.modulesByPath);
		if (_v2.$ === 'Just') {
			var existingModule = _v2.a;
			var osAgnosticPath = $jfmengels$elm_review$Path$makeOSAgnostic(path);
			var module_ = {
				ast: $jfmengels$elm_review$Review$Project$Internal$sanitizeModule(ast),
				contentHash: $jfmengels$elm_review$Review$Cache$ContentHash$hash(source),
				isInSourceDirectories: A2(
					$elm$core$List$any,
					function (dir) {
						return A2(
							$elm$core$String$startsWith,
							$jfmengels$elm_review$Path$makeOSAgnostic(dir),
							osAgnosticPath);
					},
					project.sourceDirectories),
				path: path,
				source: source
			};
			var newProject = _Utils_update(
				project,
				{
					modulesByPath: A3($elm$core$Dict$insert, path, module_, project.modulesByPath)
				});
			if (_Utils_eq(
				A2($jfmengels$elm_review$Review$Project$Valid$importedModulesSet, existingModule.ast, project.dependencyModules),
				A2($jfmengels$elm_review$Review$Project$Valid$importedModulesSet, ast, project.dependencyModules))) {
				var newModuleZipper = function () {
					if (maybeModuleZipper.$ === 'Just') {
						var moduleZipper_ = maybeModuleZipper.a;
						return moduleZipper_;
					} else {
						var moduleZipper_ = $jfmengels$elm_review$Review$Project$Valid$unsafeCreateZipper(newProject.sortedModules);
						return A2(
							$elm$core$Maybe$withDefault,
							moduleZipper_,
							A2(
								$jfmengels$elm_review$Vendor$Zipper$focusr,
								function (mod) {
									return _Utils_eq(mod.node.label, path);
								},
								moduleZipper_));
					}
				}();
				return $elm$core$Maybe$Just(
					_Utils_Tuple2(
						$jfmengels$elm_review$Review$Project$Valid$ValidProject(newProject),
						newModuleZipper));
			} else {
				var graph = $jfmengels$elm_review$Review$Project$Valid$buildModuleGraph(newProject.modulesByPath);
				var _v4 = $jfmengels$elm_review$Vendor$Graph$checkAcyclic(graph);
				if (_v4.$ === 'Err') {
					return $elm$core$Maybe$Nothing;
				} else {
					var acyclicGraph = _v4.a;
					var sortedModules = $jfmengels$elm_review$Vendor$Graph$topologicalSort(acyclicGraph);
					var moduleZipper_ = $jfmengels$elm_review$Review$Project$Valid$unsafeCreateZipper(sortedModules);
					var newModuleZipper = function () {
						if (maybeModuleZipper.$ === 'Just') {
							var prevModuleZipper = maybeModuleZipper.a;
							return A3(
								$jfmengels$elm_review$Review$Project$Valid$advanceZipper,
								path,
								$jfmengels$elm_review$Vendor$Zipper$start(prevModuleZipper),
								moduleZipper_);
						} else {
							return A2(
								$elm$core$Maybe$withDefault,
								moduleZipper_,
								A2(
									$jfmengels$elm_review$Vendor$Zipper$focusr,
									function (mod) {
										return _Utils_eq(mod.node.label, path);
									},
									moduleZipper_));
						}
					}();
					return $elm$core$Maybe$Just(
						_Utils_Tuple2(
							$jfmengels$elm_review$Review$Project$Valid$ValidProject(
								_Utils_update(
									newProject,
									{moduleGraph: graph, sortedModules: sortedModules})),
							newModuleZipper));
				}
			}
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $jfmengels$elm_review$Review$Project$Valid$addReadme = F2(
	function (readme_, _v0) {
		var project = _v0.a;
		return $jfmengels$elm_review$Review$Project$Valid$ValidProject(
			_Utils_update(
				project,
				{
					readme: $elm$core$Maybe$Just(
						_Utils_Tuple2(
							readme_,
							$jfmengels$elm_review$Review$Cache$ContentHash$hash(readme_.content)))
				}));
	});
var $jfmengels$elm_review$Review$Project$Valid$elmJson = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$first, project.elmJson);
};
var $jfmengels$elm_review$Review$Fix$Internal$tryToApplyFix = F2(
	function (fixes, sourceCode) {
		if ($jfmengels$elm_review$Review$Fix$Internal$containRangeCollisions(fixes)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var resultAfterFix = A2(
				$elm$core$String$join,
				'\n',
				A3(
					$elm$core$List$foldl,
					$jfmengels$elm_review$Review$Fix$Internal$applyFix,
					$elm$core$String$lines(sourceCode),
					A2(
						$elm$core$List$sortBy,
						A2($elm$core$Basics$composeR, $jfmengels$elm_review$Review$Fix$Internal$rangePosition, $elm$core$Basics$negate),
						fixes)));
			return _Utils_eq(sourceCode, resultAfterFix) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(resultAfterFix);
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$fixElmJson = F2(
	function (fixes, originalSourceCode) {
		var _v0 = A2($jfmengels$elm_review$Review$Fix$Internal$tryToApplyFix, fixes, originalSourceCode);
		if (_v0.$ === 'Just') {
			var resultAfterFix = _v0.a;
			var _v1 = A2($elm$json$Json$Decode$decodeString, $elm$project_metadata_utils$Elm$Project$decoder, resultAfterFix);
			if (_v1.$ === 'Ok') {
				var project = _v1.a;
				return $elm$core$Maybe$Just(
					{project: project, raw: resultAfterFix});
			} else {
				return $elm$core$Maybe$Nothing;
			}
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $stil4m$elm_syntax$Elm$Processing$ProcessContext = function (a) {
	return {$: 'ProcessContext', a: a};
};
var $stil4m$elm_syntax$Elm$Processing$addDependency = F2(
	function (dep, _v0) {
		var x = _v0.a;
		return $stil4m$elm_syntax$Elm$Processing$ProcessContext(
			A2($elm$core$Dict$union, dep.interfaces, x));
	});
var $stil4m$elm_syntax$Elm$Interface$Operator = function (a) {
	return {$: 'Operator', a: a};
};
var $jfmengels$elm_review$Review$Dependencies$elmCore = {
	interfaces: $elm$core$Dict$fromList(
		_List_fromArray(
			[
				_Utils_Tuple2(
				_List_fromArray(
					['Basics']),
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'apL'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '<|'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 0)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'apR'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '|>'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 0)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'or'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '||'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 2)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'and'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '&&'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 3)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'eq'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '=='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'neq'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '/='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'lt'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '<'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'gt'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '>'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'le'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '<='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Non),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'ge'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '>='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 4)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'append'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '++'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 5)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'add'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '+'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 6)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'sub'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '-'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 6)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'mul'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '*'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 7)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'fdiv'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '/'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 7)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'idiv'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '//'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 7)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'pow'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '^'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 8)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'composeL'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '<<'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 9)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'composeR'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '>>'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 9)
						})
					])),
				_Utils_Tuple2(
				_List_fromArray(
					['List']),
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'cons'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '::'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 5)
						})
					]))
			])),
	name: 'elm/core',
	version: '1.0.0'
};
var $jfmengels$elm_review$Review$Dependencies$elmParser = {
	interfaces: $elm$core$Dict$fromList(
		_List_fromArray(
			[
				_Utils_Tuple2(
				_List_fromArray(
					['Parser']),
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'keeper'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '|='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 5)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'ignorer'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '|.'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 6)
						})
					])),
				_Utils_Tuple2(
				_List_fromArray(
					['Parser', 'Advanced']),
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'keeper'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '|='),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 5)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'ignorer'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '|.'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 6)
						})
					]))
			])),
	name: 'elm/parser',
	version: '1.0.0'
};
var $jfmengels$elm_review$Review$Dependencies$elmUrl = {
	interfaces: $elm$core$Dict$fromList(
		_List_fromArray(
			[
				_Utils_Tuple2(
				_List_fromArray(
					['Url', 'Parser']),
				_List_fromArray(
					[
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Right),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'slash'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '</>'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 7)
						}),
						$stil4m$elm_syntax$Elm$Interface$Operator(
						{
							direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
							_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'questionMark'),
							operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, '<?>'),
							precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 8)
						})
					]))
			])),
	name: 'elm/url',
	version: '1.0.0'
};
var $stil4m$elm_syntax$Elm$Processing$init = $stil4m$elm_syntax$Elm$Processing$ProcessContext($elm$core$Dict$empty);
var $jfmengels$elm_review$Review$FileParser$elmProcessContext = A2(
	$stil4m$elm_syntax$Elm$Processing$addDependency,
	$jfmengels$elm_review$Review$Dependencies$elmParser,
	A2(
		$stil4m$elm_syntax$Elm$Processing$addDependency,
		$jfmengels$elm_review$Review$Dependencies$elmUrl,
		A2($stil4m$elm_syntax$Elm$Processing$addDependency, $jfmengels$elm_review$Review$Dependencies$elmCore, $stil4m$elm_syntax$Elm$Processing$init)));
var $stil4m$elm_syntax$Elm$Processing$findDocumentationForRange = F3(
	function (range, comments, previousComments) {
		findDocumentationForRange:
		while (true) {
			if (!comments.b) {
				return _Utils_Tuple3(previousComments, $elm$core$Maybe$Nothing, _List_Nil);
			} else {
				var comment = comments.a;
				var commentRange = comment.a;
				var commentText = comment.b;
				var restOfComments = comments.b;
				var _v1 = A2($elm$core$Basics$compare, commentRange.end.row + 1, range.start.row);
				switch (_v1.$) {
					case 'EQ':
						return A2($elm$core$String$startsWith, '{-|', commentText) ? _Utils_Tuple3(
							previousComments,
							$elm$core$Maybe$Just(comment),
							restOfComments) : _Utils_Tuple3(
							previousComments,
							$elm$core$Maybe$Nothing,
							A2($elm$core$List$cons, comment, restOfComments));
					case 'LT':
						var $temp$range = range,
							$temp$comments = restOfComments,
							$temp$previousComments = A2($elm$core$List$cons, comment, previousComments);
						range = $temp$range;
						comments = $temp$comments;
						previousComments = $temp$previousComments;
						continue findDocumentationForRange;
					default:
						return _Utils_Tuple3(
							previousComments,
							$elm$core$Maybe$Nothing,
							A2($elm$core$List$cons, comment, restOfComments));
				}
			}
		}
	});
var $stil4m$elm_syntax$Elm$Processing$addDocumentation = F3(
	function (howToUpdate, declaration, file) {
		var _v0 = A3(
			$stil4m$elm_syntax$Elm$Processing$findDocumentationForRange,
			$stil4m$elm_syntax$Elm$Syntax$Node$range(declaration),
			file.remainingComments,
			_List_Nil);
		var previous = _v0.a;
		var maybeDoc = _v0.b;
		var remaining = _v0.c;
		if (maybeDoc.$ === 'Just') {
			var doc = maybeDoc.a;
			return {
				declarations: A2(
					$elm$core$List$cons,
					A2(
						$stil4m$elm_syntax$Elm$Syntax$Node$Node,
						$stil4m$elm_syntax$Elm$Syntax$Range$combine(
							_List_fromArray(
								[
									$stil4m$elm_syntax$Elm$Syntax$Node$range(doc),
									$stil4m$elm_syntax$Elm$Syntax$Node$range(declaration)
								])),
						howToUpdate(doc)),
					file.declarations),
				previousComments: A2($elm$core$List$cons, previous, file.previousComments),
				remainingComments: remaining
			};
		} else {
			return {
				declarations: A2($elm$core$List$cons, declaration, file.declarations),
				previousComments: A2($elm$core$List$cons, previous, file.previousComments),
				remainingComments: remaining
			};
		}
	});
var $stil4m$elm_syntax$Elm$Syntax$Expression$OperatorApplication = F4(
	function (a, b, c, d) {
		return {$: 'OperatorApplication', a: a, b: b, c: c, d: d};
	});
var $stil4m$elm_syntax$Elm$Processing$expressionOperators = function (_v0) {
	var expression = _v0.b;
	if (expression.$ === 'Operator') {
		var s = expression.a;
		return $elm$core$Maybe$Just(s);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $elm_community$list_extra$List$Extra$dropWhile = F2(
	function (predicate, list) {
		dropWhile:
		while (true) {
			if (!list.b) {
				return _List_Nil;
			} else {
				var x = list.a;
				var xs = list.b;
				if (predicate(x)) {
					var $temp$predicate = predicate,
						$temp$list = xs;
					predicate = $temp$predicate;
					list = $temp$list;
					continue dropWhile;
				} else {
					return list;
				}
			}
		}
	});
var $elm_community$list_extra$List$Extra$takeWhile = function (predicate) {
	var takeWhileMemo = F2(
		function (memo, list) {
			takeWhileMemo:
			while (true) {
				if (!list.b) {
					return $elm$core$List$reverse(memo);
				} else {
					var x = list.a;
					var xs = list.b;
					if (predicate(x)) {
						var $temp$memo = A2($elm$core$List$cons, x, memo),
							$temp$list = xs;
						memo = $temp$memo;
						list = $temp$list;
						continue takeWhileMemo;
					} else {
						return $elm$core$List$reverse(memo);
					}
				}
			}
		});
	return takeWhileMemo(_List_Nil);
};
var $stil4m$elm_syntax$Elm$Processing$findNextSplit = F2(
	function (dict, exps) {
		var assocDirection = A2(
			$elm$core$Maybe$withDefault,
			$stil4m$elm_syntax$Elm$Syntax$Infix$Right,
			A2(
				$elm$core$Maybe$map,
				$stil4m$elm_syntax$Elm$Syntax$Node$value,
				$elm$core$List$head(
					A2(
						$elm$core$List$map,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Tuple$second,
							function ($) {
								return $.direction;
							}),
						$elm$core$Dict$toList(dict)))));
		var prefix = function () {
			if (assocDirection.$ === 'Left') {
				return $elm$core$List$reverse(
					A2(
						$elm$core$List$drop,
						1,
						A2(
							$elm_community$list_extra$List$Extra$dropWhile,
							function (x) {
								return _Utils_eq(
									$elm$core$Maybe$Nothing,
									A2(
										$elm$core$Maybe$andThen,
										function (key) {
											return A2($elm$core$Dict$get, key, dict);
										},
										$stil4m$elm_syntax$Elm$Processing$expressionOperators(x)));
							},
							$elm$core$List$reverse(exps))));
			} else {
				return A2(
					$elm_community$list_extra$List$Extra$takeWhile,
					function (x) {
						return _Utils_eq(
							$elm$core$Maybe$Nothing,
							A2(
								$elm$core$Maybe$andThen,
								function (key) {
									return A2($elm$core$Dict$get, key, dict);
								},
								$stil4m$elm_syntax$Elm$Processing$expressionOperators(x)));
					},
					exps);
			}
		}();
		var suffix = A2(
			$elm$core$List$drop,
			$elm$core$List$length(prefix) + 1,
			exps);
		return A2(
			$elm$core$Maybe$map,
			function (x) {
				return _Utils_Tuple3(prefix, x, suffix);
			},
			A2(
				$elm$core$Maybe$andThen,
				function (x) {
					return A2($elm$core$Dict$get, x, dict);
				},
				A2(
					$elm$core$Maybe$andThen,
					$stil4m$elm_syntax$Elm$Processing$expressionOperators,
					$elm$core$List$head(
						A2(
							$elm$core$List$drop,
							$elm$core$List$length(prefix),
							exps)))));
	});
var $elm$core$Basics$min = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) < 0) ? x : y;
	});
var $elm$core$List$minimum = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(
			A3($elm$core$List$foldl, $elm$core$Basics$min, x, xs));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $stil4m$elm_syntax$Elm$Processing$lowestPrecedence = function (input) {
	return $elm$core$Dict$fromList(
		A2(
			$elm$core$Maybe$withDefault,
			_List_Nil,
			A2(
				$elm$core$Maybe$map,
				function (m) {
					return A2(
						$elm$core$List$filter,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Tuple$second,
							A2(
								$elm$core$Basics$composeR,
								function ($) {
									return $.precedence;
								},
								A2(
									$elm$core$Basics$composeR,
									$stil4m$elm_syntax$Elm$Syntax$Node$value,
									$elm$core$Basics$eq(m)))),
						input);
				},
				$elm$core$List$minimum(
					A2(
						$elm$core$List$map,
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Tuple$second,
							A2(
								$elm$core$Basics$composeR,
								function ($) {
									return $.precedence;
								},
								$stil4m$elm_syntax$Elm$Syntax$Node$value)),
						input)))));
};
var $stil4m$elm_syntax$Elm$Processing$fixApplication = F2(
	function (operators, expressions) {
		var ops = $stil4m$elm_syntax$Elm$Processing$lowestPrecedence(
			A2(
				$elm$core$List$map,
				function (x) {
					return _Utils_Tuple2(
						x,
						A2(
							$elm$core$Maybe$withDefault,
							{
								direction: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, $stil4m$elm_syntax$Elm$Syntax$Infix$Left),
								_function: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 'todo'),
								operator: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, x),
								precedence: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, 5)
							},
							A2($elm$core$Dict$get, x, operators)));
				},
				A2($elm$core$List$filterMap, $stil4m$elm_syntax$Elm$Processing$expressionOperators, expressions)));
		var fixExprs = function (exps) {
			if (exps.b && (!exps.b.b)) {
				var _v2 = exps.a;
				var x = _v2.b;
				return x;
			} else {
				return $stil4m$elm_syntax$Elm$Syntax$Expression$Application(exps);
			}
		};
		var divideAndConquer = function (exps) {
			return $elm$core$Dict$isEmpty(ops) ? fixExprs(exps) : A2(
				$elm$core$Maybe$withDefault,
				fixExprs(exps),
				A2(
					$elm$core$Maybe$map,
					function (_v0) {
						var p = _v0.a;
						var infix_ = _v0.b;
						var s = _v0.c;
						return A4(
							$stil4m$elm_syntax$Elm$Syntax$Expression$OperatorApplication,
							$stil4m$elm_syntax$Elm$Syntax$Node$value(infix_.operator),
							$stil4m$elm_syntax$Elm$Syntax$Node$value(infix_.direction),
							A2(
								$stil4m$elm_syntax$Elm$Syntax$Node$Node,
								$stil4m$elm_syntax$Elm$Syntax$Range$combine(
									A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, p)),
								divideAndConquer(p)),
							A2(
								$stil4m$elm_syntax$Elm$Syntax$Node$Node,
								$stil4m$elm_syntax$Elm$Syntax$Range$combine(
									A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$range, s)),
								divideAndConquer(s)));
					},
					A2($stil4m$elm_syntax$Elm$Processing$findNextSplit, ops, exps)));
		};
		return divideAndConquer(expressions);
	});
var $stil4m$elm_syntax$Elm$Processing$visitExpression = F2(
	function (table, expression) {
		return A2(
			$stil4m$elm_syntax$Elm$Processing$visitExpressionInner,
			table,
			function () {
				if (expression.b.$ === 'Application') {
					var r = expression.a;
					var args = expression.b.a;
					return A2(
						$stil4m$elm_syntax$Elm$Syntax$Node$Node,
						r,
						A2($stil4m$elm_syntax$Elm$Processing$fixApplication, table, args));
				} else {
					return expression;
				}
			}());
	});
var $stil4m$elm_syntax$Elm$Processing$visitExpressionInner = F2(
	function (table, _v2) {
		var range = _v2.a;
		var expression = _v2.b;
		return A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			range,
			function () {
				switch (expression.$) {
					case 'Application':
						var expressionList = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$Application(
							A2(
								$elm$core$List$map,
								$stil4m$elm_syntax$Elm$Processing$visitExpression(table),
								expressionList));
					case 'OperatorApplication':
						var op = expression.a;
						var dir = expression.b;
						var left = expression.c;
						var right = expression.d;
						return A4(
							$stil4m$elm_syntax$Elm$Syntax$Expression$OperatorApplication,
							op,
							dir,
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, left),
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, right));
					case 'IfBlock':
						var e1 = expression.a;
						var e2 = expression.b;
						var e3 = expression.c;
						return A3(
							$stil4m$elm_syntax$Elm$Syntax$Expression$IfBlock,
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, e1),
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, e2),
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, e3));
					case 'TupledExpression':
						var expressionList = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$TupledExpression(
							A2(
								$elm$core$List$map,
								$stil4m$elm_syntax$Elm$Processing$visitExpression(table),
								expressionList));
					case 'ParenthesizedExpression':
						var expr1 = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$ParenthesizedExpression(
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, expr1));
					case 'LetExpression':
						var letBlock = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$LetExpression(
							{
								declarations: A2($stil4m$elm_syntax$Elm$Processing$visitLetDeclarations, table, letBlock.declarations),
								expression: A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, letBlock.expression)
							});
					case 'CaseExpression':
						var caseBlock = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$CaseExpression(
							{
								cases: A2(
									$elm$core$List$map,
									$elm$core$Tuple$mapSecond(
										$stil4m$elm_syntax$Elm$Processing$visitExpression(table)),
									caseBlock.cases),
								expression: A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, caseBlock.expression)
							});
					case 'LambdaExpression':
						var lambda = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$LambdaExpression(
							_Utils_update(
								lambda,
								{
									expression: A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, lambda.expression)
								}));
					case 'RecordExpr':
						var expressionStringList = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$RecordExpr(
							A2(
								$elm$core$List$map,
								$stil4m$elm_syntax$Elm$Syntax$Node$map(
									$elm$core$Tuple$mapSecond(
										$stil4m$elm_syntax$Elm$Processing$visitExpression(table))),
								expressionStringList));
					case 'ListExpr':
						var expressionList = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$ListExpr(
							A2(
								$elm$core$List$map,
								$stil4m$elm_syntax$Elm$Processing$visitExpression(table),
								expressionList));
					case 'RecordUpdateExpression':
						var name = expression.a;
						var updates = expression.b;
						return A2(
							$stil4m$elm_syntax$Elm$Syntax$Expression$RecordUpdateExpression,
							name,
							A2(
								$elm$core$List$map,
								$stil4m$elm_syntax$Elm$Syntax$Node$map(
									$elm$core$Tuple$mapSecond(
										$stil4m$elm_syntax$Elm$Processing$visitExpression(table))),
								updates));
					case 'Negation':
						var expr = expression.a;
						return $stil4m$elm_syntax$Elm$Syntax$Expression$Negation(
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, expr));
					case 'RecordAccess':
						var expr = expression.a;
						var name = expression.b;
						return A2(
							$stil4m$elm_syntax$Elm$Syntax$Expression$RecordAccess,
							A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, expr),
							name);
					default:
						return expression;
				}
			}());
	});
var $stil4m$elm_syntax$Elm$Processing$visitFunctionDecl = F2(
	function (table, _function) {
		var newFunctionDeclaration = A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$map,
			$stil4m$elm_syntax$Elm$Processing$visitFunctionDeclaration(table),
			_function.declaration);
		return _Utils_update(
			_function,
			{declaration: newFunctionDeclaration});
	});
var $stil4m$elm_syntax$Elm$Processing$visitFunctionDeclaration = F2(
	function (table, functionDeclaration) {
		var newExpression = A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, functionDeclaration.expression);
		return _Utils_update(
			functionDeclaration,
			{expression: newExpression});
	});
var $stil4m$elm_syntax$Elm$Processing$visitLetDeclaration = F2(
	function (table, _v0) {
		var range = _v0.a;
		var declaration = _v0.b;
		return A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			range,
			function () {
				if (declaration.$ === 'LetFunction') {
					var _function = declaration.a;
					return $stil4m$elm_syntax$Elm$Syntax$Expression$LetFunction(
						A2($stil4m$elm_syntax$Elm$Processing$visitFunctionDecl, table, _function));
				} else {
					var pattern = declaration.a;
					var expression = declaration.b;
					return A2(
						$stil4m$elm_syntax$Elm$Syntax$Expression$LetDestructuring,
						pattern,
						A2($stil4m$elm_syntax$Elm$Processing$visitExpression, table, expression));
				}
			}());
	});
var $stil4m$elm_syntax$Elm$Processing$visitLetDeclarations = F2(
	function (table, declarations) {
		return A2(
			$elm$core$List$map,
			$stil4m$elm_syntax$Elm$Processing$visitLetDeclaration(table),
			declarations);
	});
var $stil4m$elm_syntax$Elm$Processing$attachDocumentationAndFixOperators = F3(
	function (table, declaration, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
		switch (_v0.$) {
			case 'FunctionDeclaration':
				var functionBeforeOperatorFix = _v0.a;
				var _function = A2($stil4m$elm_syntax$Elm$Processing$visitFunctionDecl, table, functionBeforeOperatorFix);
				return A3(
					$stil4m$elm_syntax$Elm$Processing$addDocumentation,
					function (doc) {
						return $stil4m$elm_syntax$Elm$Syntax$Declaration$FunctionDeclaration(
							_Utils_update(
								_function,
								{
									documentation: $elm$core$Maybe$Just(doc)
								}));
					},
					A2(
						$stil4m$elm_syntax$Elm$Syntax$Node$Node,
						$stil4m$elm_syntax$Elm$Syntax$Node$range(declaration),
						$stil4m$elm_syntax$Elm$Syntax$Declaration$FunctionDeclaration(_function)),
					context);
			case 'AliasDeclaration':
				var typeAlias = _v0.a;
				return A3(
					$stil4m$elm_syntax$Elm$Processing$addDocumentation,
					function (doc) {
						return $stil4m$elm_syntax$Elm$Syntax$Declaration$AliasDeclaration(
							_Utils_update(
								typeAlias,
								{
									documentation: $elm$core$Maybe$Just(doc)
								}));
					},
					declaration,
					context);
			case 'CustomTypeDeclaration':
				var typeDecl = _v0.a;
				return A3(
					$stil4m$elm_syntax$Elm$Processing$addDocumentation,
					function (doc) {
						return $stil4m$elm_syntax$Elm$Syntax$Declaration$CustomTypeDeclaration(
							_Utils_update(
								typeDecl,
								{
									documentation: $elm$core$Maybe$Just(doc)
								}));
					},
					declaration,
					context);
			case 'PortDeclaration':
				return {
					declarations: A2($elm$core$List$cons, declaration, context.declarations),
					previousComments: context.previousComments,
					remainingComments: context.remainingComments
				};
			case 'InfixDeclaration':
				return {
					declarations: A2($elm$core$List$cons, declaration, context.declarations),
					previousComments: context.previousComments,
					remainingComments: context.remainingComments
				};
			default:
				return {
					declarations: A2($elm$core$List$cons, declaration, context.declarations),
					previousComments: context.previousComments,
					remainingComments: context.remainingComments
				};
		}
	});
var $stil4m$elm_syntax$Elm$Interface$operators = $elm$core$List$filterMap(
	function (_interface) {
		if (_interface.$ === 'Operator') {
			var operator = _interface.a;
			return $elm$core$Maybe$Just(operator);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $stil4m$elm_syntax$Elm$Syntax$Exposing$operator = function (t) {
	if (t.$ === 'InfixExpose') {
		var s = t.a;
		return $elm$core$Maybe$Just(s);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $stil4m$elm_syntax$Elm$Syntax$Exposing$operators = function (l) {
	return A2($elm$core$List$filterMap, $stil4m$elm_syntax$Elm$Syntax$Exposing$operator, l);
};
var $stil4m$elm_syntax$Elm$Processing$buildSingle = F2(
	function (moduleIndex, imp) {
		var _v0 = A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, imp.exposingList);
		if (_v0.$ === 'Nothing') {
			return _List_Nil;
		} else {
			if (_v0.a.$ === 'All') {
				var _v1 = A2(
					$elm$core$Dict$get,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(imp.moduleName),
					moduleIndex);
				if (_v1.$ === 'Just') {
					var module_ = _v1.a;
					return $stil4m$elm_syntax$Elm$Interface$operators(module_);
				} else {
					return _List_Nil;
				}
			} else {
				var l = _v0.a.a;
				var _v2 = A2(
					$elm$core$Dict$get,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(imp.moduleName),
					moduleIndex);
				if (_v2.$ === 'Just') {
					var module_ = _v2.a;
					var importedOperators = $stil4m$elm_syntax$Elm$Syntax$Exposing$operators(
						A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, l));
					return A2(
						$elm$core$List$filter,
						function (elem) {
							return A2(
								$elm$core$List$member,
								$stil4m$elm_syntax$Elm$Syntax$Node$value(elem.operator),
								importedOperators);
						},
						$stil4m$elm_syntax$Elm$Interface$operators(module_));
				} else {
					return _List_Nil;
				}
			}
		}
	});
var $stil4m$elm_syntax$Elm$DefaultImports$defaults = _List_fromArray(
	[
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$All($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Basics']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2($stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType, 'List', $elm$core$Maybe$Nothing))),
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$InfixExpose('::'))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['List']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType,
									'Maybe',
									$elm$core$Maybe$Just($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange))))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Maybe']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType,
									'Result',
									$elm$core$Maybe$Just($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange))))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Result']))
	},
		{
		exposingList: $elm$core$Maybe$Nothing,
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['String']))
	},
		{
		exposingList: $elm$core$Maybe$Nothing,
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Tuple']))
	},
		{
		exposingList: $elm$core$Maybe$Nothing,
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Debug']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2($stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType, 'Program', $elm$core$Maybe$Nothing)))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Platform']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2($stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType, 'Cmd', $elm$core$Maybe$Nothing))),
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$InfixExpose('!'))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Platform', 'Cmd']))
	},
		{
		exposingList: $elm$core$Maybe$Just(
			A2(
				$stil4m$elm_syntax$Elm$Syntax$Node$Node,
				$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
				$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
								A2($stil4m$elm_syntax$Elm$Syntax$Exposing$ExposedType, 'Sub', $elm$core$Maybe$Nothing)))
						])))),
		moduleAlias: $elm$core$Maybe$Nothing,
		moduleName: A2(
			$stil4m$elm_syntax$Elm$Syntax$Node$Node,
			$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
			_List_fromArray(
				['Platform', 'Sub']))
	}
	]);
var $stil4m$elm_syntax$Elm$RawFile$imports = function (_v0) {
	var file = _v0.a;
	return A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, file.imports);
};
var $stil4m$elm_syntax$Elm$Processing$tableForFile = F2(
	function (rawFile, _v0) {
		var moduleIndex = _v0.a;
		return $elm$core$Dict$fromList(
			A2(
				$elm$core$List$map,
				function (x) {
					return _Utils_Tuple2(
						$stil4m$elm_syntax$Elm$Syntax$Node$value(x.operator),
						x);
				},
				A2(
					$elm$core$List$concatMap,
					$stil4m$elm_syntax$Elm$Processing$buildSingle(moduleIndex),
					_Utils_ap(
						$stil4m$elm_syntax$Elm$DefaultImports$defaults,
						$stil4m$elm_syntax$Elm$RawFile$imports(rawFile)))));
	});
var $stil4m$elm_syntax$Elm$Processing$process = F2(
	function (processContext, rawFile) {
		var file = rawFile.a;
		var table = A2($stil4m$elm_syntax$Elm$Processing$tableForFile, rawFile, processContext);
		var changes = A3(
			$elm$core$List$foldl,
			$stil4m$elm_syntax$Elm$Processing$attachDocumentationAndFixOperators(table),
			{declarations: _List_Nil, previousComments: _List_Nil, remainingComments: file.comments},
			file.declarations);
		return {
			comments: $elm$core$List$concat(
				$elm$core$List$reverse(
					A2($elm$core$List$cons, changes.remainingComments, changes.previousComments))),
			declarations: $elm$core$List$reverse(changes.declarations),
			imports: file.imports,
			moduleDefinition: file.moduleDefinition
		};
	});
var $jfmengels$elm_review$Review$FileParser$parse = function (source) {
	var _v0 = $stil4m$elm_syntax$Elm$Parser$parse(source);
	if (_v0.$ === 'Ok') {
		var file = _v0.a;
		return $elm$core$Result$Ok(
			A2($stil4m$elm_syntax$Elm$Processing$process, $jfmengels$elm_review$Review$FileParser$elmProcessContext, file));
	} else {
		return $elm$core$Result$Err(_Utils_Tuple0);
	}
};
var $jfmengels$elm_review$Review$Fix$Internal$fixModule = F2(
	function (fixes, originalSourceCode) {
		var _v0 = A2($jfmengels$elm_review$Review$Fix$Internal$tryToApplyFix, fixes, originalSourceCode);
		if (_v0.$ === 'Just') {
			var fixedSourceCode = _v0.a;
			var _v1 = $jfmengels$elm_review$Review$FileParser$parse(fixedSourceCode);
			if (_v1.$ === 'Ok') {
				var ast = _v1.a;
				return $elm$core$Maybe$Just(
					{ast: ast, source: fixedSourceCode});
			} else {
				return $elm$core$Maybe$Nothing;
			}
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$fixReadme = F2(
	function (fixes, originalSourceCode) {
		return A2($jfmengels$elm_review$Review$Fix$Internal$tryToApplyFix, fixes, originalSourceCode);
	});
var $jfmengels$elm_review$Review$Project$Valid$getModuleByPath = F2(
	function (path, _v0) {
		var project = _v0.a;
		return A2($elm$core$Dict$get, path, project.modulesByPath);
	});
var $jfmengels$elm_review$Review$Rule$isFixable = F2(
	function (predicate, err) {
		var _v0 = err.fixes;
		if (_v0.$ === 'Just') {
			return predicate(
				{details: err.details, filePath: err.filePath, message: err.message, range: err.range, ruleName: err.ruleName}) ? err.fixes : $elm$core$Maybe$Nothing;
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $jfmengels$elm_review$Review$Project$Valid$readme = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$first, project.readme);
};
var $jfmengels$elm_review$Review$Rule$findFixHelp = F4(
	function (project, fixablePredicate, errors, maybeModuleZipper) {
		findFixHelp:
		while (true) {
			if (!errors.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var headError = errors.a.a;
				var restOfErrors = errors.b;
				var _v1 = A2($jfmengels$elm_review$Review$Rule$isFixable, fixablePredicate, headError);
				if (_v1.$ === 'Nothing') {
					var $temp$project = project,
						$temp$fixablePredicate = fixablePredicate,
						$temp$errors = restOfErrors,
						$temp$maybeModuleZipper = maybeModuleZipper;
					project = $temp$project;
					fixablePredicate = $temp$fixablePredicate;
					errors = $temp$errors;
					maybeModuleZipper = $temp$maybeModuleZipper;
					continue findFixHelp;
				} else {
					var fixes = _v1.a;
					var _v2 = headError.target;
					switch (_v2.$) {
						case 'Module':
							var _v3 = A2($jfmengels$elm_review$Review$Project$Valid$getModuleByPath, headError.filePath, project);
							if (_v3.$ === 'Nothing') {
								var $temp$project = project,
									$temp$fixablePredicate = fixablePredicate,
									$temp$errors = restOfErrors,
									$temp$maybeModuleZipper = maybeModuleZipper;
								project = $temp$project;
								fixablePredicate = $temp$fixablePredicate;
								errors = $temp$errors;
								maybeModuleZipper = $temp$maybeModuleZipper;
								continue findFixHelp;
							} else {
								var file = _v3.a;
								var _v4 = A2(
									$elm$core$Maybe$andThen,
									function (fixResult) {
										return A2(
											$elm$core$Maybe$map,
											function (_v5) {
												var newProject = _v5.a;
												var newModuleZipper = _v5.b;
												return {
													error: $jfmengels$elm_review$Review$Rule$errorToReviewError(
														$jfmengels$elm_review$Review$Rule$Error(headError)),
													fixedFile: A2($jfmengels$elm_review$Review$Rule$FixedElmModule, fixResult, newModuleZipper),
													project: newProject
												};
											},
											A3(
												$jfmengels$elm_review$Review$Project$Valid$addParsedModule,
												{ast: fixResult.ast, path: headError.filePath, source: fixResult.source},
												maybeModuleZipper,
												project));
									},
									A2($jfmengels$elm_review$Review$Fix$Internal$fixModule, fixes, file.source));
								if (_v4.$ === 'Nothing') {
									var $temp$project = project,
										$temp$fixablePredicate = fixablePredicate,
										$temp$errors = restOfErrors,
										$temp$maybeModuleZipper = maybeModuleZipper;
									project = $temp$project;
									fixablePredicate = $temp$fixablePredicate;
									errors = $temp$errors;
									maybeModuleZipper = $temp$maybeModuleZipper;
									continue findFixHelp;
								} else {
									var fixResult = _v4.a;
									return $elm$core$Maybe$Just(fixResult);
								}
							}
						case 'ElmJson':
							var _v6 = $jfmengels$elm_review$Review$Project$Valid$elmJson(project);
							if (_v6.$ === 'Nothing') {
								var $temp$project = project,
									$temp$fixablePredicate = fixablePredicate,
									$temp$errors = restOfErrors,
									$temp$maybeModuleZipper = maybeModuleZipper;
								project = $temp$project;
								fixablePredicate = $temp$fixablePredicate;
								errors = $temp$errors;
								maybeModuleZipper = $temp$maybeModuleZipper;
								continue findFixHelp;
							} else {
								var elmJson = _v6.a;
								var _v7 = A2(
									$elm$core$Maybe$andThen,
									function (fixResult) {
										return A2(
											$jfmengels$elm_review$Review$Project$Valid$addElmJson,
											{path: elmJson.path, project: fixResult.project, raw: fixResult.raw},
											project);
									},
									A2($jfmengels$elm_review$Review$Fix$Internal$fixElmJson, fixes, elmJson.raw));
								if (_v7.$ === 'Nothing') {
									var $temp$project = project,
										$temp$fixablePredicate = fixablePredicate,
										$temp$errors = restOfErrors,
										$temp$maybeModuleZipper = maybeModuleZipper;
									project = $temp$project;
									fixablePredicate = $temp$fixablePredicate;
									errors = $temp$errors;
									maybeModuleZipper = $temp$maybeModuleZipper;
									continue findFixHelp;
								} else {
									var newProject = _v7.a;
									return $elm$core$Maybe$Just(
										{
											error: $jfmengels$elm_review$Review$Rule$errorToReviewError(
												$jfmengels$elm_review$Review$Rule$Error(headError)),
											fixedFile: $jfmengels$elm_review$Review$Rule$FixedElmJson,
											project: newProject
										});
								}
							}
						case 'Readme':
							var _v8 = $jfmengels$elm_review$Review$Project$Valid$readme(project);
							if (_v8.$ === 'Nothing') {
								var $temp$project = project,
									$temp$fixablePredicate = fixablePredicate,
									$temp$errors = restOfErrors,
									$temp$maybeModuleZipper = maybeModuleZipper;
								project = $temp$project;
								fixablePredicate = $temp$fixablePredicate;
								errors = $temp$errors;
								maybeModuleZipper = $temp$maybeModuleZipper;
								continue findFixHelp;
							} else {
								var readme = _v8.a;
								var _v9 = A2($jfmengels$elm_review$Review$Fix$Internal$fixReadme, fixes, readme.content);
								if (_v9.$ === 'Nothing') {
									var $temp$project = project,
										$temp$fixablePredicate = fixablePredicate,
										$temp$errors = restOfErrors,
										$temp$maybeModuleZipper = maybeModuleZipper;
									project = $temp$project;
									fixablePredicate = $temp$fixablePredicate;
									errors = $temp$errors;
									maybeModuleZipper = $temp$maybeModuleZipper;
									continue findFixHelp;
								} else {
									var content = _v9.a;
									return $elm$core$Maybe$Just(
										{
											error: $jfmengels$elm_review$Review$Rule$errorToReviewError(
												$jfmengels$elm_review$Review$Rule$Error(headError)),
											fixedFile: $jfmengels$elm_review$Review$Rule$FixedReadme,
											project: A2(
												$jfmengels$elm_review$Review$Project$Valid$addReadme,
												{content: content, path: readme.path},
												project)
										});
								}
							}
						default:
							var $temp$project = project,
								$temp$fixablePredicate = fixablePredicate,
								$temp$errors = restOfErrors,
								$temp$maybeModuleZipper = maybeModuleZipper;
							project = $temp$project;
							fixablePredicate = $temp$fixablePredicate;
							errors = $temp$errors;
							maybeModuleZipper = $temp$maybeModuleZipper;
							continue findFixHelp;
					}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$fixedError = F2(
	function (fixedErrors, data) {
		return _List_fromArray(
			[
				_Utils_Tuple2(
				'type',
				$elm$json$Json$Encode$string('apply-fix')),
				_Utils_Tuple2(
				'ruleName',
				$elm$json$Json$Encode$string(data.ruleName)),
				_Utils_Tuple2(
				'filePath',
				$elm$json$Json$Encode$string(data.filePath)),
				_Utils_Tuple2(
				'count',
				$elm$json$Json$Encode$int(
					$jfmengels$elm_review$Review$Fix$FixedErrors$count(fixedErrors)))
			]);
	});
var $elm$core$Dict$update = F3(
	function (targetKey, alter, dictionary) {
		var _v0 = alter(
			A2($elm$core$Dict$get, targetKey, dictionary));
		if (_v0.$ === 'Just') {
			var value = _v0.a;
			return A3($elm$core$Dict$insert, targetKey, value, dictionary);
		} else {
			return A2($elm$core$Dict$remove, targetKey, dictionary);
		}
	});
var $jfmengels$elm_review$Review$Fix$FixedErrors$insert = F2(
	function (error, _v0) {
		var filePath = error.a.filePath;
		var fixCount = _v0.a;
		var fixedErrors = _v0.b;
		return A2(
			$jfmengels$elm_review$Review$Fix$FixedErrors$FixedErrors,
			fixCount + 1,
			A3(
				$elm$core$Dict$update,
				filePath,
				function (errors) {
					return $elm$core$Maybe$Just(
						A2(
							$elm$core$List$cons,
							error,
							A2($elm$core$Maybe$withDefault, _List_Nil, errors)));
				},
				fixedErrors));
	});
var $jfmengels$elm_review$Review$Logger$log = F3(
	function (_v0, message, data) {
		var logFn = _v0.a;
		return A2(
			$elm$core$Basics$always,
			data,
			logFn(message));
	});
var $jfmengels$elm_review$Review$Options$Internal$shouldApplyFix = F2(
	function (projectVisitor, reviewOptionsData) {
		var _v0 = reviewOptionsData.fixMode;
		if (_v0.$ === 'Enabled') {
			return $elm$core$Dict$isEmpty(reviewOptionsData.suppressions) ? $elm$core$Maybe$Just(
				function (err) {
					return !reviewOptionsData.ignoreFix(err);
				}) : $elm$core$Maybe$Just(
				function (err) {
					return (!A2(
						$elm$core$Dict$member,
						_Utils_Tuple2(projectVisitor.name, err.filePath),
						reviewOptionsData.suppressions)) && (!reviewOptionsData.ignoreFix(err));
				});
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $jfmengels$elm_review$Review$Rule$findFix = F6(
	function (reviewOptions, projectVisitor, project, errors, fixedErrors, maybeModuleZipper) {
		return A2(
			$elm$core$Maybe$map,
			function (fixResult) {
				var newFixedErrors = A2($jfmengels$elm_review$Review$Fix$FixedErrors$insert, fixResult.error, fixedErrors);
				return A2($jfmengels$elm_review$Review$Options$Internal$shouldAbort, reviewOptions, newFixedErrors) ? _Utils_Tuple2(
					$jfmengels$elm_review$Review$Rule$ShouldAbort(newFixedErrors),
					fixResult) : A3(
					$jfmengels$elm_review$Review$Logger$log,
					reviewOptions.logger,
					A2(
						$jfmengels$elm_review$Review$Rule$fixedError,
						newFixedErrors,
						{
							filePath: $jfmengels$elm_review$Review$Rule$errorFilePath(fixResult.error),
							ruleName: projectVisitor.name
						}),
					_Utils_Tuple2(
						$jfmengels$elm_review$Review$Rule$ShouldContinue(newFixedErrors),
						fixResult));
			},
			A2(
				$elm$core$Maybe$andThen,
				function (fixablePredicate) {
					return A4($jfmengels$elm_review$Review$Rule$findFixHelp, project, fixablePredicate, errors, maybeModuleZipper);
				},
				A2($jfmengels$elm_review$Review$Options$Internal$shouldApplyFix, projectVisitor, reviewOptions)));
	});
var $jfmengels$elm_review$Review$Cache$ContextHash$areEqual = F2(
	function (_v0, _v1) {
		var a = _v0.a;
		var b = _v1.a;
		return _Utils_eq(a, b);
	});
var $jfmengels$elm_review$Review$Cache$ContentHash$areEqualForMaybe = F2(
	function (a, b) {
		var _v0 = _Utils_Tuple2(a, b);
		_v0$2:
		while (true) {
			if (_v0.a.$ === 'Just') {
				if (_v0.b.$ === 'Just') {
					var a_ = _v0.a.a;
					var b_ = _v0.b.a;
					return _Utils_eq(a_, b_);
				} else {
					break _v0$2;
				}
			} else {
				if (_v0.b.$ === 'Nothing') {
					var _v1 = _v0.a;
					var _v2 = _v0.b;
					return true;
				} else {
					break _v0$2;
				}
			}
		}
		return false;
	});
var $jfmengels$elm_review$Review$Cache$matchMaybe = F3(
	function (contentHash, context, _v0) {
		var entry = _v0.a;
		return A2($jfmengels$elm_review$Review$Cache$ContentHash$areEqualForMaybe, contentHash, entry.contentHash) && A2($jfmengels$elm_review$Review$Cache$ContextHash$areEqual, context, entry.inputContext);
	});
var $jfmengels$elm_review$Review$Project$Valid$moduleZipper = function (_v0) {
	var project = _v0.a;
	return $jfmengels$elm_review$Review$Project$Valid$unsafeCreateZipper(project.sortedModules);
};
var $jfmengels$elm_review$Review$Cache$outputContextMaybe = function (_v0) {
	var entry = _v0.a;
	return entry.outputContext;
};
var $jfmengels$elm_review$Review$Rule$reuseProjectRuleCache = F3(
	function (predicate, getter, cache) {
		var _v0 = getter(cache);
		if (_v0.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var value = _v0.a;
			return predicate(value) ? $elm$core$Maybe$Just(value) : $elm$core$Maybe$Nothing;
		}
	});
var $jfmengels$elm_review$Review$Rule$computeDependencies = F5(
	function (_v0, project, contexts, cache, fixedErrors) {
		var reviewOptions = _v0.reviewOptions;
		var projectVisitor = _v0.projectVisitor;
		var exceptions = _v0.exceptions;
		var modulesAsNextStep = function (projectContext) {
			return A2(
				$jfmengels$elm_review$Review$Rule$Modules,
				{deps: projectContext, elmJson: contexts.elmJson, initial: contexts.initial, readme: contexts.readme},
				$jfmengels$elm_review$Review$Project$Valid$moduleZipper(project));
		};
		var inputContext = contexts.readme;
		var cachePredicate = function (entry) {
			return A3(
				$jfmengels$elm_review$Review$Cache$matchMaybe,
				$jfmengels$elm_review$Review$Project$Valid$dependenciesHash(project),
				$jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext),
				entry);
		};
		var _v1 = A3(
			$jfmengels$elm_review$Review$Rule$reuseProjectRuleCache,
			cachePredicate,
			function ($) {
				return $.dependencies;
			},
			cache);
		if (_v1.$ === 'Just') {
			var entry = _v1.a;
			return {
				cache: cache,
				fixedErrors: fixedErrors,
				project: project,
				step: modulesAsNextStep(
					$jfmengels$elm_review$Review$Cache$outputContextMaybe(entry))
			};
		} else {
			var dependencies = $jfmengels$elm_review$Review$Project$Valid$dependencies(project);
			var accumulateWithDirectDependencies = function () {
				var _v9 = projectVisitor.directDependenciesVisitors;
				if (!_v9.b) {
					return $elm$core$Basics$identity;
				} else {
					var visitors = _v9;
					return A2(
						$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
						visitors,
						$jfmengels$elm_review$Review$Project$Valid$directDependencies(project));
				}
			}();
			var _v2 = A3(
				$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
				projectVisitor.dependenciesVisitors,
				dependencies,
				accumulateWithDirectDependencies(
					_Utils_Tuple2(_List_Nil, inputContext)));
			var errorsForVisitor = _v2.a;
			var outputContext = _v2.b;
			var errors = A3($jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName, exceptions, projectVisitor.name, errorsForVisitor);
			var updateCache = function (_v8) {
				var dependenciesEntry = $jfmengels$elm_review$Review$Cache$createEntryMaybe(
					{
						contentHash: $jfmengels$elm_review$Review$Project$Valid$dependenciesHash(project),
						errors: errors,
						inputContext: inputContext,
						outputContext: outputContext
					});
				return _Utils_update(
					cache,
					{
						dependencies: $elm$core$Maybe$Just(dependenciesEntry)
					});
			};
			var resultWhenNoFix = function (_v7) {
				return {
					cache: updateCache(_Utils_Tuple0),
					fixedErrors: fixedErrors,
					project: project,
					step: modulesAsNextStep(outputContext)
				};
			};
			var _v3 = A6($jfmengels$elm_review$Review$Rule$findFix, reviewOptions, projectVisitor, project, errors, fixedErrors, $elm$core$Maybe$Nothing);
			if (_v3.$ === 'Just') {
				var _v4 = _v3.a;
				var postFixStatus = _v4.a;
				var fixResult = _v4.b;
				if (postFixStatus.$ === 'ShouldAbort') {
					var newFixedErrors = postFixStatus.a;
					return {
						cache: updateCache(_Utils_Tuple0),
						fixedErrors: newFixedErrors,
						project: fixResult.project,
						step: $jfmengels$elm_review$Review$Rule$Abort
					};
				} else {
					var newFixedErrors = postFixStatus.a;
					var _v6 = fixResult.fixedFile;
					switch (_v6.$) {
						case 'FixedElmJson':
							return {
								cache: updateCache(_Utils_Tuple0),
								fixedErrors: newFixedErrors,
								project: fixResult.project,
								step: $jfmengels$elm_review$Review$Rule$ElmJson(
									{initial: contexts.initial})
							};
						case 'FixedReadme':
							return {
								cache: updateCache(_Utils_Tuple0),
								fixedErrors: newFixedErrors,
								project: fixResult.project,
								step: $jfmengels$elm_review$Review$Rule$Readme(
									{elmJson: contexts.elmJson, initial: contexts.initial})
							};
						default:
							return resultWhenNoFix(_Utils_Tuple0);
					}
				}
			} else {
				return resultWhenNoFix(_Utils_Tuple0);
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$ElmJsonKey = function (a) {
	return {$: 'ElmJsonKey', a: a};
};
var $jfmengels$elm_review$Review$Rule$computeElmJson = F5(
	function (dataToComputeProject, project, inputContext, cache, fixedErrors) {
		computeElmJson:
		while (true) {
			var reviewOptions = dataToComputeProject.reviewOptions;
			var projectVisitor = dataToComputeProject.projectVisitor;
			var exceptions = dataToComputeProject.exceptions;
			var cachePredicate = function (elmJson) {
				return A3(
					$jfmengels$elm_review$Review$Cache$matchMaybe,
					$jfmengels$elm_review$Review$Project$Valid$elmJsonHash(project),
					$jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext),
					elmJson);
			};
			var _v0 = A3(
				$jfmengels$elm_review$Review$Rule$reuseProjectRuleCache,
				cachePredicate,
				function ($) {
					return $.elmJson;
				},
				cache);
			if (_v0.$ === 'Just') {
				var entry = _v0.a;
				return {
					cache: cache,
					fixedErrors: fixedErrors,
					project: project,
					step: $jfmengels$elm_review$Review$Rule$Readme(
						{
							elmJson: $jfmengels$elm_review$Review$Cache$outputContextMaybe(entry),
							initial: inputContext
						})
				};
			} else {
				var projectElmJson = $jfmengels$elm_review$Review$Project$Valid$elmJson(project);
				var elmJsonData = A2(
					$elm$core$Maybe$map,
					function (elmJson) {
						return {
							elmJsonKey: $jfmengels$elm_review$Review$Rule$ElmJsonKey(elmJson),
							project: elmJson.project
						};
					},
					projectElmJson);
				var _v1 = A3(
					$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
					projectVisitor.elmJsonVisitors,
					elmJsonData,
					_Utils_Tuple2(_List_Nil, inputContext));
				var errorsForVisitor = _v1.a;
				var outputContext = _v1.b;
				var errors = A3($jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName, exceptions, projectVisitor.name, errorsForVisitor);
				var updateCache = function (_v5) {
					var elmJsonEntry = $jfmengels$elm_review$Review$Cache$createEntryMaybe(
						{
							contentHash: $jfmengels$elm_review$Review$Project$Valid$elmJsonHash(project),
							errors: errors,
							inputContext: inputContext,
							outputContext: outputContext
						});
					return _Utils_update(
						cache,
						{
							elmJson: $elm$core$Maybe$Just(elmJsonEntry)
						});
				};
				var _v2 = A6($jfmengels$elm_review$Review$Rule$findFix, reviewOptions, projectVisitor, project, errors, fixedErrors, $elm$core$Maybe$Nothing);
				if (_v2.$ === 'Just') {
					var _v3 = _v2.a;
					var postFixStatus = _v3.a;
					var fixResult = _v3.b;
					if (postFixStatus.$ === 'ShouldContinue') {
						var newFixedErrors = postFixStatus.a;
						var $temp$dataToComputeProject = dataToComputeProject,
							$temp$project = fixResult.project,
							$temp$inputContext = inputContext,
							$temp$cache = cache,
							$temp$fixedErrors = newFixedErrors;
						dataToComputeProject = $temp$dataToComputeProject;
						project = $temp$project;
						inputContext = $temp$inputContext;
						cache = $temp$cache;
						fixedErrors = $temp$fixedErrors;
						continue computeElmJson;
					} else {
						var newFixedErrors = postFixStatus.a;
						return {
							cache: updateCache(_Utils_Tuple0),
							fixedErrors: newFixedErrors,
							project: fixResult.project,
							step: $jfmengels$elm_review$Review$Rule$Abort
						};
					}
				} else {
					return {
						cache: updateCache(_Utils_Tuple0),
						fixedErrors: fixedErrors,
						project: project,
						step: $jfmengels$elm_review$Review$Rule$Readme(
							{elmJson: outputContext, initial: inputContext})
					};
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$getFolderFromTraversal = function (traversalAndFolder) {
	if (traversalAndFolder.$ === 'TraverseAllModulesInParallel') {
		var maybeFolder = traversalAndFolder.a;
		return maybeFolder;
	} else {
		var folder = traversalAndFolder.a;
		return $elm$core$Maybe$Just(folder);
	}
};
var $jfmengels$elm_review$Review$Cache$outputContext = function (_v0) {
	var entry = _v0.a;
	return entry.outputContext;
};
var $jfmengels$elm_review$Review$Rule$computeFinalContext = F3(
	function (projectVisitor, cache, projectContext) {
		var _v0 = $jfmengels$elm_review$Review$Rule$getFolderFromTraversal(projectVisitor.traversalAndFolder);
		if (_v0.$ === 'Just') {
			var foldProjectContexts = _v0.a.foldProjectContexts;
			return A3(
				$elm$core$Dict$foldl,
				F3(
					function (_v1, cacheEntry, acc) {
						return A2(
							foldProjectContexts,
							$jfmengels$elm_review$Review$Cache$outputContext(cacheEntry),
							acc);
					}),
				projectContext,
				cache.moduleContexts);
		} else {
			return projectContext;
		}
	});
var $jfmengels$elm_review$Review$Error$doesPreventExtract = function (error_) {
	return error_.preventsExtract;
};
var $jfmengels$elm_review$Review$Rule$doesPreventExtract = function (_v0) {
	var err = _v0.a;
	return $jfmengels$elm_review$Review$Error$doesPreventExtract(err);
};
var $jfmengels$elm_review$Review$Rule$computeExtract = F5(
	function (reviewOptions, projectVisitor, context, errors, cache) {
		var _v0 = projectVisitor.dataExtractor;
		if (_v0.$ === 'Just') {
			var dataExtractor = _v0.a;
			if (reviewOptions.extract && (!A2($elm$core$List$any, $jfmengels$elm_review$Review$Rule$doesPreventExtract, errors))) {
				var inputContext = function () {
					if (context.$ === 'Combined') {
						var projectContext = context.a;
						return projectContext;
					} else {
						var projectContext = context.a;
						return A3($jfmengels$elm_review$Review$Rule$computeFinalContext, projectVisitor, cache, projectContext);
					}
				}();
				var cachePredicate = function (extract) {
					return _Utils_eq(
						extract.inputContext,
						$jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext));
				};
				var _v1 = A3(
					$jfmengels$elm_review$Review$Rule$reuseProjectRuleCache,
					cachePredicate,
					function ($) {
						return $.extract;
					},
					cache);
				if (_v1.$ === 'Just') {
					return cache;
				} else {
					return _Utils_update(
						cache,
						{
							extract: $elm$core$Maybe$Just(
								{
									extract: dataExtractor(inputContext),
									inputContext: $jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext)
								})
						});
				}
			} else {
				return cache;
			}
		} else {
			return cache;
		}
	});
var $jfmengels$elm_review$Review$Rule$Combined = function (a) {
	return {$: 'Combined', a: a};
};
var $jfmengels$elm_review$Review$Rule$DataExtract = function (a) {
	return {$: 'DataExtract', a: a};
};
var $jfmengels$elm_review$Review$Rule$ToCombineStartingFrom = function (a) {
	return {$: 'ToCombineStartingFrom', a: a};
};
var $jfmengels$elm_review$Review$Cache$EntryNoOutputContext = function (a) {
	return {$: 'EntryNoOutputContext', a: a};
};
var $jfmengels$elm_review$Review$Cache$createNoOutput = F2(
	function (inputContext, output) {
		return $jfmengels$elm_review$Review$Cache$EntryNoOutputContext(
			{
				context: $jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext),
				output: output
			});
	});
var $jfmengels$elm_review$Review$Cache$matchNoOutput = F2(
	function (context, _v0) {
		var entry = _v0.a;
		return A2($jfmengels$elm_review$Review$Cache$ContextHash$areEqual, context, entry.context);
	});
var $jfmengels$elm_review$Review$Rule$computeFinalProjectEvaluation = F5(
	function (_v0, project, projectContexts, cache, fixedErrors) {
		var reviewOptions = _v0.reviewOptions;
		var projectVisitor = _v0.projectVisitor;
		var exceptions = _v0.exceptions;
		if ($elm$core$List$isEmpty(projectVisitor.finalEvaluationFns)) {
			return {
				cache: cache,
				fixedErrors: fixedErrors,
				project: project,
				step: $jfmengels$elm_review$Review$Rule$DataExtract(
					$jfmengels$elm_review$Review$Rule$ToCombineStartingFrom(projectContexts.deps))
			};
		} else {
			var finalContext = A3($jfmengels$elm_review$Review$Rule$computeFinalContext, projectVisitor, cache, projectContexts.deps);
			var cachePredicate = function (entry) {
				return A2(
					$jfmengels$elm_review$Review$Cache$matchNoOutput,
					$jfmengels$elm_review$Review$Cache$ContextHash$create(finalContext),
					entry);
			};
			var _v1 = A3(
				$jfmengels$elm_review$Review$Rule$reuseProjectRuleCache,
				cachePredicate,
				function ($) {
					return $.finalEvaluationErrors;
				},
				cache);
			if (_v1.$ === 'Just') {
				return {
					cache: cache,
					fixedErrors: fixedErrors,
					project: project,
					step: $jfmengels$elm_review$Review$Rule$DataExtract(
						$jfmengels$elm_review$Review$Rule$Combined(finalContext))
				};
			} else {
				var errors = A2(
					$elm$core$List$concatMap,
					function (finalEvaluationFn) {
						return A3(
							$jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName,
							exceptions,
							projectVisitor.name,
							finalEvaluationFn(finalContext));
					},
					projectVisitor.finalEvaluationFns);
				var _v2 = A6($jfmengels$elm_review$Review$Rule$findFix, reviewOptions, projectVisitor, project, errors, fixedErrors, $elm$core$Maybe$Nothing);
				if (_v2.$ === 'Just') {
					var _v3 = _v2.a;
					var postFixStatus = _v3.a;
					var fixResult = _v3.b;
					var _v4 = function () {
						if (postFixStatus.$ === 'ShouldAbort') {
							var newFixedErrors_ = postFixStatus.a;
							return _Utils_Tuple2(newFixedErrors_, $jfmengels$elm_review$Review$Rule$Abort);
						} else {
							var newFixedErrors_ = postFixStatus.a;
							return _Utils_Tuple2(
								newFixedErrors_,
								function () {
									var _v6 = fixResult.fixedFile;
									switch (_v6.$) {
										case 'FixedElmModule':
											var moduleZipper = _v6.b;
											return A2($jfmengels$elm_review$Review$Rule$Modules, projectContexts, moduleZipper);
										case 'FixedElmJson':
											return $jfmengels$elm_review$Review$Rule$ElmJson(
												{initial: projectContexts.initial});
										default:
											return $jfmengels$elm_review$Review$Rule$Readme(
												{elmJson: projectContexts.elmJson, initial: projectContexts.initial});
									}
								}());
						}
					}();
					var newFixedErrors = _v4.a;
					var step = _v4.b;
					return {
						cache: _Utils_update(
							cache,
							{
								finalEvaluationErrors: $elm$core$Maybe$Just(
									A2($jfmengels$elm_review$Review$Cache$createNoOutput, finalContext, errors))
							}),
						fixedErrors: newFixedErrors,
						project: fixResult.project,
						step: step
					};
				} else {
					return {
						cache: _Utils_update(
							cache,
							{
								finalEvaluationErrors: $elm$core$Maybe$Just(
									A2($jfmengels$elm_review$Review$Cache$createNoOutput, finalContext, errors))
							}),
						fixedErrors: fixedErrors,
						project: project,
						step: $jfmengels$elm_review$Review$Rule$DataExtract(
							$jfmengels$elm_review$Review$Rule$Combined(finalContext))
					};
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$ModuleVisitStep = function (a) {
	return {$: 'ModuleVisitStep', a: a};
};
var $jfmengels$elm_review$Review$Rule$BackToElmJson = {$: 'BackToElmJson'};
var $jfmengels$elm_review$Review$Rule$BackToReadme = {$: 'BackToReadme'};
var $jfmengels$elm_review$Review$Rule$NextStepAbort = {$: 'NextStepAbort'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$toRangeLike = function (_v0) {
	var start = _v0.start;
	var end = _v0.end;
	return _Utils_Tuple2((start.row << 16) + start.column, (end.row << 16) + end.column);
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add = F3(
	function (range, moduleName, _v0) {
		var currentModuleName = _v0.a;
		var moduleNameLookupTable = _v0.b;
		return A2(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$ModuleNameLookupTable,
			currentModuleName,
			A3(
				$elm$core$Dict$insert,
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$toRangeLike(range),
				moduleName,
				moduleNameLookupTable));
	});
var $jfmengels$elm_review$NonEmpty$any = F2(
	function (f, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		return f(x) || A2($elm$core$List$any, f, xs);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isInScope = F2(
	function (name, scopes) {
		return A2(
			$jfmengels$elm_review$NonEmpty$any,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.names;
				},
				$elm$core$Dict$member(name)),
			scopes);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isValueDeclaredInModule = F2(
	function (valueName, module_) {
		return A2(
			$elm$core$List$any,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.name;
				},
				$elm$core$Basics$eq(valueName)),
			module_.values) || (A2(
			$elm$core$List$any,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.name;
				},
				$elm$core$Basics$eq(valueName)),
			module_.aliases) || A2(
			$elm$core$List$any,
			function (union) {
				return A2(
					$elm$core$List$any,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$Tuple$first,
						$elm$core$Basics$eq(valueName)),
					union.tags);
			},
			module_.unions));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue = F3(
	function (context, valueName, moduleName) {
		if (!moduleName.b) {
			return A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isInScope, valueName, context.scopes) ? _List_Nil : A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2($elm$core$Dict$get, valueName, context.importedFunctions));
		} else {
			if (!moduleName.b.b) {
				var moduleNameOrAlias = moduleName.a;
				var _v1 = A2($elm$core$Dict$get, moduleNameOrAlias, context.importAliases);
				if (_v1.$ === 'Just') {
					if (_v1.a.b && (!_v1.a.b.b)) {
						var _v2 = _v1.a;
						var aliasedModuleName = _v2.a;
						return aliasedModuleName;
					} else {
						var aliases = _v1.a;
						var _v3 = A2(
							$jfmengels$elm_review$Vendor$ListExtra$find,
							function (aliasedModuleName) {
								var _v4 = A2($elm$core$Dict$get, aliasedModuleName, context.modules);
								if (_v4.$ === 'Just') {
									var module_ = _v4.a;
									return A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isValueDeclaredInModule, valueName, module_);
								} else {
									return false;
								}
							},
							aliases);
						if (_v3.$ === 'Just') {
							var aliasedModuleName = _v3.a;
							return aliasedModuleName;
						} else {
							return A2(
								$elm$core$Maybe$withDefault,
								moduleName,
								$elm$core$List$head(aliases));
						}
					}
				} else {
					return moduleName;
				}
			} else {
				return moduleName;
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern = F3(
	function (context, patternsToVisit, acc) {
		collectModuleNamesFromPattern:
		while (true) {
			if (patternsToVisit.b) {
				var pattern = patternsToVisit.a;
				var restOfPatternsToVisit = patternsToVisit.b;
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(pattern);
				switch (_v1.$) {
					case 'NamedPattern':
						var moduleName = _v1.a.moduleName;
						var name = _v1.a.name;
						var subPatterns = _v1.b;
						var $temp$context = context,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(pattern),
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue, context, name, moduleName),
							acc);
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					case 'UnConsPattern':
						var left = _v1.a;
						var right = _v1.b;
						var $temp$context = context,
							$temp$patternsToVisit = A2(
							$elm$core$List$cons,
							left,
							A2($elm$core$List$cons, right, restOfPatternsToVisit)),
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					case 'TuplePattern':
						var subPatterns = _v1.a;
						var $temp$context = context,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					case 'ParenthesizedPattern':
						var subPattern = _v1.a;
						var $temp$context = context,
							$temp$patternsToVisit = A2($elm$core$List$cons, subPattern, restOfPatternsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					case 'AsPattern':
						var subPattern = _v1.a;
						var $temp$context = context,
							$temp$patternsToVisit = A2($elm$core$List$cons, subPattern, restOfPatternsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					case 'ListPattern':
						var subPatterns = _v1.a;
						var $temp$context = context,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
					default:
						var $temp$context = context,
							$temp$patternsToVisit = restOfPatternsToVisit,
							$temp$acc = acc;
						context = $temp$context;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromPattern;
				}
			} else {
				return acc;
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isTypeDeclaredInModule = F2(
	function (typeName, module_) {
		return A2(
			$elm$core$List$any,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.name;
				},
				$elm$core$Basics$eq(typeName)),
			module_.aliases) || A2(
			$elm$core$List$any,
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.name;
				},
				$elm$core$Basics$eq(typeName)),
			module_.unions);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$joinModuleName = function (name) {
	return A2($elm$core$String$join, '.', name);
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForType = F3(
	function (context, typeName, moduleName) {
		if (!moduleName.b) {
			return A2($elm$core$Set$member, typeName, context.localTypes) ? _List_Nil : A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2($elm$core$Dict$get, typeName, context.importedTypes));
		} else {
			if (!moduleName.b.b) {
				var _v1 = A2(
					$elm$core$Dict$get,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$joinModuleName(moduleName),
					context.importAliases);
				if (_v1.$ === 'Just') {
					if (_v1.a.b && (!_v1.a.b.b)) {
						var _v2 = _v1.a;
						var aliasedModuleName = _v2.a;
						return aliasedModuleName;
					} else {
						var aliases = _v1.a;
						var _v3 = A2(
							$jfmengels$elm_review$Vendor$ListExtra$find,
							function (aliasedModuleName) {
								var _v4 = A2($elm$core$Dict$get, aliasedModuleName, context.modules);
								if (_v4.$ === 'Just') {
									var module_ = _v4.a;
									return A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$isTypeDeclaredInModule, typeName, module_);
								} else {
									return false;
								}
							},
							aliases);
						if (_v3.$ === 'Just') {
							var aliasedModuleName = _v3.a;
							return aliasedModuleName;
						} else {
							return A2(
								$elm$core$Maybe$withDefault,
								moduleName,
								$elm$core$List$head(aliases));
						}
					}
				} else {
					return moduleName;
				}
			} else {
				return moduleName;
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation = F3(
	function (context, typeAnnotationsToVisit, acc) {
		collectModuleNamesFromTypeAnnotation:
		while (true) {
			if (typeAnnotationsToVisit.b) {
				var typeAnnotationNode = typeAnnotationsToVisit.a;
				var remainingTypeAnnotationsToVisit = typeAnnotationsToVisit.b;
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(typeAnnotationNode);
				switch (_v1.$) {
					case 'Typed':
						var _v2 = _v1.a;
						var range = _v2.a;
						var _v3 = _v2.b;
						var moduleName = _v3.a;
						var name = _v3.b;
						var args = _v1.b;
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = A2($elm$core$List$append, args, remainingTypeAnnotationsToVisit),
							$temp$acc = A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							range,
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForType, context, name, moduleName),
							acc);
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
					case 'Tupled':
						var nodes = _v1.a;
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = A2($elm$core$List$append, nodes, remainingTypeAnnotationsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
					case 'Record':
						var fields = _v1.a;
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = A3(
							$jfmengels$elm_review$Vendor$ListExtra$orderIndependentMapAppend,
							function (field) {
								return $stil4m$elm_syntax$Elm$Syntax$Node$value(field).b;
							},
							fields,
							remainingTypeAnnotationsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
					case 'GenericRecord':
						var fields = _v1.b;
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = A3(
							$jfmengels$elm_review$Vendor$ListExtra$orderIndependentMapAppend,
							function (field) {
								return $stil4m$elm_syntax$Elm$Syntax$Node$value(field).b;
							},
							$stil4m$elm_syntax$Elm$Syntax$Node$value(fields),
							remainingTypeAnnotationsToVisit),
							$temp$acc = acc;
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
					case 'FunctionTypeAnnotation':
						var left = _v1.a;
						var right = _v1.b;
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = A2(
							$elm$core$List$cons,
							left,
							A2($elm$core$List$cons, right, remainingTypeAnnotationsToVisit)),
							$temp$acc = acc;
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
					default:
						var $temp$context = context,
							$temp$typeAnnotationsToVisit = remainingTypeAnnotationsToVisit,
							$temp$acc = acc;
						context = $temp$context;
						typeAnnotationsToVisit = $temp$typeAnnotationsToVisit;
						acc = $temp$acc;
						continue collectModuleNamesFromTypeAnnotation;
				}
			} else {
				return acc;
			}
		}
	});
var $jfmengels$elm_review$NonEmpty$Nonempty = F2(
	function (a, b) {
		return {$: 'Nonempty', a: a, b: b};
	});
var $jfmengels$elm_review$NonEmpty$cons = F2(
	function (y, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		return A2(
			$jfmengels$elm_review$NonEmpty$Nonempty,
			y,
			A2($elm$core$List$cons, x, xs));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$emptyScope = {
	caseToExit: A2(
		$stil4m$elm_syntax$Elm$Syntax$Node$Node,
		$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
		$stil4m$elm_syntax$Elm$Syntax$Expression$Literal('root')),
	cases: _List_Nil,
	names: $elm$core$Dict$empty
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$FunctionParameter = {$: 'FunctionParameter'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectNamesFromPattern = F3(
	function (variableType, patternsToVisit, acc) {
		collectNamesFromPattern:
		while (true) {
			if (patternsToVisit.b) {
				var pattern = patternsToVisit.a;
				var restOfPatternsToVisit = patternsToVisit.b;
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(pattern);
				switch (_v1.$) {
					case 'VarPattern':
						var name = _v1.a;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = restOfPatternsToVisit,
							$temp$acc = A3(
							$elm$core$Dict$insert,
							name,
							{
								node: A2(
									$stil4m$elm_syntax$Elm$Syntax$Node$Node,
									$stil4m$elm_syntax$Elm$Syntax$Node$range(pattern),
									name),
								variableType: variableType
							},
							acc);
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'NamedPattern':
						var subPatterns = _v1.b;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'RecordPattern':
						var names = _v1.a;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = restOfPatternsToVisit,
							$temp$acc = A3(
							$elm$core$List$foldl,
							F2(
								function (nameNode, subAcc) {
									return A3(
										$elm$core$Dict$insert,
										$stil4m$elm_syntax$Elm$Syntax$Node$value(nameNode),
										{node: nameNode, variableType: variableType},
										subAcc);
								}),
							acc,
							names);
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'ParenthesizedPattern':
						var subPattern = _v1.a;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2($elm$core$List$cons, subPattern, restOfPatternsToVisit),
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'AsPattern':
						var subPattern = _v1.a;
						var alias = _v1.b;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2($elm$core$List$cons, subPattern, restOfPatternsToVisit),
							$temp$acc = A3(
							$elm$core$Dict$insert,
							$stil4m$elm_syntax$Elm$Syntax$Node$value(alias),
							{node: alias, variableType: variableType},
							acc);
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'TuplePattern':
						var subPatterns = _v1.a;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'UnConsPattern':
						var left = _v1.a;
						var right = _v1.b;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2(
							$elm$core$List$cons,
							left,
							A2($elm$core$List$cons, right, restOfPatternsToVisit)),
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					case 'ListPattern':
						var subPatterns = _v1.a;
						var $temp$variableType = variableType,
							$temp$patternsToVisit = A2($elm$core$List$append, subPatterns, restOfPatternsToVisit),
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
					default:
						var $temp$variableType = variableType,
							$temp$patternsToVisit = restOfPatternsToVisit,
							$temp$acc = acc;
						variableType = $temp$variableType;
						patternsToVisit = $temp$patternsToVisit;
						acc = $temp$acc;
						continue collectNamesFromPattern;
				}
			} else {
				return acc;
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$parameters = function (patterns) {
	return A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectNamesFromPattern, $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$FunctionParameter, patterns, $elm$core$Dict$empty);
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$updateScope = F2(
	function (innerContext, scopes) {
		return _Utils_update(
			innerContext,
			{scopes: scopes});
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationEnterVisitor = F2(
	function (node, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'FunctionDeclaration':
				var _function = _v0.a;
				var newScope = _Utils_update(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$emptyScope,
					{
						names: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$parameters(
							$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration)._arguments)
					});
				var newContext = A2(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$updateScope,
					context,
					A2($jfmengels$elm_review$NonEmpty$cons, newScope, context.scopes));
				var lookupTableAfterArguments = A3(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern,
					newContext,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration)._arguments,
					newContext.lookupTable);
				var finalLookupTable = function () {
					var _v1 = _function.signature;
					if (_v1.$ === 'Just') {
						var signature = _v1.a;
						return A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation,
							context,
							_List_fromArray(
								[
									$stil4m$elm_syntax$Elm$Syntax$Node$value(signature).typeAnnotation
								]),
							lookupTableAfterArguments);
					} else {
						return lookupTableAfterArguments;
					}
				}();
				return _Utils_update(
					newContext,
					{lookupTable: finalLookupTable});
			case 'CustomTypeDeclaration':
				var constructors = _v0.a.constructors;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$elm$core$List$foldl,
							F2(
								function (_v2, acc) {
									var constructor = _v2.b;
									return A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation, context, constructor._arguments, acc);
								}),
							context.lookupTable,
							constructors)
					});
			case 'AliasDeclaration':
				var typeAnnotation = _v0.a.typeAnnotation;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation,
							context,
							_List_fromArray(
								[typeAnnotation]),
							context.lookupTable)
					});
			case 'PortDeclaration':
				var signature = _v0.a;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation,
							context,
							_List_fromArray(
								[signature.typeAnnotation]),
							context.lookupTable)
					});
			default:
				return context;
		}
	});
var $jfmengels$elm_review$NonEmpty$pop = function (_v0) {
	var x = _v0.a;
	var xs = _v0.b;
	if (!xs.b) {
		return A2($jfmengels$elm_review$NonEmpty$Nonempty, x, xs);
	} else {
		var y = xs.a;
		var ys = xs.b;
		return A2($jfmengels$elm_review$NonEmpty$Nonempty, y, ys);
	}
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationExitVisitor = F2(
	function (node, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		if (_v0.$ === 'FunctionDeclaration') {
			return _Utils_update(
				context,
				{
					scopes: $jfmengels$elm_review$NonEmpty$pop(context.scopes)
				});
		} else {
			return context;
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$functionToExpression = function (_function) {
	return $stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression;
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionChildren = function (node) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
	switch (_v0.$) {
		case 'Application':
			var expressions = _v0.a;
			return expressions;
		case 'ListExpr':
			var elements = _v0.a;
			return elements;
		case 'RecordExpr':
			var fields = _v0.a;
			return A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$stil4m$elm_syntax$Elm$Syntax$Node$value,
					function (_v1) {
						var expr = _v1.b;
						return expr;
					}),
				fields);
		case 'RecordUpdateExpression':
			var setters = _v0.b;
			return A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$stil4m$elm_syntax$Elm$Syntax$Node$value,
					function (_v2) {
						var expr = _v2.b;
						return expr;
					}),
				setters);
		case 'ParenthesizedExpression':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		case 'OperatorApplication':
			var direction = _v0.b;
			var left = _v0.c;
			var right = _v0.d;
			switch (direction.$) {
				case 'Left':
					return _List_fromArray(
						[left, right]);
				case 'Right':
					return _List_fromArray(
						[right, left]);
				default:
					return _List_fromArray(
						[left, right]);
			}
		case 'IfBlock':
			var cond = _v0.a;
			var then_ = _v0.b;
			var else_ = _v0.c;
			return _List_fromArray(
				[cond, then_, else_]);
		case 'LetExpression':
			var expression = _v0.a.expression;
			var declarations = _v0.a.declarations;
			return A3(
				$elm$core$List$foldr,
				F2(
					function (declaration, acc) {
						var _v4 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
						if (_v4.$ === 'LetFunction') {
							var _function = _v4.a;
							return A2(
								$elm$core$List$cons,
								$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$functionToExpression(_function),
								acc);
						} else {
							var expr = _v4.b;
							return A2($elm$core$List$cons, expr, acc);
						}
					}),
				_List_fromArray(
					[expression]),
				declarations);
		case 'CaseExpression':
			var expression = _v0.a.expression;
			var cases = _v0.a.cases;
			return A2(
				$elm$core$List$cons,
				expression,
				A2(
					$elm$core$List$map,
					function (_v5) {
						var caseExpression = _v5.b;
						return caseExpression;
					},
					cases));
		case 'LambdaExpression':
			var expression = _v0.a.expression;
			return _List_fromArray(
				[expression]);
		case 'TupledExpression':
			var expressions = _v0.a;
			return expressions;
		case 'Negation':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		case 'RecordAccess':
			var expr = _v0.a;
			return _List_fromArray(
				[expr]);
		default:
			return _List_Nil;
	}
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$LetVariable = {$: 'LetVariable'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$PatternVariable = {$: 'PatternVariable'};
var $jfmengels$elm_review$NonEmpty$mapHead = F2(
	function (fn, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		return A2(
			$jfmengels$elm_review$NonEmpty$Nonempty,
			fn(x),
			xs);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerVariable = F3(
	function (variableInfo, name, scopes) {
		return A2(
			$jfmengels$elm_review$NonEmpty$mapHead,
			function (scope) {
				return _Utils_update(
					scope,
					{
						names: A3($elm$core$Dict$insert, name, variableInfo, scope.names)
					});
			},
			scopes);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionEnterVisitor = F2(
	function (node, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'LetExpression':
				var declarations = _v0.a.declarations;
				var newContext = A2(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$updateScope,
					context,
					A3(
						$elm$core$List$foldl,
						F2(
							function (declaration, scopes) {
								var _v3 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
								if (_v3.$ === 'LetFunction') {
									var _function = _v3.a;
									var nameNode = $stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).name;
									return A3(
										$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerVariable,
										{node: nameNode, variableType: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$LetVariable},
										$stil4m$elm_syntax$Elm$Syntax$Node$value(nameNode),
										scopes);
								} else {
									return scopes;
								}
							}),
						A2($jfmengels$elm_review$NonEmpty$cons, $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$emptyScope, context.scopes),
						declarations));
				var lookupTable = A3(
					$elm$core$List$foldl,
					F2(
						function (declaration, acc) {
							var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
							if (_v1.$ === 'LetFunction') {
								var _function = _v1.a;
								var withDeclarationModuleName = A3(
									$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern,
									newContext,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration)._arguments,
									acc);
								var _v2 = _function.signature;
								if (_v2.$ === 'Just') {
									var signature = _v2.a;
									return A3(
										$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromTypeAnnotation,
										context,
										_List_fromArray(
											[
												$stil4m$elm_syntax$Elm$Syntax$Node$value(signature).typeAnnotation
											]),
										withDeclarationModuleName);
								} else {
									return withDeclarationModuleName;
								}
							} else {
								var pattern = _v1.a;
								return A3(
									$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern,
									newContext,
									_List_fromArray(
										[pattern]),
									acc);
							}
						}),
					newContext.lookupTable,
					declarations);
				return _Utils_update(
					newContext,
					{lookupTable: lookupTable});
			case 'CaseExpression':
				var caseBlock = _v0.a;
				var _v4 = A3(
					$elm$core$List$foldl,
					F2(
						function (_v5, _v6) {
							var pattern = _v5.a;
							var expression = _v5.b;
							var casesAcc = _v6.a;
							var lookupTableAcc = _v6.b;
							return _Utils_Tuple2(
								A2(
									$elm$core$List$cons,
									_Utils_Tuple2(
										expression,
										A3(
											$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectNamesFromPattern,
											$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$PatternVariable,
											_List_fromArray(
												[pattern]),
											$elm$core$Dict$empty)),
									casesAcc),
								A3(
									$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern,
									context,
									_List_fromArray(
										[pattern]),
									lookupTableAcc));
						}),
					_Utils_Tuple2(_List_Nil, context.lookupTable),
					caseBlock.cases);
				var cases = _v4.a;
				var lookupTable = _v4.b;
				return _Utils_update(
					context,
					{
						lookupTable: lookupTable,
						scopes: A2(
							$jfmengels$elm_review$NonEmpty$mapHead,
							function (scope) {
								return _Utils_update(
									scope,
									{cases: cases});
							},
							context.scopes)
					});
			case 'FunctionOrValue':
				var moduleName = _v0.a;
				var name = _v0.b;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue, context, name, moduleName),
							context.lookupTable)
					});
			case 'RecordUpdateExpression':
				var _v7 = _v0.a;
				var range = _v7.a;
				var name = _v7.b;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							range,
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue, context, name, _List_Nil),
							context.lookupTable)
					});
			case 'LambdaExpression':
				var args = _v0.a.args;
				return _Utils_update(
					context,
					{
						lookupTable: A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleNamesFromPattern, context, args, context.lookupTable)
					});
			case 'PrefixOperator':
				var op = _v0.a;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue, context, op, _List_Nil),
							context.lookupTable)
					});
			case 'OperatorApplication':
				var op = _v0.a;
				return _Utils_update(
					context,
					{
						lookupTable: A3(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$add,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
							A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForValue, context, op, _List_Nil),
							context.lookupTable)
					});
			default:
				return context;
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionExitVisitor = F2(
	function (node, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'LetExpression':
				return _Utils_update(
					context,
					{
						scopes: $jfmengels$elm_review$NonEmpty$pop(context.scopes)
					});
			case 'CaseExpression':
				return _Utils_update(
					context,
					{
						scopes: A2(
							$jfmengels$elm_review$NonEmpty$mapHead,
							function (scope) {
								return _Utils_update(
									scope,
									{cases: _List_Nil});
							},
							context.scopes)
					});
			default:
				return context;
		}
	});
var $jfmengels$elm_review$NonEmpty$head = function (_v0) {
	var x = _v0.a;
	return x;
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$popScopeEnter = F2(
	function (node, context) {
		var currentScope = $jfmengels$elm_review$NonEmpty$head(context.scopes);
		var caseExpression = A2(
			$jfmengels$elm_review$Vendor$ListExtra$find,
			function (_v2) {
				var expressionNode = _v2.a;
				return _Utils_eq(node, expressionNode);
			},
			currentScope.cases);
		if (caseExpression.$ === 'Nothing') {
			return context;
		} else {
			var _v1 = caseExpression.a;
			var names = _v1.b;
			return _Utils_update(
				context,
				{
					scopes: A2(
						$jfmengels$elm_review$NonEmpty$cons,
						_Utils_update(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$emptyScope,
							{caseToExit: node, names: names}),
						context.scopes)
				});
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$popScopeExit = F2(
	function (node, context) {
		var currentScope = $jfmengels$elm_review$NonEmpty$head(context.scopes);
		return _Utils_eq(node, currentScope.caseToExit) ? _Utils_update(
			context,
			{
				scopes: $jfmengels$elm_review$NonEmpty$pop(context.scopes)
			}) : context;
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$visitExpressions = F2(
	function (node, context) {
		return A2(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionExitVisitor,
			node,
			A2(
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$popScopeExit,
				node,
				function (newContext) {
					return A3(
						$elm$core$List$foldl,
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$visitExpressions,
						newContext,
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionChildren(node));
				}(
					A2(
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$expressionEnterVisitor,
						node,
						A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$popScopeEnter, node, context)))));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectLookupTable = F2(
	function (declarations, context) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (declaration, ctx) {
					var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
					if (_v0.$ === 'FunctionDeclaration') {
						var _function = _v0.a;
						return A2(
							$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationExitVisitor,
							declaration,
							A2(
								$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$visitExpressions,
								$stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).expression,
								A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationEnterVisitor, declaration, ctx)));
					} else {
						return A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationEnterVisitor, declaration, ctx);
					}
				}),
			context,
			declarations);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$CustomTypeConstructor = {$: 'CustomTypeConstructor'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$Port = {$: 'Port'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$TopLevelVariable = {$: 'TopLevelVariable'};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$addToScope = F2(
	function (variableData, innerContext) {
		var newScopes = A3(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerVariable,
			variableData,
			$stil4m$elm_syntax$Elm$Syntax$Node$value(variableData.node),
			innerContext.scopes);
		return _Utils_update(
			innerContext,
			{scopes: newScopes});
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedCustomType = F3(
	function (constructors, name, innerContext) {
		return _Utils_update(
			innerContext,
			{
				exposedUnions: A2(
					$elm$core$List$cons,
					{
						args: _List_Nil,
						comment: '',
						name: name,
						tags: A2(
							$elm$core$List$map,
							function (constructor) {
								return _Utils_Tuple2(
									$stil4m$elm_syntax$Elm$Syntax$Node$value(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(constructor).name),
									_List_Nil);
							},
							constructors)
					},
					innerContext.exposedUnions)
			});
	});
var $elm$project_metadata_utils$Elm$Type$Tuple = function (a) {
	return {$: 'Tuple', a: a};
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedTypeAlias = F2(
	function (name, innerContext) {
		return _Utils_update(
			innerContext,
			{
				exposedAliases: A2(
					$elm$core$List$cons,
					{
						args: _List_Nil,
						comment: '',
						name: name,
						tipe: $elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
					},
					innerContext.exposedAliases)
			});
	});
var $elm$project_metadata_utils$Elm$Type$Lambda = F2(
	function (a, b) {
		return {$: 'Lambda', a: a, b: b};
	});
var $elm$project_metadata_utils$Elm$Type$Record = F2(
	function (a, b) {
		return {$: 'Record', a: a, b: b};
	});
var $elm$project_metadata_utils$Elm$Type$Type = F2(
	function (a, b) {
		return {$: 'Type', a: a, b: b};
	});
var $elm$project_metadata_utils$Elm$Type$Var = function (a) {
	return {$: 'Var', a: a};
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$recordUpdateToDocsType = F2(
	function (innerContext, updates) {
		return A2(
			$elm$core$List$map,
			function (_v6) {
				var _v7 = _v6.b;
				var name = _v7.a;
				var typeAnnotation = _v7.b;
				return _Utils_Tuple2(
					$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType, innerContext, typeAnnotation));
			},
			updates);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType = F2(
	function (innerContext, _v0) {
		var typeAnnotation = _v0.b;
		switch (typeAnnotation.$) {
			case 'GenericType':
				var name = typeAnnotation.a;
				return $elm$project_metadata_utils$Elm$Type$Var(name);
			case 'Typed':
				var _v2 = typeAnnotation.a;
				var _v3 = _v2.b;
				var moduleName = _v3.a;
				var typeName = _v3.b;
				var typeParameters = typeAnnotation.b;
				var realModuleName = A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleNameForType, innerContext, typeName, moduleName);
				return A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					A2($elm$core$String$join, '.', realModuleName) + ('.' + typeName),
					A2(
						$elm$core$List$map,
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType(innerContext),
						typeParameters));
			case 'Unit':
				return $elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil);
			case 'Tupled':
				var list = typeAnnotation.a;
				return $elm$project_metadata_utils$Elm$Type$Tuple(
					A2(
						$elm$core$List$map,
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType(innerContext),
						list));
			case 'Record':
				var updates = typeAnnotation.a;
				return A2(
					$elm$project_metadata_utils$Elm$Type$Record,
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$recordUpdateToDocsType, innerContext, updates),
					$elm$core$Maybe$Nothing);
			case 'GenericRecord':
				var _v4 = typeAnnotation.a;
				var generic = _v4.b;
				var _v5 = typeAnnotation.b;
				var updates = _v5.b;
				return A2(
					$elm$project_metadata_utils$Elm$Type$Record,
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$recordUpdateToDocsType, innerContext, updates),
					$elm$core$Maybe$Just(generic));
			default:
				var left = typeAnnotation.a;
				var right = typeAnnotation.b;
				return A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType, innerContext, left),
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType, innerContext, right));
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$convertTypeSignatureToDocsType = F2(
	function (innerContext, maybeSignature) {
		if (maybeSignature.$ === 'Just') {
			var signature = maybeSignature.a;
			return A2(
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$syntaxTypeAnnotationToDocsType,
				innerContext,
				$stil4m$elm_syntax$Elm$Syntax$Node$value(signature).typeAnnotation);
		} else {
			return $elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil);
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedValue = F3(
	function (_function, name, innerContext) {
		return _Utils_update(
			innerContext,
			{
				exposedValues: A2(
					$elm$core$List$cons,
					{
						comment: function () {
							var _v0 = _function.documentation;
							if (_v0.$ === 'Just') {
								var strNode = _v0.a;
								return $stil4m$elm_syntax$Elm$Syntax$Node$value(strNode);
							} else {
								return '';
							}
						}(),
						name: name,
						tipe: A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$convertTypeSignatureToDocsType, innerContext, _function.signature)
					},
					innerContext.exposedValues)
			});
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerIfExposed = F3(
	function (registerFn, name, innerContext) {
		return (innerContext.exposesEverything || A2($elm$core$Set$member, name, innerContext.exposedNames)) ? A2(registerFn, name, innerContext) : innerContext;
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerDeclaration = F2(
	function (declaration, innerContext) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
		switch (_v0.$) {
			case 'FunctionDeclaration':
				var _function = _v0.a;
				var nameNode = $stil4m$elm_syntax$Elm$Syntax$Node$value(_function.declaration).name;
				return A3(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerIfExposed,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedValue(_function),
					$stil4m$elm_syntax$Elm$Syntax$Node$value(nameNode),
					A2(
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$addToScope,
						{node: nameNode, variableType: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$TopLevelVariable},
						innerContext));
			case 'AliasDeclaration':
				var alias = _v0.a;
				return A3(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerIfExposed,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedTypeAlias,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(alias.name),
					function (ctx) {
						var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(alias.typeAnnotation);
						if (_v1.$ === 'Record') {
							return A2(
								$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$addToScope,
								{node: alias.name, variableType: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$TopLevelVariable},
								ctx);
						} else {
							return ctx;
						}
					}(
						_Utils_update(
							innerContext,
							{
								localTypes: A2(
									$elm$core$Set$insert,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(alias.name),
									innerContext.localTypes)
							})));
			case 'CustomTypeDeclaration':
				var name = _v0.a.name;
				var constructors = _v0.a.constructors;
				return A3(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerIfExposed,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedCustomType(constructors),
					$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
					A3(
						$elm$core$List$foldl,
						F2(
							function (constructor, innerContext_) {
								var constructorName = $stil4m$elm_syntax$Elm$Syntax$Node$value(constructor).name;
								return A2(
									$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$addToScope,
									{node: constructorName, variableType: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$CustomTypeConstructor},
									innerContext_);
							}),
						_Utils_update(
							innerContext,
							{
								localTypes: A2(
									$elm$core$Set$insert,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
									innerContext.localTypes)
							}),
						constructors));
			case 'PortDeclaration':
				var signature = _v0.a;
				return A3(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerIfExposed,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerExposedValue(
						{
							documentation: $elm$core$Maybe$Nothing,
							signature: $elm$core$Maybe$Just(
								A2(
									$stil4m$elm_syntax$Elm$Syntax$Node$Node,
									$stil4m$elm_syntax$Elm$Syntax$Node$range(declaration),
									signature))
						}),
					$stil4m$elm_syntax$Elm$Syntax$Node$value(signature.name),
					A2(
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$addToScope,
						{node: signature.name, variableType: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$Port},
						innerContext));
			case 'InfixDeclaration':
				return innerContext;
			default:
				return innerContext;
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationListVisitor = F2(
	function (declarations, innerContext) {
		return A3($elm$core$List$foldl, $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerDeclaration, innerContext, declarations);
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport = function (_v0) {
	var moduleName = _v0.moduleName;
	var moduleAlias = _v0.moduleAlias;
	var exposingList = _v0.exposingList;
	return A2(
		$stil4m$elm_syntax$Elm$Syntax$Node$Node,
		$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
		{
			exposingList: A2(
				$elm$core$Maybe$map,
				$stil4m$elm_syntax$Elm$Syntax$Node$Node($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange),
				exposingList),
			moduleAlias: A2(
				$elm$core$Maybe$map,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$List$singleton,
					$stil4m$elm_syntax$Elm$Syntax$Node$Node($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange)),
				moduleAlias),
			moduleName: A2($stil4m$elm_syntax$Elm$Syntax$Node$Node, $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, moduleName)
		});
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$elmCorePrelude = function () {
	var explicit = function (exposed) {
		return $elm$core$Maybe$Just(
			$stil4m$elm_syntax$Elm$Syntax$Exposing$Explicit(
				A2(
					$elm$core$List$map,
					$stil4m$elm_syntax$Elm$Syntax$Node$Node($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange),
					exposed)));
	};
	return _List_fromArray(
		[
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: $elm$core$Maybe$Just(
					$stil4m$elm_syntax$Elm$Syntax$Exposing$All($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange)),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Basics'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'List', open: $elm$core$Maybe$Nothing}),
							$stil4m$elm_syntax$Elm$Syntax$Exposing$InfixExpose('::')
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['List'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{
								name: 'Maybe',
								open: $elm$core$Maybe$Just($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange)
							})
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Maybe'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{
								name: 'Result',
								open: $elm$core$Maybe$Just($stil4m$elm_syntax$Elm$Syntax$Range$emptyRange)
							})
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Result'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'String', open: $elm$core$Maybe$Nothing})
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['String'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'Char', open: $elm$core$Maybe$Nothing})
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Char'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: $elm$core$Maybe$Nothing,
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Tuple'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: $elm$core$Maybe$Nothing,
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Debug'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'Program', open: $elm$core$Maybe$Nothing})
						])),
				moduleAlias: $elm$core$Maybe$Nothing,
				moduleName: _List_fromArray(
					['Platform'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'Cmd', open: $elm$core$Maybe$Nothing})
						])),
				moduleAlias: $elm$core$Maybe$Just('Cmd'),
				moduleName: _List_fromArray(
					['Platform', 'Cmd'])
			}),
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$createFakeImport(
			{
				exposingList: explicit(
					_List_fromArray(
						[
							$stil4m$elm_syntax$Elm$Syntax$Exposing$TypeExpose(
							{name: 'Sub', open: $elm$core$Maybe$Nothing})
						])),
				moduleAlias: $elm$core$Maybe$Just('Sub'),
				moduleName: _List_fromArray(
					['Platform', 'Sub'])
			})
		]);
}();
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerImportAlias = F2(
	function (import_, innerContext) {
		var _v0 = import_.moduleAlias;
		if (_v0.$ === 'Nothing') {
			var moduleName = $stil4m$elm_syntax$Elm$Syntax$Node$value(import_.moduleName);
			if (moduleName.b && (!moduleName.b.b)) {
				var singleSegmentModuleName = moduleName.a;
				return _Utils_update(
					innerContext,
					{
						importAliases: A3(
							$elm$core$Dict$update,
							singleSegmentModuleName,
							function (previousValue) {
								return $elm$core$Maybe$Just(
									A2(
										$elm$core$List$cons,
										moduleName,
										A2($elm$core$Maybe$withDefault, _List_Nil, previousValue)));
							},
							innerContext.importAliases)
					});
			} else {
				return innerContext;
			}
		} else {
			var alias = _v0.a;
			return _Utils_update(
				innerContext,
				{
					importAliases: A3(
						$elm$core$Dict$update,
						$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$joinModuleName(
							$stil4m$elm_syntax$Elm$Syntax$Node$value(alias)),
						function (previousValue) {
							return $elm$core$Maybe$Just(
								A2(
									$elm$core$List$cons,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(import_.moduleName),
									A2($elm$core$Maybe$withDefault, _List_Nil, previousValue)));
						},
						innerContext.importAliases)
				});
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$typesFromExposingList = function (topLevelExpose) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(topLevelExpose);
	switch (_v0.$) {
		case 'InfixExpose':
			return $elm$core$Maybe$Nothing;
		case 'FunctionExpose':
			return $elm$core$Maybe$Nothing;
		case 'TypeOrAliasExpose':
			var name = _v0.a;
			return $elm$core$Maybe$Just(name);
		default:
			var name = _v0.a.name;
			return $elm$core$Maybe$Just(name);
	}
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$valuesFromExposingList = F4(
	function (moduleName, module_, topLevelExposeList, acc) {
		valuesFromExposingList:
		while (true) {
			if (!topLevelExposeList.b) {
				return acc;
			} else {
				var topLevelExpose = topLevelExposeList.a;
				var rest = topLevelExposeList.b;
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(topLevelExpose);
				switch (_v1.$) {
					case 'InfixExpose':
						var operator = _v1.a;
						var $temp$moduleName = moduleName,
							$temp$module_ = module_,
							$temp$topLevelExposeList = rest,
							$temp$acc = A3($elm$core$Dict$insert, operator, moduleName, acc);
						moduleName = $temp$moduleName;
						module_ = $temp$module_;
						topLevelExposeList = $temp$topLevelExposeList;
						acc = $temp$acc;
						continue valuesFromExposingList;
					case 'FunctionExpose':
						var _function = _v1.a;
						var $temp$moduleName = moduleName,
							$temp$module_ = module_,
							$temp$topLevelExposeList = rest,
							$temp$acc = A3($elm$core$Dict$insert, _function, moduleName, acc);
						moduleName = $temp$moduleName;
						module_ = $temp$module_;
						topLevelExposeList = $temp$topLevelExposeList;
						acc = $temp$acc;
						continue valuesFromExposingList;
					case 'TypeOrAliasExpose':
						var name = _v1.a;
						if (A2(
							$elm$core$List$any,
							function (alias) {
								return _Utils_eq(alias.name, name);
							},
							module_.aliases)) {
							var $temp$moduleName = moduleName,
								$temp$module_ = module_,
								$temp$topLevelExposeList = rest,
								$temp$acc = A3($elm$core$Dict$insert, name, moduleName, acc);
							moduleName = $temp$moduleName;
							module_ = $temp$module_;
							topLevelExposeList = $temp$topLevelExposeList;
							acc = $temp$acc;
							continue valuesFromExposingList;
						} else {
							var $temp$moduleName = moduleName,
								$temp$module_ = module_,
								$temp$topLevelExposeList = rest,
								$temp$acc = acc;
							moduleName = $temp$moduleName;
							module_ = $temp$module_;
							topLevelExposeList = $temp$topLevelExposeList;
							acc = $temp$acc;
							continue valuesFromExposingList;
						}
					default:
						var name = _v1.a.name;
						var open = _v1.a.open;
						if (open.$ === 'Just') {
							var newAcc = A3(
								$elm$core$List$foldl,
								F2(
									function (union, subAcc) {
										return _Utils_eq(union.name, name) ? A3(
											$elm$core$List$foldl,
											F2(
												function (_v3, subSubAcc) {
													var tag = _v3.a;
													return A3($elm$core$Dict$insert, tag, moduleName, subSubAcc);
												}),
											subAcc,
											union.tags) : subAcc;
									}),
								acc,
								module_.unions);
							var $temp$moduleName = moduleName,
								$temp$module_ = module_,
								$temp$topLevelExposeList = rest,
								$temp$acc = newAcc;
							moduleName = $temp$moduleName;
							module_ = $temp$module_;
							topLevelExposeList = $temp$topLevelExposeList;
							acc = $temp$acc;
							continue valuesFromExposingList;
						} else {
							var $temp$moduleName = moduleName,
								$temp$module_ = module_,
								$temp$topLevelExposeList = rest,
								$temp$acc = acc;
							moduleName = $temp$moduleName;
							module_ = $temp$module_;
							topLevelExposeList = $temp$topLevelExposeList;
							acc = $temp$acc;
							continue valuesFromExposingList;
						}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerImportExposed = F2(
	function (import_, innerContext) {
		var _v0 = A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, import_.exposingList);
		if (_v0.$ === 'Nothing') {
			return innerContext;
		} else {
			var exposing_ = _v0.a;
			var moduleName = $stil4m$elm_syntax$Elm$Syntax$Node$value(import_.moduleName);
			var module_ = A2(
				$elm$core$Maybe$withDefault,
				{
					aliases: _List_Nil,
					binops: _List_Nil,
					comment: '',
					name: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$joinModuleName(moduleName),
					unions: _List_Nil,
					values: _List_Nil
				},
				A2($elm$core$Dict$get, moduleName, innerContext.modules));
			if (exposing_.$ === 'All') {
				var foldIntoDict = F2(
					function (list, dict) {
						return A3(
							$elm$core$List$foldl,
							F2(
								function (_v3, acc) {
									var name = _v3.name;
									return A3($elm$core$Dict$insert, name, moduleName, acc);
								}),
							dict,
							list);
					});
				var importedTypes = A2(
					foldIntoDict,
					module_.aliases,
					A2(foldIntoDict, module_.unions, innerContext.importedTypes));
				var foldCustomTypesIntoDict = F2(
					function (unions, dict) {
						return A3(
							$elm$core$List$foldl,
							F2(
								function (union, acc) {
									return A3(
										$elm$core$List$foldl,
										F2(
											function (_v2, subAcc) {
												var name = _v2.a;
												return A3($elm$core$Dict$insert, name, moduleName, subAcc);
											}),
										acc,
										union.tags);
								}),
							dict,
							unions);
					});
				var importedFunctions = A2(
					foldCustomTypesIntoDict,
					module_.unions,
					A2(
						foldIntoDict,
						module_.aliases,
						A2(
							foldIntoDict,
							module_.binops,
							A2(foldIntoDict, module_.values, innerContext.importedFunctions))));
				return _Utils_update(
					innerContext,
					{importedFunctions: importedFunctions, importedTypes: importedTypes});
			} else {
				var topLevelExposeList = exposing_.a;
				var importedTypes = A3(
					$elm$core$List$foldl,
					F2(
						function (topLevelExpose, acc) {
							var _v4 = $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$typesFromExposingList(topLevelExpose);
							if (_v4.$ === 'Just') {
								var name = _v4.a;
								return A3($elm$core$Dict$insert, name, moduleName, acc);
							} else {
								return acc;
							}
						}),
					innerContext.importedTypes,
					topLevelExposeList);
				var importedFunctions = A4($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$valuesFromExposingList, moduleName, module_, topLevelExposeList, innerContext.importedFunctions);
				return _Utils_update(
					innerContext,
					{importedFunctions: importedFunctions, importedTypes: importedTypes});
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$importVisitor = F2(
	function (_v0, innerContext) {
		var import_ = _v0.b;
		return A2(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerImportExposed,
			import_,
			A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$registerImportAlias, import_, innerContext));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$exposedElements = function (nodes) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (node, acc) {
				var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
				switch (_v0.$) {
					case 'FunctionExpose':
						var name = _v0.a;
						return A2($elm$core$Set$insert, name, acc);
					case 'TypeOrAliasExpose':
						var name = _v0.a;
						return A2($elm$core$Set$insert, name, acc);
					case 'TypeExpose':
						var name = _v0.a.name;
						return A2($elm$core$Set$insert, name, acc);
					default:
						return acc;
				}
			}),
		$elm$core$Set$empty,
		nodes);
};
var $stil4m$elm_syntax$Elm$Syntax$Module$exposingList = function (m) {
	switch (m.$) {
		case 'NormalModule':
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.exposingList);
		case 'PortModule':
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.exposingList);
		default:
			var x = m.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$value(x.exposingList);
	}
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleDefinitionVisitor = F2(
	function (node, innerContext) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Module$exposingList(
			$stil4m$elm_syntax$Elm$Syntax$Node$value(node));
		if (_v0.$ === 'All') {
			return _Utils_update(
				innerContext,
				{exposesEverything: true});
		} else {
			var list = _v0.a;
			return _Utils_update(
				innerContext,
				{
					exposedNames: $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$exposedElements(list)
				});
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleDocs = F2(
	function (ast, context) {
		return A2(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$declarationListVisitor,
			ast.declarations,
			A2(
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$moduleDefinitionVisitor,
				ast.moduleDefinition,
				A3(
					$elm$core$List$foldl,
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$importVisitor,
					context,
					_Utils_ap($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$elmCorePrelude, ast.imports))));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeDependencies = function (project) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (dependencyModule, acc) {
				return A3(
					$elm$core$Dict$insert,
					A2($elm$core$String$split, '.', dependencyModule.name),
					dependencyModule,
					acc);
			}),
		$elm$core$Dict$empty,
		A3(
			$elm$core$Dict$foldl,
			F3(
				function (_v0, dep, acc) {
					return A2(
						$elm$core$List$append,
						$jfmengels$elm_review$Review$Project$Dependency$modules(dep),
						acc);
				}),
			_List_Nil,
			$jfmengels$elm_review$Review$Project$Valid$directDependencies(project)));
};
var $jfmengels$elm_review$NonEmpty$fromElement = function (x) {
	return A2($jfmengels$elm_review$NonEmpty$Nonempty, x, _List_Nil);
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$fromProjectToModule = F2(
	function (moduleName, modules) {
		return {
			exposedAliases: _List_Nil,
			exposedNames: $elm$core$Set$empty,
			exposedUnions: _List_Nil,
			exposedValues: _List_Nil,
			exposesEverything: false,
			importAliases: $elm$core$Dict$empty,
			importedFunctions: $elm$core$Dict$empty,
			importedTypes: $elm$core$Dict$empty,
			localTypes: $elm$core$Set$empty,
			lookupTable: $jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$empty(moduleName),
			modules: modules,
			scopes: $jfmengels$elm_review$NonEmpty$fromElement($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$emptyScope)
		};
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeImportedModulesDocs = F4(
	function (modulesByModuleName, deps, _v1, _v2) {
		var import_ = _v1.b;
		var accImported = _v2.a;
		var accProjectCache = _v2.b;
		var importedModuleName = $stil4m$elm_syntax$Elm$Syntax$Node$value(import_.moduleName);
		var _v3 = A2($elm$core$Dict$get, importedModuleName, accProjectCache.modules);
		if (_v3.$ === 'Just') {
			var importedModule = _v3.a;
			return _Utils_Tuple2(
				A3($elm$core$Dict$insert, importedModuleName, importedModule, accImported),
				accProjectCache);
		} else {
			var _v4 = A2($elm$core$Dict$get, importedModuleName, modulesByModuleName);
			if (_v4.$ === 'Just') {
				var importedModule = _v4.a;
				var _v5 = A5($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeOnlyModuleDocs, importedModuleName, importedModule, modulesByModuleName, deps, accProjectCache);
				var importedModuleDocs = _v5.a;
				var newProjectCacheAcc = _v5.b;
				return _Utils_Tuple2(
					A3($elm$core$Dict$insert, importedModuleName, importedModuleDocs, accImported),
					newProjectCacheAcc);
			} else {
				var _v6 = A2($elm$core$Dict$get, importedModuleName, deps);
				if (_v6.$ === 'Just') {
					var importedModule = _v6.a;
					return _Utils_Tuple2(
						A3($elm$core$Dict$insert, importedModuleName, importedModule, accImported),
						accProjectCache);
				} else {
					return _Utils_Tuple2(accImported, accProjectCache);
				}
			}
		}
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeOnlyModuleDocs = F5(
	function (moduleName, module_, modulesByModuleName, deps, projectCache) {
		var _v0 = A3(
			$elm$core$List$foldl,
			A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeImportedModulesDocs, modulesByModuleName, deps),
			_Utils_Tuple2($elm$core$Dict$empty, projectCache),
			_Utils_ap($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$elmCorePrelude, module_.ast.imports));
		var imported = _v0.a;
		var projectCacheWithComputedImports = _v0.b;
		var moduleContext = A2(
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleDocs,
			module_.ast,
			A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$fromProjectToModule, moduleName, imported));
		var moduleDocs = {
			aliases: moduleContext.exposedAliases,
			binops: _List_Nil,
			comment: '',
			name: A2($elm$core$String$join, '.', moduleName),
			unions: moduleContext.exposedUnions,
			values: moduleContext.exposedValues
		};
		var modules = A3($elm$core$Dict$insert, moduleName, moduleDocs, projectCacheWithComputedImports.modules);
		return _Utils_Tuple2(
			moduleDocs,
			_Utils_update(
				projectCache,
				{modules: modules}));
	});
var $jfmengels$elm_review$Review$Project$Valid$modulesByModuleName = function (_v0) {
	var project = _v0.a;
	return project.modulesByModuleName;
};
var $jfmengels$elm_review$Review$Project$Valid$projectCache = function (_v0) {
	var project = _v0.a;
	return project.projectCache;
};
var $jfmengels$elm_review$Review$Project$Valid$updateProjectCache = F2(
	function (projectCache_, _v0) {
		var project = _v0.a;
		return $jfmengels$elm_review$Review$Project$Valid$ValidProject(
			_Utils_update(
				project,
				{projectCache: projectCache_}));
	});
var $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$compute = F3(
	function (moduleName, module_, project) {
		var projectCache = $jfmengels$elm_review$Review$Project$Valid$projectCache(project);
		var modulesByModuleName = $jfmengels$elm_review$Review$Project$Valid$modulesByModuleName(project);
		var elmJsonRaw = A2(
			$elm$core$Maybe$map,
			function ($) {
				return $.raw;
			},
			$jfmengels$elm_review$Review$Project$Valid$elmJson(project));
		var deps = function () {
			var _v4 = projectCache.dependenciesModules;
			if (_v4.$ === 'Just') {
				var cache = _v4.a;
				return _Utils_eq(elmJsonRaw, cache.elmJsonRaw) ? cache.deps : $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeDependencies(project);
			} else {
				return $jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeDependencies(project);
			}
		}();
		var _v0 = A3(
			$elm$core$List$foldl,
			A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$computeImportedModulesDocs, modulesByModuleName, deps),
			_Utils_Tuple2($elm$core$Dict$empty, projectCache),
			_Utils_ap($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$elmCorePrelude, module_.ast.imports));
		var imported = _v0.a;
		var projectCacheWithComputedImports = _v0.b;
		var cacheKey = {imported: imported, source: module_.source};
		var computeLookupTableForModule = function (_v3) {
			var moduleContext = A2(
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectLookupTable,
				module_.ast.declarations,
				A2(
					$jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$collectModuleDocs,
					module_.ast,
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$fromProjectToModule, moduleName, imported)));
			return _Utils_Tuple2(
				moduleContext.lookupTable,
				A3(
					$elm$core$Dict$insert,
					moduleName,
					{
						aliases: moduleContext.exposedAliases,
						binops: _List_Nil,
						comment: '',
						name: A2($elm$core$String$join, '.', moduleName),
						unions: moduleContext.exposedUnions,
						values: moduleContext.exposedValues
					},
					projectCacheWithComputedImports.modules));
		};
		var _v1 = function () {
			var _v2 = A2($elm$core$Dict$get, moduleName, projectCacheWithComputedImports.lookupTables);
			if (_v2.$ === 'Just') {
				var cache = _v2.a;
				return _Utils_eq(cache.key, cacheKey) ? _Utils_Tuple2(cache.lookupTable, projectCacheWithComputedImports.modules) : computeLookupTableForModule(_Utils_Tuple0);
			} else {
				return computeLookupTableForModule(_Utils_Tuple0);
			}
		}();
		var lookupTable = _v1.a;
		var modules = _v1.b;
		var newProjectCache = {
			dependenciesModules: $elm$core$Maybe$Just(
				{deps: deps, elmJsonRaw: elmJsonRaw}),
			lookupTables: A3(
				$elm$core$Dict$insert,
				moduleName,
				{key: cacheKey, lookupTable: lookupTable},
				projectCacheWithComputedImports.lookupTables),
			modules: modules
		};
		return _Utils_Tuple2(
			lookupTable,
			A2($jfmengels$elm_review$Review$Project$Valid$updateProjectCache, newProjectCache, project));
	});
var $jfmengels$elm_review$Review$Cache$ModuleEntry = function (a) {
	return {$: 'ModuleEntry', a: a};
};
var $jfmengels$elm_review$Review$Cache$createModuleEntry = function (entry) {
	return $jfmengels$elm_review$Review$Cache$ModuleEntry(
		{
			contentHash: entry.contentHash,
			errors: entry.errors,
			inputContext: $jfmengels$elm_review$Review$Cache$ContextHash$create(entry.inputContext),
			isFileIgnored: entry.isFileIgnored,
			outputContext: entry.outputContext
		});
};
var $jfmengels$elm_review$Review$Rule$mapLast = F2(
	function (mapper, lines) {
		var _v0 = $elm$core$List$reverse(lines);
		if (!_v0.b) {
			return lines;
		} else {
			var first = _v0.a;
			var rest = _v0.b;
			return $elm$core$List$reverse(
				A2(
					$elm$core$List$cons,
					mapper(first),
					rest));
		}
	});
var $jfmengels$elm_review$Review$Rule$extractSourceCode = F2(
	function (lines, range) {
		return A2(
			$elm$core$String$dropLeft,
			range.start.column - 1,
			A2(
				$elm$core$String$join,
				'\n',
				A2(
					$jfmengels$elm_review$Review$Rule$mapLast,
					A2($elm$core$String$slice, 0, range.end.column - 1),
					A2(
						$elm$core$List$take,
						(range.end.row - range.start.row) + 1,
						A2($elm$core$List$drop, range.start.row - 1, lines)))));
	});
var $jfmengels$elm_review$Vendor$Zipper$focusl = F2(
	function (fc, zipper) {
		focusl:
		while (true) {
			if (fc(
				$jfmengels$elm_review$Vendor$Zipper$current(zipper))) {
				return $elm$core$Maybe$Just(zipper);
			} else {
				var _v0 = $jfmengels$elm_review$Vendor$Zipper$prev(zipper);
				if (_v0.$ === 'Just') {
					var z = _v0.a;
					var $temp$fc = fc,
						$temp$zipper = z;
					fc = $temp$fc;
					zipper = $temp$zipper;
					continue focusl;
				} else {
					return $elm$core$Maybe$Nothing;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$setFilePathIfUnset = F2(
	function (module_, rawError) {
		var err = rawError.a;
		return (err.filePath === '') ? $jfmengels$elm_review$Review$Rule$Error(
			_Utils_update(
				err,
				{filePath: module_.path})) : rawError;
	});
var $jfmengels$elm_review$Review$Rule$accumulateList = F3(
	function (visitor, elements, errorAndContext) {
		return A3(
			$elm$core$List$foldl,
			$jfmengels$elm_review$Review$Rule$visitWithListOfVisitors(visitor),
			errorAndContext,
			elements);
	});
var $jfmengels$elm_review$Review$Rule$findModuleDocumentationBeforeCutOffLine = F2(
	function (cutOffLine, comments) {
		findModuleDocumentationBeforeCutOffLine:
		while (true) {
			if (!comments.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var comment = comments.a;
				var range = comment.a;
				var content = comment.b;
				var restOfComments = comments.b;
				if (_Utils_cmp(range.start.row, cutOffLine) > 0) {
					return $elm$core$Maybe$Nothing;
				} else {
					if (A2($elm$core$String$startsWith, '{-|', content)) {
						return $elm$core$Maybe$Just(comment);
					} else {
						var $temp$cutOffLine = cutOffLine,
							$temp$comments = restOfComments;
						cutOffLine = $temp$cutOffLine;
						comments = $temp$comments;
						continue findModuleDocumentationBeforeCutOffLine;
					}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$findModuleDocumentation = function (ast) {
	var cutOffLine = function () {
		var _v0 = ast.imports;
		if (_v0.b) {
			var firstImport = _v0.a;
			return $stil4m$elm_syntax$Elm$Syntax$Node$range(firstImport).start.row;
		} else {
			var _v1 = ast.declarations;
			if (_v1.b) {
				var firstDeclaration = _v1.a;
				return $stil4m$elm_syntax$Elm$Syntax$Node$range(firstDeclaration).start.row;
			} else {
				return 0;
			}
		}
	}();
	return A2($jfmengels$elm_review$Review$Rule$findModuleDocumentationBeforeCutOffLine, cutOffLine, ast.comments);
};
var $jfmengels$elm_review$Review$Rule$accumulateModuleDocumentationVisitor = F3(
	function (visitors, ast, initialErrorsAndContext) {
		if ($elm$core$List$isEmpty(visitors)) {
			return initialErrorsAndContext;
		} else {
			var moduleDocumentation = $jfmengels$elm_review$Review$Rule$findModuleDocumentation(ast);
			return A3(
				$elm$core$List$foldl,
				F2(
					function (visitor, errorsAndContext) {
						return A2(
							$jfmengels$elm_review$Review$Rule$accumulate,
							visitor(moduleDocumentation),
							errorsAndContext);
					}),
				initialErrorsAndContext,
				visitors);
		}
	});
var $jfmengels$elm_review$Vendor$ListExtra$orderIndependentConcatMapAppend = F3(
	function (fn, left, right) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (item, acc) {
					return A2(
						$elm$core$List$append,
						fn(item),
						acc);
				}),
			right,
			left);
	});
var $jfmengels$elm_review$Review$Rule$makeFinalModuleEvaluation = F3(
	function (finalEvaluationFns, previousErrors, context) {
		return A3(
			$jfmengels$elm_review$Vendor$ListExtra$orderIndependentConcatMapAppend,
			function (visitor) {
				return visitor(context);
			},
			finalEvaluationFns,
			previousErrors);
	});
var $jfmengels$elm_review$Review$Rule$visitModuleForProjectRule = F3(
	function (schema, initialContext, module_) {
		return function (_v0) {
			var errors = _v0.a;
			var moduleContext = _v0.b;
			return _Utils_Tuple2(
				A3($jfmengels$elm_review$Review$Rule$makeFinalModuleEvaluation, schema.finalEvaluationFns, errors, moduleContext),
				moduleContext);
		}(
			A2(
				schema.declarationAndExpressionVisitor,
				module_.ast.declarations,
				A3(
					$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
					schema.declarationListVisitors,
					module_.ast.declarations,
					A3(
						$jfmengels$elm_review$Review$Rule$accumulateList,
						schema.importVisitors,
						module_.ast.imports,
						A3(
							$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
							schema.commentsVisitors,
							module_.ast.comments,
							A3(
								$jfmengels$elm_review$Review$Rule$accumulateModuleDocumentationVisitor,
								schema.moduleDocumentationVisitors,
								module_.ast,
								A3(
									$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
									schema.moduleDefinitionVisitors,
									module_.ast.moduleDefinition,
									_Utils_Tuple2(_List_Nil, initialContext))))))));
	});
var $jfmengels$elm_review$Review$Rule$computeModule = F7(
	function (dataToComputeModules, module_, isFileIgnored, projectContext, project, moduleZipper, fixedErrors) {
		computeModule:
		while (true) {
			var moduleName = $stil4m$elm_syntax$Elm$Syntax$Node$value(
				$jfmengels$elm_review$Review$Rule$moduleNameNode(module_.ast.moduleDefinition));
			var _v0 = dataToComputeModules.projectVisitor.requestedData;
			var requestedData = _v0.a;
			var _v1 = requestedData.moduleNameLookupTable ? A3($jfmengels$elm_review$Review$ModuleNameLookupTable$Compute$compute, moduleName, module_, project) : _Utils_Tuple2(
				$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$empty(moduleName),
				project);
			var moduleNameLookupTable = _v1.a;
			var newProject = _v1.b;
			var availableData = {
				ast: module_.ast,
				extractSourceCode: requestedData.sourceCodeExtractor ? $jfmengels$elm_review$Review$Rule$extractSourceCode(
					$elm$core$String$lines(module_.source)) : $elm$core$Basics$always(''),
				filePath: module_.path,
				isFileIgnored: isFileIgnored,
				isInSourceDirectories: module_.isInSourceDirectories,
				moduleKey: $jfmengels$elm_review$Review$Rule$ModuleKey(module_.path),
				moduleNameLookupTable: moduleNameLookupTable
			};
			var initialModuleContext = A3($jfmengels$elm_review$Review$Rule$applyContextCreator, availableData, dataToComputeModules.moduleContextCreator, projectContext);
			var _v2 = A3($jfmengels$elm_review$Review$Rule$visitModuleForProjectRule, dataToComputeModules.moduleVisitor, initialModuleContext, module_);
			var moduleErrors = _v2.a;
			var resultModuleContext = _v2.b;
			var errors = A3(
				$jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName,
				dataToComputeModules.exceptions,
				dataToComputeModules.projectVisitor.name,
				A2(
					$elm$core$List$map,
					$jfmengels$elm_review$Review$Rule$setFilePathIfUnset(module_),
					moduleErrors));
			var analysis = function (_v10) {
				return $jfmengels$elm_review$Review$Cache$createModuleEntry(
					{
						contentHash: module_.contentHash,
						errors: errors,
						inputContext: projectContext,
						isFileIgnored: isFileIgnored,
						outputContext: function () {
							var _v9 = $jfmengels$elm_review$Review$Rule$getFolderFromTraversal(dataToComputeModules.projectVisitor.traversalAndFolder);
							if (_v9.$ === 'Just') {
								var fromModuleToProject = _v9.a.fromModuleToProject;
								return A3($jfmengels$elm_review$Review$Rule$applyContextCreator, availableData, fromModuleToProject, resultModuleContext);
							} else {
								return projectContext;
							}
						}()
					});
			};
			var resultWhenNoFix = function (_v8) {
				return {
					analysis: analysis(_Utils_Tuple0),
					fixedErrors: fixedErrors,
					nextStep: $jfmengels$elm_review$Review$Rule$ModuleVisitStep(
						$jfmengels$elm_review$Vendor$Zipper$next(moduleZipper)),
					project: newProject
				};
			};
			var _v3 = A6(
				$jfmengels$elm_review$Review$Rule$findFix,
				dataToComputeModules.reviewOptions,
				dataToComputeModules.projectVisitor,
				newProject,
				errors,
				fixedErrors,
				$elm$core$Maybe$Just(moduleZipper));
			if (_v3.$ === 'Just') {
				var _v4 = _v3.a;
				var postFixStatus = _v4.a;
				var fixResult = _v4.b;
				if (postFixStatus.$ === 'ShouldAbort') {
					var newFixedErrors = postFixStatus.a;
					return {
						analysis: analysis(_Utils_Tuple0),
						fixedErrors: newFixedErrors,
						nextStep: $jfmengels$elm_review$Review$Rule$NextStepAbort,
						project: fixResult.project
					};
				} else {
					var newFixedErrors = postFixStatus.a;
					var _v6 = fixResult.fixedFile;
					switch (_v6.$) {
						case 'FixedElmModule':
							var source = _v6.a.source;
							var ast = _v6.a.ast;
							var newModuleZipper_ = _v6.b;
							var filePath = $jfmengels$elm_review$Review$Rule$errorFilePath(fixResult.error);
							if (_Utils_eq(module_.path, filePath)) {
								var $temp$dataToComputeModules = dataToComputeModules,
									$temp$module_ = _Utils_update(
									module_,
									{ast: ast, source: source}),
									$temp$isFileIgnored = isFileIgnored,
									$temp$projectContext = projectContext,
									$temp$project = fixResult.project,
									$temp$moduleZipper = newModuleZipper_,
									$temp$fixedErrors = newFixedErrors;
								dataToComputeModules = $temp$dataToComputeModules;
								module_ = $temp$module_;
								isFileIgnored = $temp$isFileIgnored;
								projectContext = $temp$projectContext;
								project = $temp$project;
								moduleZipper = $temp$moduleZipper;
								fixedErrors = $temp$fixedErrors;
								continue computeModule;
							} else {
								var _v7 = A2(
									$jfmengels$elm_review$Vendor$Zipper$focusl,
									function (mod) {
										return _Utils_eq(mod.node.label, filePath);
									},
									moduleZipper);
								if (_v7.$ === 'Just') {
									var newModuleZipper = _v7.a;
									return A3(
										$jfmengels$elm_review$Review$Logger$log,
										dataToComputeModules.reviewOptions.logger,
										A2(
											$jfmengels$elm_review$Review$Rule$fixedError,
											newFixedErrors,
											{filePath: filePath, ruleName: dataToComputeModules.projectVisitor.name}),
										{
											analysis: analysis(_Utils_Tuple0),
											fixedErrors: newFixedErrors,
											nextStep: $jfmengels$elm_review$Review$Rule$ModuleVisitStep(
												$elm$core$Maybe$Just(newModuleZipper)),
											project: fixResult.project
										});
								} else {
									return resultWhenNoFix(_Utils_Tuple0);
								}
							}
						case 'FixedElmJson':
							return {
								analysis: analysis(_Utils_Tuple0),
								fixedErrors: A2($jfmengels$elm_review$Review$Fix$FixedErrors$insert, fixResult.error, fixedErrors),
								nextStep: $jfmengels$elm_review$Review$Rule$BackToElmJson,
								project: fixResult.project
							};
						default:
							return {
								analysis: analysis(_Utils_Tuple0),
								fixedErrors: A2($jfmengels$elm_review$Review$Fix$FixedErrors$insert, fixResult.error, fixedErrors),
								nextStep: $jfmengels$elm_review$Review$Rule$BackToReadme,
								project: fixResult.project
							};
					}
				}
			} else {
				return resultWhenNoFix(_Utils_Tuple0);
			}
		}
	});
var $jfmengels$elm_review$Review$Project$Valid$moduleGraph = function (_v0) {
	var project = _v0.a;
	return project.moduleGraph;
};
var $jfmengels$elm_review$Review$Rule$computeProjectContext = F5(
	function (traversalAndFolder, project, cache, incoming, initial) {
		if (traversalAndFolder.$ === 'TraverseAllModulesInParallel') {
			return initial;
		} else {
			var foldProjectContexts = traversalAndFolder.a.foldProjectContexts;
			var graph = $jfmengels$elm_review$Review$Project$Valid$moduleGraph(project);
			return A3(
				$jfmengels$elm_review$Vendor$IntDict$foldl,
				F3(
					function (key, _v1, accContext) {
						var _v2 = A2(
							$elm$core$Maybe$andThen,
							function (graphModule) {
								return A2($elm$core$Dict$get, graphModule.node.label, cache);
							},
							A2($jfmengels$elm_review$Vendor$Graph$get, key, graph));
						if (_v2.$ === 'Just') {
							var importedModuleCache = _v2.a;
							return A2(
								foldProjectContexts,
								$jfmengels$elm_review$Review$Cache$outputContext(importedModuleCache),
								accContext);
						} else {
							return accContext;
						}
					}),
				initial,
				incoming);
		}
	});
var $jfmengels$elm_review$Review$Cache$ContentHash$areEqual = F2(
	function (_v0, _v1) {
		var a = _v0.a;
		var b = _v1.a;
		return _Utils_eq(a, b);
	});
var $jfmengels$elm_review$Review$Cache$match = F4(
	function (contentHash, context, _v0, _v1) {
		var entry = _v0.a;
		var isFileIgnored = _v1.isFileIgnored;
		var rulesCareAboutIgnoredFiles = _v1.rulesCareAboutIgnoredFiles;
		return A2($jfmengels$elm_review$Review$Cache$ContentHash$areEqual, contentHash, entry.contentHash) && (A2($jfmengels$elm_review$Review$Cache$ContextHash$areEqual, context, entry.inputContext) && ((!rulesCareAboutIgnoredFiles) || _Utils_eq(isFileIgnored, entry.isFileIgnored)));
	});
var $jfmengels$elm_review$Review$Rule$reuseCache = F2(
	function (predicate, maybeCacheEntry) {
		if (maybeCacheEntry.$ === 'Nothing') {
			return false;
		} else {
			var cacheEntry = maybeCacheEntry.a;
			return predicate(cacheEntry);
		}
	});
var $jfmengels$elm_review$Review$Rule$shouldIgnoreModule = F2(
	function (dataToComputeModules, path) {
		var _v0 = dataToComputeModules.projectVisitor.traversalAndFolder;
		if (_v0.$ === 'TraverseAllModulesInParallel') {
			if (_v0.a.$ === 'Nothing') {
				var _v1 = _v0.a;
				return !A2($jfmengels$elm_review$Review$Exceptions$isFileWeWantReportsFor, dataToComputeModules.exceptions, path);
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
var $jfmengels$elm_review$Review$Rule$computeModuleAndCacheResult = F6(
	function (dataToComputeModules, inputProjectContext, moduleZipper, project, moduleContexts, fixedErrors) {
		var ignoreModule = function (_v3) {
			return {
				fixedErrors: fixedErrors,
				moduleContexts: moduleContexts,
				nextStep: $jfmengels$elm_review$Review$Rule$ModuleVisitStep(
					$jfmengels$elm_review$Vendor$Zipper$next(moduleZipper)),
				project: project
			};
		};
		var _v0 = $jfmengels$elm_review$Vendor$Zipper$current(moduleZipper);
		var node = _v0.node;
		var incoming = _v0.incoming;
		var _v1 = A2($jfmengels$elm_review$Review$Project$Valid$getModuleByPath, node.label, project);
		if (_v1.$ === 'Nothing') {
			return ignoreModule(_Utils_Tuple0);
		} else {
			var module_ = _v1.a;
			if (A2($jfmengels$elm_review$Review$Rule$shouldIgnoreModule, dataToComputeModules, module_.path)) {
				return ignoreModule(_Utils_Tuple0);
			} else {
				var projectContext = A5($jfmengels$elm_review$Review$Rule$computeProjectContext, dataToComputeModules.projectVisitor.traversalAndFolder, project, moduleContexts, incoming, inputProjectContext);
				var isFileIgnored = !A2($jfmengels$elm_review$Review$Exceptions$isFileWeWantReportsFor, dataToComputeModules.exceptions, module_.path);
				var _v2 = dataToComputeModules.projectVisitor.requestedData;
				var requestedData = _v2.a;
				if (A2(
					$jfmengels$elm_review$Review$Rule$reuseCache,
					function (cacheEntry) {
						return A4(
							$jfmengels$elm_review$Review$Cache$match,
							module_.contentHash,
							$jfmengels$elm_review$Review$Cache$ContextHash$create(projectContext),
							cacheEntry,
							{isFileIgnored: isFileIgnored, rulesCareAboutIgnoredFiles: requestedData.ignoredFiles});
					},
					A2($elm$core$Dict$get, module_.path, moduleContexts))) {
					return ignoreModule(_Utils_Tuple0);
				} else {
					var result = A7($jfmengels$elm_review$Review$Rule$computeModule, dataToComputeModules, module_, isFileIgnored, projectContext, project, moduleZipper, fixedErrors);
					return {
						fixedErrors: result.fixedErrors,
						moduleContexts: A3($elm$core$Dict$insert, module_.path, result.analysis, moduleContexts),
						nextStep: result.nextStep,
						project: result.project
					};
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$computeModules = F6(
	function (dataToComputeModules, projectContexts, maybeModuleZipper, initialProject, initialModuleContexts, fixedErrors) {
		computeModules:
		while (true) {
			if (maybeModuleZipper.$ === 'Nothing') {
				return {
					fixedErrors: fixedErrors,
					moduleContexts: initialModuleContexts,
					project: initialProject,
					step: $jfmengels$elm_review$Review$Rule$FinalProjectEvaluation(projectContexts)
				};
			} else {
				var moduleZipper = maybeModuleZipper.a;
				var result = A6($jfmengels$elm_review$Review$Rule$computeModuleAndCacheResult, dataToComputeModules, projectContexts.deps, moduleZipper, initialProject, initialModuleContexts, fixedErrors);
				var _v1 = result.nextStep;
				switch (_v1.$) {
					case 'ModuleVisitStep':
						var newModuleZipper = _v1.a;
						var $temp$dataToComputeModules = dataToComputeModules,
							$temp$projectContexts = projectContexts,
							$temp$maybeModuleZipper = newModuleZipper,
							$temp$initialProject = result.project,
							$temp$initialModuleContexts = result.moduleContexts,
							$temp$fixedErrors = result.fixedErrors;
						dataToComputeModules = $temp$dataToComputeModules;
						projectContexts = $temp$projectContexts;
						maybeModuleZipper = $temp$maybeModuleZipper;
						initialProject = $temp$initialProject;
						initialModuleContexts = $temp$initialModuleContexts;
						fixedErrors = $temp$fixedErrors;
						continue computeModules;
					case 'BackToElmJson':
						return {
							fixedErrors: result.fixedErrors,
							moduleContexts: result.moduleContexts,
							project: result.project,
							step: $jfmengels$elm_review$Review$Rule$ElmJson(
								{initial: projectContexts.initial})
						};
					case 'BackToReadme':
						return {
							fixedErrors: result.fixedErrors,
							moduleContexts: result.moduleContexts,
							project: result.project,
							step: $jfmengels$elm_review$Review$Rule$Readme(
								{elmJson: projectContexts.elmJson, initial: projectContexts.initial})
						};
					default:
						return {fixedErrors: result.fixedErrors, moduleContexts: result.moduleContexts, project: result.project, step: $jfmengels$elm_review$Review$Rule$Abort};
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$Dependencies = function (a) {
	return {$: 'Dependencies', a: a};
};
var $jfmengels$elm_review$Review$Rule$ReadmeKey = function (a) {
	return {$: 'ReadmeKey', a: a};
};
var $jfmengels$elm_review$Review$Project$Valid$readmeHash = function (_v0) {
	var project = _v0.a;
	return A2($elm$core$Maybe$map, $elm$core$Tuple$second, project.readme);
};
var $jfmengels$elm_review$Review$Rule$computeReadme = F5(
	function (dataToComputeProject, project, contexts, cache, fixedErrors) {
		computeReadme:
		while (true) {
			var reviewOptions = dataToComputeProject.reviewOptions;
			var projectVisitor = dataToComputeProject.projectVisitor;
			var exceptions = dataToComputeProject.exceptions;
			var inputContext = contexts.elmJson;
			var cachePredicate = function (entry) {
				return A3(
					$jfmengels$elm_review$Review$Cache$matchMaybe,
					$jfmengels$elm_review$Review$Project$Valid$readmeHash(project),
					$jfmengels$elm_review$Review$Cache$ContextHash$create(inputContext),
					entry);
			};
			var _v0 = A3(
				$jfmengels$elm_review$Review$Rule$reuseProjectRuleCache,
				cachePredicate,
				function ($) {
					return $.readme;
				},
				cache);
			if (_v0.$ === 'Just') {
				var entry = _v0.a;
				return {
					cache: cache,
					fixedErrors: fixedErrors,
					project: project,
					step: $jfmengels$elm_review$Review$Rule$Dependencies(
						{
							elmJson: contexts.elmJson,
							initial: contexts.initial,
							readme: $jfmengels$elm_review$Review$Cache$outputContextMaybe(entry)
						})
				};
			} else {
				var projectReadme = $jfmengels$elm_review$Review$Project$Valid$readme(project);
				var readmeData = A2(
					$elm$core$Maybe$map,
					function (readme) {
						return {
							content: readme.content,
							readmeKey: $jfmengels$elm_review$Review$Rule$ReadmeKey(
								{content: readme.content, path: readme.path})
						};
					},
					projectReadme);
				var _v1 = A3(
					$jfmengels$elm_review$Review$Rule$accumulateWithListOfVisitors,
					projectVisitor.readmeVisitors,
					readmeData,
					_Utils_Tuple2(_List_Nil, inputContext));
				var errorsForVisitor = _v1.a;
				var outputContext = _v1.b;
				var errors = A3($jfmengels$elm_review$Review$Rule$filterExceptionsAndSetName, exceptions, projectVisitor.name, errorsForVisitor);
				var updateCache = function (_v7) {
					var readmeEntry = $jfmengels$elm_review$Review$Cache$createEntryMaybe(
						{
							contentHash: $jfmengels$elm_review$Review$Project$Valid$readmeHash(project),
							errors: errors,
							inputContext: inputContext,
							outputContext: outputContext
						});
					return _Utils_update(
						cache,
						{
							readme: $elm$core$Maybe$Just(readmeEntry)
						});
				};
				var resultWhenNoFix = function (_v6) {
					return {
						cache: updateCache(_Utils_Tuple0),
						fixedErrors: fixedErrors,
						project: project,
						step: $jfmengels$elm_review$Review$Rule$Dependencies(
							{elmJson: contexts.elmJson, initial: contexts.initial, readme: outputContext})
					};
				};
				var _v2 = A6($jfmengels$elm_review$Review$Rule$findFix, reviewOptions, projectVisitor, project, errors, fixedErrors, $elm$core$Maybe$Nothing);
				if (_v2.$ === 'Just') {
					var _v3 = _v2.a;
					var postFixStatus = _v3.a;
					var fixResult = _v3.b;
					if (postFixStatus.$ === 'ShouldAbort') {
						var newFixedErrors = postFixStatus.a;
						return {
							cache: updateCache(_Utils_Tuple0),
							fixedErrors: newFixedErrors,
							project: fixResult.project,
							step: $jfmengels$elm_review$Review$Rule$Abort
						};
					} else {
						var newFixedErrors = postFixStatus.a;
						var _v5 = fixResult.fixedFile;
						switch (_v5.$) {
							case 'FixedElmJson':
								return {
									cache: updateCache(_Utils_Tuple0),
									fixedErrors: newFixedErrors,
									project: fixResult.project,
									step: $jfmengels$elm_review$Review$Rule$ElmJson(
										{initial: contexts.initial})
								};
							case 'FixedReadme':
								var $temp$dataToComputeProject = dataToComputeProject,
									$temp$project = fixResult.project,
									$temp$contexts = contexts,
									$temp$cache = updateCache(_Utils_Tuple0),
									$temp$fixedErrors = newFixedErrors;
								dataToComputeProject = $temp$dataToComputeProject;
								project = $temp$project;
								contexts = $temp$contexts;
								cache = $temp$cache;
								fixedErrors = $temp$fixedErrors;
								continue computeReadme;
							default:
								return resultWhenNoFix(_Utils_Tuple0);
						}
					}
				} else {
					return resultWhenNoFix(_Utils_Tuple0);
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Cache$errors = function (_v0) {
	var entry = _v0.a;
	return entry.errors;
};
var $jfmengels$elm_review$Review$Cache$errorsMaybe = function (maybeEntry) {
	if (maybeEntry.$ === 'Just') {
		var entry = maybeEntry.a.a;
		return entry.errors;
	} else {
		return _List_Nil;
	}
};
var $jfmengels$elm_review$Review$Cache$outputForNoOutput = function (_v0) {
	var entry = _v0.a;
	return entry.output;
};
var $jfmengels$elm_review$Review$Rule$errorsFromCache = function (cache) {
	return $elm$core$List$concat(
		_List_fromArray(
			[
				A3(
				$elm$core$Dict$foldl,
				F3(
					function (_v0, cacheEntry, acc) {
						return A2(
							$elm$core$List$append,
							$jfmengels$elm_review$Review$Cache$errors(cacheEntry),
							acc);
					}),
				_List_Nil,
				cache.moduleContexts),
				$jfmengels$elm_review$Review$Cache$errorsMaybe(cache.elmJson),
				$jfmengels$elm_review$Review$Cache$errorsMaybe(cache.readme),
				$jfmengels$elm_review$Review$Cache$errorsMaybe(cache.dependencies),
				A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2($elm$core$Maybe$map, $jfmengels$elm_review$Review$Cache$outputForNoOutput, cache.finalEvaluationErrors))
			]));
};
var $jfmengels$elm_review$Review$Rule$computeStepsForProject = F2(
	function (dataToComputeProject, acc) {
		computeStepsForProject:
		while (true) {
			var project = acc.project;
			var cache = acc.cache;
			var fixedErrors = acc.fixedErrors;
			var step = acc.step;
			switch (step.$) {
				case 'ElmJson':
					var contexts = step.a;
					var $temp$dataToComputeProject = dataToComputeProject,
						$temp$acc = A5($jfmengels$elm_review$Review$Rule$computeElmJson, dataToComputeProject, project, contexts.initial, cache, fixedErrors);
					dataToComputeProject = $temp$dataToComputeProject;
					acc = $temp$acc;
					continue computeStepsForProject;
				case 'Readme':
					var contexts = step.a;
					var $temp$dataToComputeProject = dataToComputeProject,
						$temp$acc = A5($jfmengels$elm_review$Review$Rule$computeReadme, dataToComputeProject, project, contexts, cache, fixedErrors);
					dataToComputeProject = $temp$dataToComputeProject;
					acc = $temp$acc;
					continue computeStepsForProject;
				case 'Dependencies':
					var contexts = step.a;
					var $temp$dataToComputeProject = dataToComputeProject,
						$temp$acc = A5($jfmengels$elm_review$Review$Rule$computeDependencies, dataToComputeProject, project, contexts, cache, fixedErrors);
					dataToComputeProject = $temp$dataToComputeProject;
					acc = $temp$acc;
					continue computeStepsForProject;
				case 'Modules':
					var contexts = step.a;
					var moduleZipper = step.b;
					var _v1 = dataToComputeProject.projectVisitor.moduleVisitor;
					if (_v1.$ === 'Nothing') {
						var $temp$dataToComputeProject = dataToComputeProject,
							$temp$acc = {
							cache: acc.cache,
							fixedErrors: acc.fixedErrors,
							project: acc.project,
							step: $jfmengels$elm_review$Review$Rule$FinalProjectEvaluation(contexts)
						};
						dataToComputeProject = $temp$dataToComputeProject;
						acc = $temp$acc;
						continue computeStepsForProject;
					} else {
						var _v2 = _v1.a;
						var moduleVisitor = _v2.a;
						var moduleContextCreator = _v2.b;
						var result = A6(
							$jfmengels$elm_review$Review$Rule$computeModules,
							{exceptions: dataToComputeProject.exceptions, moduleContextCreator: moduleContextCreator, moduleVisitor: moduleVisitor, projectVisitor: dataToComputeProject.projectVisitor, reviewOptions: dataToComputeProject.reviewOptions},
							contexts,
							$elm$core$Maybe$Just(moduleZipper),
							project,
							cache.moduleContexts,
							fixedErrors);
						var $temp$dataToComputeProject = dataToComputeProject,
							$temp$acc = {
							cache: _Utils_update(
								cache,
								{moduleContexts: result.moduleContexts}),
							fixedErrors: result.fixedErrors,
							project: result.project,
							step: result.step
						};
						dataToComputeProject = $temp$dataToComputeProject;
						acc = $temp$acc;
						continue computeStepsForProject;
					}
				case 'FinalProjectEvaluation':
					var contexts = step.a;
					var $temp$dataToComputeProject = dataToComputeProject,
						$temp$acc = A5($jfmengels$elm_review$Review$Rule$computeFinalProjectEvaluation, dataToComputeProject, project, contexts, cache, fixedErrors);
					dataToComputeProject = $temp$dataToComputeProject;
					acc = $temp$acc;
					continue computeStepsForProject;
				case 'DataExtract':
					var context = step.a;
					var errors = $jfmengels$elm_review$Review$Rule$errorsFromCache(cache);
					var cacheWithExtract = A5($jfmengels$elm_review$Review$Rule$computeExtract, dataToComputeProject.reviewOptions, dataToComputeProject.projectVisitor, context, errors, cache);
					return {cache: cacheWithExtract, errors: errors, fixedErrors: acc.fixedErrors, project: acc.project};
				default:
					return {cache: cache, errors: _List_Nil, fixedErrors: acc.fixedErrors, project: acc.project};
			}
		}
	});
var $jfmengels$elm_review$Review$Rule$endedRule = function (name) {
	return _List_fromArray(
		[
			_Utils_Tuple2(
			'type',
			$elm$json$Json$Encode$string('timer-end')),
			_Utils_Tuple2(
			'metric',
			$elm$json$Json$Encode$string('Running ' + name))
		]);
};
var $jfmengels$elm_review$Review$Rule$finalCacheMarker = F3(
	function (_v0, _v1, cache) {
		return cache;
	});
var $jfmengels$elm_review$Review$Rule$startedRule = function (name) {
	return _List_fromArray(
		[
			_Utils_Tuple2(
			'type',
			$elm$json$Json$Encode$string('timer-start')),
			_Utils_Tuple2(
			'metric',
			$elm$json$Json$Encode$string('Running ' + name))
		]);
};
var $jfmengels$elm_review$Review$Rule$runProjectVisitor = F5(
	function (dataToComputeProject, ruleId, cache, fixedErrors, project) {
		return A3(
			$jfmengels$elm_review$Review$Logger$log,
			dataToComputeProject.reviewOptions.logger,
			$jfmengels$elm_review$Review$Rule$endedRule(dataToComputeProject.projectVisitor.name),
			A5(
				$jfmengels$elm_review$Review$Rule$runProjectVisitorHelp,
				dataToComputeProject,
				ruleId,
				cache,
				fixedErrors,
				A3(
					$jfmengels$elm_review$Review$Logger$log,
					dataToComputeProject.reviewOptions.logger,
					$jfmengels$elm_review$Review$Rule$startedRule(dataToComputeProject.projectVisitor.name),
					project)));
	});
var $jfmengels$elm_review$Review$Rule$runProjectVisitorHelp = F5(
	function (dataToComputeProject, ruleId, initialCache, initialFixedErrors, initialProject) {
		var projectVisitor = dataToComputeProject.projectVisitor;
		var exceptions = dataToComputeProject.exceptions;
		var _v0 = A2(
			$jfmengels$elm_review$Review$Rule$computeStepsForProject,
			dataToComputeProject,
			{
				cache: initialCache,
				fixedErrors: initialFixedErrors,
				project: initialProject,
				step: $jfmengels$elm_review$Review$Rule$ElmJson(
					{initial: projectVisitor.initialProjectContext})
			});
		var project = _v0.project;
		var errors = _v0.errors;
		var cache = _v0.cache;
		var fixedErrors = _v0.fixedErrors;
		return {
			errors: errors,
			extract: A2(
				$elm$core$Maybe$map,
				function ($) {
					return $.extract;
				},
				A3($jfmengels$elm_review$Review$Rule$finalCacheMarker, projectVisitor.name, ruleId, cache).extract),
			fixedErrors: fixedErrors,
			project: project,
			rule: $jfmengels$elm_review$Review$Rule$Rule(
				{
					configurationError: $elm$core$Maybe$Nothing,
					exceptions: exceptions,
					extractsData: !_Utils_eq(projectVisitor.dataExtractor, $elm$core$Maybe$Nothing),
					id: ruleId,
					name: projectVisitor.name,
					providesFixes: projectVisitor.providesFixes,
					requestedData: projectVisitor.requestedData,
					ruleImplementation: F5(
						function (newReviewOptions, newRuleId, newExceptions, newFixedErrors, newProjectArg) {
							return A5(
								$jfmengels$elm_review$Review$Rule$runProjectVisitor,
								{exceptions: newExceptions, projectVisitor: projectVisitor, reviewOptions: newReviewOptions},
								newRuleId,
								cache,
								newFixedErrors,
								newProjectArg);
						})
				})
		};
	});
var $jfmengels$elm_review$Review$Rule$fromProjectRuleSchema = function (projectRuleSchema) {
	var schema = projectRuleSchema.a;
	return $jfmengels$elm_review$Review$Rule$Rule(
		{
			configurationError: $elm$core$Maybe$Nothing,
			exceptions: $jfmengels$elm_review$Review$Exceptions$init,
			extractsData: !_Utils_eq(schema.dataExtractor, $elm$core$Maybe$Nothing),
			id: 0,
			name: schema.name,
			providesFixes: schema.providesFixes,
			requestedData: A2(
				$jfmengels$elm_review$Review$RequestedData$combine,
				A2($elm$core$Maybe$map, $jfmengels$elm_review$Review$Rule$requestedDataFromContextCreator, schema.moduleContextCreator),
				A2(
					$elm$core$Maybe$map,
					A2(
						$elm$core$Basics$composeR,
						function ($) {
							return $.fromModuleToProject;
						},
						$jfmengels$elm_review$Review$Rule$requestedDataFromContextCreator),
					schema.folder)),
			ruleImplementation: F5(
				function (reviewOptions, ruleId, exceptions, fixedErrors, project) {
					return A5(
						$jfmengels$elm_review$Review$Rule$runProjectVisitor,
						{
							exceptions: exceptions,
							projectVisitor: $jfmengels$elm_review$Review$Rule$fromProjectRuleSchemaToRunnableProjectVisitor(projectRuleSchema),
							reviewOptions: reviewOptions
						},
						ruleId,
						A2(
							$jfmengels$elm_review$Review$Rule$removeUnknownModulesFromInitialCache,
							project,
							A3($jfmengels$elm_review$Review$Rule$initialCacheMarker, schema.name, ruleId, $jfmengels$elm_review$Review$Rule$emptyCache)),
						fixedErrors,
						project);
				})
		});
};
var $elm_community$maybe_extra$Maybe$Extra$unwrap = F3(
	function (_default, f, m) {
		if (m.$ === 'Nothing') {
			return _default;
		} else {
			var a = m.a;
			return f(a);
		}
	});
var $author$project$NoUnsortedCases$declarationListVisitor = F3(
	function (_v0, declarations, _v1) {
		var config = _v0.a;
		var moduleName = _v1.moduleName;
		var exposedTypes = _v1.exposedTypes;
		var customTypes = _v1.customTypes;
		var typeConstructors = function (type_) {
			return function (cs) {
				return {
					constructors: $elm$core$Set$fromList(cs),
					declarationOrder: cs
				};
			}(
				A2(
					$elm$core$List$map,
					A2(
						$elm$core$Basics$composeR,
						$stil4m$elm_syntax$Elm$Syntax$Node$value,
						A2(
							$elm$core$Basics$composeR,
							function ($) {
								return $.name;
							},
							$stil4m$elm_syntax$Elm$Syntax$Node$value)),
					type_.constructors));
		};
		var getCustomType = function (node) {
			var _v3 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
			if (_v3.$ === 'CustomTypeDeclaration') {
				var type_ = _v3.a;
				var name = type_.name;
				return A2(
					config.sortablePredicate,
					moduleName,
					$stil4m$elm_syntax$Elm$Syntax$Node$value(name)) ? $elm$core$Maybe$Just(
					_Utils_Tuple2(
						$stil4m$elm_syntax$Elm$Syntax$Node$value(type_.name),
						typeConstructors(type_))) : $elm$core$Maybe$Nothing;
			} else {
				return $elm$core$Maybe$Nothing;
			}
		};
		return function (ts) {
			return $elm$core$List$isEmpty(ts) ? {customTypes: customTypes, exposedCustomTypes: $elm$core$Dict$empty} : {
				customTypes: function (v) {
					return A3($elm$core$Dict$insert, _List_Nil, v, customTypes);
				}(
					$elm$core$Dict$fromList(ts)),
				exposedCustomTypes: $elm$core$Dict$fromList(
					A2(
						$elm$core$List$filter,
						function (_v2) {
							var typeName = _v2.a;
							return A3(
								$elm_community$maybe_extra$Maybe$Extra$unwrap,
								true,
								$elm$core$Set$member(typeName),
								exposedTypes);
						},
						ts))
			};
		}(
			A2($elm$core$List$filterMap, getCustomType, declarations));
	});
var $author$project$NoUnsortedCases$getExposedTypes = function () {
	var keepTypesWithExposedConstructors = function (e) {
		var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(e);
		if (_v1.$ === 'TypeExpose') {
			var name = _v1.a.name;
			return $elm$core$Maybe$Just(name);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	};
	return A2(
		$elm$core$Basics$composeR,
		$stil4m$elm_syntax$Elm$Syntax$Module$exposingList,
		function (l) {
			if (l.$ === 'All') {
				return $elm$core$Maybe$Nothing;
			} else {
				var es = l.a;
				return $elm$core$Maybe$Just(
					$elm$core$Set$fromList(
						A2($elm$core$List$filterMap, keepTypesWithExposedConstructors, es)));
			}
		});
}();
var $jfmengels$elm_review$Review$Rule$withFullAst = function (_v0) {
	var fn = _v0.a;
	var requested = _v0.b;
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		function (data) {
			return A2(fn, data, data.ast);
		},
		requested);
};
var $jfmengels$elm_review$Review$Rule$withIsFileIgnored = function (_v0) {
	var fn = _v0.a;
	var requested = _v0.b.a;
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		function (data) {
			return A2(fn, data, data.isFileIgnored);
		},
		$jfmengels$elm_review$Review$RequestedData$RequestedData(
			_Utils_update(
				requested,
				{ignoredFiles: true})));
};
var $jfmengels$elm_review$Review$Rule$withModuleNameLookupTable = function (_v0) {
	var fn = _v0.a;
	var requested = _v0.b.a;
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		function (data) {
			return A2(fn, data, data.moduleNameLookupTable);
		},
		$jfmengels$elm_review$Review$RequestedData$RequestedData(
			_Utils_update(
				requested,
				{moduleNameLookupTable: true})));
};
var $jfmengels$elm_review$Review$Rule$withSourceCodeExtractor = function (_v0) {
	var fn = _v0.a;
	var requested = _v0.b.a;
	return A2(
		$jfmengels$elm_review$Review$Rule$ContextCreator,
		function (data) {
			return A2(fn, data, data.extractSourceCode);
		},
		$jfmengels$elm_review$Review$RequestedData$RequestedData(
			_Utils_update(
				requested,
				{sourceCodeExtractor: true})));
};
var $author$project$NoUnsortedCases$fromProjectToModule = function (config) {
	return $jfmengels$elm_review$Review$Rule$withFullAst(
		$jfmengels$elm_review$Review$Rule$withIsFileIgnored(
			$jfmengels$elm_review$Review$Rule$withModuleName(
				$jfmengels$elm_review$Review$Rule$withSourceCodeExtractor(
					$jfmengels$elm_review$Review$Rule$withModuleNameLookupTable(
						$jfmengels$elm_review$Review$Rule$initContextCreator(
							F6(
								function (lookupTable, extractSource, moduleName, fileIsIgnored, _v0, projectContext) {
									var declarations = _v0.declarations;
									var moduleDefinition = _v0.moduleDefinition;
									var _v1 = A3(
										$author$project$NoUnsortedCases$declarationListVisitor,
										config,
										declarations,
										{
											customTypes: projectContext.customTypes,
											exposedTypes: $author$project$NoUnsortedCases$getExposedTypes(
												$stil4m$elm_syntax$Elm$Syntax$Node$value(moduleDefinition)),
											moduleName: A2($elm$core$String$join, '.', moduleName)
										});
									var exposedCustomTypes = _v1.exposedCustomTypes;
									var customTypes = _v1.customTypes;
									return {customTypes: customTypes, exposedCustomTypes: exposedCustomTypes, extractSource: extractSource, fileIsIgnored: fileIsIgnored, lookupTable: lookupTable};
								})))))));
};
var $author$project$NoUnsortedCases$initialProjectContext = {customTypes: $elm$core$Dict$empty};
var $elm_community$list_extra$List$Extra$find = F2(
	function (predicate, list) {
		find:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var first = list.a;
				var rest = list.b;
				if (predicate(first)) {
					return $elm$core$Maybe$Just(first);
				} else {
					var $temp$predicate = predicate,
						$temp$list = rest;
					predicate = $temp$predicate;
					list = $temp$list;
					continue find;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Fix$Internal$Replacement = F2(
	function (a, b) {
		return {$: 'Replacement', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Fix$replaceRangeBy = $jfmengels$elm_review$Review$Fix$Internal$Replacement;
var $author$project$Util$createFix = F2(
	function (extractSource, sorted) {
		var applyFix = F2(
			function (newIndex, _v0) {
				var oldIndex = _v0.a;
				var range = _v0.b;
				return _Utils_eq(newIndex, oldIndex) ? _List_Nil : A2(
					$elm$core$Maybe$withDefault,
					_List_Nil,
					A2(
						$elm$core$Maybe$map,
						function (oldRange) {
							return $elm$core$List$singleton(
								A2(
									$jfmengels$elm_review$Review$Fix$replaceRangeBy,
									oldRange,
									extractSource(range)));
						},
						A2(
							$elm$core$Maybe$map,
							$elm$core$Tuple$second,
							A2(
								$elm_community$list_extra$List$Extra$find,
								A2(
									$elm$core$Basics$composeL,
									$elm$core$Basics$eq(newIndex),
									$elm$core$Tuple$first),
								sorted))));
			});
		return $elm$core$List$concat(
			A2($elm$core$List$indexedMap, applyFix, sorted));
	});
var $elm_community$graph$Graph$AcyclicGraph = F2(
	function (a, b) {
		return {$: 'AcyclicGraph', a: a, b: b};
	});
var $elm_community$graph$Graph$Edge = F3(
	function (from, to, label) {
		return {from: from, label: label, to: to};
	});
var $elm_community$intdict$IntDict$Empty = {$: 'Empty'};
var $elm_community$intdict$IntDict$empty = $elm_community$intdict$IntDict$Empty;
var $elm_community$intdict$IntDict$findMin = function (dict) {
	findMin:
	while (true) {
		switch (dict.$) {
			case 'Empty':
				return $elm$core$Maybe$Nothing;
			case 'Leaf':
				var l = dict.a;
				return $elm$core$Maybe$Just(
					_Utils_Tuple2(l.key, l.value));
			default:
				var i = dict.a;
				var $temp$dict = i.left;
				dict = $temp$dict;
				continue findMin;
		}
	}
};
var $elm_community$intdict$IntDict$Inner = function (a) {
	return {$: 'Inner', a: a};
};
var $elm_community$intdict$IntDict$size = function (dict) {
	switch (dict.$) {
		case 'Empty':
			return 0;
		case 'Leaf':
			return 1;
		default:
			var i = dict.a;
			return i.size;
	}
};
var $elm_community$intdict$IntDict$inner = F3(
	function (p, l, r) {
		var _v0 = _Utils_Tuple2(l, r);
		if (_v0.a.$ === 'Empty') {
			var _v1 = _v0.a;
			return r;
		} else {
			if (_v0.b.$ === 'Empty') {
				var _v2 = _v0.b;
				return l;
			} else {
				return $elm_community$intdict$IntDict$Inner(
					{
						left: l,
						prefix: p,
						right: r,
						size: $elm_community$intdict$IntDict$size(l) + $elm_community$intdict$IntDict$size(r)
					});
			}
		}
	});
var $elm_community$intdict$IntDict$highestBitSet = function (n) {
	var shiftOr = F2(
		function (i, shift) {
			return i | (i >>> shift);
		});
	var n1 = A2(shiftOr, n, 1);
	var n2 = A2(shiftOr, n1, 2);
	var n3 = A2(shiftOr, n2, 4);
	var n4 = A2(shiftOr, n3, 8);
	var n5 = A2(shiftOr, n4, 16);
	return n5 & (~(n5 >>> 1));
};
var $elm_community$intdict$IntDict$signBit = $elm_community$intdict$IntDict$highestBitSet(-1);
var $elm_community$intdict$IntDict$isBranchingBitSet = function (p) {
	return A2(
		$elm$core$Basics$composeR,
		$elm$core$Bitwise$xor($elm_community$intdict$IntDict$signBit),
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Bitwise$and(p.branchingBit),
			$elm$core$Basics$neq(0)));
};
var $elm_community$intdict$IntDict$higherBitMask = function (branchingBit) {
	return branchingBit ^ (~(branchingBit - 1));
};
var $elm_community$intdict$IntDict$lcp = F2(
	function (x, y) {
		var branchingBit = $elm_community$intdict$IntDict$highestBitSet(x ^ y);
		var mask = $elm_community$intdict$IntDict$higherBitMask(branchingBit);
		var prefixBits = x & mask;
		return {branchingBit: branchingBit, prefixBits: prefixBits};
	});
var $elm_community$intdict$IntDict$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $elm_community$intdict$IntDict$leaf = F2(
	function (k, v) {
		return $elm_community$intdict$IntDict$Leaf(
			{key: k, value: v});
	});
var $elm_community$intdict$IntDict$prefixMatches = F2(
	function (p, n) {
		return _Utils_eq(
			n & $elm_community$intdict$IntDict$higherBitMask(p.branchingBit),
			p.prefixBits);
	});
var $elm_community$intdict$IntDict$update = F3(
	function (key, alter, dict) {
		var join = F2(
			function (_v2, _v3) {
				var k1 = _v2.a;
				var l = _v2.b;
				var k2 = _v3.a;
				var r = _v3.b;
				var prefix = A2($elm_community$intdict$IntDict$lcp, k1, k2);
				return A2($elm_community$intdict$IntDict$isBranchingBitSet, prefix, k2) ? A3($elm_community$intdict$IntDict$inner, prefix, l, r) : A3($elm_community$intdict$IntDict$inner, prefix, r, l);
			});
		var alteredNode = function (mv) {
			var _v1 = alter(mv);
			if (_v1.$ === 'Just') {
				var v = _v1.a;
				return A2($elm_community$intdict$IntDict$leaf, key, v);
			} else {
				return $elm_community$intdict$IntDict$empty;
			}
		};
		switch (dict.$) {
			case 'Empty':
				return alteredNode($elm$core$Maybe$Nothing);
			case 'Leaf':
				var l = dict.a;
				return _Utils_eq(l.key, key) ? alteredNode(
					$elm$core$Maybe$Just(l.value)) : A2(
					join,
					_Utils_Tuple2(
						key,
						alteredNode($elm$core$Maybe$Nothing)),
					_Utils_Tuple2(l.key, dict));
			default:
				var i = dict.a;
				return A2($elm_community$intdict$IntDict$prefixMatches, i.prefix, key) ? (A2($elm_community$intdict$IntDict$isBranchingBitSet, i.prefix, key) ? A3(
					$elm_community$intdict$IntDict$inner,
					i.prefix,
					i.left,
					A3($elm_community$intdict$IntDict$update, key, alter, i.right)) : A3(
					$elm_community$intdict$IntDict$inner,
					i.prefix,
					A3($elm_community$intdict$IntDict$update, key, alter, i.left),
					i.right)) : A2(
					join,
					_Utils_Tuple2(
						key,
						alteredNode($elm$core$Maybe$Nothing)),
					_Utils_Tuple2(i.prefix.prefixBits, dict));
		}
	});
var $elm_community$intdict$IntDict$insert = F3(
	function (key, value, dict) {
		return A3(
			$elm_community$intdict$IntDict$update,
			key,
			$elm$core$Basics$always(
				$elm$core$Maybe$Just(value)),
			dict);
	});
var $elm_community$intdict$IntDict$Disjunct = F2(
	function (a, b) {
		return {$: 'Disjunct', a: a, b: b};
	});
var $elm_community$intdict$IntDict$Left = {$: 'Left'};
var $elm_community$intdict$IntDict$Parent = F2(
	function (a, b) {
		return {$: 'Parent', a: a, b: b};
	});
var $elm_community$intdict$IntDict$Right = {$: 'Right'};
var $elm_community$intdict$IntDict$SamePrefix = {$: 'SamePrefix'};
var $elm_community$intdict$IntDict$combineBits = F3(
	function (a, b, mask) {
		return (a & (~mask)) | (b & mask);
	});
var $elm_community$intdict$IntDict$mostSignificantBranchingBit = F2(
	function (a, b) {
		return (_Utils_eq(a, $elm_community$intdict$IntDict$signBit) || _Utils_eq(b, $elm_community$intdict$IntDict$signBit)) ? $elm_community$intdict$IntDict$signBit : A2($elm$core$Basics$max, a, b);
	});
var $elm_community$intdict$IntDict$determineBranchRelation = F2(
	function (l, r) {
		var rp = r.prefix;
		var lp = l.prefix;
		var mask = $elm_community$intdict$IntDict$highestBitSet(
			A2($elm_community$intdict$IntDict$mostSignificantBranchingBit, lp.branchingBit, rp.branchingBit));
		var modifiedRightPrefix = A3($elm_community$intdict$IntDict$combineBits, rp.prefixBits, ~lp.prefixBits, mask);
		var prefix = A2($elm_community$intdict$IntDict$lcp, lp.prefixBits, modifiedRightPrefix);
		var childEdge = F2(
			function (branchPrefix, c) {
				return A2($elm_community$intdict$IntDict$isBranchingBitSet, branchPrefix, c.prefix.prefixBits) ? $elm_community$intdict$IntDict$Right : $elm_community$intdict$IntDict$Left;
			});
		return _Utils_eq(lp, rp) ? $elm_community$intdict$IntDict$SamePrefix : (_Utils_eq(prefix, lp) ? A2(
			$elm_community$intdict$IntDict$Parent,
			$elm_community$intdict$IntDict$Left,
			A2(childEdge, l.prefix, r)) : (_Utils_eq(prefix, rp) ? A2(
			$elm_community$intdict$IntDict$Parent,
			$elm_community$intdict$IntDict$Right,
			A2(childEdge, r.prefix, l)) : A2(
			$elm_community$intdict$IntDict$Disjunct,
			prefix,
			A2(childEdge, prefix, l))));
	});
var $elm_community$intdict$IntDict$get = F2(
	function (key, dict) {
		get:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return $elm$core$Maybe$Nothing;
				case 'Leaf':
					var l = dict.a;
					return _Utils_eq(l.key, key) ? $elm$core$Maybe$Just(l.value) : $elm$core$Maybe$Nothing;
				default:
					var i = dict.a;
					if (!A2($elm_community$intdict$IntDict$prefixMatches, i.prefix, key)) {
						return $elm$core$Maybe$Nothing;
					} else {
						if (A2($elm_community$intdict$IntDict$isBranchingBitSet, i.prefix, key)) {
							var $temp$key = key,
								$temp$dict = i.right;
							key = $temp$key;
							dict = $temp$dict;
							continue get;
						} else {
							var $temp$key = key,
								$temp$dict = i.left;
							key = $temp$key;
							dict = $temp$dict;
							continue get;
						}
					}
			}
		}
	});
var $elm_community$intdict$IntDict$member = F2(
	function (key, dict) {
		var _v0 = A2($elm_community$intdict$IntDict$get, key, dict);
		if (_v0.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var $elm_community$intdict$IntDict$intersect = F2(
	function (l, r) {
		intersect:
		while (true) {
			var _v0 = _Utils_Tuple2(l, r);
			_v0$1:
			while (true) {
				_v0$2:
				while (true) {
					switch (_v0.a.$) {
						case 'Empty':
							var _v1 = _v0.a;
							return $elm_community$intdict$IntDict$Empty;
						case 'Leaf':
							switch (_v0.b.$) {
								case 'Empty':
									break _v0$1;
								case 'Leaf':
									break _v0$2;
								default:
									break _v0$2;
							}
						default:
							switch (_v0.b.$) {
								case 'Empty':
									break _v0$1;
								case 'Leaf':
									var lr = _v0.b.a;
									var _v3 = A2($elm_community$intdict$IntDict$get, lr.key, l);
									if (_v3.$ === 'Just') {
										var v = _v3.a;
										return A2($elm_community$intdict$IntDict$leaf, lr.key, v);
									} else {
										return $elm_community$intdict$IntDict$Empty;
									}
								default:
									var il = _v0.a.a;
									var ir = _v0.b.a;
									var _v4 = A2($elm_community$intdict$IntDict$determineBranchRelation, il, ir);
									switch (_v4.$) {
										case 'SamePrefix':
											return A3(
												$elm_community$intdict$IntDict$inner,
												il.prefix,
												A2($elm_community$intdict$IntDict$intersect, il.left, ir.left),
												A2($elm_community$intdict$IntDict$intersect, il.right, ir.right));
										case 'Parent':
											if (_v4.a.$ === 'Left') {
												if (_v4.b.$ === 'Right') {
													var _v5 = _v4.a;
													var _v6 = _v4.b;
													var $temp$l = il.right,
														$temp$r = r;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												} else {
													var _v9 = _v4.a;
													var _v10 = _v4.b;
													var $temp$l = il.left,
														$temp$r = r;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												}
											} else {
												if (_v4.b.$ === 'Right') {
													var _v7 = _v4.a;
													var _v8 = _v4.b;
													var $temp$l = l,
														$temp$r = ir.right;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												} else {
													var _v11 = _v4.a;
													var _v12 = _v4.b;
													var $temp$l = l,
														$temp$r = ir.left;
													l = $temp$l;
													r = $temp$r;
													continue intersect;
												}
											}
										default:
											return $elm_community$intdict$IntDict$Empty;
									}
							}
					}
				}
				var ll = _v0.a.a;
				return A2($elm_community$intdict$IntDict$member, ll.key, r) ? l : $elm_community$intdict$IntDict$Empty;
			}
			var _v2 = _v0.b;
			return $elm_community$intdict$IntDict$Empty;
		}
	});
var $elm_community$graph$Graph$crashHack = function (msg) {
	crashHack:
	while (true) {
		var $temp$msg = msg;
		msg = $temp$msg;
		continue crashHack;
	}
};
var $elm_community$graph$Graph$unGraph = function (graph) {
	var rep = graph.a;
	return rep;
};
var $elm_community$graph$Graph$get = function (nodeId) {
	return A2(
		$elm$core$Basics$composeR,
		$elm_community$graph$Graph$unGraph,
		$elm_community$intdict$IntDict$get(nodeId));
};
var $elm_community$graph$Graph$unsafeGet = F3(
	function (msg, id, graph) {
		var _v0 = A2($elm_community$graph$Graph$get, id, graph);
		if (_v0.$ === 'Nothing') {
			return $elm_community$graph$Graph$crashHack(msg);
		} else {
			var ctx = _v0.a;
			return ctx;
		}
	});
var $elm_community$graph$Graph$checkForBackEdges = F2(
	function (ordering, graph) {
		var success = function (_v3) {
			return A2($elm_community$graph$Graph$AcyclicGraph, graph, ordering);
		};
		var check = F2(
			function (id, _v2) {
				var backSet = _v2.a;
				var error = 'Graph.checkForBackEdges: `ordering` didn\'t contain `id`';
				var ctx = A3($elm_community$graph$Graph$unsafeGet, error, id, graph);
				var backSetWithId = A3($elm_community$intdict$IntDict$insert, id, _Utils_Tuple0, backSet);
				var backEdges = A2($elm_community$intdict$IntDict$intersect, ctx.outgoing, backSetWithId);
				var _v0 = $elm_community$intdict$IntDict$findMin(backEdges);
				if (_v0.$ === 'Nothing') {
					return $elm$core$Result$Ok(
						_Utils_Tuple2(backSetWithId, _Utils_Tuple0));
				} else {
					var _v1 = _v0.a;
					var to = _v1.a;
					var label = _v1.b;
					return $elm$core$Result$Err(
						A3($elm_community$graph$Graph$Edge, id, to, label));
				}
			});
		return A2(
			$elm$core$Result$map,
			success,
			A3(
				$elm$core$List$foldl,
				F2(
					function (id, res) {
						return A2(
							$elm$core$Result$andThen,
							check(id),
							res);
					}),
				$elm$core$Result$Ok(
					_Utils_Tuple2($elm_community$intdict$IntDict$empty, _Utils_Tuple0)),
				ordering));
	});
var $elm_community$intdict$IntDict$foldr = F3(
	function (f, acc, dict) {
		foldr:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return acc;
				case 'Leaf':
					var l = dict.a;
					return A3(f, l.key, l.value, acc);
				default:
					var i = dict.a;
					var $temp$f = f,
						$temp$acc = A3($elm_community$intdict$IntDict$foldr, f, acc, i.right),
						$temp$dict = i.left;
					f = $temp$f;
					acc = $temp$acc;
					dict = $temp$dict;
					continue foldr;
			}
		}
	});
var $elm_community$intdict$IntDict$keys = function (dict) {
	return A3(
		$elm_community$intdict$IntDict$foldr,
		F3(
			function (key, value, keyList) {
				return A2($elm$core$List$cons, key, keyList);
			}),
		_List_Nil,
		dict);
};
var $elm_community$graph$Graph$alongOutgoingEdges = function (ctx) {
	return $elm_community$intdict$IntDict$keys(ctx.outgoing);
};
var $elm_community$graph$Graph$Graph = function (a) {
	return {$: 'Graph', a: a};
};
var $elm_community$intdict$IntDict$foldl = F3(
	function (f, acc, dict) {
		foldl:
		while (true) {
			switch (dict.$) {
				case 'Empty':
					return acc;
				case 'Leaf':
					var l = dict.a;
					return A3(f, l.key, l.value, acc);
				default:
					var i = dict.a;
					var $temp$f = f,
						$temp$acc = A3($elm_community$intdict$IntDict$foldl, f, acc, i.left),
						$temp$dict = i.right;
					f = $temp$f;
					acc = $temp$acc;
					dict = $temp$dict;
					continue foldl;
			}
		}
	});
var $elm_community$graph$Graph$applyEdgeDiff = F3(
	function (nodeId, diff, graphRep) {
		var updateOutgoingEdge = F2(
			function (upd, node) {
				return _Utils_update(
					node,
					{
						outgoing: A3($elm_community$intdict$IntDict$update, nodeId, upd, node.outgoing)
					});
			});
		var updateIncomingEdge = F2(
			function (upd, node) {
				return _Utils_update(
					node,
					{
						incoming: A3($elm_community$intdict$IntDict$update, nodeId, upd, node.incoming)
					});
			});
		var flippedFoldl = F3(
			function (f, dict, acc) {
				return A3($elm_community$intdict$IntDict$foldl, f, acc, dict);
			});
		var edgeUpdateToMaybe = function (edgeUpdate) {
			if (edgeUpdate.$ === 'Insert') {
				var lbl = edgeUpdate.a;
				return $elm$core$Maybe$Just(lbl);
			} else {
				return $elm$core$Maybe$Nothing;
			}
		};
		var updateAdjacency = F3(
			function (updateEdge, updatedId, edgeUpdate) {
				var updateLbl = updateEdge(
					$elm$core$Basics$always(
						edgeUpdateToMaybe(edgeUpdate)));
				return A2(
					$elm_community$intdict$IntDict$update,
					updatedId,
					$elm$core$Maybe$map(updateLbl));
			});
		return A3(
			flippedFoldl,
			updateAdjacency(updateOutgoingEdge),
			diff.outgoing,
			A3(
				flippedFoldl,
				updateAdjacency(updateIncomingEdge),
				diff.incoming,
				graphRep));
	});
var $elm_community$graph$Graph$Insert = function (a) {
	return {$: 'Insert', a: a};
};
var $elm_community$graph$Graph$Remove = function (a) {
	return {$: 'Remove', a: a};
};
var $elm_community$graph$Graph$emptyDiff = {incoming: $elm_community$intdict$IntDict$empty, outgoing: $elm_community$intdict$IntDict$empty};
var $elm_community$graph$Graph$computeEdgeDiff = F2(
	function (old, _new) {
		var collectUpdates = F3(
			function (edgeUpdate, updatedId, label) {
				var replaceUpdate = function (old_) {
					var _v5 = _Utils_Tuple2(
						old_,
						edgeUpdate(label));
					if (_v5.a.$ === 'Just') {
						if (_v5.a.a.$ === 'Remove') {
							if (_v5.b.$ === 'Insert') {
								var oldLbl = _v5.a.a.a;
								var newLbl = _v5.b.a;
								return _Utils_eq(oldLbl, newLbl) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
									$elm_community$graph$Graph$Insert(newLbl));
							} else {
								return $elm_community$graph$Graph$crashHack('Graph.computeEdgeDiff: Collected two removals for the same edge. This is an error in the implementation of Graph and you should file a bug report!');
							}
						} else {
							return $elm_community$graph$Graph$crashHack('Graph.computeEdgeDiff: Collected inserts before removals. This is an error in the implementation of Graph and you should file a bug report!');
						}
					} else {
						var _v6 = _v5.a;
						var eu = _v5.b;
						return $elm$core$Maybe$Just(eu);
					}
				};
				return A2($elm_community$intdict$IntDict$update, updatedId, replaceUpdate);
			});
		var collect = F3(
			function (edgeUpdate, adj, updates) {
				return A3(
					$elm_community$intdict$IntDict$foldl,
					collectUpdates(edgeUpdate),
					updates,
					adj);
			});
		var _v0 = _Utils_Tuple2(old, _new);
		if (_v0.a.$ === 'Nothing') {
			if (_v0.b.$ === 'Nothing') {
				var _v1 = _v0.a;
				var _v2 = _v0.b;
				return $elm_community$graph$Graph$emptyDiff;
			} else {
				var _v4 = _v0.a;
				var ins = _v0.b.a;
				return {
					incoming: A3(collect, $elm_community$graph$Graph$Insert, ins.outgoing, $elm_community$intdict$IntDict$empty),
					outgoing: A3(collect, $elm_community$graph$Graph$Insert, ins.incoming, $elm_community$intdict$IntDict$empty)
				};
			}
		} else {
			if (_v0.b.$ === 'Nothing') {
				var rem = _v0.a.a;
				var _v3 = _v0.b;
				return {
					incoming: A3(collect, $elm_community$graph$Graph$Remove, rem.outgoing, $elm_community$intdict$IntDict$empty),
					outgoing: A3(collect, $elm_community$graph$Graph$Remove, rem.incoming, $elm_community$intdict$IntDict$empty)
				};
			} else {
				var rem = _v0.a.a;
				var ins = _v0.b.a;
				return _Utils_eq(rem, ins) ? $elm_community$graph$Graph$emptyDiff : {
					incoming: A3(
						collect,
						$elm_community$graph$Graph$Insert,
						ins.outgoing,
						A3(collect, $elm_community$graph$Graph$Remove, rem.outgoing, $elm_community$intdict$IntDict$empty)),
					outgoing: A3(
						collect,
						$elm_community$graph$Graph$Insert,
						ins.incoming,
						A3(collect, $elm_community$graph$Graph$Remove, rem.incoming, $elm_community$intdict$IntDict$empty))
				};
			}
		}
	});
var $elm_community$intdict$IntDict$filter = F2(
	function (predicate, dict) {
		var add = F3(
			function (k, v, d) {
				return A2(predicate, k, v) ? A3($elm_community$intdict$IntDict$insert, k, v, d) : d;
			});
		return A3($elm_community$intdict$IntDict$foldl, add, $elm_community$intdict$IntDict$empty, dict);
	});
var $elm_community$graph$Graph$update = F2(
	function (nodeId, updater) {
		var wrappedUpdater = function (rep) {
			var old = A2($elm_community$intdict$IntDict$get, nodeId, rep);
			var filterInvalidEdges = function (ctx) {
				return $elm_community$intdict$IntDict$filter(
					F2(
						function (id, _v0) {
							return _Utils_eq(id, ctx.node.id) || A2($elm_community$intdict$IntDict$member, id, rep);
						}));
			};
			var cleanUpEdges = function (ctx) {
				return _Utils_update(
					ctx,
					{
						incoming: A2(filterInvalidEdges, ctx, ctx.incoming),
						outgoing: A2(filterInvalidEdges, ctx, ctx.outgoing)
					});
			};
			var _new = A2(
				$elm$core$Maybe$map,
				cleanUpEdges,
				updater(old));
			var diff = A2($elm_community$graph$Graph$computeEdgeDiff, old, _new);
			return A3(
				$elm_community$intdict$IntDict$update,
				nodeId,
				$elm$core$Basics$always(_new),
				A3($elm_community$graph$Graph$applyEdgeDiff, nodeId, diff, rep));
		};
		return A2(
			$elm$core$Basics$composeR,
			$elm_community$graph$Graph$unGraph,
			A2($elm$core$Basics$composeR, wrappedUpdater, $elm_community$graph$Graph$Graph));
	});
var $elm_community$graph$Graph$remove = F2(
	function (nodeId, graph) {
		return A3(
			$elm_community$graph$Graph$update,
			nodeId,
			$elm$core$Basics$always($elm$core$Maybe$Nothing),
			graph);
	});
var $elm_community$graph$Graph$guidedDfs = F5(
	function (selectNeighbors, visitNode, startingSeeds, startingAcc, startingGraph) {
		var go = F3(
			function (seeds, acc, graph) {
				go:
				while (true) {
					if (!seeds.b) {
						return _Utils_Tuple2(acc, graph);
					} else {
						var next = seeds.a;
						var seeds1 = seeds.b;
						var _v1 = A2($elm_community$graph$Graph$get, next, graph);
						if (_v1.$ === 'Nothing') {
							var $temp$seeds = seeds1,
								$temp$acc = acc,
								$temp$graph = graph;
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						} else {
							var ctx = _v1.a;
							var _v2 = A2(visitNode, ctx, acc);
							var accAfterDiscovery = _v2.a;
							var finishNode = _v2.b;
							var _v3 = A3(
								go,
								selectNeighbors(ctx),
								accAfterDiscovery,
								A2($elm_community$graph$Graph$remove, next, graph));
							var accBeforeFinish = _v3.a;
							var graph1 = _v3.b;
							var accAfterFinish = finishNode(accBeforeFinish);
							var $temp$seeds = seeds1,
								$temp$acc = accAfterFinish,
								$temp$graph = graph1;
							seeds = $temp$seeds;
							acc = $temp$acc;
							graph = $temp$graph;
							continue go;
						}
					}
				}
			});
		return A3(go, startingSeeds, startingAcc, startingGraph);
	});
var $elm_community$graph$Graph$nodeIds = A2($elm$core$Basics$composeR, $elm_community$graph$Graph$unGraph, $elm_community$intdict$IntDict$keys);
var $elm_community$graph$Graph$dfs = F3(
	function (visitNode, acc, graph) {
		return A5(
			$elm_community$graph$Graph$guidedDfs,
			$elm_community$graph$Graph$alongOutgoingEdges,
			visitNode,
			$elm_community$graph$Graph$nodeIds(graph),
			acc,
			graph).a;
	});
var $elm_community$graph$Graph$onFinish = F3(
	function (visitor, ctx, acc) {
		return _Utils_Tuple2(
			acc,
			visitor(ctx));
	});
var $elm_community$graph$Graph$checkAcyclic = function (graph) {
	var reversePostOrder = A3(
		$elm_community$graph$Graph$dfs,
		$elm_community$graph$Graph$onFinish(
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.node;
				},
				A2(
					$elm$core$Basics$composeR,
					function ($) {
						return $.id;
					},
					$elm$core$List$cons))),
		_List_Nil,
		graph);
	return A2($elm_community$graph$Graph$checkForBackEdges, reversePostOrder, graph);
};
var $elm_community$graph$Graph$edges = function (graph) {
	var flippedFoldl = F3(
		function (f, dict, list) {
			return A3($elm_community$intdict$IntDict$foldl, f, list, dict);
		});
	var prependEdges = F2(
		function (node1, ctx) {
			return A2(
				flippedFoldl,
				F2(
					function (node2, e) {
						return $elm$core$List$cons(
							{from: node1, label: e, to: node2});
					}),
				ctx.outgoing);
		});
	return A3(
		flippedFoldl,
		prependEdges,
		$elm_community$graph$Graph$unGraph(graph),
		_List_Nil);
};
var $elm_community$result_extra$Result$Extra$extract = F2(
	function (f, x) {
		if (x.$ === 'Ok') {
			var a = x.a;
			return a;
		} else {
			var e = x.a;
			return f(e);
		}
	});
var $elm$core$Set$filter = F2(
	function (isGood, _v0) {
		var dict = _v0.a;
		return $elm$core$Set$Set_elm_builtin(
			A2(
				$elm$core$Dict$filter,
				F2(
					function (key, _v1) {
						return isGood(key);
					}),
				dict));
	});
var $elm_community$graph$Graph$NodeContext = F3(
	function (node, incoming, outgoing) {
		return {incoming: incoming, node: node, outgoing: outgoing};
	});
var $elm_community$graph$Graph$fromNodesAndEdges = F2(
	function (nodes_, edges_) {
		var nodeRep = A3(
			$elm$core$List$foldl,
			function (n) {
				return A2(
					$elm_community$intdict$IntDict$insert,
					n.id,
					A3($elm_community$graph$Graph$NodeContext, n, $elm_community$intdict$IntDict$empty, $elm_community$intdict$IntDict$empty));
			},
			$elm_community$intdict$IntDict$empty,
			nodes_);
		var addEdge = F2(
			function (edge, rep) {
				var updateOutgoing = function (ctx) {
					return _Utils_update(
						ctx,
						{
							outgoing: A3($elm_community$intdict$IntDict$insert, edge.to, edge.label, ctx.outgoing)
						});
				};
				var updateIncoming = function (ctx) {
					return _Utils_update(
						ctx,
						{
							incoming: A3($elm_community$intdict$IntDict$insert, edge.from, edge.label, ctx.incoming)
						});
				};
				return A3(
					$elm_community$intdict$IntDict$update,
					edge.to,
					$elm$core$Maybe$map(updateIncoming),
					A3(
						$elm_community$intdict$IntDict$update,
						edge.from,
						$elm$core$Maybe$map(updateOutgoing),
						rep));
			});
		var addEdgeIfValid = F2(
			function (edge, rep) {
				return (A2($elm_community$intdict$IntDict$member, edge.from, rep) && A2($elm_community$intdict$IntDict$member, edge.to, rep)) ? A2(addEdge, edge, rep) : rep;
			});
		return $elm_community$graph$Graph$Graph(
			A3($elm$core$List$foldl, addEdgeIfValid, nodeRep, edges_));
	});
var $elm_community$dict_extra$Dict$Extra$groupBy = F2(
	function (keyfn, list) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, acc) {
					return A3(
						$elm$core$Dict$update,
						keyfn(x),
						A2(
							$elm$core$Basics$composeR,
							$elm$core$Maybe$map(
								$elm$core$List$cons(x)),
							A2(
								$elm$core$Basics$composeR,
								$elm$core$Maybe$withDefault(
									_List_fromArray(
										[x])),
								$elm$core$Maybe$Just)),
						acc);
				}),
			$elm$core$Dict$empty,
			list);
	});
var $elm_community$result_extra$Result$Extra$isErr = function (x) {
	if (x.$ === 'Ok') {
		return false;
	} else {
		return true;
	}
};
var $elm$core$Tuple$mapBoth = F3(
	function (funcA, funcB, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			funcA(x),
			funcB(y));
	});
var $elm_community$intdict$IntDict$values = function (dict) {
	return A3(
		$elm_community$intdict$IntDict$foldr,
		F3(
			function (key, value, valueList) {
				return A2($elm$core$List$cons, value, valueList);
			}),
		_List_Nil,
		dict);
};
var $elm_community$graph$Graph$nodes = A2(
	$elm$core$Basics$composeR,
	$elm_community$graph$Graph$unGraph,
	A2(
		$elm$core$Basics$composeR,
		$elm_community$intdict$IntDict$values,
		$elm$core$List$map(
			function ($) {
				return $.node;
			})));
var $elm_community$graph$Graph$Tree$MkTree = F2(
	function (a, b) {
		return {$: 'MkTree', a: a, b: b};
	});
var $elm_community$graph$Graph$Tree$empty = A2($elm_community$graph$Graph$Tree$MkTree, 0, $elm$core$Maybe$Nothing);
var $elm_community$graph$Graph$Tree$isEmpty = function (tree) {
	return _Utils_eq(tree, $elm_community$graph$Graph$Tree$empty);
};
var $elm_community$graph$Graph$Tree$size = function (tree) {
	var n = tree.a;
	return n;
};
var $elm_community$graph$Graph$Tree$inner = F2(
	function (label, children) {
		var nonEmptyChildren = A2(
			$elm$core$List$filter,
			A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm_community$graph$Graph$Tree$isEmpty),
			children);
		var totalSize = A3(
			$elm$core$List$foldl,
			A2($elm$core$Basics$composeL, $elm$core$Basics$add, $elm_community$graph$Graph$Tree$size),
			1,
			nonEmptyChildren);
		return A2(
			$elm_community$graph$Graph$Tree$MkTree,
			totalSize,
			$elm$core$Maybe$Just(
				_Utils_Tuple2(label, nonEmptyChildren)));
	});
var $elm_community$graph$Graph$dfsForest = F2(
	function (seeds, graph) {
		var visitNode = F2(
			function (ctx, trees) {
				return _Utils_Tuple2(
					_List_Nil,
					function (children) {
						return A2(
							$elm$core$List$cons,
							A2($elm_community$graph$Graph$Tree$inner, ctx, children),
							trees);
					});
			});
		return $elm$core$List$reverse(
			A5($elm_community$graph$Graph$guidedDfs, $elm_community$graph$Graph$alongOutgoingEdges, visitNode, seeds, _List_Nil, graph).a);
	});
var $elm_community$graph$Graph$empty = $elm_community$graph$Graph$Graph($elm_community$intdict$IntDict$empty);
var $elm_community$graph$Graph$insert = F2(
	function (nodeContext, graph) {
		return A3(
			$elm_community$graph$Graph$update,
			nodeContext.node.id,
			$elm$core$Basics$always(
				$elm$core$Maybe$Just(nodeContext)),
			graph);
	});
var $elm_community$graph$Graph$Tree$listForTraversal = F2(
	function (traversal, tree) {
		var f = F3(
			function (label, children, rest) {
				return A2(
					$elm$core$Basics$composeR,
					$elm$core$List$cons(label),
					rest);
			});
		var acc = $elm$core$Basics$identity;
		return A4(traversal, f, acc, tree, _List_Nil);
	});
var $elm_community$graph$Graph$Tree$root = function (tree) {
	var maybe = tree.b;
	return maybe;
};
var $elm_community$graph$Graph$Tree$preOrder = F3(
	function (visit, acc, tree) {
		var folder = F2(
			function (b, a) {
				return A3($elm_community$graph$Graph$Tree$preOrder, visit, a, b);
			});
		var _v0 = $elm_community$graph$Graph$Tree$root(tree);
		if (_v0.$ === 'Nothing') {
			return acc;
		} else {
			var _v1 = _v0.a;
			var label = _v1.a;
			var children = _v1.b;
			return A3(
				$elm$core$List$foldl,
				folder,
				A3(visit, label, children, acc),
				children);
		}
	});
var $elm_community$graph$Graph$Tree$preOrderList = $elm_community$graph$Graph$Tree$listForTraversal($elm_community$graph$Graph$Tree$preOrder);
var $elm_community$intdict$IntDict$map = F2(
	function (f, dict) {
		switch (dict.$) {
			case 'Empty':
				return $elm_community$intdict$IntDict$empty;
			case 'Leaf':
				var l = dict.a;
				return A2(
					$elm_community$intdict$IntDict$leaf,
					l.key,
					A2(f, l.key, l.value));
			default:
				var i = dict.a;
				return A3(
					$elm_community$intdict$IntDict$inner,
					i.prefix,
					A2($elm_community$intdict$IntDict$map, f, i.left),
					A2($elm_community$intdict$IntDict$map, f, i.right));
		}
	});
var $elm_community$graph$Graph$reverseEdges = function () {
	var updateContext = F2(
		function (nodeId, ctx) {
			return _Utils_update(
				ctx,
				{incoming: ctx.outgoing, outgoing: ctx.incoming});
		});
	return A2(
		$elm$core$Basics$composeR,
		$elm_community$graph$Graph$unGraph,
		A2(
			$elm$core$Basics$composeR,
			$elm_community$intdict$IntDict$map(updateContext),
			$elm_community$graph$Graph$Graph));
}();
var $elm_community$graph$Graph$stronglyConnectedComponents = function (graph) {
	var reversePostOrder = A3(
		$elm_community$graph$Graph$dfs,
		$elm_community$graph$Graph$onFinish(
			A2(
				$elm$core$Basics$composeR,
				function ($) {
					return $.node;
				},
				A2(
					$elm$core$Basics$composeR,
					function ($) {
						return $.id;
					},
					$elm$core$List$cons))),
		_List_Nil,
		graph);
	return A2(
		$elm$core$Result$mapError,
		function (_v0) {
			var forest = A2(
				$elm_community$graph$Graph$dfsForest,
				reversePostOrder,
				$elm_community$graph$Graph$reverseEdges(graph));
			return A2(
				$elm$core$List$map,
				A2(
					$elm$core$Basics$composeR,
					$elm_community$graph$Graph$Tree$preOrderList,
					A2(
						$elm$core$Basics$composeR,
						A2($elm$core$List$foldr, $elm_community$graph$Graph$insert, $elm_community$graph$Graph$empty),
						$elm_community$graph$Graph$reverseEdges)),
				forest);
		},
		A2($elm_community$graph$Graph$checkForBackEdges, reversePostOrder, graph));
};
var $elm_community$list_extra$List$Extra$unconsLast = function (list) {
	var _v0 = $elm$core$List$reverse(list);
	if (!_v0.b) {
		return $elm$core$Maybe$Nothing;
	} else {
		var last_ = _v0.a;
		var rest = _v0.b;
		return $elm$core$Maybe$Just(
			_Utils_Tuple2(
				last_,
				$elm$core$List$reverse(rest)));
	}
};
var $elm$core$Set$union = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$union, dict1, dict2));
	});
var $author$project$Util$eliminateCycles = F2(
	function (nodes, g) {
		return A2(
			$elm_community$result_extra$Result$Extra$extract,
			A2(
				$elm$core$Basics$composeR,
				$elm$core$List$map(
					function (graph) {
						var ns = $elm_community$graph$Graph$nodes(graph);
						var _v0 = A3(
							$elm$core$Tuple$mapBoth,
							A2(
								$elm$core$Basics$composeR,
								$elm$core$List$map(
									function (_v1) {
										var from = _v1.from;
										var to = _v1.to;
										return _Utils_Tuple2(from, to);
									}),
								$elm$core$Set$fromList),
							$elm$core$List$concat,
							A2(
								$elm$core$Maybe$withDefault,
								_Utils_Tuple2(_List_Nil, _List_Nil),
								$elm_community$list_extra$List$Extra$unconsLast(
									$elm$core$Dict$values(
										A2(
											$elm_community$dict_extra$Dict$Extra$groupBy,
											function ($) {
												return $.label;
											},
											$elm_community$graph$Graph$edges(graph))))));
						var lowestPriorityEdges = _v0.a;
						var higherPriorityEdges = _v0.b;
						return function (s) {
							return $elm$core$Set$isEmpty(s) ? lowestPriorityEdges : s;
						}(
							A2(
								$elm$core$Set$filter,
								function (_v2) {
									var from = _v2.a;
									var to = _v2.b;
									return $elm_community$result_extra$Result$Extra$isErr(
										$elm_community$graph$Graph$checkAcyclic(
											A2(
												$elm_community$graph$Graph$fromNodesAndEdges,
												ns,
												A2(
													$elm$core$List$cons,
													{from: from, label: -1, to: to},
													higherPriorityEdges))));
								},
								lowestPriorityEdges));
					}),
				A2(
					$elm$core$Basics$composeR,
					A2($elm$core$List$foldl, $elm$core$Set$union, $elm$core$Set$empty),
					function (toRemove) {
						return A2(
							$author$project$Util$eliminateCycles,
							nodes,
							A2(
								$elm_community$graph$Graph$fromNodesAndEdges,
								nodes,
								A2(
									$elm$core$List$filter,
									function (_v3) {
										var from = _v3.from;
										var to = _v3.to;
										return !A2(
											$elm$core$Set$member,
											_Utils_Tuple2(from, to),
											toRemove);
									},
									$elm_community$graph$Graph$edges(g))));
					})),
			$elm_community$graph$Graph$stronglyConnectedComponents(g));
	});
var $author$project$Util$fallbackCompareFor = F2(
	function (comp, fallback) {
		if (comp.$ === 'EQ') {
			return fallback(_Utils_Tuple0);
		} else {
			var ltOrGt = comp;
			return ltOrGt;
		}
	});
var $elm_community$list_extra$List$Extra$uniquePairs = function (xs) {
	if (!xs.b) {
		return _List_Nil;
	} else {
		var x = xs.a;
		var xs_ = xs.b;
		return _Utils_ap(
			A2(
				$elm$core$List$map,
				function (y) {
					return _Utils_Tuple2(x, y);
				},
				xs_),
			$elm_community$list_extra$List$Extra$uniquePairs(xs_));
	}
};
var $author$project$Util$genEdges = F2(
	function (orderings, indexed) {
		var genEdge = F2(
			function (os, _v0) {
				genEdge:
				while (true) {
					var d1 = _v0.a;
					var d2 = _v0.b;
					if (os.b) {
						var _v2 = os.a;
						var priority = _v2.a;
						var o = _v2.b;
						var os_ = os.b;
						var _v3 = A2(o, d1.label, d2.label);
						switch (_v3.$) {
							case 'EQ':
								var $temp$os = os_,
									$temp$_v0 = _Utils_Tuple2(d1, d2);
								os = $temp$os;
								_v0 = $temp$_v0;
								continue genEdge;
							case 'LT':
								return $elm$core$Maybe$Just(
									{from: d1.id, label: priority, to: d2.id});
							default:
								return $elm$core$Maybe$Just(
									{from: d2.id, label: priority, to: d1.id});
						}
					} else {
						var _v4 = A2($elm$core$Basics$compare, d1.id, d2.id);
						switch (_v4.$) {
							case 'LT':
								return $elm$core$Maybe$Just(
									{from: d1.id, label: 0, to: d2.id});
							case 'GT':
								return $elm$core$Maybe$Just(
									{from: d2.id, label: 0, to: d1.id});
							default:
								return $elm$core$Maybe$Nothing;
						}
					}
				}
			});
		return A2(
			$elm$core$List$filterMap,
			genEdge(
				A2($elm$core$List$indexedMap, $elm$core$Tuple$pair, orderings)),
			$elm_community$list_extra$List$Extra$uniquePairs(indexed));
	});
var $elm_community$graph$Graph$topologicalSort = function (_v0) {
	var graph = _v0.a;
	var ordering = _v0.b;
	var error = 'Graph.topologicalSort: Invalid `AcyclicGraph`, where the ordering contained nodes not present in the graph';
	return A2(
		$elm$core$List$map,
		function (id) {
			return A3($elm_community$graph$Graph$unsafeGet, error, id, graph);
		},
		ordering);
};
var $jfmengels$elm_review$Review$Rule$error = F2(
	function (_v0, range) {
		var message = _v0.message;
		var details = _v0.details;
		return $jfmengels$elm_review$Review$Rule$Error(
			{details: details, filePath: '', fixes: $elm$core$Maybe$Nothing, message: message, preventsExtract: false, range: range, ruleName: '', target: $jfmengels$elm_review$Review$Error$Module});
	});
var $jfmengels$elm_review$Review$Rule$withFixes = F2(
	function (fixes, error_) {
		return A2(
			$jfmengels$elm_review$Review$Rule$mapInternalError,
			function (err) {
				if ($elm$core$List$isEmpty(fixes)) {
					return _Utils_update(
						err,
						{fixes: $elm$core$Maybe$Nothing});
				} else {
					var _v0 = err.target;
					switch (_v0.$) {
						case 'Module':
							return _Utils_update(
								err,
								{
									fixes: $elm$core$Maybe$Just(fixes)
								});
						case 'Readme':
							return _Utils_update(
								err,
								{
									fixes: $elm$core$Maybe$Just(fixes)
								});
						case 'ElmJson':
							return err;
						case 'Global':
							return err;
						default:
							return err;
					}
				}
			},
			error_);
	});
var $jfmengels$elm_review$Review$Rule$errorWithFix = F3(
	function (info, range, fixes) {
		return A2(
			$jfmengels$elm_review$Review$Rule$withFixes,
			fixes,
			A2($jfmengels$elm_review$Review$Rule$error, info, range));
	});
var $author$project$Util$unsortedError = function (errorConcerns) {
	return $jfmengels$elm_review$Review$Rule$errorWithFix(
		{
			details: _List_fromArray(
				[errorConcerns + ' were found out of order.  They should be sorted as specified in the rule configuration.']),
			message: errorConcerns + ' are not sorted.'
		});
};
var $author$project$Util$checkSorting = F5(
	function (extractSource, errorConcerns, orderings, errorRange, ds) {
		var indexed = A2(
			$elm$core$List$indexedMap,
			F2(
				function (i, d) {
					return {id: i, label: d};
				}),
			ds);
		return function (sorted) {
			return (!_Utils_eq(
				A2(
					$elm$core$List$map,
					function ($) {
						return $.id;
					},
					sorted),
				A2(
					$elm$core$List$map,
					function ($) {
						return $.id;
					},
					indexed))) ? $elm$core$List$singleton(
				A3(
					$author$project$Util$unsortedError,
					errorConcerns,
					errorRange,
					A2(
						$author$project$Util$createFix,
						extractSource,
						A2(
							$elm$core$List$map,
							function (_v2) {
								var id = _v2.id;
								var label = _v2.label;
								return _Utils_Tuple2(id, label.range);
							},
							sorted)))) : _List_Nil;
		}(
			function () {
				if (orderings.b && (!orderings.b.b)) {
					var o = orderings.a;
					return A2(
						$elm$core$List$sortWith,
						F2(
							function (d1, d2) {
								return A2(
									$author$project$Util$fallbackCompareFor,
									A2(o, d1.label, d2.label),
									function (_v1) {
										return A2($elm$core$Basics$compare, d1.id, d2.id);
									});
							}),
						indexed);
				} else {
					var os = orderings;
					return A2(
						$elm$core$List$map,
						function ($) {
							return $.node;
						},
						$elm_community$graph$Graph$topologicalSort(
							A2(
								$author$project$Util$eliminateCycles,
								indexed,
								A2(
									$elm_community$graph$Graph$fromNodesAndEdges,
									indexed,
									A2($author$project$Util$genEdges, os, indexed)))));
				}
			}());
	});
var $author$project$NoUnsortedCases$LengthFirst = {$: 'LengthFirst'};
var $author$project$NoUnsortedCases$ListTupleOrUncons = function (a) {
	return {$: 'ListTupleOrUncons', a: a};
};
var $author$project$NoUnsortedCases$compareLiteral = F2(
	function (l1, l2) {
		var _v0 = _Utils_Tuple2(l1, l2);
		_v0$4:
		while (true) {
			switch (_v0.a.$) {
				case 'CharLiteral':
					if (_v0.b.$ === 'CharLiteral') {
						var c1 = _v0.a.a;
						var c2 = _v0.b.a;
						return $elm$core$Maybe$Just(
							A2($elm$core$Basics$compare, c1, c2));
					} else {
						break _v0$4;
					}
				case 'StringLiteral':
					if (_v0.b.$ === 'StringLiteral') {
						var s1 = _v0.a.a;
						var s2 = _v0.b.a;
						return $elm$core$Maybe$Just(
							A2($elm$core$Basics$compare, s1, s2));
					} else {
						break _v0$4;
					}
				case 'IntLiteral':
					if (_v0.b.$ === 'IntLiteral') {
						var i1 = _v0.a.a;
						var i2 = _v0.b.a;
						return $elm$core$Maybe$Just(
							A2($elm$core$Basics$compare, i1, i2));
					} else {
						break _v0$4;
					}
				default:
					if (_v0.b.$ === 'FloatLiteral') {
						var f1 = _v0.a.a;
						var f2 = _v0.b.a;
						return $elm$core$Maybe$Just(
							A2($elm$core$Basics$compare, f1, f2));
					} else {
						break _v0$4;
					}
			}
		}
		return $elm$core$Maybe$Nothing;
	});
var $author$project$NoUnsortedCases$comparePatternListLengths = F2(
	function (p1s, p2s) {
		var _v0 = _Utils_Tuple2(p1s.terminates, p2s.terminates);
		if (!_v0.a) {
			if (!_v0.b) {
				return A2(
					$elm$core$Basics$compare,
					$elm$core$List$length(p2s.subpatterns),
					$elm$core$List$length(p1s.subpatterns));
			} else {
				return $elm$core$Basics$GT;
			}
		} else {
			if (!_v0.b) {
				return $elm$core$Basics$LT;
			} else {
				return A2(
					$elm$core$Basics$compare,
					$elm$core$List$length(p1s.subpatterns),
					$elm$core$List$length(p2s.subpatterns));
			}
		}
	});
var $author$project$Util$fallbackCompareWithUnsortableFor = F2(
	function (comp, fallback) {
		if ((comp.$ === 'Just') && (comp.a.$ === 'EQ')) {
			var _v1 = comp.a;
			return fallback(_Utils_Tuple0);
		} else {
			var ltOrGtOrNothing = comp;
			return ltOrGtOrNothing;
		}
	});
var $author$project$NoUnsortedCases$compareNonemptyListPatterns = F3(
	function (config, _v36, _v37) {
		var sortLists = config.a.sortLists;
		var r1 = _v36.a;
		var p1 = _v36.b;
		var p1s = _v36.c;
		var r2 = _v37.a;
		var p2 = _v37.b;
		var p2s = _v37.c;
		var checkSubs = function (_v40) {
			var _v38 = A3($author$project$NoUnsortedCases$comparePatterns, config, p1, p2);
			if ((_v38.$ === 'Just') && (_v38.a.$ === 'EQ')) {
				var _v39 = _v38.a;
				return A3(
					$author$project$NoUnsortedCases$comparePatterns,
					config,
					$author$project$NoUnsortedCases$ListTupleOrUncons(
						_Utils_update(
							r1,
							{subpatterns: p1s})),
					$author$project$NoUnsortedCases$ListTupleOrUncons(
						_Utils_update(
							r2,
							{subpatterns: p2s})));
			} else {
				var ltOrGtOrNothing = _v38;
				return ltOrGtOrNothing;
			}
		};
		return _Utils_eq(sortLists, $author$project$NoUnsortedCases$LengthFirst) ? A2(
			$author$project$Util$fallbackCompareWithUnsortableFor,
			$elm$core$Maybe$Just(
				A2($author$project$NoUnsortedCases$comparePatternListLengths, r1, r2)),
			checkSubs) : checkSubs(_Utils_Tuple0);
	});
var $author$project$NoUnsortedCases$comparePatterns = F3(
	function (ruleConfig, pat1, pat2) {
		var lookPastUnsortable = ruleConfig.a.lookPastUnsortable;
		var go = F2(
			function (p1, p2) {
				return A3($author$project$NoUnsortedCases$comparePatterns, ruleConfig, p1, p2);
			});
		var _v0 = _Utils_Tuple2(pat1, pat2);
		_v0$2:
		while (true) {
			_v0$6:
			while (true) {
				switch (_v0.a.$) {
					case 'Wildcard':
						if (_v0.b.$ === 'Wildcard') {
							var _v1 = _v0.a;
							var _v2 = _v0.b;
							return $elm$core$Maybe$Just($elm$core$Basics$EQ);
						} else {
							var _v3 = _v0.a;
							return $elm$core$Maybe$Nothing;
						}
					case 'Literal':
						switch (_v0.b.$) {
							case 'Wildcard':
								break _v0$2;
							case 'Literal':
								var l1 = _v0.a.a;
								var l2 = _v0.b.a;
								return A2($author$project$NoUnsortedCases$compareLiteral, l1, l2);
							default:
								break _v0$6;
						}
					case 'Constructor':
						switch (_v0.b.$) {
							case 'Wildcard':
								break _v0$2;
							case 'Constructor':
								var c1 = _v0.a.a;
								var c2 = _v0.b.a;
								var goSubs = F3(
									function (pat1s, pat2s, _v5) {
										goSubs:
										while (true) {
											var _v6 = _Utils_Tuple3(pat1s, pat2s, lookPastUnsortable);
											_v6$3:
											while (true) {
												if (_v6.a.b) {
													if (_v6.a.a.$ === 'Just') {
														if (_v6.b.b && (_v6.b.a.$ === 'Just')) {
															var _v7 = _v6.a;
															var p1 = _v7.a.a;
															var p1s = _v7.b;
															var _v8 = _v6.b;
															var p2 = _v8.a.a;
															var p2s = _v8.b;
															return A2(
																$author$project$Util$fallbackCompareWithUnsortableFor,
																A2(go, p1, p2),
																A2(goSubs, p1s, p2s));
														} else {
															break _v6$3;
														}
													} else {
														if ((_v6.b.b && (_v6.b.a.$ === 'Nothing')) && _v6.c) {
															var _v9 = _v6.a;
															var _v10 = _v9.a;
															var p1s = _v9.b;
															var _v11 = _v6.b;
															var _v12 = _v11.a;
															var p2s = _v11.b;
															var $temp$pat1s = p1s,
																$temp$pat2s = p2s,
																$temp$_v5 = _Utils_Tuple0;
															pat1s = $temp$pat1s;
															pat2s = $temp$pat2s;
															_v5 = $temp$_v5;
															continue goSubs;
														} else {
															break _v6$3;
														}
													}
												} else {
													if (!_v6.b.b) {
														return $elm$core$Maybe$Just($elm$core$Basics$EQ);
													} else {
														break _v6$3;
													}
												}
											}
											return $elm$core$Maybe$Nothing;
										}
									});
								return A2(
									$author$project$Util$fallbackCompareWithUnsortableFor,
									$elm$core$Maybe$Just(
										A2($elm$core$Basics$compare, c1.order, c2.order)),
									A2(goSubs, c1.subpatterns, c2.subpatterns));
							default:
								break _v0$6;
						}
					default:
						switch (_v0.b.$) {
							case 'Wildcard':
								break _v0$2;
							case 'ListTupleOrUncons':
								var r1 = _v0.a.a;
								var r2 = _v0.b.a;
								var _v13 = _Utils_Tuple2(
									_Utils_Tuple2(r1.subpatterns, r1.terminates),
									_Utils_Tuple2(r2.subpatterns, r2.terminates));
								_v13$2:
								while (true) {
									if (!_v13.a.a.b) {
										if (!_v13.b.a.b) {
											if (!_v13.a.b) {
												if (_v13.b.b) {
													var _v14 = _v13.a;
													var _v15 = _v13.b;
													return $elm$core$Maybe$Just($elm$core$Basics$GT);
												} else {
													break _v13$2;
												}
											} else {
												if (!_v13.b.b) {
													var _v16 = _v13.a;
													var _v17 = _v13.b;
													return $elm$core$Maybe$Just($elm$core$Basics$LT);
												} else {
													break _v13$2;
												}
											}
										} else {
											if (_v13.a.b) {
												var _v26 = _v13.a;
												var _v27 = _v13.b;
												var _v28 = _v27.a;
												return $elm$core$Maybe$Just($elm$core$Basics$LT);
											} else {
												var _v29 = _v13.a;
												var _v30 = _v13.b;
												var _v31 = _v30.a;
												return $elm$core$Maybe$Just($elm$core$Basics$GT);
											}
										}
									} else {
										if (!_v13.b.a.b) {
											if (_v13.b.b) {
												var _v20 = _v13.a;
												var _v21 = _v20.a;
												var _v22 = _v13.b;
												return $elm$core$Maybe$Just($elm$core$Basics$GT);
											} else {
												var _v23 = _v13.a;
												var _v24 = _v23.a;
												var _v25 = _v13.b;
												return $elm$core$Maybe$Just($elm$core$Basics$LT);
											}
										} else {
											var _v32 = _v13.a;
											var _v33 = _v32.a;
											var p1 = _v33.a;
											var p1s = _v33.b;
											var _v34 = _v13.b;
											var _v35 = _v34.a;
											var p2 = _v35.a;
											var p2s = _v35.b;
											return A3(
												$author$project$NoUnsortedCases$compareNonemptyListPatterns,
												ruleConfig,
												_Utils_Tuple3(r1, p1, p1s),
												_Utils_Tuple3(r2, p2, p2s));
										}
									}
								}
								var _v18 = _v13.a;
								var _v19 = _v13.b;
								return $elm$core$Maybe$Just($elm$core$Basics$EQ);
							default:
								break _v0$6;
						}
				}
			}
			return $elm$core$Maybe$Nothing;
		}
		var _v4 = _v0.b;
		return $elm$core$Maybe$Nothing;
	});
var $author$project$NoUnsortedCases$safelySortableListPatterns = F3(
	function (config, r1, r2) {
		safelySortableListPatterns:
		while (true) {
			var _v0 = _Utils_Tuple2(r1.subpatterns, r2.subpatterns);
			if (_v0.a.b) {
				if (_v0.b.b) {
					var _v1 = _v0.a;
					var x = _v1.a;
					var xs = _v1.b;
					var _v2 = _v0.b;
					var y = _v2.a;
					var ys = _v2.b;
					var _v3 = A3($author$project$NoUnsortedCases$comparePatterns, config, x, y);
					if (_v3.$ === 'Just') {
						if (_v3.a.$ === 'EQ') {
							var _v4 = _v3.a;
							var $temp$config = config,
								$temp$r1 = _Utils_update(
								r1,
								{subpatterns: xs}),
								$temp$r2 = _Utils_update(
								r2,
								{subpatterns: ys});
							config = $temp$config;
							r1 = $temp$r1;
							r2 = $temp$r2;
							continue safelySortableListPatterns;
						} else {
							return true;
						}
					} else {
						return false;
					}
				} else {
					return r2.terminates;
				}
			} else {
				if (!_v0.b.b) {
					return true;
				} else {
					return r1.terminates;
				}
			}
		}
	});
var $author$project$NoUnsortedCases$compareByControlFlow = F3(
	function (config, _v0, _v1) {
		var i1 = _v0.a;
		var pat1 = _v0.b;
		var i2 = _v1.a;
		var pat2 = _v1.b;
		var go = F2(
			function (p1, p2) {
				return A3(
					$author$project$NoUnsortedCases$compareByControlFlow,
					config,
					_Utils_Tuple2(i1, p1),
					_Utils_Tuple2(i2, p2));
			});
		var _v2 = _Utils_Tuple2(pat1, pat2);
		_v2$2:
		while (true) {
			_v2$5:
			while (true) {
				switch (_v2.a.$) {
					case 'Wildcard':
						if (_v2.b.$ === 'Wildcard') {
							var _v3 = _v2.a;
							var _v4 = _v2.b;
							return $elm$core$Basics$EQ;
						} else {
							var _v5 = _v2.a;
							return A2($elm$core$Basics$compare, i1, i2);
						}
					case 'Constructor':
						switch (_v2.b.$) {
							case 'Wildcard':
								break _v2$2;
							case 'Constructor':
								var c1 = _v2.a.a;
								var c2 = _v2.b.a;
								var goSubs = F3(
									function (pat1s, pat2s, _v7) {
										var _v8 = _Utils_Tuple2(pat1s, pat2s);
										_v8$2:
										while (true) {
											if (_v8.a.b && _v8.b.b) {
												if (_v8.a.a.$ === 'Just') {
													if ((_v8.a.a.a.$ === 'Wildcard') && (_v8.b.a.$ === 'Nothing')) {
														var _v9 = _v8.a;
														var _v10 = _v9.a.a;
														var _v11 = _v8.b;
														var _v12 = _v11.a;
														return A2($elm$core$Basics$compare, i1, i2);
													} else {
														break _v8$2;
													}
												} else {
													if ((_v8.b.a.$ === 'Just') && (_v8.b.a.a.$ === 'Wildcard')) {
														var _v13 = _v8.a;
														var _v14 = _v13.a;
														var _v15 = _v8.b;
														var _v16 = _v15.a.a;
														return A2($elm$core$Basics$compare, i1, i2);
													} else {
														break _v8$2;
													}
												}
											} else {
												return $elm$core$Basics$EQ;
											}
										}
										var _v17 = _v8.a;
										var p1 = _v17.a;
										var p1s = _v17.b;
										var _v18 = _v8.b;
										var p2 = _v18.a;
										var p2s = _v18.b;
										return A2(
											$author$project$Util$fallbackCompareFor,
											A2(
												$elm$core$Maybe$withDefault,
												$elm$core$Basics$EQ,
												A3($elm$core$Maybe$map2, go, p1, p2)),
											A2(goSubs, p1s, p2s));
									});
								return _Utils_eq(c1.order, c2.order) ? A3(goSubs, c1.subpatterns, c2.subpatterns, _Utils_Tuple0) : $elm$core$Basics$EQ;
							default:
								break _v2$5;
						}
					case 'ListTupleOrUncons':
						switch (_v2.b.$) {
							case 'Wildcard':
								break _v2$2;
							case 'ListTupleOrUncons':
								var r1 = _v2.a.a;
								var r2 = _v2.b.a;
								return A3($author$project$NoUnsortedCases$safelySortableListPatterns, config, r1, r2) ? $elm$core$Basics$EQ : A2($elm$core$Basics$compare, i1, i2);
							default:
								break _v2$5;
						}
					default:
						if (_v2.b.$ === 'Wildcard') {
							break _v2$2;
						} else {
							break _v2$5;
						}
				}
			}
			return $elm$core$Basics$EQ;
		}
		var _v6 = _v2.b;
		return A2($elm$core$Basics$compare, i1, i2);
	});
var $author$project$NoUnsortedCases$CharLiteral = function (a) {
	return {$: 'CharLiteral', a: a};
};
var $author$project$NoUnsortedCases$Constructor = function (a) {
	return {$: 'Constructor', a: a};
};
var $author$project$NoUnsortedCases$FloatLiteral = function (a) {
	return {$: 'FloatLiteral', a: a};
};
var $author$project$NoUnsortedCases$IntLiteral = function (a) {
	return {$: 'IntLiteral', a: a};
};
var $author$project$NoUnsortedCases$Literal = function (a) {
	return {$: 'Literal', a: a};
};
var $author$project$NoUnsortedCases$StringLiteral = function (a) {
	return {$: 'StringLiteral', a: a};
};
var $author$project$NoUnsortedCases$Wildcard = {$: 'Wildcard'};
var $elm_community$list_extra$List$Extra$findIndexHelp = F3(
	function (index, predicate, list) {
		findIndexHelp:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var x = list.a;
				var xs = list.b;
				if (predicate(x)) {
					return $elm$core$Maybe$Just(index);
				} else {
					var $temp$index = index + 1,
						$temp$predicate = predicate,
						$temp$list = xs;
					index = $temp$index;
					predicate = $temp$predicate;
					list = $temp$list;
					continue findIndexHelp;
				}
			}
		}
	});
var $elm_community$list_extra$List$Extra$findIndex = $elm_community$list_extra$List$Extra$findIndexHelp(0);
var $elm_community$list_extra$List$Extra$elemIndex = function (x) {
	return $elm_community$list_extra$List$Extra$findIndex(
		$elm$core$Basics$eq(x));
};
var $elm_community$dict_extra$Dict$Extra$find = F2(
	function (predicate, dict) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, acc) {
					if (acc.$ === 'Just') {
						return acc;
					} else {
						return A2(predicate, k, v) ? $elm$core$Maybe$Just(
							_Utils_Tuple2(k, v)) : $elm$core$Maybe$Nothing;
					}
				}),
			$elm$core$Maybe$Nothing,
			dict);
	});
var $author$project$NoUnsortedCases$getActualPattern = function (node) {
	getActualPattern:
	while (true) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'ParenthesizedPattern':
				var p = _v0.a;
				var $temp$node = p;
				node = $temp$node;
				continue getActualPattern;
			case 'AsPattern':
				var p = _v0.a;
				var $temp$node = p;
				node = $temp$node;
				continue getActualPattern;
			default:
				return node;
		}
	}
};
var $elm_community$maybe_extra$Maybe$Extra$join = function (mx) {
	if (mx.$ === 'Just') {
		var x = mx.a;
		return x;
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $jfmengels$elm_review$Review$ModuleNameLookupTable$moduleNameFor = F2(
	function (_v0, _v1) {
		var dict = _v0.b;
		var range = _v1.a;
		return A2(
			$elm$core$Dict$get,
			$jfmengels$elm_review$Review$ModuleNameLookupTable$Internal$toRangeLike(range),
			dict);
	});
var $elm_community$maybe_extra$Maybe$Extra$traverseHelp = F3(
	function (f, list, acc) {
		traverseHelp:
		while (true) {
			if (list.b) {
				var head = list.a;
				var tail = list.b;
				var _v1 = f(head);
				if (_v1.$ === 'Just') {
					var a = _v1.a;
					var $temp$f = f,
						$temp$list = tail,
						$temp$acc = A2($elm$core$List$cons, a, acc);
					f = $temp$f;
					list = $temp$list;
					acc = $temp$acc;
					continue traverseHelp;
				} else {
					return $elm$core$Maybe$Nothing;
				}
			} else {
				return $elm$core$Maybe$Just(
					$elm$core$List$reverse(acc));
			}
		}
	});
var $elm_community$maybe_extra$Maybe$Extra$traverse = F2(
	function (f, list) {
		return A3($elm_community$maybe_extra$Maybe$Extra$traverseHelp, f, list, _List_Nil);
	});
var $author$project$NoUnsortedCases$getSortablePattern = F3(
	function (ruleConfig, context, node) {
		var config = ruleConfig.a;
		var n = $author$project$NoUnsortedCases$getActualPattern(node);
		var makeLiteral = F2(
			function (l, a) {
				return config.sortLiterals ? $elm$core$Maybe$Just(
					$author$project$NoUnsortedCases$Literal(
						l(a))) : $elm$core$Maybe$Nothing;
			});
		var go = A2($author$project$NoUnsortedCases$getSortablePattern, ruleConfig, context);
		var findConstructorOrder = F3(
			function (constructor, ps, moduleName) {
				return A2(
					$elm$core$Maybe$andThen,
					function (_v4) {
						var matchedType = _v4.a;
						var declarationOrder = _v4.b.declarationOrder;
						return A2(
							$elm$core$Maybe$map,
							function (order) {
								return $author$project$NoUnsortedCases$Constructor(
									{
										order: order,
										subpatterns: A2($elm$core$List$map, go, ps),
										type_: _Utils_Tuple2(moduleName, matchedType)
									});
							},
							A2($elm_community$list_extra$List$Extra$elemIndex, constructor, declarationOrder));
					},
					A2(
						$elm$core$Maybe$andThen,
						$elm_community$dict_extra$Dict$Extra$find(
							F2(
								function (_v2, _v3) {
									var constructors = _v3.constructors;
									return A2($elm$core$Set$member, constructor, constructors);
								})),
						A2($elm$core$Dict$get, moduleName, context.customTypes)));
			});
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(n);
		switch (_v0.$) {
			case 'NamedPattern':
				var name = _v0.a.name;
				var ps = _v0.b;
				return A2(
					$elm$core$Maybe$andThen,
					A2(findConstructorOrder, name, ps),
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$moduleNameFor, context.lookupTable, n));
			case 'TuplePattern':
				var ps = _v0.a;
				return A2(
					$elm$core$Maybe$map,
					function (subpatterns) {
						return $author$project$NoUnsortedCases$ListTupleOrUncons(
							{subpatterns: subpatterns, terminates: true});
					},
					A2($elm_community$maybe_extra$Maybe$Extra$traverse, go, ps));
			case 'ListPattern':
				var ps = _v0.a;
				return A2(
					$elm$core$Maybe$map,
					function (subpatterns) {
						return $author$project$NoUnsortedCases$ListTupleOrUncons(
							{subpatterns: subpatterns, terminates: true});
					},
					A2($elm_community$maybe_extra$Maybe$Extra$traverse, go, ps));
			case 'UnConsPattern':
				var p1 = _v0.a;
				var p2 = _v0.b;
				var cons = F2(
					function (x, xs) {
						switch (xs.$) {
							case 'Wildcard':
								return $elm$core$Maybe$Just(
									$author$project$NoUnsortedCases$ListTupleOrUncons(
										{
											subpatterns: _List_fromArray(
												[x]),
											terminates: false
										}));
							case 'ListTupleOrUncons':
								var r = xs.a;
								return $elm$core$Maybe$Just(
									$author$project$NoUnsortedCases$ListTupleOrUncons(
										_Utils_update(
											r,
											{
												subpatterns: A2($elm$core$List$cons, x, r.subpatterns)
											})));
							default:
								return $elm$core$Maybe$Nothing;
						}
					});
				return $elm_community$maybe_extra$Maybe$Extra$join(
					A3(
						$elm$core$Maybe$map2,
						cons,
						go(p1),
						go(p2)));
			case 'AllPattern':
				return $elm$core$Maybe$Just($author$project$NoUnsortedCases$Wildcard);
			case 'VarPattern':
				return $elm$core$Maybe$Just($author$project$NoUnsortedCases$Wildcard);
			case 'CharPattern':
				var c = _v0.a;
				return A2(makeLiteral, $author$project$NoUnsortedCases$CharLiteral, c);
			case 'StringPattern':
				var s = _v0.a;
				return A2(makeLiteral, $author$project$NoUnsortedCases$StringLiteral, s);
			case 'IntPattern':
				var i = _v0.a;
				return A2(makeLiteral, $author$project$NoUnsortedCases$IntLiteral, i);
			case 'HexPattern':
				var i = _v0.a;
				return A2(makeLiteral, $author$project$NoUnsortedCases$IntLiteral, i);
			case 'FloatPattern':
				var f = _v0.a;
				return A2(makeLiteral, $author$project$NoUnsortedCases$FloatLiteral, f);
			default:
				return $elm$core$Maybe$Nothing;
		}
	});
var $elm_community$list_extra$List$Extra$indexedFoldr = F3(
	function (func, acc, list) {
		var step = F2(
			function (x, _v0) {
				var i = _v0.a;
				var thisAcc = _v0.b;
				return _Utils_Tuple2(
					i - 1,
					A3(func, i, x, thisAcc));
			});
		return A3(
			$elm$core$List$foldr,
			step,
			_Utils_Tuple2(
				$elm$core$List$length(list) - 1,
				acc),
			list).b;
	});
var $author$project$NoUnsortedCases$expressionVisitor = F3(
	function (config, node, context) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		if (_v0.$ === 'CaseExpression') {
			var cases = _v0.a.cases;
			var errorRange = function () {
				var r = $stil4m$elm_syntax$Elm$Syntax$Node$range(node);
				return _Utils_update(
					r,
					{
						end: {column: r.start.column + 4, row: r.start.row}
					});
			}();
			return A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2(
					$elm$core$Maybe$map,
					A4(
						$author$project$Util$checkSorting,
						context.extractSource,
						'Case patterns',
						_List_fromArray(
							[
								F2(
								function (c1, c2) {
									return A3(
										$author$project$NoUnsortedCases$compareByControlFlow,
										config,
										_Utils_Tuple2(c1.index, c1.pattern),
										_Utils_Tuple2(c2.index, c2.pattern));
								}),
								F2(
								function (c1, c2) {
									return A2(
										$elm$core$Maybe$withDefault,
										$elm$core$Basics$EQ,
										A3($author$project$NoUnsortedCases$comparePatterns, config, c1.pattern, c2.pattern));
								})
							]),
						errorRange),
					A3(
						$elm_community$list_extra$List$Extra$indexedFoldr,
						F3(
							function (i, _v1, acc) {
								var p = _v1.a;
								var e = _v1.b;
								return A3(
									$elm$core$Maybe$map2,
									F2(
										function (acc_, sP) {
											return A2($elm$core$List$cons, sP, acc_);
										}),
									acc,
									A2(
										$elm$core$Maybe$map,
										function (sP) {
											return {
												index: i,
												pattern: sP,
												range: $stil4m$elm_syntax$Elm$Syntax$Range$combine(
													_List_fromArray(
														[
															$stil4m$elm_syntax$Elm$Syntax$Node$range(p),
															$stil4m$elm_syntax$Elm$Syntax$Node$range(e)
														]))
											};
										},
										A3($author$project$NoUnsortedCases$getSortablePattern, config, context, p)));
							}),
						$elm$core$Maybe$Just(_List_Nil),
						cases)));
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Rule$withExpressionEnterVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					expressionVisitorsOnEnter: A2($elm$core$List$cons, visitor, schema.expressionVisitorsOnEnter)
				}));
	});
var $author$project$NoUnsortedCases$moduleVisitor = F2(
	function (config, schema) {
		return A2(
			$jfmengels$elm_review$Review$Rule$withExpressionEnterVisitor,
			F2(
				function (e, c) {
					return c.fileIsIgnored ? _Utils_Tuple2(_List_Nil, c) : _Utils_Tuple2(
						A3($author$project$NoUnsortedCases$expressionVisitor, config, e, c),
						c);
				}),
			schema);
	});
var $jfmengels$elm_review$Review$Rule$AllModulesInParallel = {$: 'AllModulesInParallel'};
var $jfmengels$elm_review$Review$Rule$ProjectRuleSchema = function (a) {
	return {$: 'ProjectRuleSchema', a: a};
};
var $jfmengels$elm_review$Review$Rule$newProjectRuleSchema = F2(
	function (name, initialProjectContext) {
		return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
			{dataExtractor: $elm$core$Maybe$Nothing, dependenciesVisitors: _List_Nil, directDependenciesVisitors: _List_Nil, elmJsonVisitors: _List_Nil, finalEvaluationFns: _List_Nil, folder: $elm$core$Maybe$Nothing, initialProjectContext: initialProjectContext, moduleContextCreator: $elm$core$Maybe$Nothing, moduleVisitors: _List_Nil, name: name, providesFixes: false, readmeVisitors: _List_Nil, traversalType: $jfmengels$elm_review$Review$Rule$AllModulesInParallel});
	});
var $jfmengels$elm_review$Review$Rule$providesFixesForProjectRule = function (_v0) {
	var projectRuleSchema = _v0.a;
	return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
		_Utils_update(
			projectRuleSchema,
			{providesFixes: true}));
};
var $jfmengels$elm_review$Review$Rule$ImportedModulesFirst = {$: 'ImportedModulesFirst'};
var $jfmengels$elm_review$Review$Rule$withContextFromImportedModules = function (_v0) {
	var schema = _v0.a;
	return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
		_Utils_update(
			schema,
			{traversalType: $jfmengels$elm_review$Review$Rule$ImportedModulesFirst}));
};
var $elm$core$Tuple$mapFirst = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			func(x),
			y);
	});
var $jfmengels$elm_review$Review$Rule$removeErrorPhantomType = function (_v0) {
	var err = _v0.a;
	return $jfmengels$elm_review$Review$Rule$Error(err);
};
var $jfmengels$elm_review$Review$Rule$removeErrorPhantomTypeFromVisitor = F3(
	function (_function, element, projectContext) {
		return A2(
			$elm$core$Tuple$mapFirst,
			$elm$core$List$map($jfmengels$elm_review$Review$Rule$removeErrorPhantomType),
			A2(_function, element, projectContext));
	});
var $jfmengels$elm_review$Review$Rule$withDependenciesProjectVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
			_Utils_update(
				schema,
				{
					dependenciesVisitors: A2(
						$elm$core$List$cons,
						$jfmengels$elm_review$Review$Rule$removeErrorPhantomTypeFromVisitor(visitor),
						schema.dependenciesVisitors)
				}));
	});
var $jfmengels$elm_review$Review$Rule$withModuleContextUsingContextCreator = F2(
	function (functions, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
			_Utils_update(
				schema,
				{
					folder: $elm$core$Maybe$Just(
						{foldProjectContexts: functions.foldProjectContexts, fromModuleToProject: functions.fromModuleToProject}),
					moduleContextCreator: $elm$core$Maybe$Just(functions.fromProjectToModule)
				}));
	});
var $jfmengels$elm_review$Review$Rule$removeExtensibleRecordTypeVariable = function (_function) {
	return A2(
		$elm$core$Basics$composeR,
		_function,
		function (_v0) {
			var param = _v0.a;
			return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(param);
		});
};
var $jfmengels$elm_review$Review$Rule$withModuleVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
			_Utils_update(
				schema,
				{
					moduleVisitors: A2(
						$elm$core$List$cons,
						$jfmengels$elm_review$Review$Rule$removeExtensibleRecordTypeVariable(visitor),
						schema.moduleVisitors)
				}));
	});
var $author$project$NoUnsortedCases$rule = function (config) {
	return $jfmengels$elm_review$Review$Rule$fromProjectRuleSchema(
		$jfmengels$elm_review$Review$Rule$providesFixesForProjectRule(
			$jfmengels$elm_review$Review$Rule$withContextFromImportedModules(
				A2(
					$jfmengels$elm_review$Review$Rule$withModuleContextUsingContextCreator,
					{
						foldProjectContexts: $author$project$NoUnsortedCases$foldProjectContexts,
						fromModuleToProject: $author$project$NoUnsortedCases$fromModuleToProject,
						fromProjectToModule: $author$project$NoUnsortedCases$fromProjectToModule(config)
					},
					A2(
						$jfmengels$elm_review$Review$Rule$withModuleVisitor,
						$author$project$NoUnsortedCases$moduleVisitor(config),
						A2(
							$jfmengels$elm_review$Review$Rule$withDependenciesProjectVisitor,
							F2(
								function (d, c) {
									return _Utils_Tuple2(
										_List_Nil,
										A3($author$project$NoUnsortedCases$dependencyVisitor, config, d, c));
								}),
							A2($jfmengels$elm_review$Review$Rule$newProjectRuleSchema, 'NoUnsortedCases', $author$project$NoUnsortedCases$initialProjectContext)))))));
};
var $jfmengels$elm_review$Review$Project$Dependency$name = function (_v0) {
	var dependency = _v0.a;
	return dependency.name;
};
var $jfmengels$elm_review$Review$Project$addDependency = F2(
	function (dependency, _v0) {
		var project = _v0.a;
		return $jfmengels$elm_review$Review$Project$Internal$Project(
			_Utils_update(
				project,
				{
					dependencies: A3(
						$elm$core$Dict$insert,
						$jfmengels$elm_review$Review$Project$Dependency$name(dependency),
						dependency,
						project.dependencies)
				}));
	});
var $jfmengels$elm_review$Review$Project$Dependency$Dependency = function (a) {
	return {$: 'Dependency', a: a};
};
var $jfmengels$elm_review$Review$Project$Dependency$create = F3(
	function (name_, elmJson_, modules_) {
		return $jfmengels$elm_review$Review$Project$Dependency$Dependency(
			{elmJson: elmJson_, modules: modules_, name: name_});
	});
var $elm$project_metadata_utils$Elm$Docs$Left = {$: 'Left'};
var $elm$project_metadata_utils$Elm$Docs$None = {$: 'None'};
var $elm$project_metadata_utils$Elm$Docs$Right = {$: 'Right'};
var $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$dependencyModules = _List_fromArray(
	[
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' Fast immutable arrays. The elements in an array must have the same type.\n\n# Arrays\n@docs Array\n\n# Creation\n@docs empty, initialize, repeat, fromList\n\n# Query\n@docs isEmpty, length, get\n\n# Manipulate\n@docs set, push, append, slice\n\n# Lists\n@docs toList, toIndexedList\n\n# Transform\n@docs map, indexedMap, foldl, foldr, filter\n',
		name: 'Array',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['a']),
				comment: ' Representation of fast immutable arrays. You can create arrays of integers\n(`Array Int`) or strings (`Array String`) or any other type of value you can\ndream up.\n',
				name: 'Array',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Append two arrays to a new one.\n\n    append (repeat 2 42) (repeat 3 81) == fromList [42,42,81,81,81]\n',
				name: 'append',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Return an empty array.\n\n    length empty == 0\n',
				name: 'empty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Array.Array',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('a')
						]))
			},
				{
				comment: ' Keep elements that pass the test.\n\n    filter isEven (fromList [1,2,3,4,5,6]) == (fromList [2,4,6])\n',
				name: 'filter',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Reduce an array from the left. Read `foldl` as fold from the left.\n\n    foldl (::) [] (fromList [1,2,3]) == [3,2,1]\n',
				name: 'foldl',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Reduce an array from the right. Read `foldr` as fold from the right.\n\n    foldr (+) 0 (repeat 3 5) == 15\n',
				name: 'foldr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Create an array from a `List`.\n',
				name: 'fromList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Return `Just` the element at the index or `Nothing` if the index is out of\nrange.\n\n    get  0 (fromList [0,1,2]) == Just 0\n    get  2 (fromList [0,1,2]) == Just 2\n    get  5 (fromList [0,1,2]) == Nothing\n    get -1 (fromList [0,1,2]) == Nothing\n',
				name: 'get',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Apply a function on every element with its index as first argument.\n\n    indexedMap (*) (fromList [5,5,5]) == fromList [0,5,10]\n',
				name: 'indexedMap',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Initialize an array. `initialize n f` creates an array of length `n` with\nthe element at index `i` initialized to the result of `(f i)`.\n\n    initialize 4 identity    == fromList [0,1,2,3]\n    initialize 4 (\\n -> n*n) == fromList [0,1,4,9]\n    initialize 4 (always 0)  == fromList [0,0,0,0]\n',
				name: 'initialize',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
							$elm$project_metadata_utils$Elm$Type$Var('a')),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Determine if an array is empty.\n\n    isEmpty empty == True\n',
				name: 'isEmpty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Return the length of an array.\n\n    length (fromList [1,2,3]) == 3\n',
				name: 'length',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Apply a function on every element in an array.\n\n    map sqrt (fromList [1,4,9]) == fromList [1,2,3]\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Push an element onto the end of an array.\n\n    push 3 (fromList [1,2]) == fromList [1,2,3]\n',
				name: 'push',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Creates an array with a given length, filled with a default element.\n\n    repeat 5 0     == fromList [0,0,0,0,0]\n    repeat 3 "cat" == fromList ["cat","cat","cat"]\n\nNotice that `repeat 3 x` is the same as `initialize 3 (always x)`.\n',
				name: 'repeat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Array.Array',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Set the element at a particular index. Returns an updated array.\nIf the index is out of range, the array is unaltered.\n\n    set 1 7 (fromList [1,2,3]) == fromList [1,7,3]\n',
				name: 'set',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])))))
			},
				{
				comment: ' Get a sub-section of an array: `(slice start end array)`. The `start` is a\nzero-based index where we will start our slice. The `end` is a zero-based index\nthat indicates the end of the slice. The slice extracts up to but not including\n`end`.\n\n    slice  0  3 (fromList [0,1,2,3,4]) == fromList [0,1,2]\n    slice  1  4 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n\nBoth the `start` and `end` indexes can be negative, indicating an offset from\nthe end of the array.\n\n    slice  1 -1 (fromList [0,1,2,3,4]) == fromList [1,2,3]\n    slice -2  5 (fromList [0,1,2,3,4]) == fromList [3,4]\n\nThis makes it pretty easy to `pop` the last element off of an array:\n`slice 0 -1 array`\n',
				name: 'slice',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Array.Array',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])))))
			},
				{
				comment: ' Create an indexed list from an array. Each element of the array will be\npaired with its index.\n\n    toIndexedList (fromList ["cat","dog"]) == [(0,"cat"), (1,"dog")]\n',
				name: 'toIndexedList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])))
			},
				{
				comment: ' Create a list of elements from an array.\n\n    toList (fromList [3,5,8]) == [3,5,8]\n',
				name: 'toList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Array.Array',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_fromArray(
			[
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' The logical AND operator. `True` if both inputs are `True`.\n\n    True  && True  == True\n    True  && False == False\n    False && True  == False\n    False && False == False\n\n**Note:** When used in the infix position, like `(left && right)`, the operator\nshort-circuits. This means if `left` is `False` we do not bother evaluating `right`\nand just return `False` overall.\n',
				name: '&&',
				precedence: 3,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Multiply numbers like `2 * 3 == 6`.\n\nSee [`(+)`](#+) for docs on the `number` type variable.\n',
				name: '*',
				precedence: 7,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('number'),
						$elm$project_metadata_utils$Elm$Type$Var('number')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Add two numbers. The `number` type variable means this operation can be\nspecialized to `Int -> Int -> Int` or to `Float -> Float -> Float`. So you\ncan do things like this:\n\n    3002 + 4004 == 7006  -- all ints\n    3.14 + 3.14 == 6.28  -- all floats\n\nYou _cannot_ add an `Int` and a `Float` directly though. Use functions like\n[toFloat](#toFloat) or [round](#round) to convert both values to the same type.\nSo if you needed to add a list length to a `Float` for some reason, you\ncould say one of these:\n\n    3.14 + toFloat (List.length [1,2,3]) == 6.14\n    round 3.14 + List.length [1,2,3]     == 6\n\n**Note:** Languages like Java and JavaScript automatically convert `Int` values\nto `Float` values when you mix and match. This can make it difficult to be sure\nexactly what type of number you are dealing with. When you try to _infer_ these\nconversions (as Scala does) it can be even more confusing. Elm has opted for a\ndesign that makes all conversions explicit.\n',
				name: '+',
				precedence: 6,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('number'),
						$elm$project_metadata_utils$Elm$Type$Var('number')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' Put two appendable things together. This includes strings and lists.\n\n    "hello" ++ "world" == "helloworld"\n    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]\n',
				name: '++',
				precedence: 5,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('appendable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('appendable'),
						$elm$project_metadata_utils$Elm$Type$Var('appendable')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Subtract numbers like `4 - 3 == 1`.\n\nSee [`(+)`](#+) for docs on the `number` type variable.\n',
				name: '-',
				precedence: 6,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('number'),
						$elm$project_metadata_utils$Elm$Type$Var('number')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Floating-point division:\n\n    10 / 4 == 2.5\n    11 / 4 == 2.75\n    12 / 4 == 3\n    13 / 4 == 3.25\n    14 / 4 == 3.5\n\n    -1 / 4 == -0.25\n    -5 / 4 == -1.25\n\n',
				name: '/',
				precedence: 7,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Integer division:\n\n    10 // 4 == 2\n    11 // 4 == 2\n    12 // 4 == 3\n    13 // 4 == 3\n    14 // 4 == 3\n\n    -1 // 4 == 0\n    -5 // 4 == -1\n\nNotice that the remainder is discarded, so `3 // 4` is giving output\nsimilar to `truncate (3 / 4)`.\n\nIt may sometimes be useful to pair this with the [`remainderBy`](#remainderBy)\nfunction.\n',
				name: '//',
				precedence: 7,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: ' Check if values are not &ldquo;the same&rdquo;.\n\nSo `(a /= b)` is the same as `(not (a == b))`.\n',
				name: '/=',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: '',
				name: '<',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    not << isEven << sqrt\n\nYou can think of this operator as equivalent to the following:\n\n    (g << f)  ==  (\\x -> g (f x))\n\nSo our example expands out to something like this:\n\n    \\n -> not (isEven (sqrt n))\n',
				name: '<<',
				precedence: 9,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						$elm$project_metadata_utils$Elm$Type$Var('c')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b')),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('c'))))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: '',
				name: '<=',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' Saying `f <| x` is exactly the same as `f x`.\n\nIt can help you avoid parentheses, which can be nice sometimes. Maybe you want\nto apply a function to a `case` expression? That sort of thing.\n',
				name: '<|',
				precedence: 0,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: ' Check if values are &ldquo;the same&rdquo;.\n\n**Note:** Elm uses structural equality on tuples, records, and user-defined\nunion types. This means the values `(3, 4)` and `(3, 4)` are definitely equal.\nThis is not true in languages like JavaScript that use reference equality on\nobjects.\n\n**Note:** Do not use `(==)` with functions, JSON values from `elm/json`, or\nregular expressions from `elm/regex`. It does not work. It will crash if\npossible. With JSON values, decode to Elm values before doing any equality\nchecks!\n\nWhy is it like this? Equality in the Elm sense can be difficult or impossible\nto compute. Proving that functions are the same is [undecidable][], and JSON\nvalues can come in through ports and have functions, cycles, and new JS data\ntypes that interact weirdly with our equality implementation. In a future\nrelease, the compiler will detect when `(==)` is used with problematic types\nand provide a helpful error message at compile time. This will require some\npretty serious infrastructure work, so the stopgap is to crash as quickly as\npossible.\n\n[undecidable]: https://en.wikipedia.org/wiki/Undecidable_problem\n',
				name: '==',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: '',
				name: '>',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$None,
				comment: '',
				name: '>=',
				precedence: 4,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' Function composition, passing results along in the suggested direction. For\nexample, the following code checks if the square root of a number is odd:\n\n    sqrt >> isEven >> not\n\n',
				name: '>>',
				precedence: 9,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('c')),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('c'))))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' Exponentiation\n\n    3^2 == 9\n    3^3 == 27\n',
				name: '^',
				precedence: 8,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('number'),
						$elm$project_metadata_utils$Elm$Type$Var('number')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Saying `x |> f` is exactly the same as `f x`.\n\nIt is called the pipe operator because it lets you write pipelined code.\nFor example, say we have a `sanitize` function for turning user input into\nintegers:\n\n    -- BEFORE\n    sanitize : String -> Maybe Int\n    sanitize input =\n      String.toInt (String.trim input)\n\nWe can rewrite it like this:\n\n    -- AFTER\n    sanitize : String -> Maybe Int\n    sanitize input =\n      input\n        |> String.trim\n        |> String.toInt\n\nTotally equivalent! I recommend trying to rewrite code that uses `x |> f`\ninto code like `f x` until there are no pipes left. That can help you build\nyour intuition.\n\n**Note:** This can be overused! I think folks find it quite neat, but when you\nhave three or four steps, the code often gets clearer if you break out a\ntop-level helper function. Now the transformation has a name. The arguments are\nnamed. It has a type annotation. It is much more self-documenting that way!\nTesting the logic gets easier too. Nice side benefit!\n',
				name: '|>',
				precedence: 0,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b')),
						$elm$project_metadata_utils$Elm$Type$Var('b')))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' The logical OR operator. `True` if one or both inputs are `True`.\n\n    True  || True  == True\n    True  || False == True\n    False || True  == True\n    False || False == False\n\n**Note:** When used in the infix position, like `(left || right)`, the operator\nshort-circuits. This means if `left` is `True` we do not bother evaluating `right`\nand just return `True` overall.\n',
				name: '||',
				precedence: 2,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			}
			]),
		comment: ' Tons of useful functions that get imported by default.\n\n# Math\n@docs Int, Float, (+), (-), (*), (/), (//), (^)\n\n# Int to Float / Float to Int\n@docs toFloat, round, floor, ceiling, truncate\n\n# Equality\n@docs (==), (/=)\n\n# Comparison\n\nThese functions only work on `comparable` types. This includes numbers,\ncharacters, strings, lists of comparable things, and tuples of comparable\nthings.\n\n@docs (<), (>), (<=), (>=), max, min, compare, Order\n\n# Booleans\n@docs Bool, not, (&&), (||), xor\n\n# Append Strings and Lists\n@docs (++)\n\n# Fancier Math\n@docs modBy, remainderBy, negate, abs, clamp, sqrt, logBase, e\n\n# Angles\n@docs degrees, radians, turns\n\n# Trigonometry\n@docs pi, cos, sin, tan, acos, asin, atan, atan2\n\n# Polar Coordinates\n@docs toPolar, fromPolar\n\n# Floating Point Checks\n@docs isNaN, isInfinite\n\n# Function Helpers\n@docs identity, always, (<|), (|>), (<<), (>>), Never, never\n\n',
		name: 'Basics',
		unions: _List_fromArray(
			[
				{
				args: _List_Nil,
				comment: ' A Boolean value. It can either be `True` or `False`.\n\n**Note:** Programmers coming from JavaScript, Java, etc. tend to reach for\nboolean values way too often in Elm. Using a [union type][ut] is often clearer\nand more reliable. You can learn more about this from Jeremy [here][jf] or\nfrom Richard [here][rt].\n\n[ut]: https://guide.elm-lang.org/types/union_types.html\n[jf]: https://youtu.be/6TDKHGtAxeg?t=1m25s\n[rt]: https://youtu.be/IcgmSRJHu_8?t=1m14s\n',
				name: 'Bool',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('True', _List_Nil),
						_Utils_Tuple2('False', _List_Nil)
					])
			},
				{args: _List_Nil, comment: ' A `Float` is a [floating-point number][fp]. Valid syntax for floats includes:\n\n    0\n    42\n    3.14\n    0.1234\n    6.022e23   -- == (6.022 * 10^23)\n    6.022e+23  -- == (6.022 * 10^23)\n    1.602e19  -- == (1.602 * 10^-19)\n    1e3        -- == (1 * 10^3) == 1000\n\n**Historical Note:** The particular details of floats (e.g. `NaN`) are\nspecified by [IEEE 754][ieee] which is literally hard-coded into almost all\nCPUs in the world. That means if you think `NaN` is weird, you must\nsuccessfully overtake Intel and AMD with a chip that is not backwards\ncompatible with any widely-used assembly language.\n\n[fp]: https://en.wikipedia.org/wiki/Floating-point_arithmetic\n[ieee]: https://en.wikipedia.org/wiki/IEEE_754\n', name: 'Float', tags: _List_Nil},
				{args: _List_Nil, comment: ' An `Int` is a whole number. Valid syntax for integers includes:\n\n    0\n    42\n    9000\n    0xFF   -- 255 in hexadecimal\n    0x000A --  10 in hexadecimal\n\n**Note:** `Int` math is well-defined in the range `-2^31` to `2^31 - 1`. Outside\nof that range, the behavior is determined by the compilation target. When\ngenerating JavaScript, the safe range expands to `-2^53` to `2^53 - 1` for some\noperations, but if we generate WebAssembly some day, we would do the traditional\n[integer overflow][io]. This quirk is necessary to get good performance on\nquirky compilation targets.\n\n**Historical Note:** The name `Int` comes from the term [integer][]. It appears\nthat the `int` abbreviation was introduced in [ALGOL 68][68], shortening it\nfrom `integer` in [ALGOL 60][60]. Today, almost all programming languages use\nthis abbreviation.\n\n[io]: https://en.wikipedia.org/wiki/Integer_overflow\n[integer]: https://en.wikipedia.org/wiki/Integer\n[60]: https://en.wikipedia.org/wiki/ALGOL_60\n[68]: https://en.wikipedia.org/wiki/ALGOL_68\n', name: 'Int', tags: _List_Nil},
				{args: _List_Nil, comment: ' A value that can never happen! For context:\n\n  - The boolean type `Bool` has two values: `True` and `False`\n  - The unit type `()` has one value: `()`\n  - The never type `Never` has no values!\n\nYou may see it in the wild in `Html Never` which means this HTML will never\nproduce any messages. You would need to write an event handler like\n`onClick ??? : Attribute Never` but how can we fill in the question marks?!\nSo there cannot be any event handlers on that HTML.\n\nYou may also see this used with tasks that never fail, like `Task Never ()`.\n\nThe `Never` type is useful for restricting *arguments* to a function. Maybe my\nAPI can only accept HTML without event handlers, so I require `Html Never` and\nusers can give `Html msg` and everything will go fine. Generally speaking, you\ndo not want `Never` in your return types though.\n', name: 'Never', tags: _List_Nil},
				{
				args: _List_Nil,
				comment: ' Represents the relative ordering of two things.\nThe relations are less than, equal to, and greater than.\n',
				name: 'Order',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('LT', _List_Nil),
						_Utils_Tuple2('EQ', _List_Nil),
						_Utils_Tuple2('GT', _List_Nil)
					])
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Get the [absolute value][abs] of a number.\n\n    abs 16   == 16\n    abs -4   == 4\n    abs -8.5 == 8.5\n    abs 3.14 == 3.14\n\n[abs]: https://en.wikipedia.org/wiki/Absolute_value\n',
				name: 'abs',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					$elm$project_metadata_utils$Elm$Type$Var('number'))
			},
				{
				comment: ' Figure out the arccosine for `adjacent / hypotenuse` in radians:\n\n    acos (1/2) == 1.0471975511965979 -- 60 or pi/3 radians\n\n',
				name: 'acos',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Create a function that *always* returns the same value. Useful with\nfunctions like `map`:\n\n    List.map (always 0) [1,2,3,4,5] == [0,0,0,0,0]\n\n    -- List.map (\\_ -> 0) [1,2,3,4,5] == [0,0,0,0,0]\n    -- always = (\\x _ -> x)\n',
				name: 'always',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						$elm$project_metadata_utils$Elm$Type$Var('a')))
			},
				{
				comment: ' Figure out the arcsine for `opposite / hypotenuse` in radians:\n\n    asin (1/2) == 0.5235987755982989 -- 30 or pi/6 radians\n\n',
				name: 'asin',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' This helps you find the angle (in radians) to an `(x,y)` coordinate, but\nin a way that is rarely useful in programming. **You probably want\n[`atan2`](#atan2) instead!**\n\nThis version takes `y/x` as its argument, so there is no way to know whether\nthe negative signs comes from the `y` or `x` value. So as we go counter-clockwise\naround the origin from point `(1,1)` to `(1,-1)` to `(-1,-1)` to `(-1,1)` we do\nnot get angles that go in the full circle:\n\n    atan (  1 /  1 ) ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan (  1 / -1 ) == -0.7853981633974483 -- 315 or 7*pi/4 radians\n    atan ( -1 / -1 ) ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan ( -1 /  1 ) == -0.7853981633974483 -- 315 or 7*pi/4 radians\n\nNotice that everything is between `pi/2` and `-pi/2`. That is pretty useless\nfor figuring out angles in any sort of visualization, so again, check out\n[`atan2`](#atan2) instead!\n',
				name: 'atan',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' This helps you find the angle (in radians) to an `(x,y)` coordinate.\nSo rather than saying `atan (y/x)` you say `atan2 y x` and you can get a full\nrange of angles:\n\n    atan2  1  1 ==  0.7853981633974483 --  45 or   pi/4 radians\n    atan2  1 -1 ==  2.356194490192345  -- 135 or 3*pi/4 radians\n    atan2 -1 -1 == -2.356194490192345  -- 225 or 5*pi/4 radians\n    atan2 -1  1 == -0.7853981633974483 -- 315 or 7*pi/4 radians\n\n',
				name: 'atan2',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)))
			},
				{
				comment: ' Ceiling function, rounding up.\n\n    ceiling 1.0 == 1\n    ceiling 1.2 == 2\n    ceiling 1.5 == 2\n    ceiling 1.8 == 2\n\n    ceiling -1.2 == -1\n    ceiling -1.5 == -1\n    ceiling -1.8 == -1\n',
				name: 'ceiling',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Clamps a number within a given range. With the expression\n`clamp 100 200 x` the results are as follows:\n\n    100     if x < 100\n     x      if 100 <= x < 200\n    200     if 200 <= x\n',
				name: 'clamp',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('number'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('number'),
							$elm$project_metadata_utils$Elm$Type$Var('number'))))
			},
				{
				comment: ' Compare any two comparable values. Comparable values include `String`,\n`Char`, `Int`, `Float`, or a list or tuple containing comparable values. These\nare also the only values that work as `Dict` keys or `Set` members.\n\n    compare 3 4 == LT\n    compare 4 4 == EQ\n    compare 5 4 == GT\n',
				name: 'compare',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Order', _List_Nil)))
			},
				{
				comment: ' Figure out the cosine given an angle in radians.\n\n    cos (degrees 60)     == 0.5000000000000001\n    cos (turns (1/6))    == 0.5000000000000001\n    cos (radians (pi/3)) == 0.5000000000000001\n    cos (pi/3)           == 0.5000000000000001\n\n',
				name: 'cos',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Convert degrees to standard Elm angles (radians).\n\n    degrees 180 == 3.141592653589793\n',
				name: 'degrees',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' An approximation of e.\n',
				name: 'e',
				tipe: A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
			},
				{
				comment: ' Floor function, rounding down.\n\n    floor 1.0 == 1\n    floor 1.2 == 1\n    floor 1.5 == 1\n    floor 1.8 == 1\n\n    floor -1.2 == -2\n    floor -1.5 == -2\n    floor -1.8 == -2\n',
				name: 'floor',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Convert polar coordinates (r,&theta;) to Cartesian coordinates (x,y).\n\n    fromPolar (sqrt 2, degrees 45) == (1, 1)\n',
				name: 'fromPolar',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
							])),
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
							])))
			},
				{
				comment: ' Given a value, returns exactly the same value. This is called\n[the identity function](https://en.wikipedia.org/wiki/Identity_function).\n',
				name: 'identity',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					$elm$project_metadata_utils$Elm$Type$Var('a'))
			},
				{
				comment: ' Determine whether a float is positive or negative infinity.\n\n    isInfinite (0/0)     == False\n    isInfinite (sqrt -1) == False\n    isInfinite (1/0)     == True\n    isInfinite 1         == False\n\nNotice that NaN is not infinite! For float `n` to be finite implies that\n`not (isInfinite n || isNaN n)` evaluates to `True`.\n',
				name: 'isInfinite',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Determine whether a float is an undefined or unrepresentable number.\nNaN stands for *not a number* and it is [a standardized part of floating point\nnumbers](https://en.wikipedia.org/wiki/NaN).\n\n    isNaN (0/0)     == True\n    isNaN (sqrt -1) == True\n    isNaN (1/0)     == False  -- infinity is a number\n    isNaN 1         == False\n',
				name: 'isNaN',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Calculate the logarithm of a number with a given base.\n\n    logBase 10 100 == 2\n    logBase 2 256 == 8\n',
				name: 'logBase',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)))
			},
				{
				comment: ' Find the larger of two comparables.\n\n    max 42 12345678 == 12345678\n    max "abc" "xyz" == "xyz"\n',
				name: 'max',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						$elm$project_metadata_utils$Elm$Type$Var('comparable')))
			},
				{
				comment: ' Find the smaller of two comparables.\n\n    min 42 12345678 == 42\n    min "abc" "xyz" == "abc"\n',
				name: 'min',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						$elm$project_metadata_utils$Elm$Type$Var('comparable')))
			},
				{
				comment: ' Perform [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic).\nA common trick is to use (n mod 2) to detect even and odd numbers:\n\n    modBy 2 0 == 0\n    modBy 2 1 == 1\n    modBy 2 2 == 0\n    modBy 2 3 == 1\n\nOur `modBy` function works in the typical mathematical way when you run into\nnegative numbers:\n\n    List.map (modBy 4) [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n    --                 [  3,  0,  1,  2,  3,  0,  1,  2,  3,  0,  1 ]\n\nUse [`remainderBy`](#remainderBy) for a different treatment of negative numbers,\nor read Daan Leijens [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n',
				name: 'modBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Negate a number.\n\n    negate 42 == -42\n    negate -42 == 42\n    negate 0 == 0\n',
				name: 'negate',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('number'),
					$elm$project_metadata_utils$Elm$Type$Var('number'))
			},
				{
				comment: ' A function that can never be called. Seems extremely pointless, but it\n*can* come in handy. Imagine you have some HTML that should never produce any\nmessages. And say you want to use it in some other HTML that *does* produce\nmessages. You could say:\n\n    import Html exposing (..)\n\n    embedHtml : Html Never -> Html msg\n    embedHtml staticStuff =\n      div []\n        [ text "hello"\n        , Html.map never staticStuff\n        ]\n\nSo the `never` function is basically telling the type system, make sure no one\never calls me!\n',
				name: 'never',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Never', _List_Nil),
					$elm$project_metadata_utils$Elm$Type$Var('a'))
			},
				{
				comment: ' Negate a boolean value.\n\n    not True == False\n    not False == True\n',
				name: 'not',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' An approximation of pi.\n',
				name: 'pi',
				tipe: A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
			},
				{
				comment: ' Convert radians to standard Elm angles (radians).\n\n    radians pi == 3.141592653589793\n',
				name: 'radians',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Get the remainder after division. Here are bunch of examples of dividing by four:\n\n    List.map (remainderBy 4) [ -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5 ]\n    --                       [ -1,  0, -3, -2, -1,  0,  1,  2,  3,  0,  1 ]\n\nUse [`modBy`](#modBy) for a different treatment of negative numbers,\nor read Daan Leijens [Division and Modulus for Computer Scientists][dm] for more\ninformation.\n\n[dm]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf\n',
				name: 'remainderBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Round a number to the nearest integer.\n\n    round 1.0 == 1\n    round 1.2 == 1\n    round 1.5 == 2\n    round 1.8 == 2\n\n    round -1.2 == -1\n    round -1.5 == -1\n    round -1.8 == -2\n',
				name: 'round',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Figure out the sine given an angle in radians.\n\n    sin (degrees 30)     == 0.49999999999999994\n    sin (turns (1/12))   == 0.49999999999999994\n    sin (radians (pi/6)) == 0.49999999999999994\n    sin (pi/6)           == 0.49999999999999994\n\n',
				name: 'sin',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Take the square root of a number.\n\n    sqrt  4 == 2\n    sqrt  9 == 3\n    sqrt 16 == 4\n    sqrt 25 == 5\n',
				name: 'sqrt',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Figure out the tangent given an angle in radians.\n\n    tan (degrees 45)     == 0.9999999999999999\n    tan (turns (1/8))    == 0.9999999999999999\n    tan (radians (pi/4)) == 0.9999999999999999\n    tan (pi/4)           == 0.9999999999999999\n',
				name: 'tan',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Convert an integer into a float. Useful when mixing `Int` and `Float`\nvalues like this:\n\n    halfOf : Int -> Float\n    halfOf number =\n      toFloat number / 2\n\n',
				name: 'toFloat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' Convert Cartesian coordinates (x,y) to polar coordinates (r,&theta;).\n\n    toPolar (3, 4) == ( 5, 0.9272952180016122)\n    toPolar (5,12) == (13, 1.1760052070951352)\n',
				name: 'toPolar',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
							])),
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
							])))
			},
				{
				comment: ' Truncate a number, rounding towards zero.\n\n    truncate 1.0 == 1\n    truncate 1.2 == 1\n    truncate 1.5 == 1\n    truncate 1.8 == 1\n\n    truncate -1.2 == -1\n    truncate -1.5 == -1\n    truncate -1.8 == -1\n',
				name: 'truncate',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Convert turns to standard Elm angles (radians). One turn is equal to 360.\n\n    turns (1/2) == 3.141592653589793\n',
				name: 'turns',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil))
			},
				{
				comment: ' The exclusive-or operator. `True` if exactly one input is `True`.\n\n    xor True  True  == False\n    xor True  False == True\n    xor False True  == True\n    xor False False == False\n',
				name: 'xor',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' Library for [bitwise operations](https://en.wikipedia.org/wiki/Bitwise_operation).\n\n# Basic Operations\n@docs and, or, xor, complement\n\n# Bit Shifts\n@docs shiftLeftBy, shiftRightBy, shiftRightZfBy\n',
		name: 'Bitwise',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Bitwise AND\n',
				name: 'and',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Flip each bit individually, often called bitwise NOT\n',
				name: 'complement',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Bitwise OR\n',
				name: 'or',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Shift bits to the left by a given offset, filling new bits with zeros.\nThis can be used to multiply numbers by powers of two.\n\n    shiftLeftBy 1 5 == 10\n    shiftLeftBy 5 1 == 32\n',
				name: 'shiftLeftBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Shift bits to the right by a given offset, filling new bits with\nwhatever is the topmost bit. This can be used to divide numbers by powers of two.\n\n    shiftRightBy 1  32 == 16\n    shiftRightBy 2  32 == 8\n    shiftRightBy 1 -32 == -16\n\nThis is called an [arithmetic right shift][ars], often written `>>`, and\nsometimes called a sign-propagating right shift because it fills empty spots\nwith copies of the highest bit.\n\n[ars]: https://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift\n',
				name: 'shiftRightBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Shift bits to the right by a given offset, filling new bits with zeros.\n\n    shiftRightZfBy 1  32 == 16\n    shiftRightZfBy 2  32 == 8\n    shiftRightZfBy 1 -32 == 2147483632\n\nThis is called an [logical right shift][lrs], often written `>>>`, and\nsometimes called a zero-fill right shift because it fills empty spots with\nzeros.\n\n[lrs]: https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift\n',
				name: 'shiftRightZfBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			},
				{
				comment: ' Bitwise XOR\n',
				name: 'xor',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' Functions for working with characters. Character literals are enclosed in\n`\'a\'` pair of single quotes.\n\n# Characters\n@docs Char\n\n# ASCII Letters\n@docs isUpper, isLower, isAlpha, isAlphaNum\n\n# Digits\n@docs isDigit, isOctDigit, isHexDigit\n\n# Conversion\n@docs toUpper, toLower, toLocaleUpper, toLocaleLower\n\n# Unicode Code Points\n@docs toCode, fromCode\n',
		name: 'Char',
		unions: _List_fromArray(
			[
				{args: _List_Nil, comment: ' A `Char` is a single [unicode][u] character:\n\n    \'a\'\n    \'0\'\n    \'Z\'\n    \'?\'\n    \'"\'\n    \'\'\n    \'\'\n\n    \'\\t\'\n    \'\\"\'\n    \'\\\'\'\n    \'\\u{1F648}\' -- \'\'\n\n**Note 1:** You _cannot_ use single quotes around multiple characters like in\nJavaScript. This is how we distinguish [`String`](String#String) and `Char`\nvalues in syntax.\n\n**Note 2:** You can use the unicode escapes from `\\u{0000}` to `\\u{10FFFF}` to\nrepresent characters by their code point. You can also include the unicode\ncharacters directly. Using the escapes can be better if you need one of the\nmany whitespace characters with different widths.\n\n[u]: https://en.wikipedia.org/wiki/Unicode\n', name: 'Char', tags: _List_Nil}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Convert a Unicode [code point][cp] to a character.\n\n    fromCode 65      == \'A\'\n    fromCode 66      == \'B\'\n    fromCode 0x6728  == \'\'\n    fromCode 0x1D306 == \'\'\n    fromCode 0x1F603 == \'\'\n    fromCode -1      == \'\'\n\nThe full range of unicode is from `0` to `0x10FFFF`. With numbers outside that\nrange, you get [the replacement character][fffd].\n\n[cp]: https://en.wikipedia.org/wiki/Code_point\n[fffd]: https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character\n',
				name: 'fromCode',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil))
			},
				{
				comment: ' Detect upper case and lower case ASCII characters.\n\n    isAlpha \'a\' == True\n    isAlpha \'b\' == True\n    isAlpha \'E\' == True\n    isAlpha \'Y\' == True\n\n    isAlpha \'0\' == False\n    isAlpha \'-\' == False\n    isAlpha \'\' == False\n',
				name: 'isAlpha',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect upper case and lower case ASCII characters.\n\n    isAlphaNum \'a\' == True\n    isAlphaNum \'b\' == True\n    isAlphaNum \'E\' == True\n    isAlphaNum \'Y\' == True\n    isAlphaNum \'0\' == True\n    isAlphaNum \'7\' == True\n\n    isAlphaNum \'-\' == False\n    isAlphaNum \'\' == False\n',
				name: 'isAlphaNum',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect digits `0123456789`\n\n    isDigit \'0\' == True\n    isDigit \'1\' == True\n    ...\n    isDigit \'9\' == True\n\n    isDigit \'a\' == False\n    isDigit \'b\' == False\n    isDigit \'A\' == False\n',
				name: 'isDigit',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect hexadecimal digits `0123456789abcdefABCDEF`\n',
				name: 'isHexDigit',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect lower case ASCII characters.\n\n    isLower \'a\' == True\n    isLower \'b\' == True\n    ...\n    isLower \'z\' == True\n\n    isLower \'0\' == False\n    isLower \'A\' == False\n    isLower \'-\' == False\n    isLower \'\' == False\n',
				name: 'isLower',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect octal digits `01234567`\n\n    isOctDigit \'0\' == True\n    isOctDigit \'1\' == True\n    ...\n    isOctDigit \'7\' == True\n\n    isOctDigit \'8\' == False\n    isOctDigit \'a\' == False\n    isOctDigit \'A\' == False\n',
				name: 'isOctDigit',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Detect upper case ASCII characters.\n\n    isUpper \'A\' == True\n    isUpper \'B\' == True\n    ...\n    isUpper \'Z\' == True\n\n    isUpper \'0\' == False\n    isUpper \'a\' == False\n    isUpper \'-\' == False\n    isUpper \'\' == False\n',
				name: 'isUpper',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Convert to the corresponding Unicode [code point][cp].\n\n[cp]: https://en.wikipedia.org/wiki/Code_point\n\n    toCode \'A\' == 65\n    toCode \'B\' == 66\n    toCode \'\' == 0x6728\n    toCode \'\' == 0x1D306\n    toCode \'\' == 0x1F603\n',
				name: 'toCode',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Convert to lower case, according to any locale-specific case mappings. ',
				name: 'toLocaleLower',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil))
			},
				{
				comment: ' Convert to upper case, according to any locale-specific case mappings. ',
				name: 'toLocaleUpper',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil))
			},
				{
				comment: ' Convert to lower case. ',
				name: 'toLower',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil))
			},
				{
				comment: ' Convert to upper case. ',
				name: 'toUpper',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' This module can be useful while _developing_ an application. It is not\navailable for use in packages or production.\n\n# Debugging\n@docs toString, log, todo\n',
		name: 'Debug',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Log a tagged value on the developer console, and then return the value.\n\n    1 + log "number" 1        -- equals 2, logs "number: 1"\n    length (log "start" [])   -- equals 0, logs "start: []"\n\nIt is often possible to sprinkle this around to see if values are what you\nexpect. It is kind of old-school to do it this way, but it works!\n\n**Note:** This is not available with `elm make --optimize` because (1) it\nrelies on `toString` which has the same restriction and (2) it is not a pure\nfunction and would therefore have unpredictable behavior when paired with\ncompiler optimizations that move code around.\n\n**Note:** If you want to create a terminal application that prints stuff out,\nuse ports for now. That will give you full access to reading and writing in the\nterminal. We may have a package in Elm for this someday, but browser\napplications are the primary focus of platform development for now.\n',
				name: 'log',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('a')))
			},
				{
				comment: ' Turn any kind of value into a string.\n\n    toString 42                == "42"\n    toString [1,2]             == "[1,2]"\n    toString (\'a\', "cat", 13)  == "(\'a\', \\"cat\\", 13)"\n    toString "he said, \\"hi\\"" == "\\"he said, \\\\\\"hi\\\\\\"\\""\n\nNotice that with strings, this is not the `identity` function. It escapes\ncharacters so if you say `Html.text (toString "he said, \\"hi\\"")` it will\nshow `"he said, \\"hi\\""` rather than `he said, "hi"`. This makes it nice\nfor viewing Elm data structures.\n\n**Note:** This is not available with `elm make --optimize` which gets rid of\na bunch of runtime metadata. For example, it shortens record field names, and\nwe need that info to `toString` the value! As a consequence, packages cannot\nuse `toString` because they may be used in `--optimize` mode.\n',
				name: 'toString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' This is a placeholder for code that you will write later.\n\nFor example, if you are working with a large union type and have partially\ncompleted a case expression, it may make sense to do this:\n\n    type Entity = Ship | Fish | Captain | Seagull\n\n    drawEntity entity =\n      case entity of\n        Ship ->\n          ...\n\n        Fish ->\n          ...\n\n        _ ->\n          Debug.todo "handle Captain and Seagull"\n\nThe Elm compiler recognizes each `Debug.todo` so if you run into it, you get\nan **uncatchable runtime exception** that includes the module name and line\nnumber.\n\n**Note:** This is not available with `elm make --optimize` or packages. The\nidea is that a `todo` can be useful during development, but uncatchable runtime\nexceptions should not appear in the resulting applications.\n\n**Note:** For the equivalent of try/catch error handling in Elm, use modules\nlike [`Maybe`](#Maybe) and [`Result`](#Result) which guarantee that no error\ngoes unhandled!\n',
				name: 'todo',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					$elm$project_metadata_utils$Elm$Type$Var('a'))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Dictionaries\n@docs Dict\n\n# Build\n@docs empty, singleton, insert, update, remove\n\n# Query\n@docs isEmpty, member, get, size\n\n# Lists\n@docs keys, values, toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n# Combine\n@docs union, intersect, diff, merge\n\n',
		name: 'Dict',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['k', 'v']),
				comment: ' A dictionary of keys and values. So a `Dict String User` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n\n    import Dict exposing (Dict)\n\n    users : Dict String User\n    users =\n      Dict.fromList\n        [ ("Alice", User "Alice" 28 1.65)\n        , ("Bob"  , User "Bob"   19 1.82)\n        , ("Chuck", User "Chuck" 33 1.75)\n        ]\n\n    type alias User =\n      { name : String\n      , age : Int\n      , height : Float\n      }\n',
				name: 'Dict',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Keep a key-value pair when its key does not appear in the second dictionary.\n',
				name: 'diff',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Create an empty dictionary. ',
				name: 'empty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Dict.Dict',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('k'),
							$elm$project_metadata_utils$Elm$Type$Var('v')
						]))
			},
				{
				comment: ' Keep only the key-value pairs that pass the given test. ',
				name: 'filter',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('v'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Fold over the key-value pairs in a dictionary from lowest key to highest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n      Dict.foldl addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n      user.age :: ages\n\n    -- getAges users == [33,19,28]\n',
				name: 'foldl',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('k'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('v'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('b'),
								$elm$project_metadata_utils$Elm$Type$Var('b')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('k'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Fold over the key-value pairs in a dictionary from highest key to lowest key.\n\n    import Dict exposing (Dict)\n\n    getAges : Dict String User -> List String\n    getAges users =\n      Dict.foldr addAge [] users\n\n    addAge : String -> User -> List String -> List String\n    addAge _ user ages =\n      user.age :: ages\n\n    -- getAges users == [28,19,33]\n',
				name: 'foldr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('k'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('v'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('b'),
								$elm$project_metadata_utils$Elm$Type$Var('b')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('k'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Convert an association list into a dictionary. ',
				name: 'fromList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('comparable'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])))
			},
				{
				comment: ' Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ ("Tom", Cat), ("Jerry", Mouse) ]\n\n    get "Tom"   animals == Just Cat\n    get "Jerry" animals == Just Mouse\n    get "Spike" animals == Nothing\n\n',
				name: 'get',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Insert a key-value pair into a dictionary. Replaces value when there is\na collision. ',
				name: 'insert',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('v'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('comparable'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('comparable'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])))))
			},
				{
				comment: ' Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n',
				name: 'intersect',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Determine if a dictionary is empty.\n\n    isEmpty empty == True\n',
				name: 'isEmpty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [(0,"Alice"),(1,"Bob")]) == [0,1]\n',
				name: 'keys',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k')
							])))
			},
				{
				comment: ' Apply a function to all values in a dictionary.\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('k'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('k'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('k'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Determine if a key is in a dictionary. ',
				name: 'member',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n  1. Only in the left dictionary.\n  2. In both dictionaries.\n  3. Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n',
				name: 'merge',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('result'),
								$elm$project_metadata_utils$Elm$Type$Var('result')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('comparable'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('b'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('result'),
										$elm$project_metadata_utils$Elm$Type$Var('result'))))),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('comparable'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('b'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('result'),
										$elm$project_metadata_utils$Elm$Type$Var('result')))),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Dict.Dict',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('comparable'),
											$elm$project_metadata_utils$Elm$Type$Var('a')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Dict.Dict',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('comparable'),
												$elm$project_metadata_utils$Elm$Type$Var('b')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('result'),
										$elm$project_metadata_utils$Elm$Type$Var('result')))))))
			},
				{
				comment: ' Partition a dictionary according to some test. The first dictionary\ncontains all key-value pairs which passed the test, and the second contains\nthe pairs that did not.\n',
				name: 'partition',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('v'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Dict.Dict',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('comparable'),
											$elm$project_metadata_utils$Elm$Type$Var('v')
										])),
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Dict.Dict',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('comparable'),
											$elm$project_metadata_utils$Elm$Type$Var('v')
										]))
								]))))
			},
				{
				comment: ' Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made. ',
				name: 'remove',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Create a dictionary with one key-value pair. ',
				name: 'singleton',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('v'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Determine the number of key-value pairs in the dictionary. ',
				name: 'size',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Convert a dictionary into an association list of key-value pairs, sorted by keys. ',
				name: 'toList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('k'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									]))
							])))
			},
				{
				comment: ' Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n',
				name: 'union',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Dict.Dict',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable'),
									$elm$project_metadata_utils$Elm$Type$Var('v')
								]))))
			},
				{
				comment: ' Update the value of a dictionary for a specific key with a given function. ',
				name: 'update',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('v')
									]))),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('comparable'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Dict.Dict',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('comparable'),
										$elm$project_metadata_utils$Elm$Type$Var('v')
									])))))
			},
				{
				comment: ' Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [(0,"Alice"),(1,"Bob")]) == ["Alice", "Bob"]\n',
				name: 'values',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Dict.Dict',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('k'),
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('v')
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_fromArray(
			[
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Right,
				comment: ' Add an element to the front of a list.\n\n    1 :: [2,3] == [1,2,3]\n    1 :: [] == [1]\n\nThis operator is pronounced *cons* for historical reasons, but you can think\nof it like pushing an entry onto a stack.\n',
				name: '::',
				precedence: 5,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			}
			]),
		comment: ' You can create a `List` in Elm with the `[1,2,3]` syntax, so lists are\nused all over the place. This module has a bunch of functions to help you work\nwith them!\n\n# Create\n@docs singleton, repeat, range, (::)\n\n# Transform\n@docs map, indexedMap, foldl, foldr, filter, filterMap\n\n# Utilities\n@docs length, reverse, member, all, any, maximum, minimum, sum, product\n\n# Combine\n@docs append, concat, concatMap, intersperse, map2, map3, map4, map5\n\n# Sort\n@docs sort, sortBy, sortWith\n\n# Deconstruct\n@docs isEmpty, head, tail, take, drop, partition, unzip\n\n',
		name: 'List',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Determine if all elements satisfy some test.\n\n    all isEven [2,4] == True\n    all isEven [2,3] == False\n    all isEven [] == True\n',
				name: 'all',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Determine if any elements satisfy some test.\n\n    any isEven [2,3] == True\n    any isEven [1,3] == False\n    any isEven [] == False\n',
				name: 'any',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Put two lists together.\n\n    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]\n    append [\'a\',\'b\'] [\'c\'] == [\'a\',\'b\',\'c\']\n\nYou can also use [the `(++)` operator](Basics#++) to append lists.\n',
				name: 'append',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Concatenate a bunch of lists into a single list:\n\n    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]\n',
				name: 'concat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Map a given function onto a list and flatten the resulting lists.\n\n    concatMap f xs == concat (map f xs)\n',
				name: 'concatMap',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Drop the first *n* members of a list.\n\n    drop 2 [1,2,3,4] == [3,4]\n',
				name: 'drop',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Keep elements that satisfy the test.\n\n    filter isEven [1,2,3,4,5,6] == [2,4,6]\n',
				name: 'filter',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Filter out certain values. For example, maybe you have a bunch of strings\nfrom an untrusted source and you want to turn them into numbers:\n\n    numbers : List Int\n    numbers =\n      filterMap String.toInt ["3", "hi", "12", "4th", "May"]\n\n    -- numbers == [3, 12]\n\n',
				name: 'filterMap',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Reduce a list from the left.\n\n    foldl (+)  0  [1,2,3] == 6\n    foldl (::) [] [1,2,3] == [3,2,1]\n\nSo `foldl step state [1,2,3]` is like saying:\n\n    state\n      |> step 1\n      |> step 2\n      |> step 3\n',
				name: 'foldl',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Reduce a list from the right.\n\n    foldr (+)  0  [1,2,3] == 6\n    foldr (::) [] [1,2,3] == [1,2,3]\n\nSo `foldr step state [1,2,3]` is like saying:\n\n    state\n      |> step 3\n      |> step 2\n      |> step 1\n',
				name: 'foldr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Extract the first element of a list.\n\n    head [1,2,3] == Just 1\n    head [] == Nothing\n\n**Note:** It is usually preferable to use a `case` to deconstruct a `List`\nbecause it gives you `(x :: xs)` and you can work with both subparts.\n',
				name: 'head',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Same as `map` but the function is also applied to the index of each\nelement (starting at zero).\n\n    indexedMap Tuple.pair ["Tom","Sue","Bob"] == [ (0,"Tom"), (1,"Sue"), (2,"Bob") ]\n',
				name: 'indexedMap',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Places the given value between all members of the given list.\n\n    intersperse "on" ["turtles","turtles","turtles"] == ["turtles","on","turtles","on","turtles"]\n',
				name: 'intersperse',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Determine if a list is empty.\n\n    isEmpty [] == True\n\n**Note:** It is usually preferable to use a `case` to test this so you do not\nforget to handle the `(x :: xs)` case as well!\n',
				name: 'isEmpty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Determine the length of a list.\n\n    length [1,2,3] == 3\n',
				name: 'length',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Apply a function to every element of a list.\n\n    map sqrt [1,4,9] == [1,2,3]\n\n    map not [True,False,True] == [False,True,False]\n\nSo `map func [ a, b, c ]` is the same as `[ func a, func b, func c ]`\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Combine two lists, combining them with the given function.\nIf one list is longer, the extra elements are dropped.\n\n    totals : List Int -> List Int -> List Int\n    totals xs ys =\n      List.map2 (+) xs ys\n\n    -- totals [1,2,3] [4,5,6] == [5,7,9]\n\n    pairs : List a -> List b -> List (a,b)\n    pairs xs ys =\n      List.map2 Tuple.pair xs ys\n\n    -- pairs ["alice","bob","chuck"] [2,5,7,8]\n    --   == [("alice",2),("bob",5),("chuck",7)]\n\n',
				name: 'map2',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('result'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('result')
									])))))
			},
				{
				comment: '',
				name: 'map3',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('result')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('result')
										]))))))
			},
				{
				comment: '',
				name: 'map4',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									$elm$project_metadata_utils$Elm$Type$Var('result'))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'List.List',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'List.List',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('result')
											])))))))
			},
				{
				comment: '',
				name: 'map5',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('e'),
										$elm$project_metadata_utils$Elm$Type$Var('result')))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'List.List',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'List.List',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('e')
												])),
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'List.List',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('result')
												]))))))))
			},
				{
				comment: ' Find the maximum element in a non-empty list.\n\n    maximum [1,4,2] == Just 4\n    maximum []      == Nothing\n',
				name: 'maximum',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])))
			},
				{
				comment: ' Figure out whether a list contains a value.\n\n    member 9 [1,2,3,4] == False\n    member 4 [1,2,3,4] == True\n',
				name: 'member',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Find the minimum element in a non-empty list.\n\n    minimum [3,2,1] == Just 1\n    minimum []      == Nothing\n',
				name: 'minimum',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])))
			},
				{
				comment: ' Partition a list based on some test. The first list contains all values\nthat satisfy the test, and the second list contains all the value that do not.\n\n    partition (\\x -> x < 3) [0,1,2,3,4,5] == ([0,1,2], [3,4,5])\n    partition isEven        [0,1,2,3,4,5] == ([0,2,4], [1,3,5])\n',
				name: 'partition',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('a')
										])),
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('a')
										]))
								]))))
			},
				{
				comment: ' Get the product of the list elements.\n\n    product [2,2,2] == 8\n    product [3,3,3] == 27\n    product []      == 1\n\n',
				name: 'product',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('number')
							])),
					$elm$project_metadata_utils$Elm$Type$Var('number'))
			},
				{
				comment: ' Create a list of numbers, every element increasing by one.\nYou give the lowest and highest number that should be in the list.\n\n    range 3 6 == [3, 4, 5, 6]\n    range 3 3 == [3]\n    range 6 3 == []\n',
				name: 'range',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))))
			},
				{
				comment: ' Create a list with *n* copies of a value:\n\n    repeat 3 (0,0) == [(0,0),(0,0),(0,0)]\n',
				name: 'repeat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Reverse a list.\n\n    reverse [1,2,3,4] == [4,3,2,1]\n',
				name: 'reverse',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Create a list with only one element:\n\n    singleton 1234 == [1234]\n    singleton "hi" == ["hi"]\n',
				name: 'singleton',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Sort values from lowest to highest\n\n    sort [3,1,5] == [1,3,5]\n',
				name: 'sort',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])))
			},
				{
				comment: ' Sort values by a derived property.\n\n    alice = { name="Alice", height=1.62 }\n    bob   = { name="Bob"  , height=1.85 }\n    chuck = { name="Chuck", height=1.76 }\n\n    sortBy .name   [chuck,alice,bob] == [alice,bob,chuck]\n    sortBy .height [chuck,alice,bob] == [alice,chuck,bob]\n\n    sortBy String.length ["mouse","cat"] == ["cat","mouse"]\n',
				name: 'sortBy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('comparable')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Sort values with a custom comparison function.\n\n    sortWith flippedComparison [1,2,3,4,5] == [5,4,3,2,1]\n\n    flippedComparison a b =\n        case compare a b of\n          LT -> GT\n          EQ -> EQ\n          GT -> LT\n\nThis is also the most general sort function, allowing you\nto define any other: `sort == sortWith compare`\n',
				name: 'sortWith',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Order', _List_Nil))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Get the sum of the list elements.\n\n    sum [1,2,3] == 6\n    sum [1,1,1] == 3\n    sum []      == 0\n\n',
				name: 'sum',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('number')
							])),
					$elm$project_metadata_utils$Elm$Type$Var('number'))
			},
				{
				comment: ' Extract the rest of the list.\n\n    tail [1,2,3] == Just [2,3]\n    tail [] == Nothing\n\n**Note:** It is usually preferable to use a `case` to deconstruct a `List`\nbecause it gives you `(x :: xs)` and you can work with both subparts.\n',
				name: 'tail',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])))
			},
				{
				comment: ' Take the first *n* members of a list.\n\n    take 2 [1,2,3,4] == [1,2]\n',
				name: 'take',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Decompose a list of tuples into a tuple of lists.\n\n    unzip [(0, True), (17, False), (1337, True)] == ([0,17,1337], [True,False,True])\n',
				name: 'unzip',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									]))
							])),
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									]))
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' This library fills a bunch of important niches in Elm. A `Maybe` can help\nyou with optional arguments, error handling, and records with optional fields.\n\n# Definition\n@docs Maybe\n\n# Common Helpers\n@docs withDefault, map, map2, map3, map4, map5\n\n# Chaining Maybes\n@docs andThen\n',
		name: 'Maybe',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['a']),
				comment: ' Represent values that may or may not exist. It can be useful if you have a\nrecord field that is only filled in sometimes. Or if a function takes a value\nsometimes, but does not absolutely need it.\n\n    -- A person, but maybe we do not know their age.\n    type alias Person =\n        { name : String\n        , age : Maybe Int\n        }\n\n    tom = { name = "Tom", age = Just 42 }\n    sue = { name = "Sue", age = Nothing }\n',
				name: 'Maybe',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Just',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
						_Utils_Tuple2('Nothing', _List_Nil)
					])
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Chain together many computations that may fail. It is helpful to see its\ndefinition:\n\n    andThen : (a -> Maybe b) -> Maybe a -> Maybe b\n    andThen callback maybe =\n        case maybe of\n            Just value ->\n                callback value\n\n            Nothing ->\n                Nothing\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to parse some user input as a month:\n\n    parseMonth : String -> Maybe Int\n    parseMonth userInput =\n        String.toInt userInput\n          |> andThen toValidMonth\n\n    toValidMonth : Int -> Maybe Int\n    toValidMonth month =\n        if 1 <= month && month <= 12 then\n            Just month\n        else\n            Nothing\n\nIn the `parseMonth` function, if `String.toInt` produces `Nothing` (because\nthe `userInput` was not an integer) this entire chain of operations will\nshort-circuit and result in `Nothing`. If `toValidMonth` results in `Nothing`,\nagain the chain of computations will result in `Nothing`.\n',
				name: 'andThen',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Transform a `Maybe` value with a given function:\n\n    map sqrt (Just 9) == Just 3\n    map sqrt Nothing  == Nothing\n\n    map sqrt (String.toFloat "9") == Just 3\n    map sqrt (String.toFloat "x") == Nothing\n\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Apply a function if all the arguments are `Just` a value.\n\n    map2 (+) (Just 3) (Just 4) == Just 7\n    map2 (+) (Just 3) Nothing == Nothing\n    map2 (+) Nothing (Just 4) == Nothing\n\n    map2 (+) (String.toInt "1") (String.toInt "123") == Just 124\n    map2 (+) (String.toInt "x") (String.toInt "123") == Nothing\n    map2 (+) (String.toInt "1") (String.toInt "1.3") == Nothing\n',
				name: 'map2',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('value'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('value')
									])))))
			},
				{
				comment: '',
				name: 'map3',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('value')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('value')
										]))))))
			},
				{
				comment: '',
				name: 'map4',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									$elm$project_metadata_utils$Elm$Type$Var('value'))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Maybe.Maybe',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Maybe.Maybe',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('value')
											])))))))
			},
				{
				comment: '',
				name: 'map5',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('e'),
										$elm$project_metadata_utils$Elm$Type$Var('value')))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Maybe.Maybe',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Maybe.Maybe',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Maybe.Maybe',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('e')
												])),
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Maybe.Maybe',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('value')
												]))))))))
			},
				{
				comment: ' Provide a default value, turning an optional value into a normal\nvalue.  This comes in handy when paired with functions like\n[`Dict.get`](Dict#get) which gives back a `Maybe`.\n\n    withDefault 100 (Just 42)   -- 42\n    withDefault 100 Nothing     -- 100\n\n    withDefault "unknown" (Dict.get "Tom" Dict.empty)   -- "unknown"\n\n**Note:** This can be overused! Many cases are better handled by a `case`\nexpression. And if you end up using `withDefault` a lot, it can be a good sign\nthat a [custom type][ct] will clean your code up quite a bit!\n\n[ct]: https://guide.elm-lang.org/types/custom_types.html\n',
				name: 'withDefault',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						$elm$project_metadata_utils$Elm$Type$Var('a')))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: '\n\n# Programs\n@docs Program, worker\n\n# Platform Internals\n\n## Tasks and Processes\n@docs Task, ProcessId\n\n## Effect Manager Helpers\n\nAn extremely tiny portion of library authors should ever write effect managers.\nFundamentally, Elm needs maybe 10 of them total. I get that people are smart,\ncurious, etc. but that is not a substitute for a legitimate reason to make an\neffect manager. Do you have an *organic need* this fills? Or are you just\ncurious? Public discussions of your explorations should be framed accordingly.\n\n@docs Router, sendToApp, sendToSelf\n',
		name: 'Platform',
		unions: _List_fromArray(
			[
				{args: _List_Nil, comment: ' Head over to the documentation for the [`Process`](Process) module for\ninformation on this. It is only defined here because it is a platform\nprimitive.\n', name: 'ProcessId', tags: _List_Nil},
				{
				args: _List_fromArray(
					['flags', 'model', 'msg']),
				comment: ' A `Program` describes an Elm program! How does it react to input? Does it\nshow anything on screen? Etc.\n',
				name: 'Program',
				tags: _List_Nil
			},
				{
				args: _List_fromArray(
					['appMsg', 'selfMsg']),
				comment: ' An effect manager has access to a router that routes messages between\nthe main app and your individual effect manager.\n',
				name: 'Router',
				tags: _List_Nil
			},
				{
				args: _List_fromArray(
					['err', 'ok']),
				comment: ' Head over to the documentation for the [`Task`](Task) module for more\ninformation on this. It is only defined here because it is a platform\nprimitive.\n',
				name: 'Task',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Send the router a message for the main loop of your app. This message will\nbe handled by the overall `update` function, just like events from `Html`.\n',
				name: 'sendToApp',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Platform.Router',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('msg'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('msg'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
								]))))
			},
				{
				comment: ' Send the router a message for your effect manager. This message will\nbe routed to the `onSelfMsg` function, where you can update the state of your\neffect manager as necessary.\n\nAs an example, the effect manager for web sockets\n',
				name: 'sendToSelf',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Platform.Router',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								$elm$project_metadata_utils$Elm$Type$Var('msg')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('msg'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
								]))))
			},
				{
				comment: ' Create a [headless][] program with no user interface.\n\nThis is great if you want to use Elm as the &ldquo;brain&rdquo; for something\nelse. For example, you could send messages out ports to modify the DOM, but do\nall the complex logic in Elm.\n\n[headless]: https://en.wikipedia.org/wiki/Headless_software\n\nInitializing a headless program from JavaScript looks like this:\n\n```javascript\nvar app = Elm.MyThing.init();\n```\n\nIf you _do_ want to control the user interface in Elm, the [`Browser`][browser]\nmodule has a few ways to create that kind of `Program` instead!\n\n[headless]: https://en.wikipedia.org/wiki/Headless_software\n[browser]: /packages/elm/browser/latest/Browser\n',
				name: 'worker',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'init',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('flags'),
									$elm$project_metadata_utils$Elm$Type$Tuple(
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('model'),
												A2(
												$elm$project_metadata_utils$Elm$Type$Type,
												'Platform.Cmd.Cmd',
												_List_fromArray(
													[
														$elm$project_metadata_utils$Elm$Type$Var('msg')
													]))
											])))),
								_Utils_Tuple2(
								'update',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('msg'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('model'),
										$elm$project_metadata_utils$Elm$Type$Tuple(
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('model'),
													A2(
													$elm$project_metadata_utils$Elm$Type$Type,
													'Platform.Cmd.Cmd',
													_List_fromArray(
														[
															$elm$project_metadata_utils$Elm$Type$Var('msg')
														]))
												]))))),
								_Utils_Tuple2(
								'subscriptions',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('model'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Platform.Sub.Sub',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('msg')
											]))))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Platform.Program',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('flags'),
								$elm$project_metadata_utils$Elm$Type$Var('model'),
								$elm$project_metadata_utils$Elm$Type$Var('msg')
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: '\n\n> **Note:** Elm has **managed effects**, meaning that things like HTTP\n> requests or writing to disk are all treated as *data* in Elm. When this\n> data is given to the Elm runtime system, it can do some query optimization\n> before actually performing the effect. Perhaps unexpectedly, this managed\n> effects idea is the heart of why Elm is so nice for testing, reuse,\n> reproducibility, etc.\n>\n> Elm has two kinds of managed effects: commands and subscriptions.\n\n# Commands\n@docs Cmd, none, batch\n\n# Fancy Stuff\n@docs map\n\n',
		name: 'Platform.Cmd',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['msg']),
				comment: ' A command is a way of telling Elm, Hey, I want you to do this thing!\nSo if you want to send an HTTP request, you would need to command Elm to do it.\nOr if you wanted to ask for geolocation, you would need to command Elm to go\nget it.\n\nEvery `Cmd` specifies (1) which effects you need access to and (2) the type of\nmessages that will come back into your application.\n\n**Note:** Do not worry if this seems confusing at first! As with every Elm user\never, commands will make more sense as you work through [the Elm Architecture\nTutorial](https://guide.elm-lang.org/architecture/) and see how they\nfit into a real application!\n',
				name: 'Cmd',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' When you need the runtime system to perform a couple commands, you\ncan batch them together. Each is handed to the runtime at the same time,\nand since each can perform arbitrary operations in the world, there are\nno ordering guarantees about the results.\n\n**Note:** `Cmd.none` and `Cmd.batch [ Cmd.none, Cmd.none ]` and `Cmd.batch []`\nall do the same thing.\n',
				name: 'batch',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Platform.Cmd.Cmd',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('msg')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Platform.Cmd.Cmd',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('msg')
							])))
			},
				{
				comment: ' Transform the messages produced by a command.\nVery similar to [`Html.map`](/packages/elm/html/latest/Html#map).\n\nThis is very rarely useful in well-structured Elm code, so definitely read the\nsection on [structure][] in the guide before reaching for this!\n\n[structure]: https://guide.elm-lang.org/webapps/structure.html\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('msg')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Cmd.Cmd',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Cmd.Cmd',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('msg')
								]))))
			},
				{
				comment: ' Tell the runtime that there are no commands.\n\n',
				name: 'none',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Platform.Cmd.Cmd',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('msg')
						]))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: '\n\n> **Note:** Elm has **managed effects**, meaning that things like HTTP\n> requests or writing to disk are all treated as *data* in Elm. When this\n> data is given to the Elm runtime system, it can do some query optimization\n> before actually performing the effect. Perhaps unexpectedly, this managed\n> effects idea is the heart of why Elm is so nice for testing, reuse,\n> reproducibility, etc.\n>\n> Elm has two kinds of managed effects: commands and subscriptions.\n\n# Subscriptions\n@docs Sub, none, batch\n\n# Fancy Stuff\n@docs map\n',
		name: 'Platform.Sub',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['msg']),
				comment: ' A subscription is a way of telling Elm, Hey, let me know if anything\ninteresting happens over there! So if you want to listen for messages on a web\nsocket, you would tell Elm to create a subscription. If you want to get clock\nticks, you would tell Elm to subscribe to that. The cool thing here is that\nthis means *Elm* manages all the details of subscriptions instead of *you*.\nSo if a web socket goes down, *you* do not need to manually reconnect with an\nexponential backoff strategy, *Elm* does this all for you behind the scenes!\n\nEvery `Sub` specifies (1) which effects you need access to and (2) the type of\nmessages that will come back into your application.\n\n**Note:** Do not worry if this seems confusing at first! As with every Elm user\never, subscriptions will make more sense as you work through [the Elm Architecture\nTutorial](https://guide.elm-lang.org/architecture/) and see how they fit\ninto a real application!\n',
				name: 'Sub',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' When you need to subscribe to multiple things, you can create a `batch` of\nsubscriptions.\n\n**Note:** `Sub.none` and `Sub.batch [ Sub.none, Sub.none ]` and\n`Sub.batch []` all do the same thing.\n',
				name: 'batch',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Platform.Sub.Sub',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('msg')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Platform.Sub.Sub',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('msg')
							])))
			},
				{
				comment: ' Transform the messages produced by a subscription.\nVery similar to [`Html.map`](/packages/elm/html/latest/Html#map).\n\nThis is very rarely useful in well-structured Elm code, so definitely read the\nsection on [structure][] in the guide before reaching for this!\n\n[structure]: https://guide.elm-lang.org/webapps/structure.html\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('msg')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Sub.Sub',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Sub.Sub',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('msg')
								]))))
			},
				{
				comment: ' Tell the runtime that there are no subscriptions.\n',
				name: 'none',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Platform.Sub.Sub',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('msg')
						]))
			}
			])
	},
		{
		aliases: _List_fromArray(
			[
				{
				args: _List_Nil,
				comment: ' A light-weight process that runs concurrently. You can use `spawn` to\nget a bunch of different tasks running in different processes. The Elm runtime\nwill interleave their progress. So if a task is taking too long, we will pause\nit at an `andThen` and switch over to other stuff.\n\n**Note:** We make a distinction between *concurrency* which means interleaving\ndifferent sequences and *parallelism* which means running different\nsequences at the exact same time. For example, a\n[time-sharing system](https://en.wikipedia.org/wiki/Time-sharing) is definitely\nconcurrent, but not necessarily parallel. So even though JS runs within a\nsingle OS-level thread, Elm can still run things concurrently.\n',
				name: 'Id',
				tipe: A2($elm$project_metadata_utils$Elm$Type$Type, 'Platform.ProcessId', _List_Nil)
			}
			]),
		binops: _List_Nil,
		comment: '\n\n# Processes\n@docs Id, spawn, sleep, kill\n\n## Future Plans\n\nRight now, this library is pretty sparse. For example, there is no public API\nfor processes to communicate with each other. This is a really important\nability, but it is also something that is extraordinarily easy to get wrong!\n\nI think the trend will be towards an Erlang style of concurrency, where every\nprocess has an event queue that anyone can send messages to. I currently\nthink the API will be extended to be more like this:\n\n    type Id exit msg\n\n    spawn : Task exit a -> Task x (Id exit Never)\n\n    kill : Id exit msg -> Task x ()\n\n    send : Id exit msg -> msg -> Task x ()\n\nA process `Id` will have two type variables to make sure all communication is\nvalid. The `exit` type describes the messages that are produced if the process\nfails because of user code. So if processes are linked and trapping errors,\nthey will need to handle this. The `msg` type just describes what kind of\nmessages this process can be sent by strangers.\n\nWe shall see though! This is just a draft that does not cover nearly everything\nit needs to, so the long-term vision for concurrency in Elm will be rolling out\nslowly as I get more data and experience.\n\nI ask that people bullish on compiling to node.js keep this in mind. I think we\ncan do better than the hopelessly bad concurrency model of node.js, and I hope\nthe Elm community will be supportive of being more ambitious, even if it takes\nlonger. Thats kind of what Elm is all about.\n',
		name: 'Process',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Sometimes you `spawn` a process, but later decide it would be a waste to\nhave it keep running and doing stuff. The `kill` function will force a process\nto bail on whatever task it is running. So if there is an HTTP request in\nflight, it will also abort the request.\n',
				name: 'kill',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Process.Id', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Block progress on the current process for the given number of milliseconds.\nThe JavaScript equivalent of this is [`setTimeout`][setTimeout] which lets you\ndelay work until later.\n\n[setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout\n',
				name: 'sleep',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Run a task in its own light-weight process. In the following example,\n`task1` and `task2` will be interleaved. If `task1` makes a long HTTP request\nor is just taking a long time, we can hop over to `task2` and do some work\nthere.\n\n    spawn task1\n      |> Task.andThen (\\_ -> spawn task2)\n\n**Note:** This creates a relatively restricted kind of `Process` because it\ncannot receive any messages. More flexibility for user-defined processes will\ncome in a later release!\n',
				name: 'spawn',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('y'),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Process.Id', _List_Nil)
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' A `Result` is the result of a computation that may fail. This is a great\nway to manage errors in Elm.\n\n# Type and Constructors\n@docs Result\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Chaining\n@docs andThen\n\n# Handling Errors\n@docs withDefault, toMaybe, fromMaybe, mapError\n',
		name: 'Result',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['error', 'value']),
				comment: ' A `Result` is either `Ok` meaning the computation succeeded, or it is an\n`Err` meaning that there was some failure.\n',
				name: 'Result',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Ok',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('value')
							])),
						_Utils_Tuple2(
						'Err',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('error')
							]))
					])
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Chain together a sequence of computations that may fail. It is helpful\nto see its definition:\n\n    andThen : (a -> Result e b) -> Result e a -> Result e b\n    andThen callback result =\n        case result of\n          Ok value -> callback value\n          Err msg -> Err msg\n\nThis means we only continue with the callback if things are going well. For\nexample, say you need to use (`toInt : String -> Result String Int`) to parse\na month and make sure it is between 1 and 12:\n\n    toValidMonth : Int -> Result String Int\n    toValidMonth month =\n        if month >= 1 && month <= 12\n            then Ok month\n            else Err "months must be between 1 and 12"\n\n    toMonth : String -> Result String Int\n    toMonth rawString =\n        toInt rawString\n          |> andThen toValidMonth\n\n    -- toMonth "4" == Ok 4\n    -- toMonth "9" == Ok 9\n    -- toMonth "a" == Err "cannot parse to an Int"\n    -- toMonth "0" == Err "months must be between 1 and 12"\n\nThis allows us to come out of a chain of operations with quite a specific error\nmessage. It is often best to create a custom type that explicitly represents\nthe exact ways your computation may fail. This way it is easy to handle in your\ncode.\n',
				name: 'andThen',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Convert from a simple `Maybe` to interact with some code that primarily\nuses `Results`.\n\n    parseInt : String -> Maybe Int\n\n    resultParseInt : String -> Result String Int\n    resultParseInt string =\n        fromMaybe ("error parsing string: " ++ toString string) (parseInt string)\n',
				name: 'fromMaybe',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Maybe.Maybe',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Apply a function to a result. If the result is `Ok`, it will be converted.\nIf the result is an `Err`, the same error value will propagate through.\n\n    map sqrt (Ok 4.0)          == Ok 2.0\n    map sqrt (Err "bad input") == Err "bad input"\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('value')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('value')
								]))))
			},
				{
				comment: ' Apply a function if both results are `Ok`. If not, the first `Err` will\npropagate through.\n\n    map2 max (Ok 42)   (Ok 13)   == Ok 42\n    map2 max (Err "x") (Ok 13)   == Err "x"\n    map2 max (Ok 42)   (Err "y") == Err "y"\n    map2 max (Err "x") (Err "y") == Err "x"\n\nThis can be useful if you have two computations that may fail, and you want\nto put them together quickly.\n',
				name: 'map2',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('value'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Result.Result',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Result.Result',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('value')
									])))))
			},
				{
				comment: '',
				name: 'map3',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('value')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Result.Result',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('value')
										]))))))
			},
				{
				comment: '',
				name: 'map4',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									$elm$project_metadata_utils$Elm$Type$Var('value'))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Result.Result',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Result.Result',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Result.Result',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('value')
											])))))))
			},
				{
				comment: '',
				name: 'map5',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('e'),
										$elm$project_metadata_utils$Elm$Type$Var('value')))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Result.Result',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Result.Result',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Result.Result',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('x'),
													$elm$project_metadata_utils$Elm$Type$Var('e')
												])),
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Result.Result',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('x'),
													$elm$project_metadata_utils$Elm$Type$Var('value')
												]))))))))
			},
				{
				comment: ' Transform an `Err` value. For example, say the errors we get have too much\ninformation:\n\n    parseInt : String -> Result ParseError Int\n\n    type alias ParseError =\n        { message : String\n        , code : Int\n        , position : (Int,Int)\n        }\n\n    mapError .message (parseInt "123") == Ok 123\n    mapError .message (parseInt "abc") == Err "char \'a\' is not a number"\n',
				name: 'mapError',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						$elm$project_metadata_utils$Elm$Type$Var('y')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('y'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Convert to a simpler `Maybe` if the actual error message is not needed or\nyou need to interact with some code that primarily uses maybes.\n\n    parseInt : String -> Result ParseError Int\n\n    maybeParseInt : String -> Maybe Int\n    maybeParseInt string =\n        toMaybe (parseInt string)\n',
				name: 'toMaybe',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Result.Result',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' If the result is `Ok` return the value, but if the result is an `Err` then\nreturn a given default value. The following examples try to parse integers.\n\n    Result.withDefault 0 (Ok 123)   == 123\n    Result.withDefault 0 (Err "no") == 0\n',
				name: 'withDefault',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						$elm$project_metadata_utils$Elm$Type$Var('a')))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' A set of unique values. The values can be any comparable type. This\nincludes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists\nof comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Sets\n@docs Set\n\n# Build\n@docs empty, singleton, insert, remove\n\n# Query\n@docs isEmpty, member, size\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n',
		name: 'Set',
		unions: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['t']),
				comment: ' Represents a set of unique values. So `(Set Int)` is a set of integers and\n`(Set String)` is a set of strings.\n',
				name: 'Set',
				tags: _List_Nil
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n',
				name: 'diff',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			},
				{
				comment: ' Create an empty set.\n',
				name: 'empty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Set.Set',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('a')
						]))
			},
				{
				comment: ' Only keep elements that pass the given test.\n\n    import Set exposing (Set)\n\n    numbers : Set Int\n    numbers =\n      Set.fromList [-2,-1,0,1,2]\n\n    positives : Set Int\n    positives =\n      Set.filter (\\x -> x > 0) numbers\n\n    -- positives == Set.fromList [1,2]\n',
				name: 'filter',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			},
				{
				comment: ' Fold over the values in a set, in order from lowest to highest.\n',
				name: 'foldl',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Set.Set',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Fold over the values in a set, in order from highest to lowest.\n',
				name: 'foldr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Set.Set',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									])),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Convert a list into a set, removing any duplicates.\n',
				name: 'fromList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])))
			},
				{
				comment: ' Insert a value into a set.\n',
				name: 'insert',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			},
				{
				comment: ' Get the intersection of two sets. Keeps values that appear in both sets.\n',
				name: 'intersect',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			},
				{
				comment: ' Determine if a set is empty.\n',
				name: 'isEmpty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Map a function onto a set, creating a new set with no duplicates.\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						$elm$project_metadata_utils$Elm$Type$Var('comparable2')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable2')
								]))))
			},
				{
				comment: ' Determine if a value is in a set.\n',
				name: 'member',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Create two new sets. The first contains all the elements that passed the\ngiven test, and the second contains all the elements that did not.\n',
				name: 'partition',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('comparable'),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Set.Set',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('comparable')
										])),
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Set.Set',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('comparable')
										]))
								]))))
			},
				{
				comment: ' Remove a value from a set. If the value is not found, no changes are made.\n',
				name: 'remove',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			},
				{
				comment: ' Create a set with one value.\n',
				name: 'singleton',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('comparable'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])))
			},
				{
				comment: ' Determine the number of elements in a set.\n',
				name: 'size',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Convert a set into a list, sorted from lowest to highest.\n',
				name: 'toList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Get the union of two sets. Keep all values.\n',
				name: 'union',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Set.Set',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('comparable')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Set.Set',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('comparable')
								]))))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' A built-in representation for efficient string manipulation. String literals\nare enclosed in `"double quotes"`. Strings are *not* lists of characters.\n\n# Strings\n@docs String, isEmpty, length, reverse, repeat, replace\n\n# Building and Splitting\n@docs append, concat, split, join, words, lines\n\n# Get Substrings\n@docs slice, left, right, dropLeft, dropRight\n\n# Check for Substrings\n@docs contains, startsWith, endsWith, indexes, indices\n\n# Int Conversions\n@docs toInt, fromInt\n\n# Float Conversions\n@docs toFloat, fromFloat\n\n# Char Conversions\n@docs fromChar, cons, uncons\n\n# List Conversions\n@docs toList, fromList\n\n# Formatting\nCosmetic operations such as padding with extra characters or trimming whitespace.\n\n@docs toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight\n\n# Higher-Order Functions\n@docs map, filter, foldl, foldr, any, all\n',
		name: 'String',
		unions: _List_fromArray(
			[
				{args: _List_Nil, comment: ' A `String` is a chunk of text:\n\n    "Hello!"\n    "How are you?"\n    ""\n\n    -- strings with escape characters\n    "this\\n\\t\\"that\\""\n    "\\u{1F648}\\u{1F649}\\u{1F64A}" -- ""\n\n    -- multiline strings\n    \"\"\"Triple double quotes let you\n    create "multiline strings" which\n    can have unescaped quotes and newlines.\n    \"\"\"\n\nA `String` can represent any sequence of [unicode characters][u]. You can use\nthe unicode escapes from `\\u{0000}` to `\\u{10FFFF}` to represent characters\nby their code point. You can also include the unicode characters directly.\nUsing the escapes can be better if you need one of the many whitespace\ncharacters with different widths.\n\n[u]: https://en.wikipedia.org/wiki/Unicode\n\n**Note:** JavaScript lets you use double quotes and single quotes interchangably.\nThis is not true in Elm. You must use double quotes for a `String`, and you must\nuse single quotes for a [`Char`](Char#Char).\n', name: 'String', tags: _List_Nil}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Determine whether *all* characters pass the test.\n\n    all isDigit "90210" == True\n    all isDigit "R2-D2" == False\n    all isDigit "heart" == False\n',
				name: 'all',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Determine whether *any* characters pass the test.\n\n    any isDigit "90210" == True\n    any isDigit "R2-D2" == True\n    any isDigit "heart" == False\n',
				name: 'any',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Append two strings. You can also use [the `(++)` operator](Basics#++)\nto do this.\n\n    append "butter" "fly" == "butterfly"\n',
				name: 'append',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Concatenate many strings into one.\n\n    concat ["never","the","less"] == "nevertheless"\n',
				name: 'concat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Add a character to the beginning of a string.\n\n    cons \'T\' "he truth is out there" == "The truth is out there"\n',
				name: 'cons',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' See if the second string contains the first one.\n\n    contains "the" "theory" == True\n    contains "hat" "theory" == False\n    contains "THE" "theory" == False\n\n',
				name: 'contains',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Drop *n* characters from the left side of a string.\n\n    dropLeft 2 "The Lone Gunmen" == "e Lone Gunmen"\n',
				name: 'dropLeft',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Drop *n* characters from the right side of a string.\n\n    dropRight 2 "Cigarette Smoking Man" == "Cigarette Smoking M"\n',
				name: 'dropRight',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' See if the second string ends with the first one.\n\n    endsWith "the" "theory" == False\n    endsWith "ory" "theory" == True\n',
				name: 'endsWith',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Keep only the characters that pass the test.\n\n    filter isDigit "R2-D2" == "22"\n',
				name: 'filter',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Reduce a string from the left.\n\n    foldl cons "" "time" == "emit"\n',
				name: 'foldl',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Reduce a string from the right.\n\n    foldr cons "" "time" == "time"\n',
				name: 'foldr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							$elm$project_metadata_utils$Elm$Type$Var('b'))))
			},
				{
				comment: ' Create a string from a given character.\n\n    fromChar \'a\' == "a"\n',
				name: 'fromChar',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Convert a `Float` to a `String`.\n\n    String.fromFloat 123 == "123"\n    String.fromFloat -42 == "-42"\n    String.fromFloat 3.9 == "3.9"\n\nCheck out [`Debug.toString`](Debug#toString) to convert *any* value to a string\nfor debugging purposes.\n',
				name: 'fromFloat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Convert an `Int` to a `String`.\n\n    String.fromInt 123 == "123"\n    String.fromInt -42 == "-42"\n\nCheck out [`Debug.toString`](Debug#toString) to convert *any* value to a string\nfor debugging purposes.\n',
				name: 'fromInt',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Convert a list of characters into a String. Can be useful if you\nwant to create a string primarily by consing, perhaps for decoding\nsomething.\n\n    fromList [\'a\',\'b\',\'c\'] == "abc"\n    fromList [\'\',\'\',\'\'] == ""\n',
				name: 'fromList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil)
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Get all of the indexes for a substring in another string.\n\n    indexes "i" "Mississippi"   == [1,4,7,10]\n    indexes "ss" "Mississippi"  == [2,5]\n    indexes "needle" "haystack" == []\n',
				name: 'indexes',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))))
			},
				{
				comment: ' Alias for `indexes`. ',
				name: 'indices',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))))
			},
				{
				comment: ' Determine if a string is empty.\n\n    isEmpty "" == True\n    isEmpty "the world" == False\n',
				name: 'isEmpty',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))
			},
				{
				comment: ' Put many strings together with a given separator.\n\n    join "a" ["H","w","ii","n"]        == "Hawaiian"\n    join " " ["cat","dog","cow"]       == "cat dog cow"\n    join "/" ["home","evan","Desktop"] == "home/evan/Desktop"\n',
				name: 'join',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
								])),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Take *n* characters from the left side of a string.\n\n    left 2 "Mulder" == "Mu"\n',
				name: 'left',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Get the length of a string.\n\n    length "innumerable" == 11\n    length "" == 0\n\n',
				name: 'length',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil))
			},
				{
				comment: ' Break a string into lines, splitting on newlines.\n\n    lines "How are you?\\nGood?" == ["How are you?", "Good?"]\n',
				name: 'lines',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			},
				{
				comment: ' Transform every character in a string\n\n    map (\\c -> if c == \'/\' then \'.\' else c) "a/b/c" == "a.b.c"\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Pad a string on both sides until it has a given length.\n\n    pad 5 \' \' "1"   == "  1  "\n    pad 5 \' \' "11"  == "  11 "\n    pad 5 \' \' "121" == " 121 "\n',
				name: 'pad',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))))
			},
				{
				comment: ' Pad a string on the left until it has a given length.\n\n    padLeft 5 \'.\' "1"   == "....1"\n    padLeft 5 \'.\' "11"  == "...11"\n    padLeft 5 \'.\' "121" == "..121"\n',
				name: 'padLeft',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))))
			},
				{
				comment: ' Pad a string on the right until it has a given length.\n\n    padRight 5 \'.\' "1"   == "1...."\n    padRight 5 \'.\' "11"  == "11..."\n    padRight 5 \'.\' "121" == "121.."\n',
				name: 'padRight',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))))
			},
				{
				comment: ' Repeat a string *n* times.\n\n    repeat 3 "ha" == "hahaha"\n',
				name: 'repeat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Replace all occurrences of some substring.\n\n    replace "." "-" "Json.Decode.succeed" == "Json-Decode-succeed"\n    replace "," "/" "a,b,c,d,e"           == "a/b/c/d/e"\n\n**Note:** If you need more advanced replacements, check out the\n[`elm/parser`][parser] or [`elm/regex`][regex] package.\n\n[parser]: /packages/elm/parser/latest\n[regex]: /packages/elm/regex/latest\n',
				name: 'replace',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))))
			},
				{
				comment: ' Reverse a string.\n\n    reverse "stressed" == "desserts"\n',
				name: 'reverse',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Take *n* characters from the right side of a string.\n\n    right 2 "Scully" == "ly"\n',
				name: 'right',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)))
			},
				{
				comment: ' Take a substring given a start and end index. Negative indexes\nare taken starting from the *end* of the list.\n\n    slice  7  9 "snakes on a plane!" == "on"\n    slice  0  6 "snakes on a plane!" == "snakes"\n    slice  0 -7 "snakes on a plane!" == "snakes on a"\n    slice -6 -1 "snakes on a plane!" == "plane"\n',
				name: 'slice',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))))
			},
				{
				comment: ' Split a string using a given separator.\n\n    split "," "cat,dog,cow"        == ["cat","dog","cow"]\n    split "/" "home/evan/Desktop/" == ["home","evan","Desktop", ""]\n\n',
				name: 'split',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'List.List',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
								]))))
			},
				{
				comment: ' See if the second string starts with the first one.\n\n    startsWith "the" "theory" == True\n    startsWith "ory" "theory" == False\n',
				name: 'startsWith',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)))
			},
				{
				comment: ' Try to convert a string into a float, failing on improperly formatted strings.\n\n    String.toFloat "123" == Just 123.0\n    String.toFloat "-42" == Just -42.0\n    String.toFloat "3.1" == Just 3.1\n    String.toFloat "31a" == Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String.toFloat "42.5") == 42.5\n    Maybe.withDefault 0 (String.toFloat "cats") == 0\n',
				name: 'toFloat',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
							])))
			},
				{
				comment: ' Try to convert a string into an int, failing on improperly formatted strings.\n\n    String.toInt "123" == Just 123\n    String.toInt "-42" == Just -42\n    String.toInt "3.1" == Nothing\n    String.toInt "31a" == Nothing\n\nIf you are extracting a number from some raw user input, you will typically\nwant to use [`Maybe.withDefault`](Maybe#withDefault) to handle bad data:\n\n    Maybe.withDefault 0 (String.toInt "42") == 42\n    Maybe.withDefault 0 (String.toInt "ab") == 0\n',
				name: 'toInt',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
							])))
			},
				{
				comment: ' Convert a string to a list of characters.\n\n    toList "abc" == [\'a\',\'b\',\'c\']\n    toList "" == [\'\',\'\',\'\']\n',
				name: 'toList',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil)
							])))
			},
				{
				comment: ' Convert a string to all lower case. Useful for case-insensitive comparisons.\n\n    toLower "X-FILES" == "x-files"\n',
				name: 'toLower',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Convert a string to all upper case. Useful for case-insensitive comparisons\nand VIRTUAL YELLING.\n\n    toUpper "skinner" == "SKINNER"\n',
				name: 'toUpper',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Get rid of whitespace on both sides of a string.\n\n    trim "  hats  \\n" == "hats"\n',
				name: 'trim',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Get rid of whitespace on the left of a string.\n\n    trimLeft "  hats  \\n" == "hats  \\n"\n',
				name: 'trimLeft',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Get rid of whitespace on the right of a string.\n\n    trimRight "  hats  \\n" == "  hats"\n',
				name: 'trimRight',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Split a non-empty string into its head and tail. This lets you\npattern match on strings exactly as you would with lists.\n\n    uncons "abc" == Just (\'a\',"bc")\n    uncons ""    == Nothing\n',
				name: 'uncons',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Maybe.Maybe',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
										A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
									]))
							])))
			},
				{
				comment: ' Break a string into words, splitting on chunks of whitespace.\n\n    words "How are \\t you? \\n Good?" == ["How","are","you?","Good?"]\n',
				name: 'words',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			}
			])
	},
		{
		aliases: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['x', 'a']),
				comment: ' Here are some common tasks:\n\n- [`now : Task x Posix`][now]\n- [`focus : String -> Task Error ()`][focus]\n- [`sleep : Float -> Task x ()`][sleep]\n\n[now]: /packages/elm/time/latest/Time#now\n[focus]: /packages/elm/browser/latest/Browser-Dom#focus\n[sleep]: /packages/elm/core/latest/Process#sleep\n\nIn each case we have a `Task` that will resolve successfully with an `a` value\nor unsuccessfully with an `x` value. So `Browser.Dom.focus` we may fail with an\n`Error` if the given ID does not exist. Whereas `Time.now` never fails so\nI cannot be more specific than `x`. No such value will ever exist! Instead it\nalways succeeds with the current POSIX time.\n\nMore generally a task is a _description_ of what you need to do. Like a todo\nlist. Or like a grocery list. Or like GitHub issues. So saying "the task is\nto tell me the current POSIX time" does not complete the task! You need\n[`perform`](#perform) tasks or [`attempt`](#attempt) tasks.\n',
				name: 'Task',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Platform.Task',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							$elm$project_metadata_utils$Elm$Type$Var('a')
						]))
			}
			]),
		binops: _List_Nil,
		comment: ' Tasks make it easy to describe asynchronous operations that may fail, like\nHTTP requests or writing to a database.\n\n# Tasks\n@docs Task, perform, attempt\n\n# Chains\n@docs andThen, succeed, fail, sequence\n\n# Maps\n@docs map, map2, map3, map4, map5\n\n# Errors\n@docs onError, mapError\n\n',
		name: 'Task',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Chain together a task and a callback. The first task will run, and if it is\nsuccessful, you give the result to the callback resulting in another task. This\ntask then gets run. We could use this to make a task that resolves an hour from\nnow:\n\n    import Time -- elm install elm/time\n    import Process\n\n    timeInOneHour : Task x Time.Posix\n    timeInOneHour =\n      Process.sleep (60 * 60 * 1000)\n        |> andThen (\\_ -> Time.now)\n\nFirst the process sleeps for an hour **and then** it tells us what time it is.\n',
				name: 'andThen',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' This is very similar to [`perform`](#perform) except it can handle failures!\nSo we could _attempt_ to focus on a certain DOM node like this:\n\n    import Browser.Dom  -- elm install elm/browser\n    import Task\n\n    type Msg\n      = Click\n      | Search String\n      | Focus (Result Browser.DomError ())\n\n    focus : Cmd Msg\n    focus =\n      Task.attempt Focus (Browser.Dom.focus "my-app-search-box")\n\nSo the task is "focus on this DOM node" and we are turning it into the command\n"Hey Elm, attempt to focus on this DOM node and give me a `Msg` about whether\nyou succeeded or failed."\n\n**Note:** Definitely work through [`guide.elm-lang.org`][guide] to get a\nfeeling for how commands fit into The Elm Architecture.\n\n[guide]: https://guide.elm-lang.org/\n',
				name: 'attempt',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						$elm$project_metadata_utils$Elm$Type$Var('msg')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Cmd.Cmd',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('msg')
								]))))
			},
				{
				comment: ' A task that fails immediately when run. Like with `succeed`, this can be\nused with `andThen` to check on the outcome of another task.\n\n    type Error = NotFound\n\n    notFound : Task Error a\n    notFound =\n      fail NotFound\n',
				name: 'fail',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Transform a task. Maybe you want to use [`elm/time`][time] to figure\nout what time it will be in one hour:\n\n    import Task exposing (Task)\n    import Time -- elm install elm/time\n\n    timeInOneHour : Task x Time.Posix\n    timeInOneHour =\n      Task.map addAnHour Time.now\n\n    addAnHour : Time.Posix -> Time.Posix\n    addAnHour time =\n      Time.millisToPosix (Time.posixToMillis time + 60 * 60 * 1000)\n\n[time]: /packages/elm/time/latest/\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Put the results of two tasks together. For example, if we wanted to know\nthe current month, we could use [`elm/time`][time] to ask:\n\n    import Task exposing (Task)\n    import Time -- elm install elm/time\n\n    getMonth : Task x Int\n    getMonth =\n      Task.map2 Time.toMonth Time.here Time.now\n\n**Note:** Say we were doing HTTP requests instead. `map2` does each task in\norder, so it would try the first request and only continue after it succeeds.\nIf it fails, the whole thing fails!\n\n[time]: /packages/elm/time/latest/\n',
				name: 'map2',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('result'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('result')
									])))))
			},
				{
				comment: '',
				name: 'map3',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('result')))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Task.Task',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Task.Task',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('result')
										]))))))
			},
				{
				comment: '',
				name: 'map4',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									$elm$project_metadata_utils$Elm$Type$Var('result'))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Task.Task',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Task.Task',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Task.Task',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('result')
											])))))))
			},
				{
				comment: '',
				name: 'map5',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									$elm$project_metadata_utils$Elm$Type$Var('d'),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										$elm$project_metadata_utils$Elm$Type$Var('e'),
										$elm$project_metadata_utils$Elm$Type$Var('result')))))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Task.Task',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('c')
										])),
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Task.Task',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('x'),
												$elm$project_metadata_utils$Elm$Type$Var('d')
											])),
									A2(
										$elm$project_metadata_utils$Elm$Type$Lambda,
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Task.Task',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('x'),
													$elm$project_metadata_utils$Elm$Type$Var('e')
												])),
										A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Task.Task',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('x'),
													$elm$project_metadata_utils$Elm$Type$Var('result')
												]))))))))
			},
				{
				comment: ' Transform the error value. This can be useful if you need a bunch of error\ntypes to match up.\n\n    type Error\n      = Http Http.Error\n      | WebGL WebGL.Error\n\n    getResources : Task Error Resource\n    getResources =\n      sequence\n        [ mapError Http serverTask\n        , mapError WebGL textureTask\n        ]\n',
				name: 'mapError',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						$elm$project_metadata_utils$Elm$Type$Var('y')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('y'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Recover from a failure in a task. If the given task fails, we use the\ncallback to recover.\n\n    fail "file not found"\n      |> onError (\\msg -> succeed 42)\n      -- succeed 42\n\n    succeed 9\n      |> onError (\\msg -> succeed 42)\n      -- succeed 9\n',
				name: 'onError',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('y'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('y'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Like I was saying in the [`Task`](#Task) documentation, just having a\n`Task` does not mean it is done. We must command Elm to `perform` the task:\n\n    import Time  -- elm install elm/time\n    import Task\n\n    type Msg\n      = Click\n      | Search String\n      | NewTime Time.Posix\n\n    getNewTime : Cmd Msg\n    getNewTime =\n      Task.perform NewTime Time.now\n\nIf you have worked through [`guide.elm-lang.org`][guide] (highly recommended!)\nyou will recognize `Cmd` from the section on The Elm Architecture. So we have\nchanged a task like "make delicious lasagna" into a command like "Hey Elm, make\ndelicious lasagna and give it to my `update` function as a `Msg` value."\n\n[guide]: https://guide.elm-lang.org/\n',
				name: 'perform',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('msg')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Task.Task',
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Never', _List_Nil),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Platform.Cmd.Cmd',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('msg')
								]))))
			},
				{
				comment: ' Start with a list of tasks, and turn them into a single task that returns a\nlist. The tasks will be run in order one-by-one and if any task fails the whole\nsequence fails.\n\n    sequence [ succeed 1, succeed 2 ] == succeed [ 1, 2 ]\n\n',
				name: 'sequence',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Task.Task',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])))
			},
				{
				comment: ' A task that succeeds immediately when run. It is usually used with\n[`andThen`](#andThen). You can use it like `map` if you want:\n\n    import Time -- elm install elm/time\n\n    timeInMillis : Task x Int\n    timeInMillis =\n      Time.now\n        |> andThen (\\t -> succeed (Time.posixToMillis t))\n\n',
				name: 'succeed',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Task.Task',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			}
			])
	},
		{
		aliases: _List_Nil,
		binops: _List_Nil,
		comment: ' Elm has built-in syntax for tuples, so you can define 2D points like this:\n\n    origin : (Float, Float)\n    origin =\n      (0, 0)\n\n    position : (Float, Float)\n    position =\n      (3, 4)\n\nThis module is a bunch of helpers for working with 2-tuples.\n\n**Note 1:** For more complex data, it is best to switch to records. So instead\nof representing a 3D point as `(3,4,5)` and not having any helper functions,\nrepresent it as `{ x = 3, y = 4, z = 5 }` and use all the built-in record\nsyntax!\n\n**Note 2:** If your record contains a bunch of `Bool` and `Maybe` values,\nyou may want to upgrade to union types. Check out [Jols post][ut] for more\ninfo on this. (Picking appropriate data structures is super important in Elm!)\n\n[ut]: https://robots.thoughtbot.com/modeling-with-union-types\n\n# Create\n@docs pair\n\n# Access\n@docs first, second\n\n# Map\n@docs mapFirst, mapSecond, mapBoth\n\n',
		name: 'Tuple',
		unions: _List_Nil,
		values: _List_fromArray(
			[
				{
				comment: ' Extract the first value from a tuple.\n\n    first (3, 4) == 3\n    first ("john", "doe") == "john"\n',
				name: 'first',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								$elm$project_metadata_utils$Elm$Type$Var('b')
							])),
					$elm$project_metadata_utils$Elm$Type$Var('a'))
			},
				{
				comment: ' Transform both parts of a tuple.\n\n    import String\n\n    mapBoth String.reverse sqrt  ("stressed", 16) == ("desserts", 4)\n    mapBoth String.length negate ("stressed", 16) == (8, -16)\n',
				name: 'mapBoth',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('x')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('b'),
							$elm$project_metadata_utils$Elm$Type$Var('y')),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a'),
										$elm$project_metadata_utils$Elm$Type$Var('b')
									])),
							$elm$project_metadata_utils$Elm$Type$Tuple(
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('y')
									])))))
			},
				{
				comment: ' Transform the first value in a tuple.\n\n    import String\n\n    mapFirst String.reverse ("stressed", 16) == ("desserts", 16)\n    mapFirst String.length  ("stressed", 16) == (8, 16)\n',
				name: 'mapFirst',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('x')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								])),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Transform the second value in a tuple.\n\n    mapSecond sqrt   ("stressed", 16) == ("stressed", 4)\n    mapSecond negate ("stressed", 16) == ("stressed", -16)\n',
				name: 'mapSecond',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						$elm$project_metadata_utils$Elm$Type$Var('y')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								])),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a'),
									$elm$project_metadata_utils$Elm$Type$Var('y')
								]))))
			},
				{
				comment: ' Create a 2-tuple.\n\n    -- pair 3 4 == (3, 4)\n\n    zip : List a -> List b -> List (a, b)\n    zip xs ys =\n      List.map2 Tuple.pair xs ys\n',
				name: 'pair',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('b'),
						$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Extract the second value from a tuple.\n\n    second (3, 4) == 4\n    second ("john", "doe") == "doe"\n',
				name: 'second',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Tuple(
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								$elm$project_metadata_utils$Elm$Type$Var('b')
							])),
					$elm$project_metadata_utils$Elm$Type$Var('b'))
			}
			])
	}
	]);
var $elm$project_metadata_utils$Elm$License$bsd3 = A2($elm$project_metadata_utils$Elm$License$License, 'BSD-3-Clause', 'BSD 3-clause \"New\" or \"Revised\" License');
var $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$constraint = function (rawConstraint) {
	var _v0 = $elm$project_metadata_utils$Elm$Constraint$fromString(rawConstraint);
	if (_v0.$ === 'Just') {
		var constr = _v0.a;
		return constr;
	} else {
		return $elm$core$Basics$identity(
			$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$constraint(rawConstraint));
	}
};
var $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName = function (rawModuleName) {
	var _v0 = $elm$project_metadata_utils$Elm$Module$fromString(rawModuleName);
	if (_v0.$ === 'Just') {
		var name = _v0.a;
		return name;
	} else {
		return $elm$core$Basics$identity(
			$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName(rawModuleName));
	}
};
var $elm$project_metadata_utils$Elm$Version$one = A3($elm$project_metadata_utils$Elm$Version$Version, 1, 0, 0);
var $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$packageName = function (rawName) {
	var _v0 = $elm$project_metadata_utils$Elm$Package$fromString(rawName);
	if (_v0.$ === 'Just') {
		var name = _v0.a;
		return name;
	} else {
		return $elm$core$Basics$identity(
			$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$packageName(rawName));
	}
};
var $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$elmJson = $elm$project_metadata_utils$Elm$Project$Package(
	{
		deps: _List_Nil,
		elm: $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$constraint('0.19.0 <= v < 0.20.0'),
		exposed: $elm$project_metadata_utils$Elm$Project$ExposedDict(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'Primitives',
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Basics'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('String'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Char'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Bitwise'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Tuple')
						])),
					_Utils_Tuple2(
					'Collections',
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('List'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Dict'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Set'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Array')
						])),
					_Utils_Tuple2(
					'Error Handling',
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Maybe'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Result')
						])),
					_Utils_Tuple2(
					'Debug',
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Debug')
						])),
					_Utils_Tuple2(
					'Effects',
					_List_fromArray(
						[
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Platform.Cmd'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Platform.Sub'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Platform'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Process'),
							$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Task')
						]))
				])),
		license: A2(
			$elm$core$Maybe$withDefault,
			$elm$project_metadata_utils$Elm$License$bsd3,
			$elm$project_metadata_utils$Elm$License$fromString('BSD-3-Clause')),
		name: $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$packageName('elm/core'),
		summary: 'Elm\'s standard libraries',
		testDeps: _List_Nil,
		version: A2(
			$elm$core$Maybe$withDefault,
			$elm$project_metadata_utils$Elm$Version$one,
			$elm$project_metadata_utils$Elm$Version$fromString('1.0.5'))
	});
var $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$dependency = A3($jfmengels$elm_review$Review$Project$Dependency$create, 'elm/core', $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$elmJson, $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$dependencyModules);
var $jfmengels$elm_review$Review$Test$Dependencies$elmCore = $jfmengels$elm_review$Review$Test$Dependencies$ElmCore$dependency;
var $jfmengels$elm_review$Review$Project$ProjectCache$empty = {dependenciesModules: $elm$core$Maybe$Nothing, lookupTables: $elm$core$Dict$empty, modules: $elm$core$Dict$empty};
var $jfmengels$elm_review$Review$Project$new = $jfmengels$elm_review$Review$Project$Internal$Project(
	{
		cache: $jfmengels$elm_review$Review$Project$ProjectCache$empty,
		dependencies: $elm$core$Dict$empty,
		elmJson: $elm$core$Maybe$Nothing,
		moduleGraph: $elm$core$Maybe$Nothing,
		modules: $elm$core$Dict$empty,
		modulesThatFailedToParse: _List_Nil,
		readme: $elm$core$Maybe$Nothing,
		sourceDirectories: _List_fromArray(
			['src/'])
	});
var $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore = A2($jfmengels$elm_review$Review$Project$addDependency, $jfmengels$elm_review$Review$Test$Dependencies$elmCore, $jfmengels$elm_review$Review$Project$new);
var $jfmengels$elm_review$Review$Test$ConfigurationError = function (a) {
	return {$: 'ConfigurationError', a: a};
};
var $jfmengels$elm_review$Review$Test$AttemptReRun = F2(
	function (a, b) {
		return {$: 'AttemptReRun', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Test$FailedRun = function (a) {
	return {$: 'FailedRun', a: a};
};
var $jfmengels$elm_review$Review$Test$RuleCanProvideFixes = function (a) {
	return {$: 'RuleCanProvideFixes', a: a};
};
var $jfmengels$elm_review$Review$Test$SuccessfulRun = F2(
	function (a, b) {
		return {$: 'SuccessfulRun', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Project$addModuleToProject = F2(
	function (module_, _v0) {
		var project = _v0.a;
		return $jfmengels$elm_review$Review$Project$Internal$Project(
			_Utils_update(
				project,
				{
					modules: A3(
						$elm$core$Dict$insert,
						module_.path,
						_Utils_update(
							module_,
							{
								ast: $jfmengels$elm_review$Review$Project$Internal$sanitizeModule(module_.ast)
							}),
						project.modules)
				}));
	});
var $jfmengels$elm_review$Review$Project$forceModuleGraphRecomputation = function (_v0) {
	var project = _v0.a;
	return $jfmengels$elm_review$Review$Project$Internal$Project(
		_Utils_update(
			project,
			{moduleGraph: $elm$core$Maybe$Nothing}));
};
var $jfmengels$elm_review$Review$Project$removeFileFromFilesThatFailedToParse = F2(
	function (path, _v0) {
		var project = _v0.a;
		return $jfmengels$elm_review$Review$Project$Internal$Project(
			_Utils_update(
				project,
				{
					modulesThatFailedToParse: A2(
						$elm$core$List$filter,
						function (file) {
							return !_Utils_eq(file.path, path);
						},
						project.modulesThatFailedToParse)
				}));
	});
var $jfmengels$elm_review$Review$Project$Internal$sourceDirectories = function (_v0) {
	var project = _v0.a;
	return project.sourceDirectories;
};
var $jfmengels$elm_review$Review$Project$addParsedModule = F2(
	function (_v0, project) {
		var path = _v0.path;
		var source = _v0.source;
		var ast = _v0.ast;
		var osAgnosticPath = $jfmengels$elm_review$Path$makeOSAgnostic(path);
		return $jfmengels$elm_review$Review$Project$forceModuleGraphRecomputation(
			A2(
				$jfmengels$elm_review$Review$Project$addModuleToProject,
				{
					ast: ast,
					contentHash: $jfmengels$elm_review$Review$Cache$ContentHash$hash(source),
					isInSourceDirectories: A2(
						$elm$core$List$any,
						function (dir) {
							return A2(
								$elm$core$String$startsWith,
								$jfmengels$elm_review$Path$makeOSAgnostic(dir),
								osAgnosticPath);
						},
						$jfmengels$elm_review$Review$Project$Internal$sourceDirectories(project)),
					path: path,
					source: source
				},
				A2($jfmengels$elm_review$Review$Project$removeFileFromFilesThatFailedToParse, path, project)));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$duplicateModuleName = function (moduleName) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'DUPLICATE MODULE NAMES',
		'I found several modules named `' + (A2($elm$core$String$join, '.', moduleName) + '` in the test source codes.\n\nI expect all modules to be able to exist together in the same project,\nbut having several modules with the same name is not allowed by the Elm\ncompiler.\n\nPlease rename the modules so that they all have different names.'));
};
var $jfmengels$elm_review$Review$Test$hasOneElement = function (list) {
	if (list.b && (!list.b.b)) {
		return true;
	} else {
		return false;
	}
};
var $elm$core$String$indexes = _String_indexes;
var $jfmengels$elm_review$Vendor$ListExtra$last = function (items) {
	last:
	while (true) {
		if (!items.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			if (!items.b.b) {
				var x = items.a;
				return $elm$core$Maybe$Just(x);
			} else {
				var rest = items.b;
				var $temp$items = rest;
				items = $temp$items;
				continue last;
			}
		}
	}
};
var $jfmengels$elm_review$Review$Test$FailureMessage$positionAsRange = F3(
	function (sourceCode, under, position) {
		var linesInUnder = $elm$core$String$lines(under);
		var linesBeforeAndIncludingPosition = $elm$core$String$lines(
			A3($elm$core$String$slice, 0, position, sourceCode));
		var startColumn = 1 + $elm$core$String$length(
			A2(
				$elm$core$Maybe$withDefault,
				'',
				$jfmengels$elm_review$Vendor$ListExtra$last(linesBeforeAndIncludingPosition)));
		var startRow = $elm$core$List$length(linesBeforeAndIncludingPosition);
		var endRow = (startRow + $elm$core$List$length(linesInUnder)) - 1;
		var endColumn = _Utils_eq(startRow, endRow) ? (startColumn + $elm$core$String$length(under)) : (1 + $elm$core$String$length(
			A2(
				$elm$core$Maybe$withDefault,
				'',
				$jfmengels$elm_review$Vendor$ListExtra$last(linesInUnder))));
		return {
			end: {column: endColumn, row: endRow},
			start: {column: startColumn, row: startRow}
		};
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$listOccurrencesAsLocations = F3(
	function (sourceCode, under, occurrences) {
		return A2(
			$elm$core$String$join,
			'\n',
			A2(
				$elm$core$List$map,
				function (occurrence) {
					return '  - ' + $jfmengels$elm_review$Review$Test$FailureMessage$rangeAsString(
						A3($jfmengels$elm_review$Review$Test$FailureMessage$positionAsRange, sourceCode, under, occurrence));
				},
				occurrences));
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$locationIsAmbiguousInSourceCode = F4(
	function (sourceCode, error, under, occurrencesInSourceCode) {
		return A2(
			$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
			'AMBIGUOUS ERROR LOCATION',
			'Your test passes, but where the message appears is ambiguous.\n\nYou are looking for the following error message:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
				$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\nand expecting to see it under:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatSourceCode(under) + ('\n\nI found ' + ($elm$core$String$fromInt(
				$elm$core$List$length(occurrencesInSourceCode)) + (' locations where that code appeared. Please use\n`Review.Test.atExactly` to make the part you were targeting unambiguous.\n\nTip: I found them at:\n' + A3($jfmengels$elm_review$Review$Test$FailureMessage$listOccurrencesAsLocations, sourceCode, under, occurrencesInSourceCode))))))));
	});
var $jfmengels$elm_review$Review$Test$checkIfLocationIsAmbiguousInSourceCode = F3(
	function (sourceCode, error_, under) {
		var occurrencesInSourceCode = A2($elm$core$String$indexes, under, sourceCode);
		return A2(
			$elm_explorations$test$Expect$onFail,
			A4($jfmengels$elm_review$Review$Test$FailureMessage$locationIsAmbiguousInSourceCode, sourceCode, error_, under, occurrencesInSourceCode),
			A2(
				$elm_explorations$test$Expect$equal,
				true,
				$jfmengels$elm_review$Review$Test$hasOneElement(occurrencesInSourceCode)));
	});
var $elm$core$Elm$JsArray$appendN = _JsArray_appendN;
var $elm$core$Elm$JsArray$slice = _JsArray_slice;
var $elm$core$Array$appendHelpBuilder = F2(
	function (tail, builder) {
		var tailLen = $elm$core$Elm$JsArray$length(tail);
		var notAppended = ($elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(builder.tail)) - tailLen;
		var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, builder.tail, tail);
		return (notAppended < 0) ? {
			nodeList: A2(
				$elm$core$List$cons,
				$elm$core$Array$Leaf(appended),
				builder.nodeList),
			nodeListSize: builder.nodeListSize + 1,
			tail: A3($elm$core$Elm$JsArray$slice, notAppended, tailLen, tail)
		} : ((!notAppended) ? {
			nodeList: A2(
				$elm$core$List$cons,
				$elm$core$Array$Leaf(appended),
				builder.nodeList),
			nodeListSize: builder.nodeListSize + 1,
			tail: $elm$core$Elm$JsArray$empty
		} : {nodeList: builder.nodeList, nodeListSize: builder.nodeListSize, tail: appended});
	});
var $elm$core$Array$sliceLeft = F2(
	function (from, array) {
		var len = array.a;
		var tree = array.c;
		var tail = array.d;
		if (!from) {
			return array;
		} else {
			if (_Utils_cmp(
				from,
				$elm$core$Array$tailIndex(len)) > -1) {
				return A4(
					$elm$core$Array$Array_elm_builtin,
					len - from,
					$elm$core$Array$shiftStep,
					$elm$core$Elm$JsArray$empty,
					A3(
						$elm$core$Elm$JsArray$slice,
						from - $elm$core$Array$tailIndex(len),
						$elm$core$Elm$JsArray$length(tail),
						tail));
			} else {
				var skipNodes = (from / $elm$core$Array$branchFactor) | 0;
				var helper = F2(
					function (node, acc) {
						if (node.$ === 'SubTree') {
							var subTree = node.a;
							return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
						} else {
							var leaf = node.a;
							return A2($elm$core$List$cons, leaf, acc);
						}
					});
				var leafNodes = A3(
					$elm$core$Elm$JsArray$foldr,
					helper,
					_List_fromArray(
						[tail]),
					tree);
				var nodesToInsert = A2($elm$core$List$drop, skipNodes, leafNodes);
				if (!nodesToInsert.b) {
					return $elm$core$Array$empty;
				} else {
					var head = nodesToInsert.a;
					var rest = nodesToInsert.b;
					var firstSlice = from - (skipNodes * $elm$core$Array$branchFactor);
					var initialBuilder = {
						nodeList: _List_Nil,
						nodeListSize: 0,
						tail: A3(
							$elm$core$Elm$JsArray$slice,
							firstSlice,
							$elm$core$Elm$JsArray$length(head),
							head)
					};
					return A2(
						$elm$core$Array$builderToArray,
						true,
						A3($elm$core$List$foldl, $elm$core$Array$appendHelpBuilder, initialBuilder, rest));
				}
			}
		}
	});
var $elm$core$Array$fetchNewTail = F4(
	function (shift, end, treeEnd, tree) {
		fetchNewTail:
		while (true) {
			var pos = $elm$core$Array$bitMask & (treeEnd >>> shift);
			var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
			if (_v0.$ === 'SubTree') {
				var sub = _v0.a;
				var $temp$shift = shift - $elm$core$Array$shiftStep,
					$temp$end = end,
					$temp$treeEnd = treeEnd,
					$temp$tree = sub;
				shift = $temp$shift;
				end = $temp$end;
				treeEnd = $temp$treeEnd;
				tree = $temp$tree;
				continue fetchNewTail;
			} else {
				var values = _v0.a;
				return A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, values);
			}
		}
	});
var $elm$core$Array$hoistTree = F3(
	function (oldShift, newShift, tree) {
		hoistTree:
		while (true) {
			if ((_Utils_cmp(oldShift, newShift) < 1) || (!$elm$core$Elm$JsArray$length(tree))) {
				return tree;
			} else {
				var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, 0, tree);
				if (_v0.$ === 'SubTree') {
					var sub = _v0.a;
					var $temp$oldShift = oldShift - $elm$core$Array$shiftStep,
						$temp$newShift = newShift,
						$temp$tree = sub;
					oldShift = $temp$oldShift;
					newShift = $temp$newShift;
					tree = $temp$tree;
					continue hoistTree;
				} else {
					return tree;
				}
			}
		}
	});
var $elm$core$Array$sliceTree = F3(
	function (shift, endIdx, tree) {
		var lastPos = $elm$core$Array$bitMask & (endIdx >>> shift);
		var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, lastPos, tree);
		if (_v0.$ === 'SubTree') {
			var sub = _v0.a;
			var newSub = A3($elm$core$Array$sliceTree, shift - $elm$core$Array$shiftStep, endIdx, sub);
			return (!$elm$core$Elm$JsArray$length(newSub)) ? A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree) : A3(
				$elm$core$Elm$JsArray$unsafeSet,
				lastPos,
				$elm$core$Array$SubTree(newSub),
				A3($elm$core$Elm$JsArray$slice, 0, lastPos + 1, tree));
		} else {
			return A3($elm$core$Elm$JsArray$slice, 0, lastPos, tree);
		}
	});
var $elm$core$Array$sliceRight = F2(
	function (end, array) {
		var len = array.a;
		var startShift = array.b;
		var tree = array.c;
		var tail = array.d;
		if (_Utils_eq(end, len)) {
			return array;
		} else {
			if (_Utils_cmp(
				end,
				$elm$core$Array$tailIndex(len)) > -1) {
				return A4(
					$elm$core$Array$Array_elm_builtin,
					end,
					startShift,
					tree,
					A3($elm$core$Elm$JsArray$slice, 0, $elm$core$Array$bitMask & end, tail));
			} else {
				var endIdx = $elm$core$Array$tailIndex(end);
				var depth = $elm$core$Basics$floor(
					A2(
						$elm$core$Basics$logBase,
						$elm$core$Array$branchFactor,
						A2($elm$core$Basics$max, 1, endIdx - 1)));
				var newShift = A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep);
				return A4(
					$elm$core$Array$Array_elm_builtin,
					end,
					newShift,
					A3(
						$elm$core$Array$hoistTree,
						startShift,
						newShift,
						A3($elm$core$Array$sliceTree, startShift, endIdx, tree)),
					A4($elm$core$Array$fetchNewTail, startShift, end, endIdx, tree));
			}
		}
	});
var $elm$core$Array$translateIndex = F2(
	function (index, _v0) {
		var len = _v0.a;
		var posIndex = (index < 0) ? (len + index) : index;
		return (posIndex < 0) ? 0 : ((_Utils_cmp(posIndex, len) > 0) ? len : posIndex);
	});
var $elm$core$Array$slice = F3(
	function (from, to, array) {
		var correctTo = A2($elm$core$Array$translateIndex, to, array);
		var correctFrom = A2($elm$core$Array$translateIndex, from, array);
		return (_Utils_cmp(correctFrom, correctTo) > 0) ? $elm$core$Array$empty : A2(
			$elm$core$Array$sliceLeft,
			correctFrom,
			A2($elm$core$Array$sliceRight, correctTo, array));
	});
var $jfmengels$elm_review$Unicode$slice = F3(
	function (start, end, string) {
		return $elm$core$String$fromList(
			A2(
				$elm$core$List$take,
				end - start,
				A2(
					$elm$core$List$drop,
					start,
					$elm$core$String$toList(string))));
	});
var $jfmengels$elm_review$Review$Test$getCodeAtLocationInSourceCode = function (sourceCode) {
	var lines = $elm$core$Array$fromList(
		$elm$core$String$lines(sourceCode));
	return function (_v0) {
		var start = _v0.start;
		var end = _v0.end;
		if (_Utils_eq(start.row, end.row)) {
			return A2(
				$elm$core$Maybe$map,
				A2($jfmengels$elm_review$Unicode$slice, start.column - 1, end.column - 1),
				A2($elm$core$Array$get, start.row - 1, lines));
		} else {
			var lastLine = function () {
				var _v2 = A2($elm$core$Array$get, end.row - 1, lines);
				if (_v2.$ === 'Just') {
					var str = _v2.a;
					return A2($jfmengels$elm_review$Unicode$left, end.column, str);
				} else {
					return '';
				}
			}();
			var firstLine = function () {
				var _v1 = A2($elm$core$Array$get, start.row - 1, lines);
				if (_v1.$ === 'Just') {
					var str = _v1.a;
					return A2($jfmengels$elm_review$Unicode$dropLeft, start.column - 1, str);
				} else {
					return '';
				}
			}();
			var resultingLines = _Utils_eq(start.row + 1, end.row) ? _List_fromArray(
				[firstLine, lastLine]) : _List_fromArray(
				[
					firstLine,
					A2(
					$elm$core$String$join,
					'\n',
					$elm$core$Array$toList(
						A3($elm$core$Array$slice, start.row, end.row - 1, lines))),
					lastLine
				]);
			return $elm$core$Maybe$Just(
				A2($elm$core$String$join, '\n', resultingLines));
		}
	};
};
var $jfmengels$elm_review$Review$Test$codeInspectorForSource = F2(
	function (isModule, source) {
		return {
			checkIfLocationIsAmbiguous: $jfmengels$elm_review$Review$Test$checkIfLocationIsAmbiguousInSourceCode(source),
			getCodeAtLocation: $jfmengels$elm_review$Review$Test$getCodeAtLocationInSourceCode(source),
			isModule: isModule,
			source: source
		};
	});
var $jfmengels$elm_review$Review$Test$elmJsonRunResult = F2(
	function (errors, project) {
		var _v0 = $jfmengels$elm_review$Review$Project$elmJson(project);
		if (_v0.$ === 'Just') {
			var elmJsonData = _v0.a;
			var _v1 = A2(
				$elm$core$List$filter,
				function (error_) {
					return _Utils_eq(
						$jfmengels$elm_review$Review$Rule$errorFilePath(error_),
						elmJsonData.path);
				},
				errors);
			if (!_v1.b) {
				return _List_Nil;
			} else {
				var errorsForElmJson = _v1;
				return _List_fromArray(
					[
						{
						errors: errorsForElmJson,
						inspector: A2($jfmengels$elm_review$Review$Test$codeInspectorForSource, false, elmJsonData.raw),
						moduleName: elmJsonData.path
					}
					]);
			}
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Test$findDuplicateModuleNames = F2(
	function (previousModuleNames, modules) {
		findDuplicateModuleNames:
		while (true) {
			if (!modules.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var ast = modules.a.ast;
				var restOfModules = modules.b;
				var moduleName = $stil4m$elm_syntax$Elm$Syntax$Module$moduleName(
					$stil4m$elm_syntax$Elm$Syntax$Node$value(ast.moduleDefinition));
				if (A2($elm$core$Set$member, moduleName, previousModuleNames)) {
					return $elm$core$Maybe$Just(moduleName);
				} else {
					var $temp$previousModuleNames = A2($elm$core$Set$insert, moduleName, previousModuleNames),
						$temp$modules = restOfModules;
					previousModuleNames = $temp$previousModuleNames;
					modules = $temp$modules;
					continue findDuplicateModuleNames;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$globalErrorInTest = function (error) {
	return A2(
		$jfmengels$elm_review$Review$Test$FailureMessage$failureMessage,
		'GLOBAL ERROR IN SOURCE CODE',
		'I found a global error in the project you provided for this test:\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$wrapInQuotes(
			$jfmengels$elm_review$Review$Rule$errorMessage(error)) + ('\n\n  ' + ($jfmengels$elm_review$Review$Test$FailureMessage$formatDetails(
			$jfmengels$elm_review$Review$Rule$errorDetails(error)) + '\n\n`elm-review` would fail with this error if the project to be reviewed had\nthe same issue. Please fix this issue in your test.\n'))));
};
var $jfmengels$elm_review$Review$Test$indexOfHelp = F3(
	function (elementToFind, aList, offset) {
		indexOfHelp:
		while (true) {
			if (!aList.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var a = aList.a;
				var rest = aList.b;
				if (_Utils_eq(a, elementToFind)) {
					return $elm$core$Maybe$Just(offset);
				} else {
					var $temp$elementToFind = elementToFind,
						$temp$aList = rest,
						$temp$offset = offset + 1;
					elementToFind = $temp$elementToFind;
					aList = $temp$aList;
					offset = $temp$offset;
					continue indexOfHelp;
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$indexOf = F2(
	function (elementToFind, aList) {
		return A3($jfmengels$elm_review$Review$Test$indexOfHelp, elementToFind, aList, 0);
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$missingSources = A2($jfmengels$elm_review$Review$Test$FailureMessage$failureMessage, 'MISSING SOURCES', 'You used `runOnModules` or `runOnModulesWithProjectData` with an empty list\nof sources files.\n\nI need sources to reviewing, because reviewing an empty project does not\nmake much sense to me.');
var $jfmengels$elm_review$Review$Test$compareRange = F2(
	function (a, b) {
		return (_Utils_cmp(a.start.row, b.start.row) < 0) ? $elm$core$Basics$LT : ((_Utils_cmp(a.start.row, b.start.row) > 0) ? $elm$core$Basics$GT : ((_Utils_cmp(a.start.column, b.start.column) < 0) ? $elm$core$Basics$LT : ((_Utils_cmp(a.start.column, b.start.column) > 0) ? $elm$core$Basics$GT : ((_Utils_cmp(a.end.row, b.end.row) < 0) ? $elm$core$Basics$LT : ((_Utils_cmp(a.end.row, b.end.row) > 0) ? $elm$core$Basics$GT : ((_Utils_cmp(a.end.column, b.end.column) < 0) ? $elm$core$Basics$LT : ((_Utils_cmp(a.end.column, b.end.column) > 0) ? $elm$core$Basics$GT : $elm$core$Basics$EQ)))))));
	});
var $jfmengels$elm_review$Review$Test$compareErrorPositions = F2(
	function (a, b) {
		return A2(
			$jfmengels$elm_review$Review$Test$compareRange,
			$jfmengels$elm_review$Review$Rule$errorRange(a),
			$jfmengels$elm_review$Review$Rule$errorRange(b));
	});
var $jfmengels$elm_review$Review$Test$moduleToRunResult = F2(
	function (errors, projectModule) {
		return {
			errors: A2(
				$elm$core$List$sortWith,
				$jfmengels$elm_review$Review$Test$compareErrorPositions,
				A2(
					$elm$core$List$filter,
					function (error_) {
						return _Utils_eq(
							$jfmengels$elm_review$Review$Rule$errorFilePath(error_),
							projectModule.path);
					},
					errors)),
			inspector: A2($jfmengels$elm_review$Review$Test$codeInspectorForSource, true, projectModule.source),
			moduleName: A2(
				$elm$core$String$join,
				'.',
				$stil4m$elm_syntax$Elm$Syntax$Module$moduleName(
					$stil4m$elm_syntax$Elm$Syntax$Node$value(projectModule.ast.moduleDefinition)))
		};
	});
var $jfmengels$elm_review$Review$Project$modulesThatFailedToParse = function (_v0) {
	var project = _v0.a;
	return project.modulesThatFailedToParse;
};
var $jfmengels$elm_review$Review$Test$FailureMessage$parsingFailure = F2(
	function (isOnlyFile, _v0) {
		var index = _v0.index;
		var source = _v0.source;
		var hint = 'Hint: Maybe you forgot to add the module definition at the top, like:\n\n  `module A exposing (..)`';
		var details = isOnlyFile ? 'I could not parse the test source code, because it was not valid Elm code.' : ('I could not parse one of the test source codes, because it was not valid\nElm code.\n\nThe source code in question is the one at index ' + ($elm$core$String$fromInt(index) + (' starting with:\n\n  `' + ($elm$core$String$concat(
			A2(
				$elm$core$List$take,
				1,
				A2(
					$elm$core$String$split,
					'\n',
					$elm$core$String$trim(source)))) + '`'))));
		return A2($jfmengels$elm_review$Review$Test$FailureMessage$failureMessage, 'TEST SOURCE CODE PARSING ERROR', details + ('\n\n' + hint));
	});
var $jfmengels$elm_review$Review$Test$readmeRunResult = F2(
	function (errors, project) {
		var _v0 = $jfmengels$elm_review$Review$Project$readme(project);
		if (_v0.$ === 'Just') {
			var projectReadme = _v0.a;
			var _v1 = A2(
				$elm$core$List$filter,
				function (error_) {
					return _Utils_eq(
						$jfmengels$elm_review$Review$Rule$errorFilePath(error_),
						projectReadme.path);
				},
				errors);
			if (!_v1.b) {
				return _List_Nil;
			} else {
				var errorsForReadme = _v1;
				return _List_fromArray(
					[
						{
						errors: errorsForReadme,
						inspector: A2($jfmengels$elm_review$Review$Test$codeInspectorForSource, false, projectReadme.content),
						moduleName: projectReadme.path
					}
					]);
			}
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Rule$ruleProvidesFixes = function (_v0) {
	var rule = _v0.a;
	return rule.providesFixes;
};
var $jfmengels$elm_review$Review$Test$runOnModulesWithProjectDataHelp = F3(
	function (project, rule, sources) {
		var _v0 = A3(
			$elm$core$List$foldl,
			F2(
				function (source, _v1) {
					var accProject = _v1.a;
					var accModulesThatFailedToParse = _v1.b;
					var _v2 = $jfmengels$elm_review$Review$FileParser$parse(source);
					if (_v2.$ === 'Ok') {
						var ast = _v2.a;
						return _Utils_Tuple2(
							A2(
								$jfmengels$elm_review$Review$Project$addParsedModule,
								{
									ast: ast,
									path: 'src/' + (A2(
										$elm$core$String$join,
										'/',
										$stil4m$elm_syntax$Elm$Syntax$Module$moduleName(
											$stil4m$elm_syntax$Elm$Syntax$Node$value(ast.moduleDefinition))) + '.elm'),
									source: source
								},
								accProject),
							accModulesThatFailedToParse);
					} else {
						return _Utils_Tuple2(
							accProject,
							A2(
								$elm$core$List$cons,
								{path: 'test/DummyFilePath.elm', source: source},
								accModulesThatFailedToParse));
					}
				}),
			_Utils_Tuple2(project, _List_Nil),
			sources);
		var projectWithModules = _v0.a;
		var modulesThatFailedToParse = _v0.b;
		var _v3 = _Utils_ap(
			modulesThatFailedToParse,
			$jfmengels$elm_review$Review$Project$modulesThatFailedToParse(projectWithModules));
		if (_v3.b) {
			var source = _v3.a.source;
			var fileAndIndex = {
				index: A2(
					$elm$core$Maybe$withDefault,
					-1,
					A2($jfmengels$elm_review$Review$Test$indexOf, source, sources)),
				source: source
			};
			return $jfmengels$elm_review$Review$Test$FailedRun(
				A2(
					$jfmengels$elm_review$Review$Test$FailureMessage$parsingFailure,
					$jfmengels$elm_review$Review$Test$hasOneElement(sources),
					fileAndIndex));
		} else {
			var modules = $jfmengels$elm_review$Review$Project$modules(projectWithModules);
			if ($elm$core$List$isEmpty(modules)) {
				return $jfmengels$elm_review$Review$Test$FailedRun($jfmengels$elm_review$Review$Test$FailureMessage$missingSources);
			} else {
				var _v4 = A2($jfmengels$elm_review$Review$Test$findDuplicateModuleNames, $elm$core$Set$empty, modules);
				if (_v4.$ === 'Just') {
					var moduleName = _v4.a;
					return $jfmengels$elm_review$Review$Test$FailedRun(
						$jfmengels$elm_review$Review$Test$FailureMessage$duplicateModuleName(moduleName));
				} else {
					var _v5 = A3(
						$jfmengels$elm_review$Review$Rule$reviewV3,
						A2($jfmengels$elm_review$Review$Options$withDataExtraction, true, $jfmengels$elm_review$Review$Options$defaults),
						_List_fromArray(
							[rule]),
						projectWithModules);
					var errors = _v5.errors;
					var extracts = _v5.extracts;
					var extract = A2(
						$elm$core$Dict$get,
						$jfmengels$elm_review$Review$Rule$ruleName(rule),
						extracts);
					var _v6 = A2(
						$jfmengels$elm_review$Vendor$ListExtra$find,
						function (err) {
							return _Utils_eq(
								$jfmengels$elm_review$Review$Rule$errorTarget(err),
								$jfmengels$elm_review$Review$Error$Global);
						},
						errors);
					if (_v6.$ === 'Just') {
						var globalError_ = _v6.a;
						return $jfmengels$elm_review$Review$Test$FailedRun(
							$jfmengels$elm_review$Review$Test$FailureMessage$globalErrorInTest(globalError_));
					} else {
						var foundGlobalErrors = A2(
							$elm$core$List$map,
							function (error_) {
								return {
									details: $jfmengels$elm_review$Review$Rule$errorDetails(error_),
									message: $jfmengels$elm_review$Review$Rule$errorMessage(error_)
								};
							},
							A2(
								$elm$core$List$filter,
								function (error_) {
									return _Utils_eq(
										$jfmengels$elm_review$Review$Rule$errorTarget(error_),
										$jfmengels$elm_review$Review$Error$UserGlobal);
								},
								errors));
						var fileErrors = $elm$core$List$concat(
							_List_fromArray(
								[
									A2(
									$elm$core$List$map,
									$jfmengels$elm_review$Review$Test$moduleToRunResult(errors),
									modules),
									A2($jfmengels$elm_review$Review$Test$elmJsonRunResult, errors, projectWithModules),
									A2($jfmengels$elm_review$Review$Test$readmeRunResult, errors, projectWithModules)
								]));
						return A2(
							$jfmengels$elm_review$Review$Test$SuccessfulRun,
							{
								allErrors: errors,
								extract: extract,
								foundGlobalErrors: foundGlobalErrors,
								ruleCanProvideFixes: $jfmengels$elm_review$Review$Test$RuleCanProvideFixes(
									$jfmengels$elm_review$Review$Rule$ruleProvidesFixes(rule)),
								runResults: fileErrors
							},
							A2($jfmengels$elm_review$Review$Test$AttemptReRun, rule, projectWithModules));
					}
				}
			}
		}
	});
var $jfmengels$elm_review$Review$Test$runOnModulesWithProjectData = F3(
	function (project, rule, sources) {
		var _v0 = $jfmengels$elm_review$Review$Rule$getConfigurationError(rule);
		if (_v0.$ === 'Just') {
			var configurationError = _v0.a;
			return $jfmengels$elm_review$Review$Test$ConfigurationError(configurationError);
		} else {
			return A3($jfmengels$elm_review$Review$Test$runOnModulesWithProjectDataHelp, project, rule, sources);
		}
	});
var $jfmengels$elm_review$Review$Test$runWithProjectData = F3(
	function (project, rule, source) {
		return A3(
			$jfmengels$elm_review$Review$Test$runOnModulesWithProjectData,
			project,
			rule,
			_List_fromArray(
				[source]));
	});
var $jfmengels$elm_review$Review$Test$run = F2(
	function (rule, source) {
		return A3($jfmengels$elm_review$Review$Test$runWithProjectData, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore, rule, source);
	});
var $elm_explorations$test$Test$Internal$blankDescriptionFailure = $elm_explorations$test$Test$Internal$failNow(
	{
		description: 'This test has a blank description. Let\'s give it a useful one!',
		reason: $elm_explorations$test$Test$Runner$Failure$Invalid($elm_explorations$test$Test$Runner$Failure$BadDescription)
	});
var $elm_explorations$test$Test$test = F2(
	function (untrimmedDesc, thunk) {
		var desc = $elm$core$String$trim(untrimmedDesc);
		return $elm$core$String$isEmpty(desc) ? $elm_explorations$test$Test$Internal$blankDescriptionFailure : A2(
			$elm_explorations$test$Test$Internal$ElmTestVariant__Labeled,
			desc,
			$elm_explorations$test$Test$Internal$ElmTestVariant__UnitTest(
				function (_v0) {
					return _List_fromArray(
						[
							thunk(_Utils_Tuple0)
						]);
				}));
	});
var $jfmengels$elm_review$Review$Test$ExpectedError = function (a) {
	return {$: 'ExpectedError', a: a};
};
var $jfmengels$elm_review$Review$Test$Under = function (a) {
	return {$: 'Under', a: a};
};
var $jfmengels$elm_review$Review$Test$error = function (input) {
	return $jfmengels$elm_review$Review$Test$ExpectedError(
		{
			details: input.details,
			fixedSource: $elm$core$Maybe$Nothing,
			message: input.message,
			under: $jfmengels$elm_review$Review$Test$Under(input.under)
		});
};
var $author$project$NoUnsortedCasesTest$unsortedError = $jfmengels$elm_review$Review$Test$error(
	{
		details: _List_fromArray(
			['Case patterns were found out of order.  They should be sorted as specified in the rule configuration.']),
		message: 'Case patterns are not sorted.',
		under: 'case'
	});
var $jfmengels$elm_review$Review$Test$whenFixed = F2(
	function (fixedSource, _v0) {
		var expectedError = _v0.a;
		return $jfmengels$elm_review$Review$Test$ExpectedError(
			_Utils_update(
				expectedError,
				{
					fixedSource: $elm$core$Maybe$Just(fixedSource)
				}));
	});
var $author$project$NoUnsortedCasesTest$bugs = A2(
	$elm_explorations$test$Test$describe,
	'correctly handles',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'does not unstably sort patterns (1)',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\n\ntype Foo\n    = A\n    | B\n\n\na =\n    case ( x, y, z ) of\n        ( _, False, Just B ) ->\n            0\n\n        ( _, False, Nothing ) ->\n            1\n\n        ( True, True, Just A ) ->\n            2\n\n        ( _, True, _ ) ->\n            3\n\n        _ ->\n            4\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not unstably sort patterns (2)',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\n\ntype Foo\n    = A\n    | B\n\n\na =\n    case ( x, y, z ) of\n        ( _, False, Just B ) ->\n            0\n\n        ( _, False, Nothing ) ->\n            1\n\n        ( True, True, Just A ) ->\n            2\n\n        ( _, True, _ ) ->\n            3\n\n        _ ->\n            4\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\n\ntype Foo\n    = A\n    | B\n\n\na =\n    case ( x, y, z ) of\n        ( _, False, Nothing ) ->\n            1\n\n        ( _, False, Just B ) ->\n            0\n\n        ( True, True, Just A ) ->\n            2\n\n        ( _, True, _ ) ->\n            3\n\n        _ ->\n            4\n'));
			})
		]));
var $jfmengels$elm_review$Review$Test$expectErrorsForModuleFiles = F3(
	function (ruleCanProvideFixes, expectedErrorsList, runResults) {
		return A2(
			$elm$core$List$map,
			F2(
				function (runResult, _v0) {
					var expectedErrors = A2(
						$elm$core$Maybe$withDefault,
						_List_Nil,
						A2(
							$elm$core$Maybe$map,
							$elm$core$Tuple$second,
							A2(
								$jfmengels$elm_review$Vendor$ListExtra$find,
								function (_v1) {
									var moduleName = _v1.a;
									return _Utils_eq(moduleName, runResult.moduleName);
								},
								expectedErrorsList)));
					return $elm$core$List$isEmpty(expectedErrors) ? $jfmengels$elm_review$Review$Test$expectNoErrorForModuleRunResult(runResult) : A3($jfmengels$elm_review$Review$Test$checkAllErrorsMatch, ruleCanProvideFixes, runResult, expectedErrors);
				}),
			runResults);
	});
var $jfmengels$elm_review$Review$Test$FailureMessage$unknownModulesInExpectedErrors = function (moduleName) {
	return A2($jfmengels$elm_review$Review$Test$FailureMessage$failureMessage, 'UNKNOWN MODULES IN EXPECTED ERRORS', 'I expected errors for a module named `' + (moduleName + '` in the list passed to\n`expectErrorsForModules`, but I couldn\'t find a module in the test source\ncodes named that way.\n\nI assume that there was a mistake during the writing of the test. Please\nmatch the names of the modules in the test source codes to the ones in the\nexpected errors list.'));
};
var $jfmengels$elm_review$Review$Test$expectErrorsForModulesHelp = F3(
	function (ruleCanProvideFixes, expectedErrorsList, runResults) {
		var maybeUnknownModule = $elm$core$List$head(
			$elm$core$Set$toList(
				A2(
					$elm$core$Set$diff,
					$elm$core$Set$fromList(
						A2($elm$core$List$map, $elm$core$Tuple$first, expectedErrorsList)),
					$elm$core$Set$fromList(
						A2(
							$elm$core$List$map,
							function ($) {
								return $.moduleName;
							},
							runResults)))));
		if (maybeUnknownModule.$ === 'Just') {
			var unknownModule = maybeUnknownModule.a;
			return $elm_explorations$test$Expect$fail(
				$jfmengels$elm_review$Review$Test$FailureMessage$unknownModulesInExpectedErrors(unknownModule));
		} else {
			return A2(
				$elm_explorations$test$Expect$all,
				A3($jfmengels$elm_review$Review$Test$expectErrorsForModuleFiles, ruleCanProvideFixes, expectedErrorsList, runResults),
				_Utils_Tuple0);
		}
	});
var $jfmengels$elm_review$Review$Test$expectGlobalAndModuleErrors = F2(
	function (_v0, reviewResult) {
		var global = _v0.global;
		var modules = _v0.modules;
		switch (reviewResult.$) {
			case 'ConfigurationError':
				var configurationError = reviewResult.a;
				return $elm_explorations$test$Expect$fail(
					$jfmengels$elm_review$Review$Test$FailureMessage$unexpectedConfigurationError(configurationError));
			case 'FailedRun':
				var errorMessage = reviewResult.a;
				return $elm_explorations$test$Expect$fail(errorMessage);
			default:
				var ruleCanProvideFixes = reviewResult.a.ruleCanProvideFixes;
				var foundGlobalErrors = reviewResult.a.foundGlobalErrors;
				var runResults = reviewResult.a.runResults;
				var extract = reviewResult.a.extract;
				var allErrors = reviewResult.a.allErrors;
				var reRun = reviewResult.b;
				return A2(
					$elm_explorations$test$Expect$all,
					_List_fromArray(
						[
							function (_v2) {
							return $elm$core$List$isEmpty(global) ? $jfmengels$elm_review$Review$Test$expectNoGlobalErrors(foundGlobalErrors) : A2(
								$jfmengels$elm_review$Review$Test$checkAllGlobalErrorsMatch,
								$elm$core$List$length(global),
								{actual: foundGlobalErrors, expected: global});
						},
							function (_v3) {
							return A3($jfmengels$elm_review$Review$Test$expectErrorsForModulesHelp, ruleCanProvideFixes, modules, runResults);
						},
							function (_v4) {
							return $jfmengels$elm_review$Review$Test$expectNoDataExtract(extract);
						},
							function (_v5) {
							return A2($jfmengels$elm_review$Review$Test$checkResultsAreTheSameWhenIgnoringFiles, allErrors, reRun);
						}
						]),
					_Utils_Tuple0);
		}
	});
var $jfmengels$elm_review$Review$Test$expectErrorsForModules = F2(
	function (expectedErrorsList, reviewResult) {
		return A2(
			$jfmengels$elm_review$Review$Test$expectGlobalAndModuleErrors,
			{global: _List_Nil, modules: expectedErrorsList},
			reviewResult);
	});
var $jfmengels$elm_review$Review$Test$runOnModules = F2(
	function (rule, sources) {
		return A3($jfmengels$elm_review$Review$Test$runOnModulesWithProjectData, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore, rule, sources);
	});
var $author$project$NoUnsortedCasesTest$failsCrossModule = A2(
	$elm_explorations$test$Test$describe,
	'case is defined in another module',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Baz -> "Baz"\n        Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> "Bar"\n        A.Foo -> "Foo"\n        A.Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names disambiguating',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'C',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> "Baz"\n        A.Bar -> "Bar"\n        A.Foo -> "Foo"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with disambiguation by import',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'C',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Bar -> "Bar"\n        Foo -> "Foo"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with local name',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Bar -> "Bar"\n        Foo -> "Foo"\n'])));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsListsElementwise = A2(
	$elm_explorations$test$Test$describe,
	'sorted elementwise',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Baz] -> "Baz"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in length-first order',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with mixed list/uncons in length-first order',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        Foo :: [] -> "Foo"\n        Foo :: _ -> "Foo+"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        Bar :: Bar :: [] -> "BarBar"\n        Bar :: Bar :: _ -> "BarBar+"\n        [Bar, Baz] -> "BarBaz"\n        Bar :: _ :: _ -> "Bar++"\n        Bar :: _ -> "Bar+"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        Foo :: [] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Bar, Foo] -> "BarFoo"\n        Bar :: Bar :: [] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        Bar :: Bar :: _ -> "BarBar+"\n        Bar :: _ :: _ -> "Bar++"\n        Foo :: _ -> "Foo+"\n        Bar :: _ -> "Bar+"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCases$sortListPatternsByLength = function (_v0) {
	var c = _v0.a;
	return $author$project$NoUnsortedCases$RuleConfig(
		_Utils_update(
			c,
			{sortLists: $author$project$NoUnsortedCases$LengthFirst}));
};
var $author$project$NoUnsortedCasesTest$failsListsLengthFirst = A2(
	$elm_explorations$test$Test$describe,
	'sorted length-first',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortListPatternsByLength($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Baz] -> "BarBaz"\n        [Bar, Bar] -> "BarBar"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in elementwise order',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortListPatternsByLength($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with mixed list/uncons in elementwise order',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        Foo :: Foo :: [] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        Bar :: Bar :: _ -> "BarBar+"\n        Bar :: _ :: _ -> "Bar++"\n        Foo :: _ -> "Foo+"\n        Bar :: _ -> "Bar+"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortListPatternsByLength($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        Foo :: Foo :: [] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        Foo :: _ -> "Foo+"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        Bar :: Bar :: _ -> "BarBar+"\n        [Bar, Baz] -> "BarBaz"\n        Bar :: _ :: _ -> "Bar++"\n        Bar :: _ -> "Bar+"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsLists = A2(
	$elm_explorations$test$Test$describe,
	'with lists',
	_List_fromArray(
		[$author$project$NoUnsortedCasesTest$failsListsLengthFirst, $author$project$NoUnsortedCasesTest$failsListsElementwise]));
var $author$project$NoUnsortedCasesTest$failsLiterals = A2(
	$elm_explorations$test$Test$describe,
	'with literals',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order with ints',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0 -> "0"\n        2 -> "2"\n        4 -> "4"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        2 -> "2"\n        0 -> "0"\n        4 -> "4"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order with hex ints',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0x0 -> "0"\n        0x2 -> "2"\n        0xF -> "F"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0x2 -> "2"\n        0x0 -> "0"\n        0xF -> "F"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order with floats',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Float -> String\ntoString f =\n    case f of\n        0.0 -> "0"\n        2.3 -> "2"\n        4.0 -> "4"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Float -> String\ntoString f =\n    case f of\n        2.3 -> "2"\n        0.0 -> "0"\n        4.0 -> "4"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order with Strings',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : String -> Char\ntoString s =\n    case s of\n        "A" -> \'A\'\n        "B" -> \'B\'\n        "C" -> \'C\'\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : String -> Char\ntoString s =\n    case s of\n        "A" -> \'A\'\n        "C" -> \'C\'\n        "B" -> \'B\'\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order with Chars',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Char -> String\ntoString c =\n    case c of\n        \'A\' -> "A"\n        \'B\' -> "B"\n        \'C\' -> "C"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Char -> String\ntoString c =\n    case c of\n        \'A\' -> "A"\n        \'C\' -> "C"\n        \'B\' -> "B"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not in literal order in combination with other types',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> "0"\n        (Foo, 2) -> "0"\n        (Bar, 2) -> "2"\n        (Baz, 2) -> "2"\n        (_, 4) -> "4"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 2) -> "0"\n        (Foo, 0) -> "0"\n        (Bar, 2) -> "2"\n        (Baz, 2) -> "2"\n        (_, 4) -> "4"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in literal order in combination with other types and not sorted',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> "0"\n        (Bar, 2) -> "2"\n        (Baz, 2) -> "2"\n        (_, 4) -> "4"\n        _ -> "Something else..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> "0"\n        (Baz, 2) -> "2"\n        (Bar, 2) -> "2"\n        (_, 4) -> "4"\n        _ -> "Something else..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$matchesName = F3(
	function (_v0, m, t) {
		var expM = _v0.a;
		var expT = _v0.b;
		return _Utils_eq(m, expM) && _Utils_eq(t, expT);
	});
var $author$project$NoUnsortedCases$sortOnlyMatchingTypes = F2(
	function (sortablePredicate, _v0) {
		var c = _v0.a;
		return $author$project$NoUnsortedCases$RuleConfig(
			_Utils_update(
				c,
				{sortablePredicate: sortablePredicate}));
	});
var $author$project$NoUnsortedCasesTest$failsOnWhitelist = A2(
	$elm_explorations$test$Test$describe,
	'on whitelist',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> "Baz"\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names disambiguating',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'C',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> "Baz"\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with disambiguation by import',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'C',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Bar -> "Bar"\n        Foo -> "Foo"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('B', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with local name',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('B', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with sub module',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'B',
							_List_fromArray(
								[
									A2($jfmengels$elm_review$Review$Test$whenFixed, 'module B exposing (..)\n\nimport A.C.Internal as X\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        X.Baz -> "Baz"\n        X.Bar -> "Bar"\n        X.Foo -> "Foo"\n', $author$project$NoUnsortedCasesTest$unsortedError)
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A.C.Internal', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A.C.Internal exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module B exposing (..)\n\nimport A.C.Internal as X\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        X.Baz -> "Baz"\n        X.Foo -> "Foo"\n        X.Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with import name',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (True, Foo) -> "Foo"\n        (False, Foo) -> "Foo"\n        (False, Bar) -> "Bar"\n        (False, Baz) -> "Baz"\n        _ -> "Rest"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								F2(
									function (m, t) {
										var _v7 = _Utils_Tuple2(m, t);
										_v7$2:
										while (true) {
											switch (_v7.a) {
												case 'A':
													if (_v7.b === 'Custom') {
														return true;
													} else {
														break _v7$2;
													}
												case 'Basics':
													if (_v7.b === 'Bool') {
														return true;
													} else {
														break _v7$2;
													}
												default:
													break _v7$2;
											}
										}
										return false;
									}),
								$author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (False, Bar) -> "Bar"\n        (False, Foo) -> "Foo"\n        (True, Foo) -> "Foo"\n        (False, Baz) -> "Baz"\n        _ -> "Rest"\n'));
			})
		]));
var $author$project$NoUnsortedCases$doNotSortLiterals = function (_v0) {
	var c = _v0.a;
	return $author$project$NoUnsortedCases$RuleConfig(
		_Utils_update(
			c,
			{sortLiterals: false}));
};
var $author$project$NoUnsortedCases$AlphabeticalOrder = {$: 'AlphabeticalOrder'};
var $author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically = function (_v0) {
	var c = _v0.a;
	return $author$project$NoUnsortedCases$RuleConfig(
		_Utils_update(
			c,
			{sortTypesFromDependencies: $author$project$NoUnsortedCases$AlphabeticalOrder}));
};
var $author$project$NoUnsortedCasesTest$failsSubpatterns = A2(
	$elm_explorations$test$Test$describe,
	'with subpatterns',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'not sorted at first level',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> "Foo"\n        Just Bar -> "Bar"\n        Just Baz -> "Baz"\n        Nothing -> "Nothing"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Nothing -> "Nothing"\n        Just Foo -> "Foo"\n        Just Bar -> "Bar"\n        Just Baz -> "Baz"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'not sorted at lower level',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> "Foo"\n        Just Bar -> "Bar"\n        Just Baz -> "Baz"\n        Nothing -> "Nothing"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Bar -> "Bar"\n        Just Foo -> "Foo"\n        Just Baz -> "Baz"\n        Nothing -> "Nothing"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with non-sortable patterns',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Foo 1 2 -> "Foo"\n        Container Bar 2 1 -> "Bar"\n        Container Baz 2 2 -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$doNotSortLiterals($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Bar 2 1 -> "Bar"\n        Container Foo 1 2 -> "Foo"\n        Container Baz 2 2 -> "Baz"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts past non-sortable patterns',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Container = Container Int {field : Bool} Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 {field} Foo 1 -> "Foo"\n        Container 1 {field} Bar 1 -> "Bar"\n        Container 1 {field} Baz 1 -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$doNotSortLiterals($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Container = Container Int {field : Bool} Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 {field} Baz 1 -> "Baz"\n        Container 1 {field} Foo 1 -> "Foo"\n        Container 1 {field} Bar 1 -> "Bar"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsTransparentPatterns = A2(
	$elm_explorations$test$Test$describe,
	'with transparent patterns',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with parenthesized patterns',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        (Baz) -> "Bar"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        (Baz) -> "Bar"\n        Foo -> "Foo"\n        Bar -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with as pattern',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        (Bar as b) -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        (Bar as b) -> "Bar"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsTuples = A2(
	$elm_explorations$test$Test$describe,
	'with tuples',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted at first level',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> "FooA"\n        (Foo, B) -> "FooB"\n        (Foo, C) -> "FooC"\n        (Bar, A) -> "BarA"\n        (Bar, B) -> "BarB"\n        (Bar, C) -> "BarC"\n        (Baz, A) -> "BazA"\n        (Baz, B) -> "BazB"\n        (Baz, C) -> "BazC"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Bar, A) -> "BarA"\n        (Bar, B) -> "BarB"\n        (Bar, C) -> "BarC"\n        (Foo, A) -> "FooA"\n        (Foo, B) -> "FooB"\n        (Foo, C) -> "FooC"\n        (Baz, A) -> "BazA"\n        (Baz, B) -> "BazB"\n        (Baz, C) -> "BazC"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted at second level',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> "FooA"\n        (Foo, B) -> "FooB"\n        (Foo, C) -> "FooC"\n        (Bar, A) -> "BarA"\n        (Bar, B) -> "BarB"\n        (Bar, C) -> "BarC"\n        (Baz, A) -> "BazA"\n        (Baz, B) -> "BazB"\n        (Baz, C) -> "BazC"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> "FooA"\n        (Foo, C) -> "FooC"\n        (Foo, B) -> "FooB"\n        (Bar, A) -> "BarA"\n        (Bar, B) -> "BarB"\n        (Bar, C) -> "BarC"\n        (Baz, A) -> "BazA"\n        (Baz, B) -> "BazB"\n        (Baz, C) -> "BazC"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with threeples at third level',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> "FooAFoo"\n        (Foo, A, Bar) -> "FooABar"\n        (Foo, A, Baz) -> "FooABaz"\n        (Foo, B, Foo) -> "FooBFoo"\n        (Foo, B, Bar) -> "FooBBar"\n        (Foo, B, Baz) -> "FooBBaz"\n        (Foo, C, Foo) -> "FooCFoo"\n        (Foo, C, Bar) -> "FooCBar"\n        (Foo, C, Baz) -> "FooCBaz"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> "FooAFoo"\n        (Foo, A, Bar) -> "FooABar"\n        (Foo, A, Baz) -> "FooABaz"\n        (Foo, B, Foo) -> "FooBFoo"\n        (Foo, B, Baz) -> "FooBBaz"\n        (Foo, B, Bar) -> "FooBBar"\n        (Foo, C, Foo) -> "FooCFoo"\n        (Foo, C, Bar) -> "FooCBar"\n        (Foo, C, Baz) -> "FooCBaz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with nested tuples',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> "FooAFoo"\n        ((Foo, A), Bar) -> "FooABar"\n        ((Foo, A), Baz) -> "FooABaz"\n        ((Foo, B), Foo) -> "FooBFoo"\n        ((Foo, B), Bar) -> "FooBBar"\n        ((Foo, B), Baz) -> "FooBBaz"\n        ((Foo, C), Foo) -> "FooCFoo"\n        ((Foo, C), Bar) -> "FooCBar"\n        ((Foo, C), Baz) -> "FooCBaz"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> "FooAFoo"\n        ((Foo, A), Bar) -> "FooABar"\n        ((Foo, A), Baz) -> "FooABaz"\n        ((Foo, B), Foo) -> "FooBFoo"\n        ((Foo, C), Foo) -> "FooCFoo"\n        ((Foo, B), Bar) -> "FooBBar"\n        ((Foo, B), Baz) -> "FooBBaz"\n        ((Foo, C), Bar) -> "FooCBar"\n        ((Foo, C), Baz) -> "FooCBaz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with deeply nested tuples',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> "1"\n        ((Foo, (A, B)), Foo, (A, A)) -> "2"\n        ((Foo, (A, C)), Foo, (A, A)) -> "3"\n        ((Foo, (B, A)), Foo, (A, A)) -> "4"\n        ((Foo, (B, A)), Foo, (A, C)) -> "5"\n        ((Foo, (B, A)), Foo, (B, A)) -> "6"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> "1"\n        ((Foo, (A, B)), Foo, (A, A)) -> "2"\n        ((Foo, (B, A)), Foo, (A, A)) -> "4"\n        ((Foo, (A, C)), Foo, (A, A)) -> "3"\n        ((Foo, (B, A)), Foo, (A, C)) -> "5"\n        ((Foo, (B, A)), Foo, (B, A)) -> "6"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsTypesFromDependencies = A2(
	$elm_explorations$test$Test$describe,
	'with types from dependencies',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'in alphabetical order with declaration sorting',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> "True"\n        False -> "False"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> "False"\n        True -> "True"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in declaration order with alphabetical sorting',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> "False"\n        True -> "True"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> "True"\n        False -> "False"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsUncons = A2(
	$elm_explorations$test$Test$describe,
	'with uncons',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> "Foo"\n        Bar :: _ -> "Bar"\n        Baz :: _ -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> "Foo"\n        Baz :: _ -> "Baz"\n        Bar :: _ -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted including tuples',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Foo, 1) :: (Foo, 2) :: _ -> "Foo"\n        (Bar, 1) :: (Bar, 2) :: _ -> "Bar"\n        (Baz, 1) :: (Baz, 2) :: _ -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Bar, 1) :: (Bar, 2) :: _ -> "Bar"\n        (Foo, 1) :: (Foo, 2) :: _ -> "Foo"\n        (Baz, 1) :: (Baz, 2) :: _ -> "Baz"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$failsWildcards = A2(
	$elm_explorations$test$Test$describe,
	'with wildcards',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with all pattern at end',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Baz -> "Baz"\n        _ -> "Bar"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        _ -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not sorted with var pattern at end',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Baz -> "Baz"\n        bar -> "Bar"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        bar -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts past wildcards where possible with tuples',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, A) -> "A"\n        (_, B) -> "B"\n        (Foo, _) -> "FooNotBOrA"\n        (Bar, _) -> "BarNotBOrA"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, B) -> "B"\n        (_, A) -> "A"\n        (Bar, _) -> "BarNotBOrA"\n        (Foo, _) -> "FooNotBOrA"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts past wildcards where possible with lists',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Foo] -> "_Foo"\n        [_, Bar] -> "_Bar"\n        [Foo, _] -> "Foo_"\n        [Bar, _] -> "Bar_"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Bar] -> "_Bar"\n        [_, Foo] -> "_Foo"\n        [Bar, _] -> "Bar_"\n        [Foo, _] -> "Foo_"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts past wildcards where possible with uncons',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Foo :: _ -> "_Foo_"\n        _ :: Bar :: _ -> "_Bar_"\n        Foo :: _ -> "Foo_"\n        Bar :: _ -> "Bar_"\n        _ -> "Too many..."\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Bar :: _ -> "_Bar_"\n        _ :: Foo :: _ -> "_Foo_"\n        Bar :: _ -> "Bar_"\n        Foo :: _ -> "Foo_"\n        _ -> "Too many..."\n'));
			})
		]));
var $jfmengels$elm_review$Review$Test$UnderExactly = F2(
	function (a, b) {
		return {$: 'UnderExactly', a: a, b: b};
	});
var $jfmengels$elm_review$Review$Test$atExactly = F2(
	function (range, expectedError) {
		var expectedError_ = expectedError.a;
		return $jfmengels$elm_review$Review$Test$ExpectedError(
			_Utils_update(
				expectedError_,
				{
					under: A2(
						$jfmengels$elm_review$Review$Test$UnderExactly,
						$jfmengels$elm_review$Review$Test$getUnder(expectedError),
						range)
				}));
	});
var $author$project$NoUnsortedCasesTest$fixesProperly = A2(
	$elm_explorations$test$Test$describe,
	'automatic fixes',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'preserve comments',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    -- A block of patterns\n    case custom of\n        Foo ->\n            -- Foo\n            "Foo"\n\n        Bar ->\n            -- Bar\n            "Bar"\n\n        Baz ->\n            -- Baz\n            "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    -- A block of patterns\n    case custom of\n        Bar ->\n            -- Bar\n            "Bar"\n\n        Baz ->\n            -- Baz\n            "Baz"\n\n        Foo ->\n            -- Foo\n            "Foo"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'work with multiline expression/patterns',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String -> String\ntoString custom string =\n    -- A multiline expression\n    case\n        ( custom\n        , string\n        )\n    of\n        ( Foo, _ ) ->\n            -- Foo\n            toString\n                |> toPipeline\n                |> andSuch\n\n        ( Bar, "A pattern" ) ->\n            -- Bar\n            "Bar"\n\n        ( Baz, foo ) ->\n            -- Baz\n            "Baz"\n\n        _ ->\n            \"\"\"Multiline\n        string\n        expression?\"\"\"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String -> String\ntoString custom string =\n    -- A multiline expression\n    case\n        ( custom\n        , string\n        )\n    of\n        ( Bar, "A pattern" ) ->\n            -- Bar\n            "Bar"\n\n        ( Baz, foo ) ->\n            -- Baz\n            "Baz"\n\n        ( Foo, _ ) ->\n            -- Foo\n            toString\n                |> toPipeline\n                |> andSuch\n\n        _ ->\n            \"\"\"Multiline\n        string\n        expression?\"\"\"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'do not mangle syntax in complex cases',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\ntype A = B | C | D\nfoo bar =\n    let\n        thing =\n            case bar of\n                B ->\n                    \\a b ->\n                        case ( Nothing, Nothing ) of\n                            ( Just a_, Just b_ ) ->\n                                GT\n                            ( Just _, Nothing ) ->\n                                LT\n                            ( Nothing, Just _ ) ->\n                                GT\n                            ( Nothing, Nothing ) ->\n                                LT\n                C ->\n                    \\a b -> GT\n                D ->\n                    \\a b -> GT\n    in\n    thing\n        ',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 17, row: 6},
									start: {column: 13, row: 6}
								},
								$author$project$NoUnsortedCasesTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\ntype A = B | C | D\nfoo bar =\n    let\n        thing =\n            case bar of\n                B ->\n                    \\a b ->\n                        case ( Nothing, Nothing ) of\n                            ( Just a_, Just b_ ) ->\n                                GT\n                            ( Just _, Nothing ) ->\n                                LT\n                            ( Nothing, Just _ ) ->\n                                GT\n                            ( Nothing, Nothing ) ->\n                                LT\n                D ->\n                    \\a b -> GT\n                C ->\n                    \\a b -> GT\n    in\n    thing\n        '));
			})
		]));
var $author$project$NoUnsortedCasesTest$fails = A2(
	$elm_explorations$test$Test$describe,
	'reports an error when',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'case is not sorted',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> "Bar"\n        Baz -> "Baz"\n        Foo -> "Foo"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'type is not exposed',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (toString)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (toString)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> "Bar"\n        Baz -> "Baz"\n        Foo -> "Foo"\n'));
			}),
			$author$project$NoUnsortedCasesTest$fixesProperly,
			$author$project$NoUnsortedCasesTest$failsCrossModule,
			$author$project$NoUnsortedCasesTest$failsWildcards,
			$author$project$NoUnsortedCasesTest$failsTransparentPatterns,
			$author$project$NoUnsortedCasesTest$failsTuples,
			$author$project$NoUnsortedCasesTest$failsLists,
			$author$project$NoUnsortedCasesTest$failsUncons,
			$author$project$NoUnsortedCasesTest$failsLiterals,
			$author$project$NoUnsortedCasesTest$failsTypesFromDependencies,
			$author$project$NoUnsortedCasesTest$failsSubpatterns,
			$author$project$NoUnsortedCasesTest$failsOnWhitelist
		]));
var $author$project$NoUnsortedCasesTest$passesCrossModule = A2(
	$elm_explorations$test$Test$describe,
	'case is defined in another module',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'but type is not exported (this is a compile error, just for checking context management)',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (Custom)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> "Bar"\n        Foo -> "Foo"\n        Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names disambiguating',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> "Foo"\n        A.Bar -> "Bar"\n        A.Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with disambiguation by import',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Bar -> "Bar"\n        Foo -> "Foo"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with local name',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n'])));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesListsElementwise = A2(
	$elm_explorations$test$Test$describe,
	'sorted elementwise',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is sorted with mixed list/uncons',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        Foo :: Foo :: [] -> "FooFoo"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        Foo :: _ -> "Foo+"\n        [Bar] -> "Bar"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        Bar :: Bar :: _ -> "BarBar+"\n        [Bar, Baz] -> "BarBaz"\n        Bar :: _ :: _ -> "Bar++"\n        Bar :: _ -> "Bar+"\n        [Baz] -> "Baz"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesListsLengthFirst = A2(
	$elm_explorations$test$Test$describe,
	'sorted length-first',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortListPatternsByLength($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        [Foo] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Foo, Foo] -> "FooFoo"\n        [Foo, Bar] -> "FooBar"\n        [Foo, Baz] -> "FooBaz"\n        [Bar, Foo] -> "BarFoo"\n        [Bar, Bar] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        [Foo, Foo, Foo] -> "FooFooFoo"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is sorted with mixed list/uncons',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortListPatternsByLength($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> ""\n        Foo :: [] -> "Foo"\n        [Bar] -> "Bar"\n        [Baz] -> "Baz"\n        [Bar, Foo] -> "BarFoo"\n        Bar :: Bar :: [] -> "BarBar"\n        [Bar, Baz] -> "BarBaz"\n        Bar :: Bar :: _ -> "BarBar+"\n        Bar :: _ :: _ -> "Bar++"\n        Foo :: _ -> "Foo+"\n        Bar :: _ -> "Bar+"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesUncons = A2(
	$elm_explorations$test$Test$describe,
	'with uncons',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> "Foo"\n        Bar :: _ -> "Bar"\n        Baz :: _ -> "Baz"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is sorted including tuples',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Foo, 1) :: (Foo, 2) :: _ -> "Foo"\n        (Bar, 1) :: (Bar, 2) :: _ -> "Bar"\n        (Baz, 1) :: (Baz, 2) :: _ -> "Baz"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves order when mixed with lists when matches could be equally short in simple case',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\nfoo : List String -> String\nfoo list =\n    case list of\n        [] ->\n            ""\n        [ last ] ->\n            last\n        second :: rest ->\n            second ++ rest\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves order when mixed with lists when matches could be equally short in complex case',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Nonempty a\n    = Nonempty a (List a)\n\nfoo : String -> Nonempty String -> String\nfoo fn list =\n    case list of\n        Nonempty first [] ->\n            first\n        Nonempty first [ last ] ->\n            first ++ " " ++ fn ++ " " ++ last\n        Nonempty first (second :: rest) ->\n            first ++ ", " ++ foo fn (Nonempty second rest)\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesLists = A2(
	$elm_explorations$test$Test$describe,
	'with lists',
	_List_fromArray(
		[$author$project$NoUnsortedCasesTest$passesListsLengthFirst, $author$project$NoUnsortedCasesTest$passesListsElementwise, $author$project$NoUnsortedCasesTest$passesUncons]));
var $author$project$NoUnsortedCasesTest$passesLiterals = A2(
	$elm_explorations$test$Test$describe,
	'with literals',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'in literal order',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0 -> "0"\n        2 -> "2"\n        4 -> "4"\n        _ -> "Something else..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in literal order in combination with other types',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> "0"\n        (Bar, 0) -> "0"\n        (Bar, 2) -> "2"\n        (Baz, 2) -> "2"\n        (_, 4) -> "4"\n        _ -> "Something else..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesNotOnWhitelist = A2(
	$elm_explorations$test$Test$describe,
	'not on whitelist',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'not sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('B', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> "Baz"\n        Foo -> "Foo"\n        Bar -> "Bar"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('B', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> "Bar"\n        A.Foo -> "Foo"\n        A.Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with qualified names disambiguating',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('B', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> "Bar"\n        A.Foo -> "Foo"\n        A.Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with disambiguation by import',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n', 'module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> "Bar"\n        Foo -> "Foo"\n        Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with local name',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						_List_fromArray(
							['module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n', 'module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> "Bar"\n        Foo -> "Foo"\n        Baz -> "Baz"\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with import name',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							A2(
								$author$project$NoUnsortedCases$sortOnlyMatchingTypes,
								$author$project$NoUnsortedCasesTest$matchesName(
									_Utils_Tuple2('A', 'Custom')),
								$author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (False, Bar) -> "Bar"\n        (False, Foo) -> "Foo"\n        (True, Foo) -> "Foo"\n        (False, Baz) -> "Baz"\n        _ -> "Rest"\n'));
			})
		]));
var $author$project$NoUnsortedCases$doNotLookPastUnsortable = function (_v0) {
	var c = _v0.a;
	return $author$project$NoUnsortedCases$RuleConfig(
		_Utils_update(
			c,
			{lookPastUnsortable: false}));
};
var $author$project$NoUnsortedCasesTest$passesSubpatterns = A2(
	$elm_explorations$test$Test$describe,
	'with subpatterns',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> "Foo"\n        Just Bar -> "Bar"\n        Just Baz -> "Baz"\n        Nothing -> "Nothing"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with non-sortable patterns',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$doNotSortLiterals($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Foo 1 2 -> "Foo"\n        Container Bar 2 1 -> "Bar"\n        Container Baz 2 2 -> "Baz"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not sort past non-sortable patterns when specified',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$doNotLookPastUnsortable(
								$author$project$NoUnsortedCases$doNotSortLiterals($author$project$NoUnsortedCases$defaults))),
						'module A exposing (..)\n\ntype Container = Container Int Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 Baz 1 -> "Baz"\n        Container 1 Foo 1 -> "Foo"\n        Container 1 Bar 1 -> "Bar"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesTransparentPatterns = A2(
	$elm_explorations$test$Test$describe,
	'with transparent patterns',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with parenthesized patterns',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        (Baz) -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with as pattern',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        (Bar as b) -> "Bar"\n        Baz -> "Baz"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesTuples = A2(
	$elm_explorations$test$Test$describe,
	'with tuples',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> "FooA"\n        (Foo, B) -> "FooB"\n        (Foo, C) -> "FooC"\n        (Bar, A) -> "BarA"\n        (Bar, B) -> "BarB"\n        (Bar, C) -> "BarC"\n        (Baz, A) -> "BazA"\n        (Baz, B) -> "BazB"\n        (Baz, C) -> "BazC"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with threeples',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> "FooAFoo"\n        (Foo, A, Bar) -> "FooABar"\n        (Foo, A, Baz) -> "FooABaz"\n        (Foo, B, Foo) -> "FooBFoo"\n        (Foo, B, Bar) -> "FooBBar"\n        (Foo, B, Baz) -> "FooBBaz"\n        (Foo, C, Foo) -> "FooCFoo"\n        (Foo, C, Bar) -> "FooCBar"\n        (Foo, C, Baz) -> "FooCBaz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with nested tuples',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> "FooAFoo"\n        ((Foo, A), Bar) -> "FooABar"\n        ((Foo, A), Baz) -> "FooABaz"\n        ((Foo, B), Foo) -> "FooBFoo"\n        ((Foo, B), Bar) -> "FooBBar"\n        ((Foo, B), Baz) -> "FooBBaz"\n        ((Foo, C), Foo) -> "FooCFoo"\n        ((Foo, C), Bar) -> "FooCBar"\n        ((Foo, C), Baz) -> "FooCBaz"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with deeply nested tuples',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> "1"\n        ((Foo, (A, B)), Foo, (A, A)) -> "2"\n        ((Foo, (A, C)), Foo, (A, A)) -> "3"\n        ((Foo, (B, A)), Foo, (A, A)) -> "4"\n        ((Foo, (B, A)), Foo, (A, C)) -> "5"\n        ((Foo, (B, A)), Foo, (B, A)) -> "6"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves order when moving wildcards would create compile errors',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Thing\n    = Thing Int Int\n    | OtherThing\n\ntoInt : Thing -> Result a -> Int\ntoInt foo bar =\n    case ( foo, bar) of\n        ( Thing _ _, _ ) ->\n            1\n        ( _, Ok _ ) ->\n            2\n        ( _, Err _ ) ->\n           3\n'));
			})
		]));
var $author$project$NoUnsortedCases$doNotSortTypesFromDependencies = function (_v0) {
	var c = _v0.a;
	return $author$project$NoUnsortedCases$RuleConfig(
		_Utils_update(
			c,
			{sortTypesFromDependencies: $author$project$NoUnsortedCases$DoNotSort}));
};
var $author$project$NoUnsortedCasesTest$passesTypesFromDependencies = A2(
	$elm_explorations$test$Test$describe,
	'with types from dependencies',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'is sorted in declaration order',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> "True"\n        False -> "False"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is sorted in alphabetical order',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$sortTypesFromDependenciesAlphabetically($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> "False"\n        True -> "True"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in any order when not sorting',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule(
							$author$project$NoUnsortedCases$doNotSortTypesFromDependencies($author$project$NoUnsortedCases$defaults)),
						'module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> "False"\n        True -> "True"\n\ntoString2 : Bool -> String\ntoString2 b =\n    case b of\n        True -> "True"\n        False -> "False"\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passesWildcards = A2(
	$elm_explorations$test$Test$describe,
	'with wildcards',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted order with all pattern at end',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Baz -> "Baz"\n        _ -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'and is sorted with var pattern at end',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Baz -> "Baz"\n        bar -> "Bar"\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves control flow when sorting would destroy it with tuples',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, A) -> "A"\n        (Foo, _) -> "FooNotA"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'control flow is not mangled by transitive assumption',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\ntype T\n    = A\n    | B\n    | C String\n    | D Int\n\nfoo t1 t2=\n    case ( t1, t2 ) of\n        ( A, _ ) ->\n            Just A\n\n        ( _, A ) ->\n            Just A\n\n        ( _, C s ) ->\n            Just (C s)\n\n        ( B, _ ) ->\n            Just B\n\n        ( C s, _ ) ->\n            Just (C s)\n\n        ( _, B ) ->\n            Just B\n\n        ( D _, D i ) ->\n            Just (D i)\n', $author$project$NoUnsortedCasesTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype T\n    = A\n    | B\n    | C String\n    | D Int\n\nfoo t1 t2=\n    case ( t1, t2 ) of\n        ( A, _ ) ->\n            Just A\n\n        ( _, A ) ->\n            Just A\n\n        ( _, C s ) ->\n            Just (C s)\n\n        ( C s, _ ) ->\n            Just (C s)\n\n        ( B, _ ) ->\n            Just B\n\n        ( _, B ) ->\n            Just B\n\n        ( D _, D i ) ->\n            Just (D i)\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves control flow when sorting would destroy it with lists',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Foo] -> "_Foo"\n        [Foo, _] -> "Foo_"\n        _ -> "Too many..."\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'preserves control flow when sorting would destroy it with uncons',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Foo :: _ -> "_Foo_"\n        Foo :: _ -> "Foo_"\n        _ -> "Too many..."\n'));
			})
		]));
var $author$project$NoUnsortedCasesTest$passes = A2(
	$elm_explorations$test$Test$describe,
	'does not report an error when',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'case is sorted',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedCases$rule($author$project$NoUnsortedCases$defaults),
						'module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> "Foo"\n        Bar -> "Bar"\n        Baz -> "Baz"\n'));
			}),
			$author$project$NoUnsortedCasesTest$passesCrossModule,
			$author$project$NoUnsortedCasesTest$passesWildcards,
			$author$project$NoUnsortedCasesTest$passesTransparentPatterns,
			$author$project$NoUnsortedCasesTest$passesTuples,
			$author$project$NoUnsortedCasesTest$passesLists,
			$author$project$NoUnsortedCasesTest$passesUncons,
			$author$project$NoUnsortedCasesTest$passesLiterals,
			$author$project$NoUnsortedCasesTest$passesTypesFromDependencies,
			$author$project$NoUnsortedCasesTest$passesSubpatterns,
			$author$project$NoUnsortedCasesTest$passesNotOnWhitelist
		]));
var $author$project$NoUnsortedCasesTest$all = A2(
	$elm_explorations$test$Test$describe,
	'NoUnsortedCases',
	_List_fromArray(
		[$author$project$NoUnsortedCasesTest$passes, $author$project$NoUnsortedCasesTest$fails, $author$project$NoUnsortedCasesTest$bugs]));
var $author$project$NoUnsortedLetDeclarations$RuleConfig = function (a) {
	return {$: 'RuleConfig', a: a};
};
var $author$project$NoUnsortedLetDeclarations$alphabetically = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							return A2(
								$elm$core$Basics$compare,
								$elm$core$Set$toList(d1.namesBound),
								$elm$core$Set$toList(d2.namesBound));
						}),
					r.sortBy)
			}));
};
var $author$project$Util$GluedAfterFirst = function (a) {
	return {$: 'GluedAfterFirst', a: a};
};
var $elm_community$list_extra$List$Extra$indexedFoldl = F3(
	function (func, acc, list) {
		var step = F2(
			function (x, _v0) {
				var i = _v0.a;
				var thisAcc = _v0.b;
				return _Utils_Tuple2(
					i + 1,
					A3(func, i, x, thisAcc));
			});
		return A3(
			$elm$core$List$foldl,
			step,
			_Utils_Tuple2(0, acc),
			list).b;
	});
var $elm$core$Dict$intersect = F2(
	function (t1, t2) {
		return A2(
			$elm$core$Dict$filter,
			F2(
				function (k, _v0) {
					return A2($elm$core$Dict$member, k, t2);
				}),
			t1);
	});
var $elm$core$Set$intersect = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$intersect, dict1, dict2));
	});
var $author$project$Util$findDependencies = F2(
	function (_v0, ds) {
		var decI = _v0.a;
		var d = _v0.b;
		return A3(
			$elm_community$list_extra$List$Extra$indexedFoldl,
			F3(
				function (i, _v1, acc) {
					var dependentOnBindings = _v1.dependentOnBindings;
					var namesBound = _v1.namesBound;
					var glueAcc = acc.a;
					var numberUsedIn = acc.b;
					return (_Utils_eq(i, decI) || $elm$core$Set$isEmpty(
						A2($elm$core$Set$intersect, d.namesBound, dependentOnBindings))) ? acc : _Utils_Tuple2(
						A2($elm$core$Set$union, glueAcc, namesBound),
						numberUsedIn + 1);
				}),
			_Utils_Tuple2($elm$core$Set$empty, 0),
			ds);
	});
var $author$project$Util$validate = F2(
	function (pred, x) {
		return pred(x) ? $elm$core$Maybe$Just(x) : $elm$core$Maybe$Nothing;
	});
var $author$project$NoUnsortedLetDeclarations$glueDependenciesAfterFirstDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$Util$allBindingsInPattern = function (pattern) {
	var go = $elm$core$List$concatMap($author$project$Util$allBindingsInPattern);
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(pattern);
	switch (_v0.$) {
		case 'ListPattern':
			var ps = _v0.a;
			return go(ps);
		case 'TuplePattern':
			var ps = _v0.a;
			return go(ps);
		case 'RecordPattern':
			var ps = _v0.a;
			return A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, ps);
		case 'NamedPattern':
			var ps = _v0.b;
			return go(ps);
		case 'UnConsPattern':
			var p = _v0.a;
			var ps = _v0.b;
			return go(
				_List_fromArray(
					[p, ps]));
		case 'VarPattern':
			var name = _v0.a;
			return _List_fromArray(
				[name]);
		case 'AsPattern':
			var p = _v0.a;
			var name = _v0.b;
			return A2(
				$elm$core$List$cons,
				$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
				go(
					_List_fromArray(
						[p])));
		case 'ParenthesizedPattern':
			var p = _v0.a;
			return go(
				_List_fromArray(
					[p]));
		case 'AllPattern':
			return _List_Nil;
		case 'UnitPattern':
			return _List_Nil;
		case 'CharPattern':
			return _List_Nil;
		case 'StringPattern':
			return _List_Nil;
		case 'IntPattern':
			return _List_Nil;
		case 'HexPattern':
			return _List_Nil;
		default:
			return _List_Nil;
	}
};
var $author$project$Util$compareByOrderings = F3(
	function (orderings, d1, d2) {
		var go = function (os) {
			if (!os.b) {
				return $elm$core$Basics$EQ;
			} else {
				var o = os.a;
				var os_ = os.b;
				return A2(
					$author$project$Util$fallbackCompareFor,
					A2(o, d1, d2),
					function (_v1) {
						return go(os_);
					});
			}
		};
		return go(orderings);
	});
var $author$project$Util$gluedTo = function (g) {
	switch (g.$) {
		case 'GluedBeforeFirst':
			var ns = g.a;
			return ns;
		case 'GluedAfterFirst':
			var ns = g.a;
			return ns;
		case 'GluedBeforeLast':
			var ns = g.a;
			return ns;
		default:
			var ns = g.a;
			return ns;
	}
};
var $author$project$Util$gluedListToDAG = function (ds) {
	var namesToNodeId = $elm$core$Dict$fromList(
		A2(
			$elm$core$List$concatMap,
			function (_v1) {
				var id = _v1.id;
				var label = _v1.label;
				return A2(
					$elm$core$List$map,
					function (n) {
						return _Utils_Tuple2(n, id);
					},
					$elm$core$Set$toList(label.namesBound));
			},
			ds));
	var edges = A2(
		$elm$core$List$concatMap,
		function (_v0) {
			var id = _v0.id;
			var label = _v0.label;
			return A2(
				$elm$core$List$filterMap,
				function (n) {
					return A2(
						$elm$core$Maybe$map,
						function (from) {
							return {from: from, label: 0, to: id};
						},
						A2($elm$core$Dict$get, n, namesToNodeId));
				},
				A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					_List_Nil,
					A2($elm$core$Basics$composeL, $elm$core$Set$toList, $author$project$Util$gluedTo),
					label.glued));
		},
		ds);
	return A2(
		$author$project$Util$eliminateCycles,
		ds,
		A2($elm_community$graph$Graph$fromNodesAndEdges, ds, edges));
};
var $elm_community$intdict$IntDict$findMax = function (dict) {
	findMax:
	while (true) {
		switch (dict.$) {
			case 'Empty':
				return $elm$core$Maybe$Nothing;
			case 'Leaf':
				var l = dict.a;
				return $elm$core$Maybe$Just(
					_Utils_Tuple2(l.key, l.value));
			default:
				var i = dict.a;
				var $temp$dict = i.right;
				dict = $temp$dict;
				continue findMax;
		}
	}
};
var $elm_community$graph$Graph$nodeIdRange = function (graph) {
	return A2(
		$elm$core$Maybe$andThen,
		function (_v0) {
			var min = _v0.a;
			return A2(
				$elm$core$Maybe$andThen,
				function (_v1) {
					var max = _v1.a;
					return $elm$core$Maybe$Just(
						_Utils_Tuple2(min, max));
				},
				$elm_community$intdict$IntDict$findMax(
					$elm_community$graph$Graph$unGraph(graph)));
		},
		$elm_community$intdict$IntDict$findMin(
			$elm_community$graph$Graph$unGraph(graph)));
};
var $elm_community$graph$Graph$fold = F3(
	function (f, acc, graph) {
		var go = F2(
			function (acc1, graph1) {
				go:
				while (true) {
					var maybeContext = A2(
						$elm$core$Maybe$andThen,
						function (id) {
							return A2($elm_community$graph$Graph$get, id, graph);
						},
						A2(
							$elm$core$Maybe$map,
							$elm$core$Tuple$first,
							$elm_community$graph$Graph$nodeIdRange(graph1)));
					if (maybeContext.$ === 'Just') {
						var ctx = maybeContext.a;
						var $temp$acc1 = A2(f, ctx, acc1),
							$temp$graph1 = A2($elm_community$graph$Graph$remove, ctx.node.id, graph1);
						acc1 = $temp$acc1;
						graph1 = $temp$graph1;
						continue go;
					} else {
						return acc1;
					}
				}
			});
		return A2(go, acc, graph);
	});
var $elm_community$intdict$IntDict$isEmpty = function (dict) {
	if (dict.$ === 'Empty') {
		return true;
	} else {
		return false;
	}
};
var $elm_community$graph$Graph$heightLevels = function (_v0) {
	var startingGraph = _v0.a;
	var subtract = F2(
		function (a, b) {
			return b - a;
		});
	var isSource = function (ctx) {
		return $elm_community$intdict$IntDict$isEmpty(ctx.incoming);
	};
	var sources = A3(
		$elm_community$graph$Graph$fold,
		F2(
			function (ctx, acc) {
				return isSource(ctx) ? A2($elm$core$List$cons, ctx, acc) : acc;
			}),
		_List_Nil,
		startingGraph);
	var decrementAndNoteSources = F3(
		function (id, _v7, _v8) {
			var nextLevel = _v8.a;
			var indegrees = _v8.b;
			var indegreesDec = A3(
				$elm_community$intdict$IntDict$update,
				id,
				$elm$core$Maybe$map(
					subtract(1)),
				indegrees);
			var _v5 = A2($elm_community$intdict$IntDict$get, id, indegreesDec);
			if ((_v5.$ === 'Just') && (!_v5.a)) {
				var _v6 = A2($elm_community$graph$Graph$get, id, startingGraph);
				if (_v6.$ === 'Just') {
					var ctx = _v6.a;
					return _Utils_Tuple2(
						A2($elm$core$List$cons, ctx, nextLevel),
						indegreesDec);
				} else {
					return $elm_community$graph$Graph$crashHack('Graph.heightLevels: Could not get a node of a graph which should be there by invariants. Please file a bug report!');
				}
			} else {
				return _Utils_Tuple2(nextLevel, indegreesDec);
			}
		});
	var decrementIndegrees = F3(
		function (source, nextLevel, indegrees) {
			return A3(
				$elm_community$intdict$IntDict$foldl,
				decrementAndNoteSources,
				_Utils_Tuple2(nextLevel, indegrees),
				source.outgoing);
		});
	var go = F4(
		function (currentLevel, nextLevel, indegrees, graph) {
			var _v1 = _Utils_Tuple2(currentLevel, nextLevel);
			if (!_v1.a.b) {
				if (!_v1.b.b) {
					return _List_fromArray(
						[_List_Nil]);
				} else {
					return A2(
						$elm$core$List$cons,
						_List_Nil,
						A4(go, nextLevel, _List_Nil, indegrees, graph));
				}
			} else {
				var _v2 = _v1.a;
				var source = _v2.a;
				var currentLevel1 = _v2.b;
				var _v3 = A3(decrementIndegrees, source, nextLevel, indegrees);
				var nextLevel1 = _v3.a;
				var indegrees1 = _v3.b;
				var _v4 = A4(
					go,
					currentLevel1,
					nextLevel1,
					indegrees1,
					A2($elm_community$graph$Graph$remove, source.node.id, graph));
				if (!_v4.b) {
					return $elm_community$graph$Graph$crashHack('Graph.heightLevels: Reached a branch which is impossible by invariants. Please file a bug report!');
				} else {
					var level = _v4.a;
					var levels = _v4.b;
					return A2(
						$elm$core$List$cons,
						A2($elm$core$List$cons, source, level),
						levels);
				}
			}
		});
	var countIndegrees = A2(
		$elm_community$graph$Graph$fold,
		function (ctx) {
			return A2(
				$elm_community$intdict$IntDict$insert,
				ctx.node.id,
				$elm_community$intdict$IntDict$size(ctx.incoming));
		},
		$elm_community$intdict$IntDict$empty);
	return A4(
		go,
		sources,
		_List_Nil,
		countIndegrees(startingGraph),
		startingGraph);
};
var $author$project$Util$isGluedBefore = function (g) {
	switch (g.$) {
		case 'GluedBeforeFirst':
			return true;
		case 'GluedAfterFirst':
			return false;
		case 'GluedBeforeLast':
			return true;
		default:
			return false;
	}
};
var $author$project$Util$isGluedToFirst = function (g) {
	switch (g.$) {
		case 'GluedBeforeFirst':
			return true;
		case 'GluedAfterFirst':
			return true;
		case 'GluedBeforeLast':
			return false;
		default:
			return false;
	}
};
var $elm$core$List$partition = F2(
	function (pred, list) {
		var step = F2(
			function (x, _v0) {
				var trues = _v0.a;
				var falses = _v0.b;
				return pred(x) ? _Utils_Tuple2(
					A2($elm$core$List$cons, x, trues),
					falses) : _Utils_Tuple2(
					trues,
					A2($elm$core$List$cons, x, falses));
			});
		return A3(
			$elm$core$List$foldr,
			step,
			_Utils_Tuple2(_List_Nil, _List_Nil),
			list);
	});
var $author$project$Util$checkSortingWithGlue = F5(
	function (extractSource, errorConcerns, orderings, errorRange, ds) {
		var sort = $elm$core$List$sortWith(
			F2(
				function (d1, d2) {
					return A2(
						$author$project$Util$fallbackCompareFor,
						A3($author$project$Util$compareByOrderings, orderings, d1.label, d2.label),
						function (_v7) {
							return A2($elm$core$Basics$compare, d1.id, d2.id);
						});
				}));
		var insertGlued = F2(
			function (glued, dec) {
				var label = dec.label;
				return function (_v5) {
					var _v6 = _v5.a;
					var gluedBefore = _v6.a;
					var gluedAfter = _v6.b;
					var toGlue = _v5.b;
					return {
						inserted: _Utils_ap(
							gluedBefore,
							A2($elm$core$List$cons, dec, gluedAfter)),
						toGlue: toGlue
					};
				}(
					A2(
						$elm$core$Tuple$mapFirst,
						$elm$core$List$partition(
							A2(
								$elm$core$Basics$composeL,
								A2(
									$elm$core$Basics$composeL,
									A2($elm_community$maybe_extra$Maybe$Extra$unwrap, false, $author$project$Util$isGluedBefore),
									function ($) {
										return $.glued;
									}),
								function ($) {
									return $.label;
								})),
						A2(
							$elm$core$List$partition,
							A2(
								$elm$core$Basics$composeR,
								function ($) {
									return $.label;
								},
								A2(
									$elm$core$Basics$composeR,
									function ($) {
										return $.glued;
									},
									A2(
										$elm_community$maybe_extra$Maybe$Extra$unwrap,
										false,
										A2(
											$elm$core$Basics$composeL,
											A2(
												$elm$core$Basics$composeL,
												A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$Set$isEmpty),
												$elm$core$Set$intersect(label.namesBound)),
											$author$project$Util$gluedTo)))),
							glued)));
			});
		var indexed = A2(
			$elm$core$List$indexedMap,
			F2(
				function (i, d) {
					return {id: i, label: d};
				}),
			ds);
		var glueLevel = F2(
			function (sorted, glued) {
				if (!glued.b) {
					return sorted;
				} else {
					var g = glued.a;
					var gs = glued.b;
					var asList = sort(
						A2(
							$elm$core$List$map,
							function ($) {
								return $.node;
							},
							g));
					return function (sorted_) {
						return A2(glueLevel, sorted_, gs);
					}(
						$elm$core$List$isEmpty(sorted) ? asList : function (_v1) {
							var toFirst = _v1.a;
							var toLast = _v1.b;
							return A3(
								$elm$core$List$foldr,
								F2(
									function (d, _v3) {
										var toGlue = _v3.toGlue;
										var inserted = _v3.inserted;
										return function (r) {
											return _Utils_update(
												r,
												{
													inserted: _Utils_ap(r.inserted, inserted)
												});
										}(
											A2(insertGlued, toGlue, d));
									}),
								{inserted: _List_Nil, toGlue: toLast},
								A3(
									$elm$core$List$foldl,
									F2(
										function (d, _v2) {
											var toGlue = _v2.toGlue;
											var inserted = _v2.inserted;
											return function (r) {
												return _Utils_update(
													r,
													{
														inserted: _Utils_ap(inserted, r.inserted)
													});
											}(
												A2(insertGlued, toGlue, d));
										}),
									{inserted: _List_Nil, toGlue: toFirst},
									sorted).inserted).inserted;
						}(
							A2(
								$elm$core$List$partition,
								A2(
									$elm$core$Basics$composeL,
									A2(
										$elm$core$Basics$composeL,
										A2($elm_community$maybe_extra$Maybe$Extra$unwrap, false, $author$project$Util$isGluedToFirst),
										function ($) {
											return $.glued;
										}),
									function ($) {
										return $.label;
									}),
								asList)));
				}
			});
		return function (sorted) {
			return (!_Utils_eq(
				A2(
					$elm$core$List$map,
					function ($) {
						return $.id;
					},
					sorted),
				A2(
					$elm$core$List$map,
					function ($) {
						return $.id;
					},
					indexed))) ? $elm$core$List$singleton(
				A3(
					$author$project$Util$unsortedError,
					errorConcerns,
					errorRange,
					A2(
						$author$project$Util$createFix,
						extractSource,
						A2(
							$elm$core$List$map,
							function (_v4) {
								var id = _v4.id;
								var label = _v4.label;
								return _Utils_Tuple2(id, label.range);
							},
							sorted)))) : _List_Nil;
		}(
			A2(
				glueLevel,
				_List_Nil,
				$elm_community$graph$Graph$heightLevels(
					$author$project$Util$gluedListToDAG(indexed))));
	});
var $author$project$Util$subexpressions = function (expr) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(expr);
	switch (_v0.$) {
		case 'LetExpression':
			var letBlock = _v0.a;
			var subExprs = function (n) {
				var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(n);
				if (_v1.$ === 'LetFunction') {
					var declaration = _v1.a.declaration;
					return $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration).expression;
				} else {
					var e = _v1.b;
					return e;
				}
			};
			return A2(
				$elm$core$List$cons,
				letBlock.expression,
				A2($elm$core$List$map, subExprs, letBlock.declarations));
		case 'ListExpr':
			var es = _v0.a;
			return es;
		case 'TupledExpression':
			var es = _v0.a;
			return es;
		case 'RecordExpr':
			var setters = _v0.a;
			return A2(
				$elm$core$List$map,
				A2($elm$core$Basics$composeL, $elm$core$Tuple$second, $stil4m$elm_syntax$Elm$Syntax$Node$value),
				setters);
		case 'RecordUpdateExpression':
			var record = _v0.a;
			var updaters = _v0.b;
			return A2(
				$elm$core$List$cons,
				A2(
					$stil4m$elm_syntax$Elm$Syntax$Node$map,
					$stil4m$elm_syntax$Elm$Syntax$Expression$FunctionOrValue(_List_Nil),
					record),
				A2(
					$elm$core$List$map,
					A2($elm$core$Basics$composeL, $elm$core$Tuple$second, $stil4m$elm_syntax$Elm$Syntax$Node$value),
					updaters));
		case 'Application':
			var es = _v0.a;
			return es;
		case 'CaseExpression':
			var caseBlock = _v0.a;
			return A2(
				$elm$core$List$cons,
				caseBlock.expression,
				A2($elm$core$List$map, $elm$core$Tuple$second, caseBlock.cases));
		case 'OperatorApplication':
			var e1 = _v0.c;
			var e2 = _v0.d;
			return _List_fromArray(
				[e1, e2]);
		case 'IfBlock':
			var predExpr = _v0.a;
			var thenExpr = _v0.b;
			var elseExpr = _v0.c;
			return _List_fromArray(
				[predExpr, thenExpr, elseExpr]);
		case 'LambdaExpression':
			var expression = _v0.a.expression;
			return _List_fromArray(
				[expression]);
		case 'RecordAccess':
			var record = _v0.a;
			return _List_fromArray(
				[record]);
		case 'ParenthesizedExpression':
			var e = _v0.a;
			return _List_fromArray(
				[e]);
		case 'Negation':
			var e = _v0.a;
			return _List_fromArray(
				[e]);
		case 'UnitExpr':
			return _List_Nil;
		case 'Integer':
			return _List_Nil;
		case 'Hex':
			return _List_Nil;
		case 'Floatable':
			return _List_Nil;
		case 'Literal':
			return _List_Nil;
		case 'CharLiteral':
			return _List_Nil;
		case 'GLSLExpression':
			return _List_Nil;
		case 'RecordAccessFunction':
			return _List_Nil;
		case 'FunctionOrValue':
			return _List_Nil;
		case 'Operator':
			return _List_Nil;
		default:
			return _List_Nil;
	}
};
var $author$project$Util$countUsesIn = F2(
	function (expr, name) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(expr);
		if ((_v0.$ === 'FunctionOrValue') && (!_v0.a.b)) {
			var n = _v0.b;
			return _Utils_eq(n, name) ? 1 : 0;
		} else {
			return A3(
				$elm$core$List$foldl,
				function (e) {
					return $elm$core$Basics$add(
						A2($author$project$Util$countUsesIn, e, name));
				},
				0,
				$author$project$Util$subexpressions(expr));
		}
	});
var $elm$core$Set$singleton = function (key) {
	return $elm$core$Set$Set_elm_builtin(
		A2($elm$core$Dict$singleton, key, _Utils_Tuple0));
};
var $author$project$Util$findAllNamesIn = function (expr) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(expr);
	if ((_v0.$ === 'FunctionOrValue') && (!_v0.a.b)) {
		var n = _v0.b;
		return $elm$core$Set$singleton(n);
	} else {
		return A3(
			$elm$core$List$foldl,
			function (e) {
				return $elm$core$Set$union(
					$author$project$Util$findAllNamesIn(e));
			},
			$elm$core$Set$empty,
			$author$project$Util$subexpressions(expr));
	}
};
var $elm_community$list_extra$List$Extra$findMap = F2(
	function (f, list) {
		findMap:
		while (true) {
			if (!list.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var a = list.a;
				var tail = list.b;
				var _v1 = f(a);
				if (_v1.$ === 'Just') {
					var b = _v1.a;
					return $elm$core$Maybe$Just(b);
				} else {
					var $temp$f = f,
						$temp$list = tail;
					f = $temp$f;
					list = $temp$list;
					continue findMap;
				}
			}
		}
	});
var $elm_community$list_extra$List$Extra$reverseMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (x, acc) {
					return A2(
						$elm$core$List$cons,
						f(x),
						acc);
				}),
			_List_Nil,
			xs);
	});
var $author$project$NoUnsortedLetDeclarations$expressionVisitor = F3(
	function (_v0, n, context) {
		var glues = _v0.a.glues;
		var sortBy = _v0.a.sortBy;
		var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(n);
		if (_v1.$ === 'LetExpression') {
			var lb = _v1.a;
			var step = F2(
				function (d, _v5) {
					var dAcc = _v5.a;
					var eAcc = _v5.b;
					var _v3 = $stil4m$elm_syntax$Elm$Syntax$Node$value(d);
					if (_v3.$ === 'LetFunction') {
						var declaration = _v3.a.declaration;
						var name = $stil4m$elm_syntax$Elm$Syntax$Node$value(
							$stil4m$elm_syntax$Elm$Syntax$Node$value(declaration).name);
						var _v4 = $stil4m$elm_syntax$Elm$Syntax$Node$value(declaration);
						var expression = _v4.expression;
						var _arguments = _v4._arguments;
						return _Utils_Tuple2(
							A2(
								$elm$core$List$cons,
								function (es) {
									return {
										args: A2($elm$core$List$concatMap, $author$project$Util$allBindingsInPattern, _arguments),
										dependentOnBindings: $author$project$Util$findAllNamesIn(expression),
										glued: $elm$core$Maybe$Nothing,
										namesBound: $elm$core$Set$singleton(name),
										range: $stil4m$elm_syntax$Elm$Syntax$Node$range(d),
										usedInExpression: A2($author$project$Util$countUsesIn, lb.expression, name) >= 1,
										usedInOtherDecs: A2(
											$elm$core$List$any,
											function (e) {
												return A2($author$project$Util$countUsesIn, e, name) >= 1;
											},
											es)
									};
								},
								dAcc),
							A2($elm$core$List$cons, expression, eAcc));
					} else {
						var p = _v3.a;
						var expression = _v3.b;
						var bs = $author$project$Util$allBindingsInPattern(p);
						return _Utils_Tuple2(
							A2(
								$elm$core$List$cons,
								function (es) {
									return {
										args: _List_Nil,
										dependentOnBindings: $author$project$Util$findAllNamesIn(expression),
										glued: $elm$core$Maybe$Nothing,
										namesBound: $elm$core$Set$fromList(bs),
										range: $stil4m$elm_syntax$Elm$Syntax$Node$range(d),
										usedInExpression: A2(
											$elm$core$List$any,
											A2(
												$elm$core$Basics$composeL,
												function (numUses) {
													return numUses > 0;
												},
												$author$project$Util$countUsesIn(lb.expression)),
											bs),
										usedInOtherDecs: A2(
											$elm$core$List$any,
											function (e) {
												return A2(
													$elm$core$List$any,
													A2(
														$elm$core$Basics$composeL,
														function (numUses) {
															return numUses > 0;
														},
														$author$project$Util$countUsesIn(e)),
													bs);
											},
											es)
									};
								},
								dAcc),
							A2($elm$core$List$cons, expression, eAcc));
					}
				});
			var errorRange = function () {
				var r = $stil4m$elm_syntax$Elm$Syntax$Node$range(n);
				return _Utils_update(
					r,
					{
						end: {column: r.start.column + 3, row: r.start.row}
					});
			}();
			var applyGlues = F3(
				function (ds, i, d) {
					return _Utils_update(
						d,
						{
							glued: A2(
								$elm_community$list_extra$List$Extra$findMap,
								function (g) {
									return A2(
										g,
										_Utils_Tuple2(i, d),
										ds);
								},
								glues)
						});
				});
			var _v2 = A3(
				$elm$core$List$foldl,
				step,
				_Utils_Tuple2(_List_Nil, _List_Nil),
				lb.declarations);
			var exprsToDecs = _v2.a;
			var exprs = _v2.b;
			return A5(
				$author$project$Util$checkSortingWithGlue,
				context.extractSource,
				'Let declarations',
				sortBy,
				errorRange,
				function (ds) {
					return A2(
						$elm$core$List$indexedMap,
						applyGlues(ds),
						ds);
				}(
					A2(
						$elm_community$list_extra$List$Extra$reverseMap,
						function (f) {
							return f(exprs);
						},
						exprsToDecs)));
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Rule$compactProjectDataVisitors = F2(
	function (getData, visitors) {
		return $elm$core$List$isEmpty(visitors) ? _List_Nil : _List_fromArray(
			[
				F2(
				function (rawData, moduleContext) {
					var data = getData(rawData);
					return _Utils_Tuple2(
						_List_Nil,
						A3(
							$elm$core$List$foldr,
							F2(
								function (visitor, moduleContext_) {
									return A2(visitor, data, moduleContext_);
								}),
							moduleContext,
							visitors));
				})
			]);
	});
var $jfmengels$elm_review$Review$Rule$fromModuleRuleSchema = function (moduleVisitor) {
	var schema = moduleVisitor.a;
	var _v0 = schema.initialModuleContext;
	if (_v0.$ === 'Just') {
		var initialModuleContext = _v0.a;
		return $jfmengels$elm_review$Review$Rule$fromProjectRuleSchema(
			$jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
				{
					dataExtractor: $elm$core$Maybe$Nothing,
					dependenciesVisitors: A2($jfmengels$elm_review$Review$Rule$compactProjectDataVisitors, $elm$core$Basics$identity, schema.dependenciesVisitors),
					directDependenciesVisitors: A2($jfmengels$elm_review$Review$Rule$compactProjectDataVisitors, $elm$core$Basics$identity, schema.directDependenciesVisitors),
					elmJsonVisitors: A2(
						$jfmengels$elm_review$Review$Rule$compactProjectDataVisitors,
						$elm$core$Maybe$map(
							function ($) {
								return $.project;
							}),
						schema.elmJsonVisitors),
					finalEvaluationFns: _List_Nil,
					folder: $elm$core$Maybe$Nothing,
					initialProjectContext: initialModuleContext,
					moduleContextCreator: $elm$core$Maybe$Just(
						$jfmengels$elm_review$Review$Rule$initContextCreator($elm$core$Basics$identity)),
					moduleVisitors: _List_fromArray(
						[
							$jfmengels$elm_review$Review$Rule$removeExtensibleRecordTypeVariable(
							$elm$core$Basics$always(moduleVisitor))
						]),
					name: schema.name,
					providesFixes: schema.providesFixes,
					readmeVisitors: A2(
						$jfmengels$elm_review$Review$Rule$compactProjectDataVisitors,
						$elm$core$Maybe$map(
							function ($) {
								return $.content;
							}),
						schema.readmeVisitors),
					traversalType: $jfmengels$elm_review$Review$Rule$AllModulesInParallel
				}));
	} else {
		return $jfmengels$elm_review$Review$Rule$fromProjectRuleSchema(
			$jfmengels$elm_review$Review$Rule$ProjectRuleSchema(
				{
					dataExtractor: $elm$core$Maybe$Nothing,
					dependenciesVisitors: _List_Nil,
					directDependenciesVisitors: _List_Nil,
					elmJsonVisitors: _List_Nil,
					finalEvaluationFns: _List_Nil,
					folder: $elm$core$Maybe$Nothing,
					initialProjectContext: _Utils_Tuple0,
					moduleContextCreator: $elm$core$Maybe$Just(schema.moduleContextCreator),
					moduleVisitors: _List_fromArray(
						[
							$jfmengels$elm_review$Review$Rule$removeExtensibleRecordTypeVariable(
							$elm$core$Basics$always(moduleVisitor))
						]),
					name: schema.name,
					providesFixes: schema.providesFixes,
					readmeVisitors: _List_Nil,
					traversalType: $jfmengels$elm_review$Review$Rule$AllModulesInParallel
				}));
	}
};
var $author$project$NoUnsortedLetDeclarations$initialContext = $jfmengels$elm_review$Review$Rule$withSourceCodeExtractor(
	$jfmengels$elm_review$Review$Rule$initContextCreator(
		F2(
			function (extractSource, _v0) {
				return {extractSource: extractSource};
			})));
var $jfmengels$elm_review$Review$Rule$newModuleRuleSchemaUsingContextCreator = F2(
	function (name, moduleContextCreator) {
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			{caseBranchVisitorsOnEnter: _List_Nil, caseBranchVisitorsOnExit: _List_Nil, commentsVisitors: _List_Nil, declarationListVisitors: _List_Nil, declarationVisitorsOnEnter: _List_Nil, declarationVisitorsOnExit: _List_Nil, dependenciesVisitors: _List_Nil, directDependenciesVisitors: _List_Nil, elmJsonVisitors: _List_Nil, expressionVisitorsOnEnter: _List_Nil, expressionVisitorsOnExit: _List_Nil, finalEvaluationFns: _List_Nil, importVisitors: _List_Nil, initialModuleContext: $elm$core$Maybe$Nothing, letDeclarationVisitorsOnEnter: _List_Nil, letDeclarationVisitorsOnExit: _List_Nil, moduleContextCreator: moduleContextCreator, moduleDefinitionVisitors: _List_Nil, moduleDocumentationVisitors: _List_Nil, name: name, providesFixes: false, readmeVisitors: _List_Nil});
	});
var $jfmengels$elm_review$Review$Rule$providesFixesForModuleRule = function (_v0) {
	var moduleRuleSchema = _v0.a;
	return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
		_Utils_update(
			moduleRuleSchema,
			{providesFixes: true}));
};
var $author$project$NoUnsortedLetDeclarations$rule = function (_v0) {
	var r = _v0.a;
	return $jfmengels$elm_review$Review$Rule$fromModuleRuleSchema(
		$jfmengels$elm_review$Review$Rule$providesFixesForModuleRule(
			A2(
				$jfmengels$elm_review$Review$Rule$withExpressionEnterVisitor,
				F2(
					function (e, c) {
						return _Utils_Tuple2(
							A3(
								$author$project$NoUnsortedLetDeclarations$expressionVisitor,
								$author$project$NoUnsortedLetDeclarations$RuleConfig(
									_Utils_update(
										r,
										{
											glues: $elm$core$List$reverse(r.glues),
											sortBy: $elm$core$List$reverse(r.sortBy)
										})),
								e,
								c),
							c);
					}),
				A2($jfmengels$elm_review$Review$Rule$newModuleRuleSchemaUsingContextCreator, 'NoUnsortedLetDeclarations', $author$project$NoUnsortedLetDeclarations$initialContext))));
};
var $author$project$NoUnsortedLetDeclarations$sortLetDeclarations = $author$project$NoUnsortedLetDeclarations$RuleConfig(
	{glues: _List_Nil, sortBy: _List_Nil});
var $author$project$NoUnsortedLetDeclarationsTest$unsortedError = $jfmengels$elm_review$Review$Test$error(
	{
		details: _List_fromArray(
			['Let declarations were found out of order.  They should be sorted as specified in the rule configuration.']),
		message: 'Let declarations are not sorted.',
		under: 'let'
	});
var $author$project$NoUnsortedLetDeclarations$usedInExpressionFirst = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.usedInExpression, d2.usedInExpression);
							_v1$2:
							while (true) {
								if (_v1.a) {
									if (!_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarations$usedInExpressionLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.usedInExpression, d2.usedInExpression);
							_v1$2:
							while (true) {
								if (!_v1.a) {
									if (_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (!_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesAfterFirstDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesAfterFirstDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesAfterFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        help =\n            foo\n\n        b =\n            bar help\n\n        z =\n            zed help\n    in\n    a + b + z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        help =\n            foo x\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        z =\n            zed help y\n\n        y =\n            help\n    in\n    a\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesAfterFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n'));
			})
		]));
var $author$project$Util$GluedAfterLast = function (a) {
	return {$: 'GluedAfterLast', a: a};
};
var $author$project$NoUnsortedLetDeclarations$glueDependenciesAfterLastDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterLast, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesAfterLastDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesAfterLastDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesAfterLastDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help\n\n        z =\n            zed help\n\n        help =\n            foo\n    in\n    a + b + z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        z =\n            zed help y\n\n        help =\n            foo x\n\n        y =\n            help\n    in\n    a\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesAfterLastDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n'));
			})
		]));
var $author$project$Util$GluedBeforeFirst = function (a) {
	return {$: 'GluedBeforeFirst', a: a};
};
var $author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeFirstDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesBeforeFirstDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesBeforeFirstDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        help =\n            foo\n\n        a =\n            foo help\n\n        b =\n            bar help\n\n        z =\n            zed help\n    in\n    a + b + z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not a dependency if in exactly one func',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar\n\n        help =\n            foo\n\n        z =\n            zed\n    in\n    bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is a dependency if multiple bindings used in exactly one func each (not the same)',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        (helpA, helpB) =\n            foo\n\n        a =\n            foo helpA\n\n        b =\n            bar helpB\n\n        z =\n            zed\n    in\n    bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        x =\n            y\n\n        b =\n            bar help x\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n'));
			})
		]));
var $author$project$Util$GluedBeforeLast = function (a) {
	return {$: 'GluedBeforeLast', a: a};
};
var $author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeLastDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeLast, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesBeforeLastDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesBeforeLastDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeLastDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help\n\n        help =\n            foo\n\n        z =\n            zed help\n    in\n    a + b + z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        x =\n            y\n\n        b =\n            bar help x\n\n        help =\n            foo x\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueDependenciesBeforeLastDependent(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$glueHelpersAfter = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									A2(
										$elm$core$Basics$composeL,
										$elm$core$Basics$eq(1),
										$elm$core$Tuple$second),
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueHelpersAfterTests = A2(
	$elm_explorations$test$Test$describe,
	'glueHelpersAfter',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not helper if used in multiple funcs',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        calledInB =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo calledInB\n\n        b =\n            bar calledInB\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not glue to self',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n\n        dalledInB =\n            foo\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        dalledInB =\n            foo\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'chains properly and ignores mutual dependencies',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        mutualDep1 =\n            mutualDep2\n\n        mutualDep2 =\n            bar mutualDep3\n\n        mutualDep3 =\n            mutualDep1\n\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            calledInBHelp foo\n\n        calledInBHelp =\n            bar\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo\n\n        mutualDep3 =\n            mutualDep1\n\n        b =\n            bar calledInB\n\n        mutualDep2 =\n            bar mutualDep3\n\n        calledInBHelp =\n            bar\n\n        mutualDep1 =\n            mutualDep2\n\n        z =\n            zed\n\n        calledInB =\n            calledInBHelp foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles mutual recursion when one is not viable for gluing',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n\n        z =\n            zed\n    in\n    a + b\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$glueHelpersBefore = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (!d.usedInExpression) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									A2(
										$elm$core$Basics$composeL,
										$elm$core$Basics$eq(1),
										$elm$core$Tuple$second),
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$glueHelpersBeforeTests = A2(
	$elm_explorations$test$Test$describe,
	'glueHelpersBefore',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not helper if used in multiple funcs',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        calledInB =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo calledInB\n\n        b =\n            bar calledInB\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is a helper if multiple bindings used in single binding',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        (help1, help2) =\n            foo\n\n        (y, b) =\n            bar help1 help2\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        (help1, help2) =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo\n\n        (y, b) =\n            bar help1 help2\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not glue to self',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            calledInB foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            calledInB foo\n\n        dalledInB =\n            foo\n\n        b =\n            bar calledInB dalledInB\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        dalledInB =\n            foo\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'chains properly and ignores mutual dependencies',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        mutualDep1 =\n            mutualDep2\n\n        mutualDep2 =\n            bar mutualDep3\n\n        mutualDep3 =\n            mutualDep1\n\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInBHelp =\n            bar\n\n        calledInB =\n            calledInBHelp foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo\n\n        mutualDep3 =\n            mutualDep1\n\n        b =\n            bar calledInB\n\n        mutualDep2 =\n            bar mutualDep3\n\n        calledInBHelp =\n            bar\n\n        mutualDep1 =\n            mutualDep2\n\n        z =\n            zed\n\n        calledInB =\n            calledInBHelp foo\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles mutual recursion when one is not viable for gluing',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        aHelp =\n            a\n\n        a =\n            aHelp\n\n        b =\n            bar\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedLetDeclarations$alphabetically(
									$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)))),
						'module A exposing (..)\n\nfunc =\n    let\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n\n        z =\n            zed\n    in\n    a + b\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarationsTest$glues = A2(
	$elm_explorations$test$Test$describe,
	'glues',
	_List_fromArray(
		[$author$project$NoUnsortedLetDeclarationsTest$glueHelpersBeforeTests, $author$project$NoUnsortedLetDeclarationsTest$glueHelpersAfterTests, $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesBeforeFirstDependentTests, $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesAfterFirstDependentTests, $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesBeforeLastDependentTests, $author$project$NoUnsortedLetDeclarationsTest$glueDependenciesAfterLastDependentTests]));
var $author$project$NoUnsortedLetDeclarationsTest$alphabeticallyTests = A2(
	$elm_explorations$test$Test$describe,
	'alphabetically',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        bar =\n            x\n        baz =\n            y\n        foo =\n            z\n    in\n    foo |> bar |> baz\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        bar =\n            x\n        baz =\n            y\n        foo =\n            z\n    in\n    foo |> bar |> baz\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        foo =\n            z\n        bar =\n            x\n        baz =\n            y\n    in\n    foo |> bar |> baz\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'passes sorted destructuring',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        (Opaque a) =\n            i\n\n        ( z, b ) =\n            j\n\n        { y, c } =\n            k\n\n        d =\n            l\n    in\n    x\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails unsorted destructuring',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        (Opaque a) =\n            i\n\n        ( z, b ) =\n            j\n\n        { y, c } =\n            k\n\n        d =\n            l\n    in\n    x\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        ( z, b ) =\n            j\n\n        (Opaque a) =\n            i\n\n        d =\n            l\n\n        { y, c } =\n            k\n    in\n    x\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarationsTest$usedInExpressionFirstTests = A2(
	$elm_explorations$test$Test$describe,
	'usedInExpressionFirst',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        -- These are used in the expression\n        y =\n            b\n\n        x =\n            a\n\n        -- These are not\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        a =\n            i\n\n        b =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'falls back to other',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'falls back to other failing',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        y =\n            b\n\n        x =\n            a\n\n        b =\n            j\n\n        a =\n            i\n    in\n    x + y\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarationsTest$usedInExpressionLastTests = A2(
	$elm_explorations$test$Test$describe,
	'usedInExpressionLast',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        -- These are not used in the expression\n        x =\n            i\n\n        y =\n            j\n\n        -- These are used in the expression\n        b =\n            y\n\n        a =\n            x\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        b =\n            y\n\n        a =\n            x\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations)),
						'module A exposing (..)\nf =\n    let\n        b =\n            y\n\n        a =\n            x\n\n        x =\n            i\n\n        y =\n            j\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'falls back to other',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'falls back to other failing',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInExpressionLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n\n        a =\n            x\n    in\n    a + b\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsFirst = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.usedInOtherDecs, d2.usedInOtherDecs);
							_v1$2:
							while (true) {
								if (_v1.a) {
									if (!_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$usedInOtherDeclarationsFirstTests = A2(
	$elm_explorations$test$Test$describe,
	'usedInOtherDeclarationsFirst',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n    in\n    0\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.usedInOtherDecs, d2.usedInOtherDecs);
							_v1$2:
							while (true) {
								if (!_v1.a) {
									if (_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (!_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$usedInOtherDeclarationsLastTests = A2(
	$elm_explorations$test$Test$describe,
	'usedInOtherDeclarationsLast',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInOtherDeclarationsLast($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n    in\n    0\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$valuesAfterFunctions = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(
								$elm$core$List$isEmpty(d1.args),
								$elm$core$List$isEmpty(d2.args));
							_v1$2:
							while (true) {
								if (!_v1.a) {
									if (_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (!_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$valuesAfterFunctionsTests = A2(
	$elm_explorations$test$Test$describe,
	'valuesAfterFunctions',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$valuesAfterFunctions($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        a i =\n            i\n\n        b j =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        a i =\n            i\n\n        b j =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$valuesAfterFunctions($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        a i =\n            i\n\n        y =\n            b\n\n        b j =\n            j\n    in\n    x + y\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarations$valuesBeforeFunctions = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedLetDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(
								$elm$core$List$isEmpty(d1.args),
								$elm$core$List$isEmpty(d2.args));
							_v1$2:
							while (true) {
								if (_v1.a) {
									if (!_v1.b) {
										return $elm$core$Basics$LT;
									} else {
										break _v1$2;
									}
								} else {
									if (_v1.b) {
										return $elm$core$Basics$GT;
									} else {
										break _v1$2;
									}
								}
							}
							return $elm$core$Basics$EQ;
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedLetDeclarationsTest$valuesBeforeFunctionsTests = A2(
	$elm_explorations$test$Test$describe,
	'valuesBeforeFunctions',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$valuesBeforeFunctions($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n', $author$project$NoUnsortedLetDeclarationsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$valuesBeforeFunctions($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        a i =\n            i\n\n        y =\n            b\n\n        b j =\n            j\n    in\n    x + y\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarationsTest$orderings = A2(
	$elm_explorations$test$Test$describe,
	'orderings',
	_List_fromArray(
		[$author$project$NoUnsortedLetDeclarationsTest$alphabeticallyTests, $author$project$NoUnsortedLetDeclarationsTest$usedInExpressionFirstTests, $author$project$NoUnsortedLetDeclarationsTest$usedInExpressionLastTests, $author$project$NoUnsortedLetDeclarationsTest$usedInOtherDeclarationsLastTests, $author$project$NoUnsortedLetDeclarationsTest$usedInOtherDeclarationsFirstTests, $author$project$NoUnsortedLetDeclarationsTest$valuesBeforeFunctionsTests, $author$project$NoUnsortedLetDeclarationsTest$valuesAfterFunctionsTests]));
var $author$project$NoUnsortedLetDeclarationsTest$passes = A2(
	$elm_explorations$test$Test$describe,
	'passes when',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'single declaration',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule(
							$author$project$NoUnsortedLetDeclarations$alphabetically(
								$author$project$NoUnsortedLetDeclarations$usedInExpressionFirst($author$project$NoUnsortedLetDeclarations$sortLetDeclarations))),
						'module A exposing (..)\nf =\n    let\n        foo =\n            bar\n    in\n    foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no orderings',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedLetDeclarations$rule($author$project$NoUnsortedLetDeclarations$sortLetDeclarations),
						'module A exposing (..)\nf =\n    let\n        foo =\n            bar\n        bar =\n            baz\n    in\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedLetDeclarationsTest$all = A2(
	$elm_explorations$test$Test$describe,
	'NoUnsortedLetDeclarations',
	_List_fromArray(
		[$author$project$NoUnsortedLetDeclarationsTest$passes, $author$project$NoUnsortedLetDeclarationsTest$orderings, $author$project$NoUnsortedLetDeclarationsTest$glues]));
var $author$project$NoUnsortedRecordsTest$ambiguousRecordError = F2(
	function (matching, under) {
		return $jfmengels$elm_review$Review$Test$error(
			{
				details: _List_fromArray(
					[
						'This record could be one of several possible record aliases, so whether or not its fields are sorted could not be determined!',
						'Try adding a type annotation, or remove reportAmbiguousRecordsWithoutFix from your rule configuration.',
						'The record matched the following possible aliases: ' + A2($elm$core$String$join, ', ', matching)
					]),
				message: 'Ambiguous record encountered.',
				under: under
			});
	});
var $author$project$NoUnsortedRecords$Alphabetically = {$: 'Alphabetically'};
var $author$project$NoUnsortedRecords$CanonicalWhenSubrecord = {$: 'CanonicalWhenSubrecord'};
var $author$project$NoUnsortedRecords$GenericFieldsFirst = {$: 'GenericFieldsFirst'};
var $author$project$NoUnsortedRecords$RuleConfig = function (a) {
	return {$: 'RuleConfig', a: a};
};
var $author$project$NoUnsortedRecords$defaults = $author$project$NoUnsortedRecords$RuleConfig(
	{sortAmbiguous: $author$project$NoUnsortedRecords$Alphabetically, sortGenerics: $author$project$NoUnsortedRecords$GenericFieldsFirst, sortUnknown: $author$project$NoUnsortedRecords$Alphabetically, subrecordTreatment: $author$project$NoUnsortedRecords$CanonicalWhenSubrecord, typecheckUnambiguousRecords: false});
var $author$project$NoUnsortedRecords$DoNotSort = {$: 'DoNotSort'};
var $author$project$NoUnsortedRecords$doNotSortAmbiguousRecords = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{sortAmbiguous: $author$project$NoUnsortedRecords$DoNotSort}));
};
var $author$project$NoUnsortedRecords$ReportOnly = {$: 'ReportOnly'};
var $author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{sortAmbiguous: $author$project$NoUnsortedRecords$ReportOnly}));
};
var $author$project$NoUnsortedRecords$DereferencedType = function (a) {
	return {$: 'DereferencedType', a: a};
};
var $author$project$NoUnsortedRecords$NamedType = F2(
	function (a, b) {
		return {$: 'NamedType', a: a, b: b};
	});
var $author$project$NoUnsortedRecords$TypeVar = F2(
	function (a, b) {
		return {$: 'TypeVar', a: a, b: b};
	});
var $author$project$NoUnsortedRecords$TypeWithPositionalVars = function (a) {
	return {$: 'TypeWithPositionalVars', a: a};
};
var $author$project$NoUnsortedRecords$FunctionType = function (a) {
	return {$: 'FunctionType', a: a};
};
var $author$project$NoUnsortedRecords$ListType = function (a) {
	return {$: 'ListType', a: a};
};
var $author$project$NoUnsortedRecords$RecordType = function (a) {
	return {$: 'RecordType', a: a};
};
var $author$project$NoUnsortedRecords$TupleType = function (a) {
	return {$: 'TupleType', a: a};
};
var $author$project$NoUnsortedRecords$UnitType = {$: 'UnitType'};
var $author$project$NoUnsortedRecords$getType = function (_v0) {
	var t = _v0.a;
	return t;
};
var $author$project$NoUnsortedRecords$assignTypeVars = F2(
	function (typeVars, type_) {
		var go = function (t) {
			switch (t.$) {
				case 'FunctionType':
					var from = t.a.from;
					var to = t.a.to;
					return $author$project$NoUnsortedRecords$FunctionType(
						{
							from: go(from),
							to: go(to)
						});
				case 'TupleType':
					var ts = t.a;
					return $author$project$NoUnsortedRecords$TupleType(
						A2($elm$core$List$map, go, ts));
				case 'ListType':
					var t_ = t.a;
					return $author$project$NoUnsortedRecords$ListType(
						go(t_));
				case 'NamedType':
					var _v1 = t.a;
					var moduleName = _v1.a;
					var name = _v1.b;
					var ts = t.b;
					return A2(
						$author$project$NoUnsortedRecords$NamedType,
						_Utils_Tuple2(moduleName, name),
						A2($elm$core$List$map, go, ts));
				case 'RecordType':
					var r = t.a;
					return $author$project$NoUnsortedRecords$RecordType(
						_Utils_update(
							r,
							{
								fields: A2(
									$elm$core$List$map,
									$elm$core$Tuple$mapSecond(go),
									r.fields),
								generic: A2($elm$core$Maybe$map, go, r.generic)
							}));
				case 'TypeVar':
					var _var = t.b;
					return A2(
						$elm$core$Maybe$withDefault,
						t,
						A2($elm$core$Dict$get, _var, typeVars));
				default:
					return $author$project$NoUnsortedRecords$UnitType;
			}
		};
		return $author$project$NoUnsortedRecords$DereferencedType(
			go(
				$author$project$NoUnsortedRecords$getType(type_)));
	});
var $elm_community$maybe_extra$Maybe$Extra$filter = F2(
	function (f, m) {
		if (m.$ === 'Just') {
			var a = m.a;
			return f(a) ? m : $elm$core$Maybe$Nothing;
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$NoUnsortedRecords$Appendable = {$: 'Appendable'};
var $author$project$NoUnsortedRecords$CompAppend = {$: 'CompAppend'};
var $author$project$NoUnsortedRecords$Comparable = {$: 'Comparable'};
var $author$project$NoUnsortedRecords$Number = {$: 'Number'};
var $author$project$NoUnsortedRecords$makeTypeVar = F2(
	function (constrainedTypeVarsAreRespected, s) {
		return function (t) {
			return A2($author$project$NoUnsortedRecords$TypeVar, t, s);
		}(
			A2(
				$elm_community$maybe_extra$Maybe$Extra$filter,
				$elm$core$Basics$always(constrainedTypeVarsAreRespected),
				A2($elm$core$String$startsWith, 'number', s) ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$Number) : (A2($elm$core$String$startsWith, 'appendable', s) ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$Appendable) : (A2($elm$core$String$startsWith, 'comparable', s) ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$Comparable) : (A2($elm$core$String$startsWith, 'compappend', s) ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$CompAppend) : $elm$core$Maybe$Nothing)))));
	});
var $elm_community$maybe_extra$Maybe$Extra$withDefaultLazy = F2(
	function (_default, m) {
		if (m.$ === 'Nothing') {
			return _default(_Utils_Tuple0);
		} else {
			var a = m.a;
			return a;
		}
	});
var $author$project$NoUnsortedRecords$docTypeToType = F3(
	function (moduleName, settings, type_) {
		var constrainedTypeVarsAreRespected = settings.constrainedTypeVarsAreRespected;
		var subrecordIsAlsoCanonical = settings.subrecordIsAlsoCanonical;
		var go = function (subrecordStillCanon) {
			return A2(
				$author$project$NoUnsortedRecords$docTypeToType,
				moduleName,
				_Utils_update(
					settings,
					{subrecordIsAlsoCanonical: subrecordStillCanon}));
		}(
			A2($elm_community$maybe_extra$Maybe$Extra$filter, $elm$core$Basics$identity, subrecordIsAlsoCanonical));
		var makeList = F3(
			function (mod, name, args) {
				var _v4 = _Utils_Tuple3(mod, name, args);
				if (((((_v4.a.b && (_v4.a.a === 'List')) && (!_v4.a.b.b)) && (_v4.b === 'List')) && _v4.c.b) && (!_v4.c.b.b)) {
					var _v5 = _v4.a;
					var _v6 = _v4.c;
					var listType = _v6.a;
					return $elm$core$Maybe$Just(
						$author$project$NoUnsortedRecords$ListType(
							go(listType)));
				} else {
					return $elm$core$Maybe$Nothing;
				}
			});
		switch (type_.$) {
			case 'Lambda':
				var from = type_.a;
				var to = type_.b;
				return $author$project$NoUnsortedRecords$FunctionType(
					{
						from: go(from),
						to: go(to)
					});
			case 'Tuple':
				var ts = type_.a;
				return $author$project$NoUnsortedRecords$TupleType(
					A2($elm$core$List$map, go, ts));
			case 'Type':
				var qualified = type_.a;
				var args = type_.b;
				return function (_v2) {
					var mod = _v2.a;
					var name = _v2.b;
					return A2(
						$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
						function (_v3) {
							return A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(mod, name),
								A2($elm$core$List$map, go, args));
						},
						A3(makeList, mod, name, args));
				}(
					A2(
						$elm$core$Maybe$withDefault,
						_Utils_Tuple2(moduleName, qualified),
						A2(
							$elm$core$Maybe$map,
							function (_v1) {
								var n = _v1.a;
								var m = _v1.b;
								return _Utils_eq(m, _List_Nil) ? _Utils_Tuple2(moduleName, n) : _Utils_Tuple2(m, n);
							},
							$elm_community$list_extra$List$Extra$unconsLast(
								A2($elm$core$String$split, '.', qualified)))));
			case 'Record':
				var fields = type_.a;
				var generic = type_.b;
				return $author$project$NoUnsortedRecords$RecordType(
					{
						canonical: !_Utils_eq(subrecordIsAlsoCanonical, $elm$core$Maybe$Nothing),
						fields: A2(
							$elm$core$List$map,
							$elm$core$Tuple$mapSecond(go),
							fields),
						generic: A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$TypeVar($elm$core$Maybe$Nothing),
							generic)
					});
			default:
				var s = type_.a;
				return A2($author$project$NoUnsortedRecords$makeTypeVar, constrainedTypeVarsAreRespected, s);
		}
	});
var $author$project$NoUnsortedRecords$makePositionalArgTypeVars = A2(
	$elm$core$Basics$composeR,
	$elm$core$List$indexedMap(
		F2(
			function (i, s) {
				return _Utils_Tuple2(
					s,
					A2(
						$author$project$NoUnsortedRecords$TypeVar,
						$elm$core$Maybe$Nothing,
						'positional arg ' + $elm$core$String$fromInt(i)));
			})),
	$elm$core$Dict$fromList);
var $author$project$NoUnsortedRecords$docTypeToTypeWithPositionalVars = F3(
	function (moduleName, settings, typeArgs) {
		return A2(
			$elm$core$Basics$composeR,
			A2($author$project$NoUnsortedRecords$docTypeToType, moduleName, settings),
			A2(
				$elm$core$Basics$composeR,
				$author$project$NoUnsortedRecords$DereferencedType,
				A2(
					$elm$core$Basics$composeR,
					$author$project$NoUnsortedRecords$assignTypeVars(
						$author$project$NoUnsortedRecords$makePositionalArgTypeVars(typeArgs)),
					A2($elm$core$Basics$composeR, $author$project$NoUnsortedRecords$getType, $author$project$NoUnsortedRecords$TypeWithPositionalVars))));
	});
var $author$project$NoUnsortedRecords$initialProjectContext = {aliases: $elm$core$Dict$empty, canonicalRecords: $elm$core$Dict$empty, constructors: $elm$core$Dict$empty, functionTypes: $elm$core$Dict$empty};
var $author$project$NoUnsortedRecords$AlwaysCanonical = {$: 'AlwaysCanonical'};
var $author$project$NoUnsortedRecords$makeSubrecordsFromType = F3(
	function (recurse, namePrefix, type_) {
		var go = function (s) {
			return recurse ? A2(
				$author$project$NoUnsortedRecords$makeSubrecordsFromType,
				recurse,
				A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					namePrefix,
					function (subRec) {
						return _Utils_ap(namePrefix, subRec);
					},
					s)) : $elm$core$Basics$always(_List_Nil);
		};
		switch (type_.$) {
			case 'FunctionType':
				var from = type_.a.from;
				var to = type_.a.to;
				return _Utils_ap(
					A2(go, $elm$core$Maybe$Nothing, from),
					A2(go, $elm$core$Maybe$Nothing, to));
			case 'TupleType':
				var ts = type_.a;
				return A2(
					$elm$core$List$concatMap,
					go($elm$core$Maybe$Nothing),
					ts);
			case 'ListType':
				var t_ = type_.a;
				return A2(go, $elm$core$Maybe$Nothing, t_);
			case 'RecordType':
				var fields = type_.a.fields;
				var generic = type_.a.generic;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(
						namePrefix,
						{
							isGeneric: !_Utils_eq(generic, $elm$core$Maybe$Nothing),
							isSubrecord: true,
							order: A3(
								$elm_community$list_extra$List$Extra$indexedFoldl,
								F2(
									function (i, _v1) {
										var f = _v1.a;
										var t = _v1.b;
										return A2(
											$elm$core$Dict$insert,
											f,
											_Utils_Tuple2(i, t));
									}),
								$elm$core$Dict$empty,
								fields)
						}),
					A2(
						$elm$core$List$concatMap,
						function (_v2) {
							var f = _v2.a;
							var t = _v2.b;
							return A2(
								go,
								$elm$core$Maybe$Just('.' + f),
								t);
						},
						fields));
			default:
				return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$subrecordCanonicityForField = function (subrecordTreatment) {
	switch (subrecordTreatment.$) {
		case 'CanonicalWhenSubrecord':
			return $elm$core$Maybe$Just(true);
		case 'CustomTypeArgsAlwaysCanonical':
			return $elm$core$Maybe$Just(true);
		case 'AlwaysUnknown':
			return $elm$core$Maybe$Nothing;
		default:
			return $elm$core$Maybe$Just(true);
	}
};
var $author$project$NoUnsortedRecords$knownRecordFromDocType = F3(
	function (subrecordTreatment, moduleName, _v0) {
		var fields = _v0.a;
		var isGeneric = _v0.b;
		return function (k) {
			return _Utils_eq(subrecordTreatment, $author$project$NoUnsortedRecords$AlwaysCanonical) ? A2(
				$elm$core$List$cons,
				_Utils_Tuple2('', k),
				A2(
					$elm$core$List$concatMap,
					function (_v2) {
						var f = _v2.a;
						var _v3 = _v2.b;
						var t = _v3.b;
						return A3($author$project$NoUnsortedRecords$makeSubrecordsFromType, true, '.' + f, t);
					},
					$elm$core$Dict$toList(k.order))) : _List_fromArray(
				[
					_Utils_Tuple2('', k)
				]);
		}(
			function (order) {
				return {isGeneric: isGeneric, isSubrecord: false, order: order};
			}(
				A3(
					$elm_community$list_extra$List$Extra$indexedFoldl,
					F2(
						function (i, _v1) {
							var f = _v1.a;
							var t = _v1.b;
							return A2(
								$elm$core$Dict$insert,
								f,
								_Utils_Tuple2(
									i,
									A3(
										$author$project$NoUnsortedRecords$docTypeToType,
										moduleName,
										{
											constrainedTypeVarsAreRespected: false,
											subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
										},
										t)));
						}),
					$elm$core$Dict$empty,
					fields)));
	});
var $author$project$NoUnsortedRecords$getTypeWithPositionalVars = function (_v0) {
	var t = _v0.a;
	return t;
};
var $author$project$NoUnsortedRecords$makeCustomTypeSubrecords = F3(
	function (subrecordTreatment, n, ts) {
		return A3(
			$elm_community$maybe_extra$Maybe$Extra$unwrap,
			_List_Nil,
			function (recurse) {
				return $elm$core$List$concat(
					A2(
						$elm$core$List$indexedMap,
						F2(
							function (i, t) {
								return A3(
									$author$project$NoUnsortedRecords$makeSubrecordsFromType,
									recurse,
									n + (' arg' + $elm$core$String$fromInt(i)),
									$author$project$NoUnsortedRecords$getTypeWithPositionalVars(t));
							}),
						ts));
			},
			function () {
				switch (subrecordTreatment.$) {
					case 'AlwaysUnknown':
						return $elm$core$Maybe$Nothing;
					case 'CanonicalWhenSubrecord':
						return $elm$core$Maybe$Nothing;
					case 'CustomTypeArgsAlwaysCanonical':
						return $elm$core$Maybe$Just(false);
					default:
						return $elm$core$Maybe$Just(true);
				}
			}());
	});
var $author$project$NoUnsortedRecords$makeFunctionType = F2(
	function (_return, ts) {
		if (!ts.b) {
			return _return;
		} else {
			var t = ts.a;
			var ts_ = ts.b;
			return $author$project$NoUnsortedRecords$FunctionType(
				{
					from: t,
					to: A2($author$project$NoUnsortedRecords$makeFunctionType, _return, ts_)
				});
		}
	});
var $author$project$NoUnsortedRecords$makeFunctionTypeWithPositionalVars = F2(
	function (_return, ts) {
		return $author$project$NoUnsortedRecords$TypeWithPositionalVars(
			A2(
				$author$project$NoUnsortedRecords$makeFunctionType,
				$author$project$NoUnsortedRecords$getTypeWithPositionalVars(_return),
				A2($elm$core$List$map, $author$project$NoUnsortedRecords$getTypeWithPositionalVars, ts)));
	});
var $author$project$NoUnsortedRecords$subrecordCanonicityForRecord = function (subrecordTreatment) {
	switch (subrecordTreatment.$) {
		case 'CanonicalWhenSubrecord':
			return $elm$core$Maybe$Just(true);
		case 'CustomTypeArgsAlwaysCanonical':
			return $elm$core$Maybe$Just(true);
		case 'AlwaysUnknown':
			return $elm$core$Maybe$Just(false);
		default:
			return $elm$core$Maybe$Just(true);
	}
};
var $elm$core$List$unzip = function (pairs) {
	var step = F2(
		function (_v0, _v1) {
			var x = _v0.a;
			var y = _v0.b;
			var xs = _v1.a;
			var ys = _v1.b;
			return _Utils_Tuple2(
				A2($elm$core$List$cons, x, xs),
				A2($elm$core$List$cons, y, ys));
		});
	return A3(
		$elm$core$List$foldr,
		step,
		_Utils_Tuple2(_List_Nil, _List_Nil),
		pairs);
};
var $author$project$NoUnsortedRecords$dependencyVisitor = function (_v0) {
	var subrecordTreatment = _v0.a.subrecordTreatment;
	var step = F2(
		function (mod, acc) {
			var aliases = mod.aliases;
			var binops = mod.binops;
			var unions = mod.unions;
			var values = mod.values;
			var moduleName = A2($elm$core$String$split, '.', mod.name);
			var recordFromTypeAlias = function (_v20) {
				var name = _v20.name;
				var args = _v20.args;
				var tipe = _v20.tipe;
				if (tipe.$ === 'Record') {
					if (tipe.b.$ === 'Nothing') {
						var fields = tipe.a;
						var _v19 = tipe.b;
						return _Utils_Tuple2(
							A2(
								$elm$core$List$map,
								$elm$core$Tuple$mapFirst(
									function (s) {
										return _Utils_ap(name, s);
									}),
								A3(
									$author$project$NoUnsortedRecords$knownRecordFromDocType,
									subrecordTreatment,
									moduleName,
									_Utils_Tuple2(fields, false))),
							_List_fromArray(
								[
									_Utils_Tuple2(
									name,
									{
										customTypeName: $elm$core$Maybe$Nothing,
										type_: A2(
											$author$project$NoUnsortedRecords$makeFunctionTypeWithPositionalVars,
											A4(
												$author$project$NoUnsortedRecords$docTypeToTypeWithPositionalVars,
												moduleName,
												{
													constrainedTypeVarsAreRespected: true,
													subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForRecord(subrecordTreatment)
												},
												args,
												tipe),
											A2(
												$elm$core$List$map,
												A2(
													$elm$core$Basics$composeR,
													$elm$core$Tuple$second,
													A3(
														$author$project$NoUnsortedRecords$docTypeToTypeWithPositionalVars,
														moduleName,
														{
															constrainedTypeVarsAreRespected: true,
															subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
														},
														args)),
												fields))
									})
								]));
					} else {
						var fields = tipe.a;
						return _Utils_Tuple2(
							A2(
								$elm$core$List$map,
								$elm$core$Tuple$mapFirst(
									function (s) {
										return _Utils_ap(name, s);
									}),
								A3(
									$author$project$NoUnsortedRecords$knownRecordFromDocType,
									subrecordTreatment,
									moduleName,
									_Utils_Tuple2(fields, true))),
							_List_Nil);
					}
				} else {
					return _Utils_Tuple2(_List_Nil, _List_Nil);
				}
			};
			var makeConstructor = F3(
				function (_return, typeVars, _v17) {
					var name = _v17.a;
					var _arguments = _v17.b;
					return function (ts) {
						return _Utils_Tuple3(
							name,
							A2($author$project$NoUnsortedRecords$makeFunctionTypeWithPositionalVars, _return, ts),
							A3($author$project$NoUnsortedRecords$makeCustomTypeSubrecords, subrecordTreatment, name, ts));
					}(
						A2(
							$elm$core$List$map,
							A3(
								$author$project$NoUnsortedRecords$docTypeToTypeWithPositionalVars,
								moduleName,
								{
									constrainedTypeVarsAreRespected: true,
									subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
								},
								typeVars),
							_arguments));
				});
			var makeAlias = function (_v16) {
				var name = _v16.name;
				var args = _v16.args;
				var tipe = _v16.tipe;
				return _Utils_Tuple2(
					name,
					A4(
						$author$project$NoUnsortedRecords$docTypeToTypeWithPositionalVars,
						moduleName,
						{
							constrainedTypeVarsAreRespected: false,
							subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForRecord(subrecordTreatment)
						},
						args,
						tipe));
			};
			var newAliases = A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$pair(moduleName),
				A2(
					$elm$core$Maybe$map,
					$elm$core$Dict$fromList,
					A2(
						$author$project$Util$validate,
						A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
						A2($elm$core$List$map, makeAlias, aliases))));
			var functionsFromCustomType = function (_v15) {
				var name = _v15.name;
				var args = _v15.args;
				var tags = _v15.tags;
				return A3(
					$elm$core$List$foldl,
					F2(
						function (t, _v13) {
							var fAcc = _v13.a;
							var rAcc = _v13.b;
							return function (_v14) {
								var n = _v14.a;
								var type_ = _v14.b;
								var rs = _v14.c;
								return _Utils_Tuple2(
									A2(
										$elm$core$List$cons,
										_Utils_Tuple2(
											n,
											{
												customTypeName: $elm$core$Maybe$Just(name),
												type_: type_
											}),
										fAcc),
									_Utils_ap(rs, rAcc));
							}(
								A3(
									makeConstructor,
									$author$project$NoUnsortedRecords$TypeWithPositionalVars(
										$author$project$NoUnsortedRecords$getType(
											A2(
												$author$project$NoUnsortedRecords$assignTypeVars,
												$author$project$NoUnsortedRecords$makePositionalArgTypeVars(args),
												$author$project$NoUnsortedRecords$DereferencedType(
													A2(
														$author$project$NoUnsortedRecords$NamedType,
														_Utils_Tuple2(moduleName, name),
														A2(
															$elm$core$List$map,
															$author$project$NoUnsortedRecords$TypeVar($elm$core$Maybe$Nothing),
															args)))))),
									args,
									t));
						}),
					_Utils_Tuple2(_List_Nil, _List_Nil),
					tags);
			};
			var functionFromValue = function (_v12) {
				var name = _v12.name;
				var tipe = _v12.tipe;
				return A2(
					$elm$core$Tuple$pair,
					name,
					A3(
						$author$project$NoUnsortedRecords$docTypeToType,
						moduleName,
						{constrainedTypeVarsAreRespected: true, subrecordIsAlsoCanonical: $elm$core$Maybe$Nothing},
						tipe));
			};
			var functionFromOperator = function (_v11) {
				var name = _v11.name;
				var tipe = _v11.tipe;
				return A2(
					$elm$core$Tuple$pair,
					name,
					A3(
						$author$project$NoUnsortedRecords$docTypeToType,
						moduleName,
						{constrainedTypeVarsAreRespected: true, subrecordIsAlsoCanonical: $elm$core$Maybe$Nothing},
						tipe));
			};
			var newOperators = $elm$core$Dict$fromList(
				A2($elm$core$List$map, functionFromOperator, binops));
			var newFunctions = A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$pair(moduleName),
				A2(
					$author$project$Util$validate,
					A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$Dict$isEmpty),
					A2(
						$elm$core$Dict$union,
						newOperators,
						$elm$core$Dict$fromList(
							A2($elm$core$List$map, functionFromValue, values)))));
			var _v3 = A3(
				$elm$core$Tuple$mapBoth,
				A2($elm$core$Basics$composeL, $elm$core$Dict$fromList, $elm$core$List$concat),
				A2($elm$core$Basics$composeL, $elm$core$Dict$fromList, $elm$core$List$concat),
				$elm$core$List$unzip(
					A2($elm$core$List$map, recordFromTypeAlias, aliases)));
			var newAliasRecords = _v3.a;
			var newRecordConstructors = _v3.b;
			var _v4 = A3(
				$elm$core$Tuple$mapBoth,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$Dict$fromList,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$Dict$union(newRecordConstructors),
						A2(
							$elm$core$Basics$composeR,
							$author$project$Util$validate(
								A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$Dict$isEmpty)),
							$elm$core$Maybe$map(
								$elm$core$Tuple$pair(moduleName))))),
				A2(
					$elm$core$Basics$composeR,
					$elm$core$Dict$fromList,
					A2(
						$elm$core$Basics$composeR,
						$elm$core$Dict$union(newAliasRecords),
						A2(
							$elm$core$Basics$composeR,
							$author$project$Util$validate(
								A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$Dict$isEmpty)),
							$elm$core$Maybe$map(
								$elm$core$Tuple$pair(moduleName))))),
				A3(
					$elm$core$List$foldl,
					F2(
						function (u, _v5) {
							var fAcc = _v5.a;
							var rAcc = _v5.b;
							return function (_v6) {
								var fs = _v6.a;
								var rs = _v6.b;
								return _Utils_Tuple2(
									_Utils_ap(fs, fAcc),
									_Utils_ap(rs, rAcc));
							}(
								functionsFromCustomType(u));
						}),
					_Utils_Tuple2(_List_Nil, _List_Nil),
					unions));
			var newConstructors = _v4.a;
			var newRecords = _v4.b;
			return _Utils_update(
				acc,
				{
					aliases: A3(
						$elm_community$maybe_extra$Maybe$Extra$unwrap,
						acc.aliases,
						function (_v7) {
							var k = _v7.a;
							var v = _v7.b;
							return A3($elm$core$Dict$insert, k, v, acc.aliases);
						},
						newAliases),
					canonicalRecords: A3(
						$elm_community$maybe_extra$Maybe$Extra$unwrap,
						acc.canonicalRecords,
						function (_v8) {
							var k = _v8.a;
							var v = _v8.b;
							return A3($elm$core$Dict$insert, k, v, acc.canonicalRecords);
						},
						newRecords),
					constructors: A3(
						$elm_community$maybe_extra$Maybe$Extra$unwrap,
						acc.constructors,
						function (_v9) {
							var k = _v9.a;
							var v = _v9.b;
							return A3($elm$core$Dict$insert, k, v, acc.constructors);
						},
						newConstructors),
					functionTypes: A3(
						$elm_community$maybe_extra$Maybe$Extra$unwrap,
						acc.functionTypes,
						function (_v10) {
							var k = _v10.a;
							var v = _v10.b;
							return A3($elm$core$Dict$insert, k, v, acc.functionTypes);
						},
						newFunctions)
				});
		});
	return $elm$core$Dict$foldl(
		F3(
			function (_v1, dep, acc) {
				return function (_v2) {
					var aliases = _v2.aliases;
					var canonicalRecords = _v2.canonicalRecords;
					var constructors = _v2.constructors;
					var functionTypes = _v2.functionTypes;
					return _Utils_update(
						acc,
						{
							aliases: A2($elm$core$Dict$union, aliases, acc.aliases),
							canonicalRecords: A2($elm$core$Dict$union, canonicalRecords, acc.canonicalRecords),
							constructors: A2($elm$core$Dict$union, constructors, acc.constructors),
							functionTypes: A2($elm$core$Dict$union, functionTypes, acc.functionTypes)
						});
				}(
					A3(
						$elm$core$List$foldl,
						step,
						$author$project$NoUnsortedRecords$initialProjectContext,
						$jfmengels$elm_review$Review$Project$Dependency$modules(dep)));
			}));
};
var $author$project$NoUnsortedRecords$foldProjectContexts = F2(
	function (newContext, prevContext) {
		return {
			aliases: A2($elm$core$Dict$union, newContext.aliases, prevContext.aliases),
			canonicalRecords: A2($elm$core$Dict$union, newContext.canonicalRecords, prevContext.canonicalRecords),
			constructors: A2($elm$core$Dict$union, newContext.constructors, prevContext.constructors),
			functionTypes: A2($elm$core$Dict$union, newContext.functionTypes, prevContext.functionTypes)
		};
	});
var $author$project$NoUnsortedRecords$fromModuleToProject = $jfmengels$elm_review$Review$Rule$withModuleName(
	$jfmengels$elm_review$Review$Rule$initContextCreator(
		F2(
			function (moduleName, _v0) {
				var exposed = _v0.exposed;
				return {
					aliases: $elm$core$Dict$isEmpty(exposed.aliases) ? $elm$core$Dict$empty : A2($elm$core$Dict$singleton, moduleName, exposed.aliases),
					canonicalRecords: $elm$core$Dict$isEmpty(exposed.canonicalRecords) ? $elm$core$Dict$empty : A2($elm$core$Dict$singleton, moduleName, exposed.canonicalRecords),
					constructors: $elm$core$Dict$isEmpty(exposed.constructors) ? $elm$core$Dict$empty : A2($elm$core$Dict$singleton, moduleName, exposed.constructors),
					functionTypes: $elm$core$Dict$isEmpty(exposed.functionTypes) ? $elm$core$Dict$empty : A2($elm$core$Dict$singleton, moduleName, exposed.functionTypes)
				};
			})));
var $author$project$NoUnsortedRecords$annotToFields = function (annot) {
	var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(annot);
	switch (_v0.$) {
		case 'Record':
			var fields = _v0.a;
			return $elm$core$Maybe$Just(
				_Utils_Tuple2(fields, false));
		case 'GenericRecord':
			var fields = _v0.b;
			return $elm$core$Maybe$Just(
				_Utils_Tuple2(
					$stil4m$elm_syntax$Elm$Syntax$Node$value(fields),
					true));
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $author$project$NoUnsortedRecords$typeAnnotToType = F3(
	function (context, settings, annot) {
		var constrainedTypeVarsAreRespected = settings.constrainedTypeVarsAreRespected;
		var subrecordIsAlsoCanonical = settings.subrecordIsAlsoCanonical;
		var go = function (subrecordStillCanon) {
			return A2(
				$author$project$NoUnsortedRecords$typeAnnotToType,
				context,
				_Utils_update(
					settings,
					{subrecordIsAlsoCanonical: subrecordStillCanon}));
		}(
			A2($elm_community$maybe_extra$Maybe$Extra$filter, $elm$core$Basics$identity, subrecordIsAlsoCanonical));
		var makeList = F3(
			function (moduleName, name, args) {
				var _v3 = _Utils_Tuple3(moduleName, name, args);
				if (((((_v3.a.b && (_v3.a.a === 'List')) && (!_v3.a.b.b)) && (_v3.b === 'List')) && _v3.c.b) && (!_v3.c.b.b)) {
					var _v4 = _v3.a;
					var _v5 = _v3.c;
					var listType = _v5.a;
					return $elm$core$Maybe$Just(
						$author$project$NoUnsortedRecords$ListType(
							go(listType)));
				} else {
					return $elm$core$Maybe$Nothing;
				}
			});
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(annot);
		switch (_v0.$) {
			case 'Typed':
				var name = _v0.a;
				var args = _v0.b;
				return function (_v1) {
					var n = _v1.a;
					var moduleName = _v1.b;
					return A2(
						$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
						function (_v2) {
							return A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(moduleName, n),
								A2($elm$core$List$map, go, args));
						},
						A3(makeList, moduleName, n, args));
				}(
					A2(
						$elm$core$Tuple$pair,
						$stil4m$elm_syntax$Elm$Syntax$Node$value(name).b,
						function (moduleName) {
							return _Utils_eq(moduleName, _List_Nil) ? context.moduleName : moduleName;
						}(
							A2(
								$elm$core$Maybe$withDefault,
								$stil4m$elm_syntax$Elm$Syntax$Node$value(name).a,
								A2($jfmengels$elm_review$Review$ModuleNameLookupTable$moduleNameFor, context.lookupTable, name)))));
			case 'Unit':
				return $author$project$NoUnsortedRecords$UnitType;
			case 'Tupled':
				var ts = _v0.a;
				return $author$project$NoUnsortedRecords$TupleType(
					A2($elm$core$List$map, go, ts));
			case 'Record':
				var fs = _v0.a;
				return $author$project$NoUnsortedRecords$RecordType(
					{
						canonical: !_Utils_eq(subrecordIsAlsoCanonical, $elm$core$Maybe$Nothing),
						fields: A2(
							$elm$core$List$map,
							A2(
								$elm$core$Basics$composeL,
								A2($elm$core$Tuple$mapBoth, $stil4m$elm_syntax$Elm$Syntax$Node$value, go),
								$stil4m$elm_syntax$Elm$Syntax$Node$value),
							fs),
						generic: $elm$core$Maybe$Nothing
					});
			case 'GenericRecord':
				var generic = _v0.a;
				var fs = _v0.b;
				return $author$project$NoUnsortedRecords$RecordType(
					{
						canonical: !_Utils_eq(subrecordIsAlsoCanonical, $elm$core$Maybe$Nothing),
						fields: A2(
							$elm$core$List$map,
							A2(
								$elm$core$Basics$composeL,
								A2($elm$core$Tuple$mapBoth, $stil4m$elm_syntax$Elm$Syntax$Node$value, go),
								$stil4m$elm_syntax$Elm$Syntax$Node$value),
							$stil4m$elm_syntax$Elm$Syntax$Node$value(fs)),
						generic: $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$TypeVar,
								$elm$core$Maybe$Nothing,
								$stil4m$elm_syntax$Elm$Syntax$Node$value(generic)))
					});
			case 'FunctionTypeAnnotation':
				var from = _v0.a;
				var to = _v0.b;
				return $author$project$NoUnsortedRecords$FunctionType(
					{
						from: go(from),
						to: go(to)
					});
			default:
				var s = _v0.a;
				return A2($author$project$NoUnsortedRecords$makeTypeVar, constrainedTypeVarsAreRespected, s);
		}
	});
var $author$project$NoUnsortedRecords$knownRecordFromTypeAnnot = F3(
	function (subrecordTreatment, context, _v0) {
		var fields = _v0.a;
		var isGeneric = _v0.b;
		return function (k) {
			return _Utils_eq(subrecordTreatment, $author$project$NoUnsortedRecords$AlwaysCanonical) ? A2(
				$elm$core$List$cons,
				_Utils_Tuple2('', k),
				A2(
					$elm$core$List$concatMap,
					function (_v2) {
						var f = _v2.a;
						var _v3 = _v2.b;
						var t = _v3.b;
						return A3($author$project$NoUnsortedRecords$makeSubrecordsFromType, true, '.' + f, t);
					},
					$elm$core$Dict$toList(k.order))) : _List_fromArray(
				[
					_Utils_Tuple2('', k)
				]);
		}(
			function (order) {
				return {isGeneric: isGeneric, isSubrecord: false, order: order};
			}(
				A3(
					$elm_community$list_extra$List$Extra$indexedFoldl,
					F2(
						function (i, field) {
							var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(field);
							var f = _v1.a;
							var t = _v1.b;
							return A2(
								$elm$core$Dict$insert,
								$stil4m$elm_syntax$Elm$Syntax$Node$value(f),
								_Utils_Tuple2(
									i,
									A3(
										$author$project$NoUnsortedRecords$typeAnnotToType,
										context,
										{
											constrainedTypeVarsAreRespected: false,
											subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
										},
										t)));
						}),
					$elm$core$Dict$empty,
					fields)));
	});
var $author$project$NoUnsortedRecords$typeAnnotToNoncanonicalType = function (context) {
	return A2(
		$author$project$NoUnsortedRecords$typeAnnotToType,
		context,
		{constrainedTypeVarsAreRespected: true, subrecordIsAlsoCanonical: $elm$core$Maybe$Nothing});
};
var $author$project$NoUnsortedRecords$typeAnnotToTypeWithPositionalVars = F3(
	function (context, settings, typeArgs) {
		return A2(
			$elm$core$Basics$composeR,
			A2($author$project$NoUnsortedRecords$typeAnnotToType, context, settings),
			A2(
				$elm$core$Basics$composeR,
				$author$project$NoUnsortedRecords$DereferencedType,
				A2(
					$elm$core$Basics$composeR,
					$author$project$NoUnsortedRecords$assignTypeVars(
						$author$project$NoUnsortedRecords$makePositionalArgTypeVars(typeArgs)),
					A2($elm$core$Basics$composeR, $author$project$NoUnsortedRecords$getType, $author$project$NoUnsortedRecords$TypeWithPositionalVars))));
	});
var $author$project$NoUnsortedRecords$accumulateDeclarationInfo = F4(
	function (subrecordTreatment, context, node, acc) {
		var skipIfIgnored = F5(
			function (checkIfExposed, acc_, makeInfo, addLocal, addExposed) {
				var isExposed = A3($elm_community$maybe_extra$Maybe$Extra$unwrap, true, checkIfExposed, context.exposingList);
				var _v13 = _Utils_Tuple2(context.fileIsIgnored, isExposed);
				if (_v13.a) {
					if (!_v13.b) {
						return acc_;
					} else {
						return A2(
							addExposed,
							makeInfo(_Utils_Tuple0),
							acc_);
					}
				} else {
					if (_v13.b) {
						var info = makeInfo(_Utils_Tuple0);
						return A2(
							addExposed,
							info,
							A2(addLocal, info, acc_));
					} else {
						return A2(
							addLocal,
							makeInfo(_Utils_Tuple0),
							acc_);
					}
				}
			});
		var makeConstructorAndSubrecords = F3(
			function (_return, typeVars, _v12) {
				var name = _v12.name;
				var _arguments = _v12._arguments;
				return function (ts) {
					var n = $stil4m$elm_syntax$Elm$Syntax$Node$value(name);
					return _Utils_Tuple3(
						n,
						A2($author$project$NoUnsortedRecords$makeFunctionTypeWithPositionalVars, _return, ts),
						A3($author$project$NoUnsortedRecords$makeCustomTypeSubrecords, subrecordTreatment, n, ts));
				}(
					A2(
						$elm$core$List$map,
						A3(
							$author$project$NoUnsortedRecords$typeAnnotToTypeWithPositionalVars,
							context,
							{
								constrainedTypeVarsAreRespected: true,
								subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
							},
							A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, typeVars)),
						_arguments));
			});
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'FunctionDeclaration':
				var signature = _v0.a.signature;
				return A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					acc,
					function (_v1) {
						var name = _v1.name;
						var typeAnnotation = _v1.typeAnnotation;
						var n = $stil4m$elm_syntax$Elm$Syntax$Node$value(name);
						return A5(
							skipIfIgnored,
							A2(
								$elm$core$Basics$composeL,
								$elm$core$Set$member(n),
								function ($) {
									return $.functions;
								}),
							acc,
							function (_v2) {
								return _Utils_Tuple2(
									n,
									A2($author$project$NoUnsortedRecords$typeAnnotToNoncanonicalType, context, typeAnnotation));
							},
							F2(
								function (info, acc_) {
									return _Utils_update(
										acc_,
										{
											functionTypes: A2($elm$core$List$cons, info, acc.functionTypes)
										});
								}),
							F2(
								function (info, acc_) {
									return _Utils_update(
										acc_,
										{
											exposedFunctionTypes: A2($elm$core$List$cons, info, acc.exposedFunctionTypes)
										});
								}));
					},
					A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, signature));
			case 'CustomTypeDeclaration':
				var name = _v0.a.name;
				var generics = _v0.a.generics;
				var constructors = _v0.a.constructors;
				var n = $stil4m$elm_syntax$Elm$Syntax$Node$value(name);
				return A5(
					skipIfIgnored,
					A2(
						$elm$core$Basics$composeL,
						$elm$core$Set$member(n),
						function ($) {
							return $.openTypes;
						}),
					acc,
					function (_v3) {
						return A3(
							$elm$core$List$foldl,
							F2(
								function (c, _v4) {
									var fAcc = _v4.a;
									var rAcc = _v4.b;
									return function (_v5) {
										var n_ = _v5.a;
										var type_ = _v5.b;
										var rs = _v5.c;
										return _Utils_Tuple2(
											A2(
												$elm$core$List$cons,
												_Utils_Tuple2(
													n_,
													{
														customTypeName: $elm$core$Maybe$Just(n),
														type_: type_
													}),
												fAcc),
											_Utils_ap(rs, rAcc));
									}(
										A3(
											makeConstructorAndSubrecords,
											function (gs) {
												return $author$project$NoUnsortedRecords$TypeWithPositionalVars(
													$author$project$NoUnsortedRecords$getType(
														A2(
															$author$project$NoUnsortedRecords$assignTypeVars,
															$author$project$NoUnsortedRecords$makePositionalArgTypeVars(gs),
															$author$project$NoUnsortedRecords$DereferencedType(
																A2(
																	$author$project$NoUnsortedRecords$NamedType,
																	_Utils_Tuple2(_List_Nil, n),
																	A2(
																		$elm$core$List$map,
																		$author$project$NoUnsortedRecords$TypeVar($elm$core$Maybe$Nothing),
																		gs))))));
											}(
												A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, generics)),
											generics,
											$stil4m$elm_syntax$Elm$Syntax$Node$value(c)));
								}),
							_Utils_Tuple2(_List_Nil, _List_Nil),
							constructors);
					},
					F2(
						function (_v6, acc_) {
							var newConstructors = _v6.a;
							var newRecords = _v6.b;
							return _Utils_update(
								acc_,
								{
									canonicalRecords: _Utils_ap(newRecords, acc.canonicalRecords),
									constructors: _Utils_ap(newConstructors, acc.constructors)
								});
						}),
					F2(
						function (_v7, acc_) {
							var newConstructors = _v7.a;
							var newRecords = _v7.b;
							return _Utils_update(
								acc_,
								{
									exposedCanonicalRecords: _Utils_ap(newRecords, acc.exposedCanonicalRecords),
									exposedConstructors: _Utils_ap(newConstructors, acc.exposedConstructors)
								});
						}));
			case 'AliasDeclaration':
				var name = _v0.a.name;
				var generics = _v0.a.generics;
				var typeAnnotation = _v0.a.typeAnnotation;
				var n = $stil4m$elm_syntax$Elm$Syntax$Node$value(name);
				var aliasInfo = _Utils_Tuple2(
					n,
					A4(
						$author$project$NoUnsortedRecords$typeAnnotToTypeWithPositionalVars,
						context,
						{
							constrainedTypeVarsAreRespected: false,
							subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForRecord(subrecordTreatment)
						},
						A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, generics),
						typeAnnotation));
				return A5(
					skipIfIgnored,
					A2(
						$elm$core$Basics$composeL,
						$elm$core$Set$member(n),
						function ($) {
							return $.types;
						}),
					_Utils_update(
						acc,
						{
							exposedAliases: A2($elm$core$List$cons, aliasInfo, acc.exposedAliases)
						}),
					function (_v8) {
						return A3(
							$elm_community$maybe_extra$Maybe$Extra$unwrap,
							_Utils_Tuple2(_List_Nil, _List_Nil),
							function (_v9) {
								var fields = _v9.a;
								var isGeneric = _v9.b;
								return _Utils_Tuple2(
									isGeneric ? _List_Nil : _List_fromArray(
										[
											_Utils_Tuple2(
											n,
											{
												customTypeName: $elm$core$Maybe$Nothing,
												type_: function (vars) {
													return A2(
														$author$project$NoUnsortedRecords$makeFunctionTypeWithPositionalVars,
														A4(
															$author$project$NoUnsortedRecords$typeAnnotToTypeWithPositionalVars,
															context,
															{
																constrainedTypeVarsAreRespected: true,
																subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForRecord(subrecordTreatment)
															},
															vars,
															typeAnnotation),
														A2(
															$elm$core$List$map,
															A2(
																$elm$core$Basics$composeR,
																$stil4m$elm_syntax$Elm$Syntax$Node$value,
																A2(
																	$elm$core$Basics$composeR,
																	$elm$core$Tuple$second,
																	A3(
																		$author$project$NoUnsortedRecords$typeAnnotToTypeWithPositionalVars,
																		context,
																		{
																			constrainedTypeVarsAreRespected: true,
																			subrecordIsAlsoCanonical: $author$project$NoUnsortedRecords$subrecordCanonicityForField(subrecordTreatment)
																		},
																		vars))),
															fields));
												}(
													A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, generics))
											})
										]),
									A2(
										$elm$core$List$map,
										$elm$core$Tuple$mapFirst(
											function (s) {
												return _Utils_ap(n, s);
											}),
										A3(
											$author$project$NoUnsortedRecords$knownRecordFromTypeAnnot,
											subrecordTreatment,
											context,
											_Utils_Tuple2(fields, isGeneric))));
							},
							$author$project$NoUnsortedRecords$annotToFields(typeAnnotation));
					},
					F2(
						function (_v10, acc_) {
							var newConstructors = _v10.a;
							var newRecords = _v10.b;
							return _Utils_update(
								acc_,
								{
									aliases: A2($elm$core$List$cons, aliasInfo, acc.aliases),
									canonicalRecords: _Utils_ap(newRecords, acc.canonicalRecords),
									constructors: _Utils_ap(newConstructors, acc.constructors)
								});
						}),
					F2(
						function (_v11, acc_) {
							var newConstructors = _v11.a;
							var newRecords = _v11.b;
							return _Utils_update(
								acc_,
								{
									exposedCanonicalRecords: _Utils_ap(newRecords, acc.exposedCanonicalRecords),
									exposedConstructors: _Utils_ap(newConstructors, acc.exposedConstructors)
								});
						}));
			default:
				return acc;
		}
	});
var $author$project$NoUnsortedRecords$declarationListVisitor = F3(
	function (_v0, context, declarations) {
		var subrecordTreatment = _v0.a.subrecordTreatment;
		return function (r) {
			return context.fileIsIgnored ? {
				aliases: $elm$core$Dict$empty,
				canonicalRecords: $elm$core$Dict$empty,
				constructors: $elm$core$Dict$empty,
				exposed: {
					aliases: $elm$core$Dict$fromList(r.exposedAliases),
					canonicalRecords: $elm$core$Dict$fromList(r.exposedCanonicalRecords),
					constructors: $elm$core$Dict$fromList(r.exposedConstructors),
					functionTypes: $elm$core$Dict$fromList(r.exposedFunctionTypes)
				},
				functionTypes: $elm$core$Dict$empty
			} : {
				aliases: A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					context.aliases,
					function (v) {
						return A3($elm$core$Dict$insert, context.moduleName, v, context.aliases);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$Dict$fromList,
						A2(
							$author$project$Util$validate,
							A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
							r.aliases))),
				canonicalRecords: A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					context.canonicalRecords,
					function (v) {
						return A3($elm$core$Dict$insert, context.moduleName, v, context.canonicalRecords);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$Dict$fromList,
						A2(
							$author$project$Util$validate,
							A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
							r.canonicalRecords))),
				constructors: A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					context.constructors,
					function (v) {
						return A3($elm$core$Dict$insert, context.moduleName, v, context.constructors);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$Dict$fromList,
						A2(
							$author$project$Util$validate,
							A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
							r.constructors))),
				exposed: {
					aliases: $elm$core$Dict$fromList(r.exposedAliases),
					canonicalRecords: $elm$core$Dict$fromList(r.exposedCanonicalRecords),
					constructors: $elm$core$Dict$fromList(r.exposedConstructors),
					functionTypes: $elm$core$Dict$fromList(r.exposedFunctionTypes)
				},
				functionTypes: A3(
					$elm_community$maybe_extra$Maybe$Extra$unwrap,
					context.functionTypes,
					function (v) {
						return A3($elm$core$Dict$insert, context.moduleName, v, context.functionTypes);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$Dict$fromList,
						A2(
							$author$project$Util$validate,
							A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
							r.functionTypes)))
			};
		}(
			A3(
				$elm$core$List$foldl,
				A2($author$project$NoUnsortedRecords$accumulateDeclarationInfo, subrecordTreatment, context),
				{aliases: _List_Nil, canonicalRecords: _List_Nil, constructors: _List_Nil, exposedAliases: _List_Nil, exposedCanonicalRecords: _List_Nil, exposedConstructors: _List_Nil, exposedFunctionTypes: _List_Nil, functionTypes: _List_Nil},
				declarations));
	});
var $author$project$NoUnsortedRecords$getExposedNames = function () {
	var step = F2(
		function (e, acc) {
			var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(e);
			switch (_v1.$) {
				case 'FunctionExpose':
					var name = _v1.a;
					return _Utils_update(
						acc,
						{
							functions: A2($elm$core$Set$insert, name, acc.functions)
						});
				case 'TypeExpose':
					var name = _v1.a.name;
					return _Utils_update(
						acc,
						{
							openTypes: A2($elm$core$Set$insert, name, acc.openTypes)
						});
				case 'InfixExpose':
					var name = _v1.a;
					return _Utils_update(
						acc,
						{
							functions: A2($elm$core$Set$insert, name, acc.functions)
						});
				default:
					var name = _v1.a;
					return _Utils_update(
						acc,
						{
							types: A2($elm$core$Set$insert, name, acc.types)
						});
			}
		});
	return A2(
		$elm$core$Basics$composeR,
		$stil4m$elm_syntax$Elm$Syntax$Module$exposingList,
		function (l) {
			if (l.$ === 'All') {
				return $elm$core$Maybe$Nothing;
			} else {
				var es = l.a;
				return $elm$core$Maybe$Just(
					A3(
						$elm$core$List$foldl,
						step,
						{functions: $elm$core$Set$empty, openTypes: $elm$core$Set$empty, types: $elm$core$Set$empty},
						es));
			}
		});
}();
var $author$project$NoUnsortedRecords$fromProjectToModule = function (config) {
	return $jfmengels$elm_review$Review$Rule$withFullAst(
		$jfmengels$elm_review$Review$Rule$withIsFileIgnored(
			$jfmengels$elm_review$Review$Rule$withModuleName(
				$jfmengels$elm_review$Review$Rule$withSourceCodeExtractor(
					$jfmengels$elm_review$Review$Rule$withModuleNameLookupTable(
						$jfmengels$elm_review$Review$Rule$initContextCreator(
							F6(
								function (lookupTable, sourceCodeExtractor, moduleName, fileIsIgnored, _v0, projectContext) {
									var moduleDefinition = _v0.moduleDefinition;
									var declarations = _v0.declarations;
									var _v1 = A3(
										$author$project$NoUnsortedRecords$declarationListVisitor,
										config,
										{
											aliases: projectContext.aliases,
											canonicalRecords: projectContext.canonicalRecords,
											constructors: projectContext.constructors,
											exposingList: $author$project$NoUnsortedRecords$getExposedNames(
												$stil4m$elm_syntax$Elm$Syntax$Node$value(moduleDefinition)),
											fileIsIgnored: fileIsIgnored,
											functionTypes: projectContext.functionTypes,
											lookupTable: lookupTable,
											moduleName: moduleName
										},
										declarations);
									var aliases = _v1.aliases;
									var canonicalRecords = _v1.canonicalRecords;
									var constructors = _v1.constructors;
									var functionTypes = _v1.functionTypes;
									var exposed = _v1.exposed;
									return {aliases: aliases, canonicalRecords: canonicalRecords, constructors: constructors, exposed: exposed, extractSource: sourceCodeExtractor, fileIsIgnored: fileIsIgnored, functionTypes: functionTypes, lookupTable: lookupTable, moduleName: moduleName};
								})))))));
};
var $author$project$NoUnsortedRecords$assignPositionalTypeVars = F2(
	function (ts, t) {
		return $author$project$NoUnsortedRecords$getType(
			function (vars) {
				return A2(
					$author$project$NoUnsortedRecords$assignTypeVars,
					vars,
					$author$project$NoUnsortedRecords$DereferencedType(
						$author$project$NoUnsortedRecords$getTypeWithPositionalVars(t)));
			}(
				$elm$core$Dict$fromList(
					A2(
						$elm$core$List$indexedMap,
						function (i) {
							return $elm$core$Tuple$pair(
								'positional arg ' + $elm$core$String$fromInt(i));
						},
						ts))));
	});
var $author$project$NoUnsortedRecords$dereferenceType = F2(
	function (context, type_) {
		var dropFields = F2(
			function (toDrop, t) {
				if (t.$ === 'RecordType') {
					var r = t.a;
					return $author$project$NoUnsortedRecords$RecordType(
						_Utils_update(
							r,
							{
								fields: A2(
									$elm$core$List$filter,
									function (_v1) {
										var f = _v1.a;
										return !A2($elm$core$Set$member, f, toDrop);
									},
									r.fields),
								generic: A2(
									$elm$core$Maybe$map,
									dropFields(toDrop),
									r.generic)
							}));
				} else {
					var notARecord = t;
					return notARecord;
				}
			});
		var go = function (t) {
			switch (t.$) {
				case 'FunctionType':
					var from = t.a.from;
					var to = t.a.to;
					return $author$project$NoUnsortedRecords$FunctionType(
						{
							from: go(from),
							to: go(to)
						});
				case 'TupleType':
					var ts = t.a;
					return $author$project$NoUnsortedRecords$TupleType(
						A2($elm$core$List$map, go, ts));
				case 'ListType':
					var t_ = t.a;
					return $author$project$NoUnsortedRecords$ListType(
						go(t_));
				case 'NamedType':
					var _v3 = t.a;
					var moduleName = _v3.a;
					var name = _v3.b;
					var ts = t.b;
					var ts_ = A2($elm$core$List$map, go, ts);
					return A2(
						$elm$core$Maybe$withDefault,
						A2(
							$author$project$NoUnsortedRecords$NamedType,
							_Utils_Tuple2(moduleName, name),
							ts_),
						A2(
							$elm$core$Maybe$map,
							A2(
								$elm$core$Basics$composeL,
								go,
								$author$project$NoUnsortedRecords$assignPositionalTypeVars(ts_)),
							A2(
								$elm$core$Maybe$andThen,
								$elm$core$Dict$get(name),
								A2($elm$core$Dict$get, moduleName, context.aliases))));
				case 'RecordType':
					var r = t.a;
					var fields = A2(
						$elm$core$List$map,
						$elm$core$Tuple$mapSecond(go),
						r.fields);
					return $author$project$NoUnsortedRecords$RecordType(
						_Utils_update(
							r,
							{
								fields: fields,
								generic: A2(
									$elm$core$Maybe$map,
									dropFields(
										$elm$core$Set$fromList(
											A2($elm$core$List$map, $elm$core$Tuple$first, fields))),
									A2($elm$core$Maybe$map, go, r.generic))
							}));
				default:
					return t;
			}
		};
		return $author$project$NoUnsortedRecords$DereferencedType(
			go(type_));
	});
var $author$project$NoUnsortedRecords$flattenFunctionType = function () {
	var go = function (t) {
		if (t.$ === 'FunctionType') {
			var from = t.a.from;
			var to = t.a.to;
			return A2(
				$elm$core$List$cons,
				from,
				go(to));
		} else {
			var otherType = t;
			return _List_fromArray(
				[otherType]);
		}
	};
	return A2(
		$elm$core$Basics$composeR,
		$author$project$NoUnsortedRecords$getType,
		A2(
			$elm$core$Basics$composeR,
			go,
			$elm$core$List$map($author$project$NoUnsortedRecords$DereferencedType)));
}();
var $elm_community$maybe_extra$Maybe$Extra$orElseLazy = F2(
	function (fma, mb) {
		if (mb.$ === 'Nothing') {
			return fma(_Utils_Tuple0);
		} else {
			return mb;
		}
	});
var $author$project$NoUnsortedRecords$findFunctionType = F4(
	function (_v0, type_, moduleNode, name) {
		var context = _v0.context;
		var localFunctions = _v0.localFunctions;
		var getTypeVars = function (t) {
			var _v2 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, t);
			if ((_v2.$ === 'Just') && (_v2.a.$ === 'NamedType')) {
				var _v3 = _v2.a;
				var ts = _v3.b;
				return ts;
			} else {
				return _List_Nil;
			}
		};
		return A2(
			$elm$core$Maybe$map,
			A2(
				$elm$core$Basics$composeL,
				$author$project$NoUnsortedRecords$flattenFunctionType,
				$author$project$NoUnsortedRecords$dereferenceType(context)),
			A2(
				$elm$core$Maybe$andThen,
				function (moduleName) {
					return A3(
						$elm_community$maybe_extra$Maybe$Extra$unwrap,
						false,
						A2($elm$core$Basics$composeL, $elm$core$Char$isUpper, $elm$core$Tuple$first),
						$elm$core$String$uncons(name)) ? A2(
						$elm$core$Maybe$map,
						$author$project$NoUnsortedRecords$assignPositionalTypeVars(
							getTypeVars(type_)),
						A2(
							$elm$core$Maybe$map,
							function ($) {
								return $.type_;
							},
							A2(
								$elm$core$Maybe$andThen,
								$elm$core$Dict$get(name),
								A2($elm$core$Dict$get, moduleName, context.constructors)))) : A2(
						$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
						function (_v1) {
							return A2($elm$core$Dict$get, name, localFunctions);
						},
						A2(
							$elm$core$Maybe$andThen,
							$elm$core$Dict$get(name),
							A2($elm$core$Dict$get, moduleName, context.functionTypes)));
				},
				A2(
					$elm$core$Maybe$map,
					function (moduleName) {
						return _Utils_eq(moduleName, _List_Nil) ? context.moduleName : moduleName;
					},
					A2($jfmengels$elm_review$Review$ModuleNameLookupTable$moduleNameFor, context.lookupTable, moduleNode))));
	});
var $author$project$NoUnsortedRecords$getListType = function (assocType) {
	var _v0 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, assocType);
	if ((_v0.$ === 'Just') && (_v0.a.$ === 'ListType')) {
		var t = _v0.a.a;
		return $elm$core$Maybe$Just(
			$author$project$NoUnsortedRecords$DereferencedType(t));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$NoUnsortedRecords$getRecordFieldTypes = function (type_) {
	var _v0 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, type_);
	if ((_v0.$ === 'Just') && (_v0.a.$ === 'RecordType')) {
		var fields = _v0.a.a.fields;
		return $elm$core$Dict$fromList(
			A2(
				$elm$core$List$map,
				$elm$core$Tuple$mapSecond($author$project$NoUnsortedRecords$DereferencedType),
				fields));
	} else {
		return $elm$core$Dict$empty;
	}
};
var $author$project$NoUnsortedRecords$getTupleTypes = F2(
	function (emptyList, assocType) {
		var _v0 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, assocType);
		if ((_v0.$ === 'Just') && (_v0.a.$ === 'TupleType')) {
			var ts = _v0.a.a;
			return A2(
				$elm$core$List$map,
				A2($elm$core$Basics$composeL, $elm$core$Maybe$Just, $author$project$NoUnsortedRecords$DereferencedType),
				ts);
		} else {
			return A2(
				$elm$core$List$map,
				$elm$core$Basics$always($elm$core$Maybe$Nothing),
				emptyList);
		}
	});
var $author$project$NoUnsortedRecords$bindingsInPatternWithType = F3(
	function (context, pattern, type_) {
		var makeType = F2(
			function (n, t) {
				return A2(
					$elm$core$Maybe$withDefault,
					_List_Nil,
					A2(
						$elm$core$Maybe$map,
						A2(
							$elm$core$Basics$composeL,
							$elm$core$List$singleton,
							$elm$core$Tuple$pair(n)),
						A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, t)));
			});
		var go = $author$project$NoUnsortedRecords$bindingsInPatternWithType(context);
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(pattern);
		switch (_v0.$) {
			case 'ListPattern':
				var ps = _v0.a;
				return function (t) {
					return A2(
						$elm$core$List$concatMap,
						function (p) {
							return A2(go, p, t);
						},
						ps);
				}(
					$author$project$NoUnsortedRecords$getListType(type_));
			case 'TuplePattern':
				var ps = _v0.a;
				return $elm$core$List$concat(
					A3(
						$elm$core$List$map2,
						go,
						ps,
						A2($author$project$NoUnsortedRecords$getTupleTypes, ps, type_)));
			case 'RecordPattern':
				var ps = _v0.a;
				return $elm$core$List$concat(
					function (ts) {
						return A2(
							$elm$core$List$map,
							function (p) {
								return A2(
									makeType,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(p),
									A2(
										$elm$core$Dict$get,
										$stil4m$elm_syntax$Elm$Syntax$Node$value(p),
										ts));
							},
							ps);
					}(
						$author$project$NoUnsortedRecords$getRecordFieldTypes(type_)));
			case 'NamedPattern':
				var name = _v0.a.name;
				var ps = _v0.b;
				return A2(
					$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
					function (_v1) {
						return A2(
							$elm$core$List$concatMap,
							function (p) {
								return A2(go, p, $elm$core$Maybe$Nothing);
							},
							ps);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$List$concat,
						A2(
							$elm$core$Maybe$map,
							A2(
								$elm$core$List$map2,
								F2(
									function (p, t) {
										return A2(
											go,
											p,
											$elm$core$Maybe$Just(t));
									}),
								ps),
							A4(
								$author$project$NoUnsortedRecords$findFunctionType,
								{context: context, localFunctions: $elm$core$Dict$empty},
								type_,
								pattern,
								name))));
			case 'UnConsPattern':
				var p = _v0.a;
				var ps = _v0.b;
				return function (t) {
					return _Utils_ap(
						A2(go, p, t),
						A2(go, ps, type_));
				}(
					$author$project$NoUnsortedRecords$getListType(type_));
			case 'VarPattern':
				var name = _v0.a;
				return A2(makeType, name, type_);
			case 'AsPattern':
				var p = _v0.a;
				var name = _v0.b;
				return _Utils_ap(
					A2(
						makeType,
						$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
						type_),
					A2(go, p, type_));
			case 'ParenthesizedPattern':
				var p = _v0.a;
				return A2(go, p, type_);
			default:
				return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$checkOperatorApplication = F4(
	function (checkApp, op, e1, e2) {
		switch (op) {
			case '|>':
				return checkApp(
					_List_fromArray(
						[e2, e1]));
			case '<|':
				return checkApp(
					_List_fromArray(
						[e1, e2]));
			default:
				return checkApp(
					_List_fromArray(
						[
							A2(
							$stil4m$elm_syntax$Elm$Syntax$Node$Node,
							$stil4m$elm_syntax$Elm$Syntax$Range$emptyRange,
							$stil4m$elm_syntax$Elm$Syntax$Expression$PrefixOperator(op)),
							e1,
							e2
						]));
		}
	});
var $elm_community$maybe_extra$Maybe$Extra$combineHelp = F2(
	function (list, acc) {
		combineHelp:
		while (true) {
			if (list.b) {
				var head = list.a;
				var tail = list.b;
				if (head.$ === 'Just') {
					var a = head.a;
					var $temp$list = tail,
						$temp$acc = A2($elm$core$List$cons, a, acc);
					list = $temp$list;
					acc = $temp$acc;
					continue combineHelp;
				} else {
					return $elm$core$Maybe$Nothing;
				}
			} else {
				return $elm$core$Maybe$Just(
					$elm$core$List$reverse(acc));
			}
		}
	});
var $elm_community$maybe_extra$Maybe$Extra$combine = function (list) {
	return A2($elm_community$maybe_extra$Maybe$Extra$combineHelp, list, _List_Nil);
};
var $elm_community$dict_extra$Dict$Extra$filterMap = F2(
	function (f, dict) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, acc) {
					var _v0 = A2(f, k, v);
					if (_v0.$ === 'Just') {
						var newVal = _v0.a;
						return A3($elm$core$Dict$insert, k, newVal, acc);
					} else {
						return acc;
					}
				}),
			$elm$core$Dict$empty,
			dict);
	});
var $author$project$NoUnsortedRecords$findOperatorType = F2(
	function (context, op) {
		return A2(
			$elm$core$Maybe$map,
			A2(
				$elm$core$Basics$composeR,
				$elm$core$Tuple$second,
				A2(
					$elm$core$Basics$composeR,
					$elm$core$Tuple$second,
					A2(
						$elm$core$Basics$composeR,
						$author$project$NoUnsortedRecords$dereferenceType(context),
						$author$project$NoUnsortedRecords$flattenFunctionType))),
			$elm$core$List$head(
				$elm$core$Dict$toList(
					A2(
						$elm_community$dict_extra$Dict$Extra$filterMap,
						F2(
							function (_v0, funcs) {
								return A2(
									$elm_community$dict_extra$Dict$Extra$find,
									F2(
										function (funcName, _v1) {
											return _Utils_eq(op, funcName);
										}),
									funcs);
							}),
						context.functionTypes))));
	});
var $author$project$NoUnsortedRecords$getFunctionBinding = F2(
	function (context, _v0) {
		var signature = _v0.signature;
		return A2(
			$elm$core$Maybe$map,
			function (_v1) {
				var name = _v1.name;
				var typeAnnotation = _v1.typeAnnotation;
				return _Utils_Tuple2(
					$stil4m$elm_syntax$Elm$Syntax$Node$value(name),
					A2(
						$author$project$NoUnsortedRecords$dereferenceType,
						context,
						A2($author$project$NoUnsortedRecords$typeAnnotToNoncanonicalType, context, typeAnnotation)));
			},
			A2($elm$core$Maybe$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, signature));
	});
var $author$project$Util$makeAccessFunc = function (accessFunc) {
	return A2($elm$core$String$startsWith, '.', accessFunc) ? A2($elm$core$String$dropLeft, 1, accessFunc) : accessFunc;
};
var $elm_community$dict_extra$Dict$Extra$mapKeys = F2(
	function (keyMapper, dict) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, acc) {
					return A3(
						$elm$core$Dict$insert,
						keyMapper(k),
						v,
						acc);
				}),
			$elm$core$Dict$empty,
			dict);
	});
var $elm_community$list_extra$List$Extra$splitAt = F2(
	function (n, xs) {
		return _Utils_Tuple2(
			A2($elm$core$List$take, n, xs),
			A2($elm$core$List$drop, n, xs));
	});
var $author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes = F2(
	function (args, types) {
		return function (_v0) {
			var argTypes = _v0.a;
			var _return = _v0.b;
			return A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$pair(argTypes),
				A2(
					$elm$core$Maybe$map,
					A2(
						$elm$core$Basics$composeR,
						A2(
							$elm$core$Tuple$mapBoth,
							$author$project$NoUnsortedRecords$getType,
							$elm$core$List$map($author$project$NoUnsortedRecords$getType)),
						A2(
							$elm$core$Basics$composeR,
							function (_v1) {
								var r = _v1.a;
								var ts = _v1.b;
								return A2($author$project$NoUnsortedRecords$makeFunctionType, r, ts);
							},
							$author$project$NoUnsortedRecords$DereferencedType)),
					$elm_community$list_extra$List$Extra$unconsLast(_return)));
		}(
			function (i) {
				return A2($elm_community$list_extra$List$Extra$splitAt, i, types);
			}(
				$elm$core$List$length(args)));
	});
var $author$project$NoUnsortedRecords$prefixTypeVars = F2(
	function (prefix, type_) {
		var go = function (t) {
			switch (t.$) {
				case 'FunctionType':
					var from = t.a.from;
					var to = t.a.to;
					return $author$project$NoUnsortedRecords$FunctionType(
						{
							from: go(from),
							to: go(to)
						});
				case 'TupleType':
					var ts = t.a;
					return $author$project$NoUnsortedRecords$TupleType(
						A2($elm$core$List$map, go, ts));
				case 'ListType':
					var t_ = t.a;
					return $author$project$NoUnsortedRecords$ListType(
						go(t_));
				case 'NamedType':
					var _v1 = t.a;
					var moduleName = _v1.a;
					var name = _v1.b;
					var ts = t.b;
					return A2(
						$author$project$NoUnsortedRecords$NamedType,
						_Utils_Tuple2(moduleName, name),
						A2($elm$core$List$map, go, ts));
				case 'RecordType':
					var r = t.a;
					return $author$project$NoUnsortedRecords$RecordType(
						_Utils_update(
							r,
							{
								fields: A2(
									$elm$core$List$map,
									$elm$core$Tuple$mapSecond(go),
									r.fields),
								generic: A2($elm$core$Maybe$map, go, r.generic)
							}));
				case 'TypeVar':
					var _class = t.a;
					var _var = t.b;
					return A2(
						$author$project$NoUnsortedRecords$TypeVar,
						_class,
						_Utils_ap(prefix, _var));
				default:
					return $author$project$NoUnsortedRecords$UnitType;
			}
		};
		return $author$project$NoUnsortedRecords$DereferencedType(
			go(
				$author$project$NoUnsortedRecords$getType(type_)));
	});
var $author$project$NoUnsortedRecords$matchesTypeClass = F2(
	function (type_, _class) {
		var typeIsNumber = function (t) {
			_v13$2:
			while (true) {
				if (((((t.$ === 'NamedType') && t.a.a.b) && (t.a.a.a === 'Basics')) && (!t.a.a.b.b)) && (!t.b.b)) {
					switch (t.a.b) {
						case 'Int':
							var _v14 = t.a;
							var _v15 = _v14.a;
							return true;
						case 'Float':
							var _v16 = t.a;
							var _v17 = _v16.a;
							return true;
						default:
							break _v13$2;
					}
				} else {
					break _v13$2;
				}
			}
			return false;
		};
		var typeIsComparable = function (t) {
			typeIsComparable:
			while (true) {
				_v0$6:
				while (true) {
					switch (t.$) {
						case 'NamedType':
							if ((t.a.a.b && (!t.a.a.b.b)) && (!t.b.b)) {
								switch (t.a.a.a) {
									case 'String':
										if (t.a.b === 'String') {
											var _v1 = t.a;
											var _v2 = _v1.a;
											return true;
										} else {
											break _v0$6;
										}
									case 'Char':
										if (t.a.b === 'Char') {
											var _v3 = t.a;
											var _v4 = _v3.a;
											return true;
										} else {
											break _v0$6;
										}
									case 'Basics':
										switch (t.a.b) {
											case 'Int':
												var _v5 = t.a;
												var _v6 = _v5.a;
												return true;
											case 'Float':
												var _v7 = t.a;
												var _v8 = _v7.a;
												return true;
											default:
												break _v0$6;
										}
									default:
										break _v0$6;
								}
							} else {
								break _v0$6;
							}
						case 'ListType':
							var t_ = t.a;
							var $temp$t = t_;
							t = $temp$t;
							continue typeIsComparable;
						case 'TupleType':
							var ts = t.a;
							return A2($elm$core$List$all, typeIsComparable, ts);
						default:
							break _v0$6;
					}
				}
				return false;
			}
		};
		var typeIsAppendable = function (t) {
			_v10$2:
			while (true) {
				switch (t.$) {
					case 'NamedType':
						if ((((t.a.a.b && (t.a.a.a === 'String')) && (!t.a.a.b.b)) && (t.a.b === 'String')) && (!t.b.b)) {
							var _v11 = t.a;
							var _v12 = _v11.a;
							return true;
						} else {
							break _v10$2;
						}
					case 'ListType':
						return true;
					default:
						break _v10$2;
				}
			}
			return false;
		};
		switch (_class.$) {
			case 'Appendable':
				return typeIsAppendable(type_);
			case 'Comparable':
				return typeIsComparable(type_);
			case 'CompAppend':
				return typeIsAppendable(type_) && typeIsComparable(type_);
			default:
				return typeIsNumber(type_);
		}
	});
var $elm$core$Dict$merge = F6(
	function (leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
		var stepState = F3(
			function (rKey, rValue, _v0) {
				stepState:
				while (true) {
					var list = _v0.a;
					var result = _v0.b;
					if (!list.b) {
						return _Utils_Tuple2(
							list,
							A3(rightStep, rKey, rValue, result));
					} else {
						var _v2 = list.a;
						var lKey = _v2.a;
						var lValue = _v2.b;
						var rest = list.b;
						if (_Utils_cmp(lKey, rKey) < 0) {
							var $temp$rKey = rKey,
								$temp$rValue = rValue,
								$temp$_v0 = _Utils_Tuple2(
								rest,
								A3(leftStep, lKey, lValue, result));
							rKey = $temp$rKey;
							rValue = $temp$rValue;
							_v0 = $temp$_v0;
							continue stepState;
						} else {
							if (_Utils_cmp(lKey, rKey) > 0) {
								return _Utils_Tuple2(
									list,
									A3(rightStep, rKey, rValue, result));
							} else {
								return _Utils_Tuple2(
									rest,
									A4(bothStep, lKey, lValue, rValue, result));
							}
						}
					}
				}
			});
		var _v3 = A3(
			$elm$core$Dict$foldl,
			stepState,
			_Utils_Tuple2(
				$elm$core$Dict$toList(leftDict),
				initialResult),
			rightDict);
		var leftovers = _v3.a;
		var intermediateResult = _v3.b;
		return A3(
			$elm$core$List$foldl,
			F2(
				function (_v4, result) {
					var k = _v4.a;
					var v = _v4.b;
					return A3(leftStep, k, v, result);
				}),
			intermediateResult,
			leftovers);
	});
var $elm_community$list_extra$List$Extra$zip = $elm$core$List$map2($elm$core$Tuple$pair);
var $author$project$NoUnsortedRecords$typesMatch = F3(
	function (inVars, _v0, _v1) {
		var derefType1 = _v0.a;
		var derefType2 = _v1.a;
		var checkListOfTypes = F3(
			function (typeVars, t1s, t2s) {
				return (!_Utils_eq(
					$elm$core$List$length(t1s),
					$elm$core$List$length(t2s))) ? _Utils_Tuple2(typeVars, false) : A3(
					$elm$core$List$foldl,
					F2(
						function (_v18, _v19) {
							var t1_ = _v18.a;
							var t2_ = _v18.b;
							var varAcc = _v19.a;
							var matchAcc = _v19.b;
							return A2(
								$elm$core$Tuple$mapSecond,
								$elm$core$Basics$and(matchAcc),
								A3(go, varAcc, t1_, t2_));
						}),
					_Utils_Tuple2(typeVars, true),
					A2($elm_community$list_extra$List$Extra$zip, t1s, t2s));
			});
		var go = F3(
			function (typeVars, type1, type2) {
				var _v10 = _Utils_Tuple2(type1, type2);
				_v10$1:
				while (true) {
					_v10$8:
					while (true) {
						switch (_v10.a.$) {
							case 'TypeVar':
								var _v11 = _v10.a;
								var c = _v11.a;
								var n = _v11.b;
								var t = _v10.b;
								return A5(matchTypeVars, 1, typeVars, c, n, t);
							case 'ListType':
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'ListType':
										var t1 = _v10.a.a;
										var t2 = _v10.b.a;
										return A3(go, typeVars, t1, t2);
									default:
										break _v10$8;
								}
							case 'TupleType':
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'TupleType':
										var t1s = _v10.a.a;
										var t2s = _v10.b.a;
										return A3(checkListOfTypes, typeVars, t1s, t2s);
									default:
										break _v10$8;
								}
							case 'FunctionType':
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'FunctionType':
										var f1 = _v10.a.a;
										var f2 = _v10.b.a;
										return A3(
											checkListOfTypes,
											typeVars,
											_List_fromArray(
												[f1.from, f1.to]),
											_List_fromArray(
												[f1.from, f2.to]));
									default:
										break _v10$8;
								}
							case 'UnitType':
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'UnitType':
										var _v13 = _v10.a;
										var _v14 = _v10.b;
										return _Utils_Tuple2(typeVars, true);
									default:
										break _v10$8;
								}
							case 'NamedType':
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'NamedType':
										var _v15 = _v10.a;
										var n1 = _v15.a;
										var args1 = _v15.b;
										var _v16 = _v10.b;
										var n2 = _v16.a;
										var args2 = _v16.b;
										return A2(
											$elm$core$Tuple$mapSecond,
											$elm$core$Basics$and(
												_Utils_eq(n1, n2)),
											A3(checkListOfTypes, typeVars, args1, args2));
									default:
										break _v10$8;
								}
							default:
								switch (_v10.b.$) {
									case 'TypeVar':
										break _v10$1;
									case 'RecordType':
										var r1 = _v10.a.a;
										var r2 = _v10.b.a;
										return A4(
											validateRecordMatch,
											typeVars,
											r1.generic,
											r2.generic,
											A6(
												$elm$core$Dict$merge,
												F3(
													function (f, t1, acc) {
														return _Utils_update(
															acc,
															{
																only1: A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(f, t1),
																	acc.only1)
															});
													}),
												F4(
													function (_v17, t1, t2, acc) {
														return _Utils_update(
															acc,
															{
																both: A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(t1, t2),
																	acc.both)
															});
													}),
												F3(
													function (f, t2, acc) {
														return _Utils_update(
															acc,
															{
																only2: A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(f, t2),
																	acc.only2)
															});
													}),
												$elm$core$Dict$fromList(r1.fields),
												$elm$core$Dict$fromList(r2.fields),
												{both: _List_Nil, only1: _List_Nil, only2: _List_Nil}));
									default:
										break _v10$8;
								}
						}
					}
					return _Utils_Tuple2(typeVars, false);
				}
				var t = _v10.a;
				var _v12 = _v10.b;
				var c = _v12.a;
				var n = _v12.b;
				return A5(matchTypeVars, 2, typeVars, c, n, t);
			});
		var matchTypeVars = F5(
			function (side, typeVars, typeclass, name, type_) {
				var _v6 = _Utils_Tuple2(
					A2(
						$elm$core$Dict$get,
						_Utils_Tuple2(side, name),
						typeVars),
					type_);
				if (_v6.a.$ === 'Just') {
					var t = _v6.a.a;
					return A2(
						$elm$core$Tuple$mapFirst,
						A2(
							$elm$core$Dict$insert,
							_Utils_Tuple2(side, name),
							t),
						A3(
							go,
							A2(
								$elm$core$Dict$remove,
								_Utils_Tuple2(side, name),
								typeVars),
							t,
							type_));
				} else {
					if (_v6.b.$ === 'TypeVar') {
						var _v7 = _v6.a;
						var _v8 = _v6.b;
						return _Utils_Tuple2(typeVars, true);
					} else {
						var _v9 = _v6.a;
						return A2(
							$elm$core$Maybe$withDefault,
							true,
							A2(
								$elm$core$Maybe$map,
								$author$project$NoUnsortedRecords$matchesTypeClass(type_),
								typeclass)) ? _Utils_Tuple2(
							A3(
								$elm$core$Dict$insert,
								_Utils_Tuple2(side, name),
								type_,
								typeVars),
							true) : _Utils_Tuple2(typeVars, false);
					}
				}
			});
		var validateRecordMatch = F4(
			function (typeVars, generic1, generic2, _v5) {
				var only1 = _v5.only1;
				var only2 = _v5.only2;
				var both = _v5.both;
				return function (_v4) {
					var vars = _v4.a;
					var matchAcc = _v4.b;
					return A2(
						$elm$core$Tuple$mapSecond,
						$elm$core$Basics$and(matchAcc),
						A2(
							$elm$core$Maybe$withDefault,
							_Utils_Tuple2(
								vars,
								$elm$core$List$isEmpty(only2)),
							A3(
								$elm$core$Maybe$map2,
								F2(
									function (g, fs) {
										return A3(
											go,
											vars,
											$author$project$NoUnsortedRecords$RecordType(
												{canonical: false, fields: fs, generic: $elm$core$Maybe$Nothing}),
											g);
									}),
								generic1,
								A2(
									$author$project$Util$validate,
									A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
									only2))));
				}(
					function (_v3) {
						var vars = _v3.a;
						var matchAcc = _v3.b;
						return A2(
							$elm$core$Tuple$mapSecond,
							$elm$core$Basics$and(matchAcc),
							A2(
								$elm$core$Maybe$withDefault,
								_Utils_Tuple2(
									vars,
									$elm$core$List$isEmpty(only1)),
								A3(
									$elm$core$Maybe$map2,
									F2(
										function (g, fs) {
											return A3(
												go,
												vars,
												$author$project$NoUnsortedRecords$RecordType(
													{canonical: false, fields: fs, generic: $elm$core$Maybe$Nothing}),
												g);
										}),
									generic2,
									A2(
										$author$project$Util$validate,
										A2($elm$core$Basics$composeL, $elm$core$Basics$not, $elm$core$List$isEmpty),
										only1))));
					}(
						function (_v2) {
							var l1s = _v2.a;
							var l2s = _v2.b;
							return A3(checkListOfTypes, typeVars, l1s, l2s);
						}(
							$elm$core$List$unzip(both))));
			});
		return A3(go, inVars, derefType1, derefType2);
	});
var $elm_community$list_extra$List$Extra$uncons = function (list) {
	if (!list.b) {
		return $elm$core$Maybe$Nothing;
	} else {
		var first = list.a;
		var rest = list.b;
		return $elm$core$Maybe$Just(
			_Utils_Tuple2(first, rest));
	}
};
var $author$project$NoUnsortedRecords$unifyTwoTypes = F2(
	function (type1, type2) {
		var _v4 = _Utils_Tuple2(type1, type2);
		_v4$1:
		while (true) {
			_v4$3:
			while (true) {
				_v4$8:
				while (true) {
					switch (_v4.a.$) {
						case 'TypeVar':
							if (_v4.a.a.$ === 'Nothing') {
								var _v5 = _v4.a;
								var _v6 = _v5.a;
								return $elm$core$Maybe$Just(type2);
							} else {
								if ((_v4.b.$ === 'TypeVar') && (_v4.b.a.$ === 'Nothing')) {
									break _v4$1;
								} else {
									var _v9 = _v4.a;
									var tc = _v9.a.a;
									return A2(
										$author$project$Util$validate,
										function (t) {
											return A2($author$project$NoUnsortedRecords$matchesTypeClass, t, tc);
										},
										type2);
								}
							}
						case 'FunctionType':
							switch (_v4.b.$) {
								case 'TypeVar':
									if (_v4.b.a.$ === 'Nothing') {
										break _v4$1;
									} else {
										break _v4$3;
									}
								case 'FunctionType':
									var f1 = _v4.a.a;
									var f2 = _v4.b.a;
									return A3(
										$elm$core$Maybe$map2,
										F2(
											function (from, to) {
												return $author$project$NoUnsortedRecords$FunctionType(
													{from: from, to: to});
											}),
										$author$project$NoUnsortedRecords$cyclic$unifyTypes()(
											_List_fromArray(
												[f1.from, f2.from])),
										$author$project$NoUnsortedRecords$cyclic$unifyTypes()(
											_List_fromArray(
												[f1.to, f2.to])));
								default:
									break _v4$8;
							}
						case 'ListType':
							switch (_v4.b.$) {
								case 'TypeVar':
									if (_v4.b.a.$ === 'Nothing') {
										break _v4$1;
									} else {
										break _v4$3;
									}
								case 'ListType':
									var t1 = _v4.a.a;
									var t2 = _v4.b.a;
									return A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$ListType,
										$author$project$NoUnsortedRecords$cyclic$unifyTypes()(
											_List_fromArray(
												[t1, t2])));
								default:
									break _v4$8;
							}
						case 'TupleType':
							switch (_v4.b.$) {
								case 'TypeVar':
									if (_v4.b.a.$ === 'Nothing') {
										break _v4$1;
									} else {
										break _v4$3;
									}
								case 'TupleType':
									var t1s = _v4.a.a;
									var t2s = _v4.b.a;
									return A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$TupleType,
										A2(
											$elm_community$maybe_extra$Maybe$Extra$traverse,
											function (_v11) {
												var t1 = _v11.a;
												var t2 = _v11.b;
												return $author$project$NoUnsortedRecords$cyclic$unifyTypes()(
													_List_fromArray(
														[t1, t2]));
											},
											A2($elm_community$list_extra$List$Extra$zip, t1s, t2s)));
								default:
									break _v4$8;
							}
						case 'RecordType':
							switch (_v4.b.$) {
								case 'TypeVar':
									if (_v4.b.a.$ === 'Nothing') {
										break _v4$1;
									} else {
										break _v4$3;
									}
								case 'RecordType':
									var r1 = _v4.a.a;
									var r2 = _v4.b.a;
									return function (_v12) {
										var only1 = _v12.only1;
										var both = _v12.both;
										var only2 = _v12.only2;
										return A2(
											$elm$core$Maybe$andThen,
											function (both_) {
												var _v13 = _Utils_Tuple2(
													_Utils_Tuple2(r1.generic, only2),
													_Utils_Tuple2(r2.generic, only1));
												_v13$4:
												while (true) {
													if (_v13.a.a.$ === 'Just') {
														if (_v13.a.a.a.$ === 'TypeVar') {
															if (_v13.b.a.$ === 'Just') {
																if (_v13.b.a.a.$ === 'TypeVar') {
																	var _v14 = _v13.a;
																	var _v15 = _v14.a.a;
																	var _v16 = _v13.b;
																	var _v17 = _v16.a.a;
																	return $elm$core$Maybe$Just(
																		$author$project$NoUnsortedRecords$RecordType(
																			_Utils_update(
																				r1,
																				{
																					fields: _Utils_ap(
																						only1,
																						_Utils_ap(both_, only2))
																				})));
																} else {
																	break _v13$4;
																}
															} else {
																if (!_v13.b.b.b) {
																	var _v22 = _v13.a;
																	var _v23 = _v22.a.a;
																	var _v24 = _v13.b;
																	var _v25 = _v24.a;
																	return $elm$core$Maybe$Just(
																		$author$project$NoUnsortedRecords$RecordType(
																			_Utils_update(
																				r1,
																				{
																					fields: _Utils_ap(both_, only2)
																				})));
																} else {
																	break _v13$4;
																}
															}
														} else {
															break _v13$4;
														}
													} else {
														if (!_v13.a.b.b) {
															if (_v13.b.a.$ === 'Nothing') {
																if (!_v13.b.b.b) {
																	var _v18 = _v13.a;
																	var _v19 = _v18.a;
																	var _v20 = _v13.b;
																	var _v21 = _v20.a;
																	return $elm$core$Maybe$Just(
																		$author$project$NoUnsortedRecords$RecordType(
																			_Utils_update(
																				r1,
																				{fields: both_})));
																} else {
																	break _v13$4;
																}
															} else {
																if (_v13.b.a.a.$ === 'TypeVar') {
																	var _v26 = _v13.a;
																	var _v27 = _v26.a;
																	var _v28 = _v13.b;
																	var _v29 = _v28.a.a;
																	return $elm$core$Maybe$Just(
																		$author$project$NoUnsortedRecords$RecordType(
																			_Utils_update(
																				r1,
																				{
																					fields: _Utils_ap(both_, only1)
																				})));
																} else {
																	break _v13$4;
																}
															}
														} else {
															break _v13$4;
														}
													}
												}
												return $elm$core$Maybe$Nothing;
											},
											$elm_community$maybe_extra$Maybe$Extra$combine(both));
									}(
										A6(
											$elm$core$Dict$merge,
											F3(
												function (f, t1, acc) {
													return _Utils_update(
														acc,
														{
															only1: A2(
																$elm$core$List$cons,
																_Utils_Tuple2(f, t1),
																acc.only1)
														});
												}),
											F4(
												function (f, t1, t2, acc) {
													return _Utils_update(
														acc,
														{
															both: function (x) {
																return A2($elm$core$List$cons, x, acc.both);
															}(
																A2(
																	$elm$core$Maybe$map,
																	$elm$core$Tuple$pair(f),
																	$author$project$NoUnsortedRecords$cyclic$unifyTypes()(
																		_List_fromArray(
																			[t1, t2]))))
														});
												}),
											F3(
												function (f, t2, acc) {
													return _Utils_update(
														acc,
														{
															only2: A2(
																$elm$core$List$cons,
																_Utils_Tuple2(f, t2),
																acc.only2)
														});
												}),
											$elm$core$Dict$fromList(r1.fields),
											$elm$core$Dict$fromList(r2.fields),
											{both: _List_Nil, only1: _List_Nil, only2: _List_Nil}));
								default:
									break _v4$8;
							}
						default:
							if (_v4.b.$ === 'TypeVar') {
								if (_v4.b.a.$ === 'Nothing') {
									break _v4$1;
								} else {
									break _v4$3;
								}
							} else {
								break _v4$8;
							}
					}
				}
				return $elm$core$Maybe$Nothing;
			}
			var _v10 = _v4.b;
			var tc = _v10.a.a;
			return A2(
				$author$project$Util$validate,
				function (t) {
					return A2($author$project$NoUnsortedRecords$matchesTypeClass, t, tc);
				},
				type1);
		}
		var _v7 = _v4.b;
		var _v8 = _v7.a;
		return $elm$core$Maybe$Just(type1);
	});
function $author$project$NoUnsortedRecords$cyclic$unifyTypes() {
	return A2(
		$elm$core$Basics$composeR,
		A2(
			$elm$core$List$foldl,
			F2(
				function (t, acc) {
					return A2($elm$core$List$member, t, acc) ? acc : A2($elm$core$List$cons, t, acc);
				}),
			_List_Nil),
		function (ts) {
			var _v0 = _Utils_Tuple2(
				ts,
				A2(
					$elm$core$List$filter,
					$elm$core$Basics$neq(
						A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, 'inferred empty list typevar')),
					ts));
			_v0$0:
			while (true) {
				if (!_v0.b.b) {
					if (_v0.a.b && (!_v0.a.b.b)) {
						break _v0$0;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				} else {
					if (_v0.a.b && (!_v0.a.b.b)) {
						break _v0$0;
					} else {
						if (!_v0.b.b.b) {
							var _v2 = _v0.b;
							var t = _v2.a;
							return $elm$core$Maybe$Just(t);
						} else {
							var _v3 = _v0.b;
							var t = _v3.a;
							var ts_ = _v3.b;
							return A3(
								$elm$core$List$foldl,
								F2(
									function (t_, acc) {
										return A2(
											$elm$core$Maybe$andThen,
											$author$project$NoUnsortedRecords$unifyTwoTypes(t_),
											acc);
									}),
								$elm$core$Maybe$Just(t),
								ts_);
						}
					}
				}
			}
			var _v1 = _v0.a;
			var t = _v1.a;
			return $elm$core$Maybe$Just(t);
		});
}
try {
	var $author$project$NoUnsortedRecords$unifyTypes = $author$project$NoUnsortedRecords$cyclic$unifyTypes();
	$author$project$NoUnsortedRecords$cyclic$unifyTypes = function () {
		return $author$project$NoUnsortedRecords$unifyTypes;
	};
} catch ($) {
	throw 'Some top-level definitions from `NoUnsortedRecords` are causing infinite recursion:\n\n  \n      unifyTwoTypes\n       \n      unifyTypes\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $elm_community$maybe_extra$Maybe$Extra$unpack = F3(
	function (_default, f, m) {
		if (m.$ === 'Nothing') {
			return _default(_Utils_Tuple0);
		} else {
			var a = m.a;
			return f(a);
		}
	});
var $elm_community$maybe_extra$Maybe$Extra$cons = F2(
	function (item, list) {
		if (item.$ === 'Just') {
			var v = item.a;
			return A2($elm$core$List$cons, v, list);
		} else {
			return list;
		}
	});
var $elm_community$maybe_extra$Maybe$Extra$values = A2($elm$core$List$foldr, $elm_community$maybe_extra$Maybe$Extra$cons, _List_Nil);
var $author$project$NoUnsortedRecords$bindingsFromLetDeclaration = F2(
	function (local, d) {
		if (d.$ === 'LetFunction') {
			var f = d.a;
			return A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2(
					$elm$core$Maybe$map,
					$elm$core$List$singleton,
					A2(
						$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
						function (_v17) {
							return function (_v18) {
								var name = _v18.name;
								var expression = _v18.expression;
								return A2(
									$elm$core$Maybe$map,
									$elm$core$Tuple$pair(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
									A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$getType,
										A2($author$project$NoUnsortedRecords$inferExprType, local, expression)));
							}(
								$stil4m$elm_syntax$Elm$Syntax$Node$value(f.declaration));
						},
						A2(
							$elm$core$Maybe$map,
							$elm$core$Tuple$mapSecond($author$project$NoUnsortedRecords$getType),
							A2($author$project$NoUnsortedRecords$getFunctionBinding, local.context, f)))));
		} else {
			var p = d.a;
			var e = d.b;
			return A3(
				$author$project$NoUnsortedRecords$bindingsInPatternWithType,
				local.context,
				p,
				A2($author$project$NoUnsortedRecords$inferExprType, local, e));
		}
	});
var $author$project$NoUnsortedRecords$inferApplicationChain = F2(
	function (local, es) {
		inferApplicationChain:
		while (true) {
			var inferExpr = $author$project$NoUnsortedRecords$inferExprType(local);
			var getReturnType = F2(
				function (args, _v15) {
					var argTypes = _v15.a;
					var returnType = _v15.b;
					return function (typeVars) {
						return A2($author$project$NoUnsortedRecords$assignTypeVars, typeVars, returnType);
					}(
						A2(
							$elm_community$dict_extra$Dict$Extra$mapKeys,
							$elm$core$Tuple$second,
							A2(
								$elm$core$Dict$filter,
								F2(
									function (_v13, _v14) {
										var i = _v13.a;
										return i === 1;
									}),
								A3(
									$elm$core$List$foldl,
									F2(
										function (_v12, typeVars) {
											var t1 = _v12.a;
											var t2 = _v12.b;
											return A2(
												$elm$core$Maybe$withDefault,
												typeVars,
												A2(
													$elm$core$Maybe$map,
													$elm$core$Tuple$first,
													A2(
														$elm$core$Maybe$map,
														A2($author$project$NoUnsortedRecords$typesMatch, typeVars, t1),
														t2)));
										}),
									$elm$core$Dict$empty,
									A2(
										$elm_community$list_extra$List$Extra$zip,
										argTypes,
										A2($elm$core$List$map, inferExpr, args))))));
				});
			if (!es.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				if (!es.b.b) {
					var e = es.a;
					return inferExpr(e);
				} else {
					var func = es.a;
					var args = es.b;
					var _v10 = $stil4m$elm_syntax$Elm$Syntax$Node$value(func);
					switch (_v10.$) {
						case 'FunctionOrValue':
							var name = _v10.b;
							return A2(
								$elm$core$Maybe$map,
								getReturnType(args),
								A2(
									$elm$core$Maybe$andThen,
									$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
									A2(
										$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
										function (_v11) {
											return A2(
												$elm$core$Maybe$map,
												$author$project$NoUnsortedRecords$flattenFunctionType,
												inferExpr(func));
										},
										A4($author$project$NoUnsortedRecords$findFunctionType, local, $elm$core$Maybe$Nothing, func, name))));
						case 'PrefixOperator':
							var op = _v10.a;
							return A2(
								$elm$core$Maybe$map,
								getReturnType(args),
								A2(
									$elm$core$Maybe$andThen,
									$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
									A2($author$project$NoUnsortedRecords$findOperatorType, local.context, op)));
						case 'ParenthesizedExpression':
							var func_ = _v10.a;
							var $temp$local = local,
								$temp$es = A2($elm$core$List$cons, func_, args);
							local = $temp$local;
							es = $temp$es;
							continue inferApplicationChain;
						case 'RecordAccessFunction':
							var accessFunc = _v10.a;
							return function (ts) {
								return function (f) {
									return A2($elm$core$Dict$get, f, ts);
								}(
									$author$project$Util$makeAccessFunc(accessFunc));
							}(
								$author$project$NoUnsortedRecords$getRecordFieldTypes(
									A2(
										$elm$core$Maybe$andThen,
										inferExpr,
										$elm$core$List$head(args))));
						default:
							return A2(
								$elm$core$Maybe$map,
								getReturnType(args),
								A2(
									$elm$core$Maybe$andThen,
									$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
									A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$flattenFunctionType,
										inferExpr(func))));
					}
				}
			}
		}
	});
var $author$project$NoUnsortedRecords$inferExprType = function (local) {
	var makeFunc = function (typeVarPrefix) {
		return A2(
			$elm$core$Basics$composeR,
			$elm$core$Maybe$map(
				$elm$core$List$map(
					$author$project$NoUnsortedRecords$prefixTypeVars(typeVarPrefix))),
			A2(
				$elm$core$Basics$composeR,
				$elm$core$Maybe$andThen($elm_community$list_extra$List$Extra$unconsLast),
				$elm$core$Maybe$map(
					A2(
						$elm$core$Basics$composeR,
						A2(
							$elm$core$Tuple$mapBoth,
							$author$project$NoUnsortedRecords$getType,
							$elm$core$List$map($author$project$NoUnsortedRecords$getType)),
						function (_v8) {
							var r = _v8.a;
							var ts = _v8.b;
							return A2($author$project$NoUnsortedRecords$makeFunctionType, r, ts);
						}))));
	};
	var go = F2(
		function (typeVarPrefix, node) {
			go:
			while (true) {
				var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
				switch (_v0.$) {
					case 'UnitExpr':
						return $elm$core$Maybe$Just($author$project$NoUnsortedRecords$UnitType);
					case 'Integer':
						return $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(
									_List_fromArray(
										['Basics']),
									'Int'),
								_List_Nil));
					case 'Hex':
						return $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(
									_List_fromArray(
										['Basics']),
									'Int'),
								_List_Nil));
					case 'Floatable':
						return $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(
									_List_fromArray(
										['Basics']),
									'Float'),
								_List_Nil));
					case 'Literal':
						return $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(
									_List_fromArray(
										['String']),
									'String'),
								_List_Nil));
					case 'CharLiteral':
						return $elm$core$Maybe$Just(
							A2(
								$author$project$NoUnsortedRecords$NamedType,
								_Utils_Tuple2(
									_List_fromArray(
										['Char']),
									'Char'),
								_List_Nil));
					case 'TupledExpression':
						var es = _v0.a;
						return A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$TupleType,
							$elm_community$maybe_extra$Maybe$Extra$combine(
								A2(
									$elm$core$List$indexedMap,
									F2(
										function (i, e) {
											return A2(
												go,
												typeVarPrefix + ('Tuple Expression ' + $elm$core$String$fromInt(i)),
												e);
										}),
									es)));
					case 'ListExpr':
						var es = _v0.a;
						return $elm$core$List$isEmpty(es) ? $elm$core$Maybe$Just(
							$author$project$NoUnsortedRecords$ListType(
								A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, typeVarPrefix + 'inferred empty list typevar'))) : A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$ListType,
							$author$project$NoUnsortedRecords$unifyTypes(
								$elm_community$maybe_extra$Maybe$Extra$values(
									A2(
										$elm$core$List$indexedMap,
										F2(
											function (i, e) {
												return A2(
													go,
													typeVarPrefix + ('List Element ' + $elm$core$String$fromInt(i)),
													e);
											}),
										es))));
					case 'RecordExpr':
						var rs = _v0.a;
						return A2(
							$elm$core$Maybe$map,
							function (fields) {
								return $author$project$NoUnsortedRecords$RecordType(
									{canonical: false, fields: fields, generic: $elm$core$Maybe$Nothing});
							},
							$elm_community$maybe_extra$Maybe$Extra$combine(
								A2(
									$elm$core$List$map,
									function (n) {
										var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(n);
										var f = _v1.a;
										var e = _v1.b;
										return A2(
											$elm$core$Maybe$map,
											$elm$core$Tuple$pair(
												$stil4m$elm_syntax$Elm$Syntax$Node$value(f)),
											A2(
												go,
												typeVarPrefix + ('Record Field ' + $stil4m$elm_syntax$Elm$Syntax$Node$value(f)),
												e));
									},
									rs)));
					case 'FunctionOrValue':
						var name = _v0.b;
						return A2(
							makeFunc,
							typeVarPrefix,
							A4($author$project$NoUnsortedRecords$findFunctionType, local, $elm$core$Maybe$Nothing, node, name));
					case 'ParenthesizedExpression':
						var e = _v0.a;
						var $temp$typeVarPrefix = typeVarPrefix,
							$temp$node = e;
						typeVarPrefix = $temp$typeVarPrefix;
						node = $temp$node;
						continue go;
					case 'Negation':
						var e = _v0.a;
						var $temp$typeVarPrefix = typeVarPrefix,
							$temp$node = e;
						typeVarPrefix = $temp$typeVarPrefix;
						node = $temp$node;
						continue go;
					case 'IfBlock':
						var e1 = _v0.b;
						var e2 = _v0.c;
						return $author$project$NoUnsortedRecords$unifyTypes(
							$elm_community$maybe_extra$Maybe$Extra$values(
								_List_fromArray(
									[
										A2(go, typeVarPrefix + 'If Block True', e1),
										A2(go, typeVarPrefix + 'If Block False', e2)
									])));
					case 'PrefixOperator':
						var p = _v0.a;
						return A2(
							makeFunc,
							typeVarPrefix,
							A2($author$project$NoUnsortedRecords$findOperatorType, local.context, p));
					case 'CaseExpression':
						var cases = _v0.a.cases;
						return $author$project$NoUnsortedRecords$unifyTypes(
							$elm_community$maybe_extra$Maybe$Extra$values(
								A2(
									$elm$core$List$indexedMap,
									F2(
										function (i, _v2) {
											var e = _v2.b;
											return A2(
												go,
												typeVarPrefix + ('Case Expression ' + $elm$core$String$fromInt(i)),
												e);
										}),
									cases)));
					case 'Application':
						var es = _v0.a;
						return A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$getType,
							A2($author$project$NoUnsortedRecords$inferApplicationChain, local, es));
					case 'LambdaExpression':
						var args = _v0.a.args;
						var expression = _v0.a.expression;
						var unwrapArgs = function (xs) {
							return A3(
								$elm_community$maybe_extra$Maybe$Extra$unpack,
								function (_v3) {
									return A2(go, typeVarPrefix, expression);
								},
								function (_v4) {
									var x = _v4.a;
									var xs_ = _v4.b;
									return A2(
										$elm$core$Maybe$map,
										function (t) {
											return $author$project$NoUnsortedRecords$FunctionType(
												{
													from: A2(
														$author$project$NoUnsortedRecords$TypeVar,
														$elm$core$Maybe$Nothing,
														_Utils_ap(typeVarPrefix, x)),
													to: t
												});
										},
										unwrapArgs(xs_));
								},
								$elm_community$list_extra$List$Extra$uncons(xs));
						};
						return unwrapArgs(
							A2(
								$elm$core$List$indexedMap,
								F2(
									function (i, _v5) {
										return 'lambda arg' + $elm$core$String$fromInt(i);
									}),
								args));
					case 'RecordAccess':
						var e = _v0.a;
						var accessFunc = _v0.b;
						return A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$getType,
							function (ts) {
								return function (f) {
									return A2($elm$core$Dict$get, f, ts);
								}(
									$author$project$Util$makeAccessFunc(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(accessFunc)));
							}(
								$author$project$NoUnsortedRecords$getRecordFieldTypes(
									A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$DereferencedType,
										A2(go, typeVarPrefix, e)))));
					case 'GLSLExpression':
						return $elm$core$Maybe$Nothing;
					case 'RecordAccessFunction':
						var accessFunc = _v0.a;
						return function (f) {
							return $elm$core$Maybe$Just(
								$author$project$NoUnsortedRecords$FunctionType(
									{
										from: $author$project$NoUnsortedRecords$RecordType(
											{
												canonical: false,
												fields: _List_fromArray(
													[
														_Utils_Tuple2(
														f,
														A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, typeVarPrefix + ('record access inferred field for ' + f)))
													]),
												generic: $elm$core$Maybe$Just(
													A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, typeVarPrefix + ('record access inferred for ' + f)))
											}),
										to: A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, typeVarPrefix + ('record access inferred field for ' + f))
									}));
						}(
							$author$project$Util$makeAccessFunc(accessFunc));
					case 'Operator':
						return $elm$core$Maybe$Nothing;
					case 'OperatorApplication':
						var op = _v0.a;
						var e1 = _v0.c;
						var e2 = _v0.d;
						return A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$getType,
							A4(
								$author$project$NoUnsortedRecords$checkOperatorApplication,
								$author$project$NoUnsortedRecords$inferApplicationChain(local),
								op,
								e1,
								e2));
					case 'LetExpression':
						var declarations = _v0.a.declarations;
						var expression = _v0.a.expression;
						var newBindings = $elm$core$Dict$fromList(
							A2(
								$elm$core$List$concatMap,
								A2(
									$elm$core$Basics$composeL,
									$author$project$NoUnsortedRecords$bindingsFromLetDeclaration(local),
									$stil4m$elm_syntax$Elm$Syntax$Node$value),
								declarations));
						return A2(
							$elm$core$Maybe$map,
							$author$project$NoUnsortedRecords$getType,
							A2(
								$elm$core$Maybe$map,
								$author$project$NoUnsortedRecords$prefixTypeVars(typeVarPrefix),
								A2(
									$author$project$NoUnsortedRecords$inferExprType,
									_Utils_update(
										local,
										{
											localFunctions: A2($elm$core$Dict$union, local.localFunctions, newBindings)
										}),
									expression)));
					default:
						var _var = _v0.a;
						var fs = _v0.b;
						return A2(
							$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
							function (_v6) {
								return A2(
									$elm$core$Maybe$map,
									function (fields) {
										return $author$project$NoUnsortedRecords$RecordType(
											{
												canonical: false,
												fields: fields,
												generic: $elm$core$Maybe$Just(
													A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, typeVarPrefix + 'inferred update generic'))
											});
									},
									A2(
										$elm_community$maybe_extra$Maybe$Extra$traverse,
										A2(
											$elm$core$Basics$composeL,
											function (_v7) {
												var f = _v7.a;
												var e = _v7.b;
												return A2(
													$elm$core$Maybe$map,
													$elm$core$Tuple$pair(
														$stil4m$elm_syntax$Elm$Syntax$Node$value(f)),
													A2(
														go,
														typeVarPrefix + ('Record Update Field ' + $stil4m$elm_syntax$Elm$Syntax$Node$value(f)),
														e));
											},
											$stil4m$elm_syntax$Elm$Syntax$Node$value),
										fs));
							},
							A2(
								makeFunc,
								typeVarPrefix,
								A4(
									$author$project$NoUnsortedRecords$findFunctionType,
									local,
									$elm$core$Maybe$Nothing,
									_var,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(_var))));
				}
			}
		});
	return A2(
		$elm$core$Basics$composeR,
		go(''),
		$elm$core$Maybe$map($author$project$NoUnsortedRecords$DereferencedType));
};
var $author$project$NoUnsortedRecords$ambiguousRecordError = F3(
	function (_v0, matching, range) {
		var fields = _v0.fields;
		var prettyGeneric = function (s) {
			if (!s.b) {
				return '';
			} else {
				if (!s.b.b) {
					var x = s.a;
					return x;
				} else {
					var x = s.a;
					var xs = s.b;
					return x + (' (' + (prettyGeneric(xs) + ')'));
				}
			}
		};
		if (fields.b && fields.b.b) {
			var _v3 = fields.b;
			return _List_fromArray(
				[
					A2(
					$jfmengels$elm_review$Review$Rule$error,
					{
						details: _List_fromArray(
							[
								'This record could be one of several possible record aliases, so whether or not its fields are sorted could not be determined!',
								'Try adding a type annotation, or remove reportAmbiguousRecordsWithoutFix from your rule configuration.',
								'The record matched the following possible aliases: ' + A2(
								$elm$core$String$join,
								', ',
								A2(
									$elm$core$List$map,
									prettyGeneric,
									$elm$core$List$sort(matching)))
							]),
						message: 'Ambiguous record encountered.'
					},
					range)
				]);
		} else {
			return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$FieldOrder = function (a) {
	return {$: 'FieldOrder', a: a};
};
var $author$project$NoUnsortedRecords$OrderedFields = function (a) {
	return {$: 'OrderedFields', a: a};
};
var $author$project$NoUnsortedRecords$UnknownFields = function (a) {
	return {$: 'UnknownFields', a: a};
};
var $elm$core$Dict$sizeHelp = F2(
	function (n, dict) {
		sizeHelp:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return n;
			} else {
				var left = dict.d;
				var right = dict.e;
				var $temp$n = A2($elm$core$Dict$sizeHelp, n + 1, right),
					$temp$dict = left;
				n = $temp$n;
				dict = $temp$dict;
				continue sizeHelp;
			}
		}
	});
var $elm$core$Dict$size = function (dict) {
	return A2($elm$core$Dict$sizeHelp, 0, dict);
};
var $author$project$NoUnsortedRecords$searchOrders = F4(
	function (_v0, context, hasAllFields, fields) {
		var typecheckUnambiguousRecords = _v0.a.typecheckUnambiguousRecords;
		var missingFieldLimit = hasAllFields ? $elm$core$Basics$always(1) : A2(
			$elm$core$Basics$composeL,
			$elm$core$Dict$size,
			function ($) {
				return $.order;
			});
		var matchFields = $elm$core$Dict$fromList(
			A2(
				$elm$core$List$map,
				function (f) {
					return _Utils_Tuple2(f.field, f);
				},
				fields));
		var step = F4(
			function (moduleName, name, o, acc) {
				return (_Utils_cmp(
					$elm$core$Dict$size(
						A2($elm$core$Dict$diff, o.order, matchFields)),
					missingFieldLimit(o)) > -1) ? acc : (o.isGeneric ? _Utils_update(
					acc,
					{
						genericMatches: A2(
							$elm$core$List$cons,
							{
								missing: $elm$core$Dict$values(
									A2($elm$core$Dict$diff, matchFields, o.order)),
								type_: _Utils_Tuple2(
									_Utils_Tuple2(moduleName, name),
									o)
							},
							acc.genericMatches)
					}) : ($elm$core$Dict$isEmpty(
					A2($elm$core$Dict$diff, matchFields, o.order)) ? _Utils_update(
					acc,
					{
						canonicalMatches: A2(
							$elm$core$List$cons,
							_Utils_Tuple2(
								_Utils_Tuple2(moduleName, name),
								o),
							acc.canonicalMatches)
					}) : acc));
			});
		var checkTypes = function (_v5) {
			var order = _v5.order;
			return A3(
				$elm$core$List$foldl,
				F2(
					function (_v1, _v2) {
						var field = _v1.field;
						var type_ = _v1.type_;
						var varAcc = _v2.a;
						var matchAcc = _v2.b;
						var assignedVars = A2(
							$elm$core$Dict$filter,
							F2(
								function (_v3, _v4) {
									var i = _v3.a;
									return i === 2;
								}),
							varAcc);
						return A2(
							$elm$core$Tuple$mapSecond,
							$elm$core$Basics$and(matchAcc),
							A2(
								$elm$core$Maybe$withDefault,
								_Utils_Tuple2(assignedVars, true),
								A3(
									$elm$core$Maybe$map2,
									$author$project$NoUnsortedRecords$typesMatch(assignedVars),
									type_,
									A2(
										$elm$core$Maybe$map,
										A2(
											$elm$core$Basics$composeL,
											$author$project$NoUnsortedRecords$dereferenceType(context),
											$elm$core$Tuple$second),
										A2($elm$core$Dict$get, field, order)))));
					}),
				_Utils_Tuple2($elm$core$Dict$empty, true),
				fields).b;
		};
		return function (res) {
			var canonicalMatches = res.canonicalMatches;
			var genericMatches = res.genericMatches;
			return (typecheckUnambiguousRecords || (($elm$core$List$length(canonicalMatches) + $elm$core$List$length(genericMatches)) > 1)) ? {
				canonicalMatches: A2(
					$elm$core$List$filter,
					A2($elm$core$Basics$composeL, checkTypes, $elm$core$Tuple$second),
					canonicalMatches),
				genericMatches: A2(
					$elm$core$List$filter,
					A2(
						$elm$core$Basics$composeL,
						A2($elm$core$Basics$composeL, checkTypes, $elm$core$Tuple$second),
						function ($) {
							return $.type_;
						}),
					genericMatches)
			} : res;
		}(
			A3(
				$elm$core$Dict$foldl,
				F3(
					function (moduleName, moduleTypes, outerAcc) {
						return A3(
							$elm$core$Dict$foldl,
							step(moduleName),
							outerAcc,
							moduleTypes);
					}),
				{canonicalMatches: _List_Nil, genericMatches: _List_Nil},
				context.canonicalRecords));
	});
var $author$project$NoUnsortedRecords$findMatchingTypes = F4(
	function (config, context, info, matchFields) {
		var toFieldOrder = F2(
			function (generic, _v8) {
				var order = _v8.order;
				return $author$project$NoUnsortedRecords$FieldOrder(
					{canonical: order, generic: generic});
			});
		var hasAllFields = function () {
			if ((info.$ === 'Just') && (info.a.$ === 'HasAllFields')) {
				var _v7 = info.a;
				return true;
			} else {
				return false;
			}
		}();
		var getMatches = function (fs) {
			var _v4 = $elm$core$List$isEmpty(fs) ? {canonicalMatches: _List_Nil, genericMatches: _List_Nil} : A4($author$project$NoUnsortedRecords$searchOrders, config, context, hasAllFields, fs);
			var canonicalMatches = _v4.canonicalMatches;
			var genericMatches = _v4.genericMatches;
			return _Utils_ap(
				A2(
					$elm$core$List$map,
					function (_v5) {
						var name = _v5.a;
						var k = _v5.b;
						return {
							fieldOrder: A2(toFieldOrder, $elm$core$Maybe$Nothing, k),
							isSubrecord: k.isSubrecord,
							typeName: _List_fromArray(
								[name])
						};
					},
					canonicalMatches),
				A2($elm$core$List$concatMap, makeGeneric, genericMatches));
		};
		var makeGeneric = function (_v3) {
			var type_ = _v3.type_;
			var missing = _v3.missing;
			var _v1 = type_;
			var n = _v1.a;
			var rec = _v1.b;
			return function (ls) {
				return $elm$core$List$isEmpty(ls) ? _List_fromArray(
					[
						{
						fieldOrder: A2(
							toFieldOrder,
							$elm$core$Maybe$Just(
								$author$project$NoUnsortedRecords$UnknownFields(
									A2(
										$elm$core$List$map,
										function ($) {
											return $.field;
										},
										missing))),
							rec),
						isSubrecord: rec.isSubrecord,
						typeName: _List_fromArray(
							[n])
					}
					]) : ls;
			}(
				A2(
					$elm$core$List$map,
					function (_v2) {
						var typeName = _v2.typeName;
						var fieldOrder = _v2.fieldOrder;
						var isSubrecord = _v2.isSubrecord;
						return {
							fieldOrder: A2(
								toFieldOrder,
								$elm$core$Maybe$Just(
									$author$project$NoUnsortedRecords$OrderedFields(fieldOrder)),
								rec),
							isSubrecord: rec.isSubrecord || isSubrecord,
							typeName: A2($elm$core$List$cons, n, typeName)
						};
					},
					getMatches(missing)));
		};
		if ((info.$ === 'Just') && (info.a.$ === 'HasFieldOrder')) {
			var f = info.a.a;
			return _List_fromArray(
				[
					{fieldOrder: f, isSubrecord: false, typeName: _List_Nil}
				]);
		} else {
			return getMatches(matchFields);
		}
	});
var $elm_community$dict_extra$Dict$Extra$insertDedupe = F4(
	function (combine, key, value, dict) {
		var _with = function (mbValue) {
			if (mbValue.$ === 'Just') {
				var oldValue = mbValue.a;
				return $elm$core$Maybe$Just(
					A2(combine, oldValue, value));
			} else {
				return $elm$core$Maybe$Just(value);
			}
		};
		return A3($elm$core$Dict$update, key, _with, dict);
	});
var $elm_community$dict_extra$Dict$Extra$fromListDedupe = F2(
	function (combine, xs) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (_v0, acc) {
					var key = _v0.a;
					var value = _v0.b;
					return A4($elm_community$dict_extra$Dict$Extra$insertDedupe, combine, key, value, acc);
				}),
			$elm$core$Dict$empty,
			xs);
	});
var $author$project$NoUnsortedRecords$keepOnlyMatchingFieldTypes = F2(
	function (d1, d2) {
		return A6(
			$elm$core$Dict$merge,
			F3(
				function (_v0, _v1, acc) {
					return acc;
				}),
			F4(
				function (field, t1, t2, acc) {
					return _Utils_eq(t1, t2) ? A3($elm$core$Dict$insert, field, t1, acc) : acc;
				}),
			F3(
				function (_v2, _v3, acc) {
					return acc;
				}),
			d1,
			d2,
			$elm$core$Dict$empty);
	});
var $elm$core$Dict$map = F2(
	function (func, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				A2(func, key, value),
				A2($elm$core$Dict$map, func, left),
				A2($elm$core$Dict$map, func, right));
		}
	});
var $author$project$NoUnsortedRecords$makeOrder = F3(
	function (sortGenerics, inFields, _v0) {
		var inOrder = _v0.a;
		var genericOffset = function () {
			if (sortGenerics.$ === 'GenericFieldsFirst') {
				return -1000000;
			} else {
				return 1000000;
			}
		}();
		var go = F3(
			function (offsetMult, fieldsToMake, _v1) {
				var canonical = _v1.a.canonical;
				var generic = _v1.a.generic;
				var step = F2(
					function (f, _v7) {
						var canAcc = _v7.a;
						var genAcc = _v7.b;
						var _v5 = A2($elm$core$Dict$get, f.field, canonical);
						if (_v5.$ === 'Just') {
							var _v6 = _v5.a;
							var i = _v6.a;
							return _Utils_Tuple2(
								A2(
									$elm$core$List$cons,
									_Utils_Tuple2(f.field, i + (offsetMult * genericOffset)),
									canAcc),
								genAcc);
						} else {
							return _Utils_Tuple2(
								canAcc,
								A2($elm$core$List$cons, f, genAcc));
						}
					});
				return function (_v3) {
					var f1s = _v3.a;
					var _v4 = _v3.b;
					var f2s = _v4.a;
					var unknown = _v4.b;
					return _Utils_Tuple2(
						A2($elm$core$Dict$union, f1s, f2s),
						unknown);
				}(
					A3(
						$elm$core$Tuple$mapBoth,
						$elm$core$Dict$fromList,
						function (fs) {
							if (generic.$ === 'Just') {
								if (generic.a.$ === 'OrderedFields') {
									var order = generic.a.a;
									return A3(go, offsetMult + 1, fs, order);
								} else {
									var fs_ = generic.a.a;
									var alph = $elm$core$List$sort(fs_);
									return _Utils_Tuple2(
										$elm$core$Dict$fromList(
											A2(
												$elm$core$List$map,
												function (f) {
													return _Utils_Tuple2(
														f.field,
														((offsetMult + 1) * genericOffset) + A2(
															$elm$core$Maybe$withDefault,
															-1,
															A2($elm_community$list_extra$List$Extra$elemIndex, f.field, alph)));
												},
												fs)),
										true);
								}
							} else {
								return _Utils_Tuple2($elm$core$Dict$empty, false);
							}
						},
						A3(
							$elm$core$List$foldl,
							step,
							_Utils_Tuple2(_List_Nil, _List_Nil),
							fieldsToMake)));
			});
		return function (_v8) {
			var fieldOrder = _v8.a;
			var hasUnknownFields = _v8.b;
			return {
				canonicalFieldTypes: A2(
					$elm$core$Dict$map,
					F2(
						function (_v9, v) {
							return v.b;
						}),
					inOrder.canonical),
				fieldOrder: fieldOrder,
				hasUnknownFields: hasUnknownFields
			};
		}(
			A3(
				go,
				0,
				inFields,
				$author$project$NoUnsortedRecords$FieldOrder(inOrder)));
	});
var $author$project$NoUnsortedRecords$unknownRecordError = F2(
	function (_v0, range) {
		var fields = _v0.fields;
		if (fields.b && fields.b.b) {
			var _v2 = fields.b;
			return _List_fromArray(
				[
					A2(
					$jfmengels$elm_review$Review$Rule$error,
					{
						details: _List_fromArray(
							['This record did not correspond with any known alias or custom type argument record, so whether or not its fields are sorted could not be determined!', 'Create a type alias for this record type, or remove reportUnknownRecordsWithoutFix from your rule configuration.']),
						message: 'Unknown record encountered.'
					},
					range)
				]);
		} else {
			return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$checkRecord = F3(
	function (config, context, record) {
		var sortUnknown = config.a.sortUnknown;
		var sortAmbiguous = config.a.sortAmbiguous;
		var sortGenerics = config.a.sortGenerics;
		var fullRange = record.fullRange;
		var orderInfo = record.orderInfo;
		var fields = record.fields;
		var matchingOrders = function (os) {
			if (!os.b.b.b) {
				if (!os.b.a.b) {
					if (!os.a.b.b) {
						var _v9 = os.a;
						var unknownIsSubrecord = _v9.a;
						var _v10 = os.b;
						return _Utils_Tuple2(unknownIsSubrecord, true);
					} else {
						var _v11 = os.a;
						var unknownNotSubrecord = _v11.b;
						var _v12 = os.b;
						return _Utils_Tuple2(unknownNotSubrecord, true);
					}
				} else {
					var _v13 = os.b;
					var noUnknownIsSubrecord = _v13.a;
					return _Utils_Tuple2(noUnknownIsSubrecord, false);
				}
			} else {
				var _v14 = os.b;
				var noUnknownNotSubrecord = _v14.b;
				return _Utils_Tuple2(noUnknownNotSubrecord, false);
			}
		}(
			A3(
				$elm$core$Tuple$mapBoth,
				$elm$core$List$partition(
					function ($) {
						return $.isSubrecord;
					}),
				$elm$core$List$partition(
					function ($) {
						return $.isSubrecord;
					}),
				A2(
					$elm$core$List$partition,
					function ($) {
						return $.hasUnknownFields;
					},
					$elm$core$Dict$values(
						A2(
							$elm_community$dict_extra$Dict$Extra$fromListDedupe,
							F2(
								function (o1, o2) {
									return function (o) {
										return _Utils_update(
											o,
											{
												canonicalFieldTypes: A2($author$project$NoUnsortedRecords$keepOnlyMatchingFieldTypes, o.canonicalFieldTypes, o2.canonicalFieldTypes)
											});
									}(
										o1.hasUnknownFields ? o2 : o1);
								}),
							A2(
								$elm$core$List$map,
								function (_v7) {
									var typeName = _v7.typeName;
									var fieldOrder = _v7.fieldOrder;
									var isSubrecord = _v7.isSubrecord;
									return function (o) {
										return _Utils_Tuple2(
											$elm$core$Dict$toList(o.fieldOrder),
											{canonicalFieldTypes: o.canonicalFieldTypes, fieldOrder: o.fieldOrder, hasUnknownFields: o.hasUnknownFields, isSubrecord: isSubrecord, typeName: typeName});
									}(
										A3($author$project$NoUnsortedRecords$makeOrder, sortGenerics, fields, fieldOrder));
								},
								A4($author$project$NoUnsortedRecords$findMatchingTypes, config, context, orderInfo, fields)))))));
		var errorRange = function () {
			var s = fullRange.start;
			return {
				end: _Utils_update(
					s,
					{column: s.column + 1}),
				start: s
			};
		}();
		var checkSortingBy = function (o) {
			return A5(
				$author$project$Util$checkSorting,
				context.extractSource,
				'Record fields',
				_List_fromArray(
					[o]),
				errorRange,
				fields);
		};
		var handleUnknown = function (whenAlphabetical) {
			switch (sortUnknown.$) {
				case 'Alphabetically':
					return checkSortingBy(whenAlphabetical);
				case 'ReportOnly':
					return A2($author$project$NoUnsortedRecords$unknownRecordError, record, fullRange);
				default:
					return _List_Nil;
			}
		};
		var byFieldOrder = F3(
			function (ord, f1, f2) {
				var o = function (f) {
					return A2(
						$elm$core$Maybe$withDefault,
						-1,
						A2($elm$core$Dict$get, f, ord));
				};
				return A2(
					$elm$core$Basics$compare,
					o(f1.field),
					o(f2.field));
			});
		var alphabetical = F2(
			function (f1, f2) {
				return A2($elm$core$Basics$compare, f1.field, f2.field);
			});
		if (!matchingOrders.a.b) {
			return _Utils_Tuple2(
				handleUnknown(alphabetical),
				$elm$core$Dict$empty);
		} else {
			if (!matchingOrders.a.b.b) {
				if (matchingOrders.b) {
					var _v1 = matchingOrders.a;
					var fieldOrder = _v1.a.fieldOrder;
					var canonicalFieldTypes = _v1.a.canonicalFieldTypes;
					return _Utils_Tuple2(
						handleUnknown(
							byFieldOrder(fieldOrder)),
						canonicalFieldTypes);
				} else {
					var _v2 = matchingOrders.a;
					var fieldOrder = _v2.a.fieldOrder;
					var canonicalFieldTypes = _v2.a.canonicalFieldTypes;
					return _Utils_Tuple2(
						checkSortingBy(
							byFieldOrder(fieldOrder)),
						canonicalFieldTypes);
				}
			} else {
				var ambiguous = matchingOrders.a;
				var unambiguousFieldTypes = A3(
					$elm$core$List$foldl,
					F2(
						function (_v5, acc) {
							var canonicalFieldTypes = _v5.canonicalFieldTypes;
							return A2($author$project$NoUnsortedRecords$keepOnlyMatchingFieldTypes, canonicalFieldTypes, acc);
						}),
					$elm$core$Dict$empty,
					ambiguous);
				switch (sortAmbiguous.$) {
					case 'Alphabetically':
						return _Utils_Tuple2(
							checkSortingBy(alphabetical),
							unambiguousFieldTypes);
					case 'ReportOnly':
						return _Utils_Tuple2(
							A3(
								$author$project$NoUnsortedRecords$ambiguousRecordError,
								record,
								A2(
									$elm$core$List$map,
									A2(
										$elm$core$Basics$composeL,
										$elm$core$List$map(
											function (_v4) {
												var m = _v4.a;
												var n = _v4.b;
												return A2(
													$elm$core$String$join,
													'.',
													_Utils_ap(
														m,
														_List_fromArray(
															[n])));
											}),
										function ($) {
											return $.typeName;
										}),
									ambiguous),
								fullRange),
							unambiguousFieldTypes);
					default:
						return _Utils_Tuple2(_List_Nil, unambiguousFieldTypes);
				}
			}
		}
	});
var $author$project$NoUnsortedRecords$HasFieldOrder = function (a) {
	return {$: 'HasFieldOrder', a: a};
};
var $author$project$NoUnsortedRecords$makeFieldOrder = function () {
	var go = function (type_) {
		if (type_.$ === 'RecordType') {
			var canonical = type_.a.canonical;
			var generic = type_.a.generic;
			var fields = type_.a.fields;
			return canonical ? $elm$core$Result$Ok(
				$author$project$NoUnsortedRecords$FieldOrder(
					{
						canonical: $elm$core$Dict$fromList(
							A2(
								$elm$core$List$indexedMap,
								F2(
									function (i, _v1) {
										var n = _v1.a;
										var t = _v1.b;
										return _Utils_Tuple2(
											n,
											_Utils_Tuple2(i, t));
									}),
								fields)),
						generic: A2(
							$elm$core$Maybe$map,
							function (g) {
								var _v2 = go(g);
								if (_v2.$ === 'Ok') {
									var o = _v2.a;
									return $author$project$NoUnsortedRecords$OrderedFields(o);
								} else {
									if (!_v2.a.b) {
										return $author$project$NoUnsortedRecords$OrderedFields(
											$author$project$NoUnsortedRecords$FieldOrder(
												{canonical: $elm$core$Dict$empty, generic: $elm$core$Maybe$Nothing}));
									} else {
										var fs = _v2.a;
										return $author$project$NoUnsortedRecords$UnknownFields(
											A2($elm$core$List$map, $elm$core$Tuple$first, fs));
									}
								}
							},
							generic)
					})) : $elm$core$Result$Err(fields);
		} else {
			return $elm$core$Result$Err(_List_Nil);
		}
	};
	return A2($elm$core$Basics$composeL, go, $author$project$NoUnsortedRecords$getType);
}();
var $author$project$NoUnsortedRecords$recordPatternToCheckable = F2(
	function (fullRange, hasType) {
		var types = $author$project$NoUnsortedRecords$getRecordFieldTypes(hasType);
		var orderInfo = A2(
			$elm$core$Maybe$map,
			$author$project$NoUnsortedRecords$HasFieldOrder,
			A2(
				$elm$core$Maybe$andThen,
				A2($elm$core$Basics$composeL, $elm$core$Result$toMaybe, $author$project$NoUnsortedRecords$makeFieldOrder),
				hasType));
		return A2(
			$elm$core$Basics$composeR,
			$elm$core$List$map(
				function (r) {
					return {
						field: $stil4m$elm_syntax$Elm$Syntax$Node$value(r),
						range: $stil4m$elm_syntax$Elm$Syntax$Node$range(r),
						type_: A2(
							$elm$core$Dict$get,
							$stil4m$elm_syntax$Elm$Syntax$Node$value(r),
							types)
					};
				}),
			function (fs) {
				return {fields: fs, fullRange: fullRange, orderInfo: orderInfo};
			});
	});
var $author$project$NoUnsortedRecords$checkPattern = F4(
	function (config, context, hasType, node) {
		var go = A2($author$project$NoUnsortedRecords$checkPattern, config, context);
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v0.$) {
			case 'TuplePattern':
				var ps = _v0.a;
				return $elm$core$List$concat(
					A3(
						$elm$core$List$map2,
						go,
						A2($author$project$NoUnsortedRecords$getTupleTypes, ps, hasType),
						ps));
			case 'UnConsPattern':
				var p = _v0.a;
				var ps = _v0.b;
				var type_ = $author$project$NoUnsortedRecords$getListType(hasType);
				return _Utils_ap(
					A2(go, type_, p),
					A2(go, type_, ps));
			case 'ListPattern':
				var ps = _v0.a;
				var type_ = $author$project$NoUnsortedRecords$getListType(hasType);
				return A2(
					$elm$core$List$concatMap,
					go(type_),
					ps);
			case 'AsPattern':
				var p = _v0.a;
				return A2(go, hasType, p);
			case 'ParenthesizedPattern':
				var p = _v0.a;
				return A2(go, hasType, p);
			case 'NamedPattern':
				var name = _v0.a.name;
				var pats = _v0.b;
				return A2(
					$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
					function (_v1) {
						return A2(
							$elm$core$List$concatMap,
							go($elm$core$Maybe$Nothing),
							pats);
					},
					A2(
						$elm$core$Maybe$map,
						$elm$core$List$concat,
						A2(
							$elm$core$Maybe$map,
							A2(
								$elm$core$List$map2,
								F2(
									function (p, t) {
										return A2(
											go,
											$elm$core$Maybe$Just(t),
											p);
									}),
								pats),
							A4(
								$author$project$NoUnsortedRecords$findFunctionType,
								{context: context, localFunctions: $elm$core$Dict$empty},
								hasType,
								node,
								name))));
			case 'RecordPattern':
				var fields = _v0.a;
				return A3(
					$author$project$NoUnsortedRecords$checkRecord,
					config,
					context,
					A3(
						$author$project$NoUnsortedRecords$recordPatternToCheckable,
						$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
						hasType,
						fields)).a;
			default:
				return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$HasAllFields = {$: 'HasAllFields'};
var $elm_community$maybe_extra$Maybe$Extra$orElse = F2(
	function (ma, mb) {
		if (mb.$ === 'Nothing') {
			return ma;
		} else {
			return mb;
		}
	});
var $author$project$NoUnsortedRecords$recordDefToCheckable = F5(
	function (context, fullRange, hasAllFields, hasTypeFromParent, fields) {
		var orderInfo = A2(
			$elm_community$maybe_extra$Maybe$Extra$orElse,
			hasAllFields ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$HasAllFields) : $elm$core$Maybe$Nothing,
			A2(
				$elm$core$Maybe$map,
				$author$project$NoUnsortedRecords$HasFieldOrder,
				A2(
					$elm$core$Maybe$andThen,
					A2($elm$core$Basics$composeL, $elm$core$Result$toMaybe, $author$project$NoUnsortedRecords$makeFieldOrder),
					hasTypeFromParent)));
		var makeType = A2(
			$elm$core$Basics$composeR,
			$author$project$NoUnsortedRecords$typeAnnotToNoncanonicalType(context),
			A2(
				$elm$core$Basics$composeR,
				$author$project$NoUnsortedRecords$dereferenceType(context),
				$elm$core$Maybe$Just));
		return function (fs) {
			return {fields: fs, fullRange: fullRange, orderInfo: orderInfo};
		}(
			A2(
				$elm$core$List$map,
				function (f) {
					var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(f);
					var field = _v0.a;
					var type_ = _v0.b;
					return {
						field: $stil4m$elm_syntax$Elm$Syntax$Node$value(field),
						range: $stil4m$elm_syntax$Elm$Syntax$Node$range(f),
						type_: makeType(type_)
					};
				},
				fields));
	});
var $author$project$NoUnsortedRecords$checkTypeAnnotation = F4(
	function (config, context, hasTypeFromParent, type_) {
		var go = A2($author$project$NoUnsortedRecords$checkTypeAnnotation, config, context);
		var checkFields = F2(
			function (fields, _v6) {
				var parentError = _v6.a;
				var canonicalTypeInfoFromParent = _v6.b;
				return _Utils_ap(
					parentError,
					A2(
						$elm$core$List$concatMap,
						function (_v5) {
							var field = _v5.a;
							var a = _v5.b;
							return function (t) {
								return A4($author$project$NoUnsortedRecords$checkTypeAnnotation, config, context, t, a);
							}(
								A2(
									$elm$core$Maybe$map,
									$author$project$NoUnsortedRecords$dereferenceType(context),
									A2(
										$elm$core$Dict$get,
										$stil4m$elm_syntax$Elm$Syntax$Node$value(field),
										canonicalTypeInfoFromParent)));
						},
						fields));
			});
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(type_);
		switch (_v0.$) {
			case 'Record':
				var def = _v0.a;
				return A2(
					checkFields,
					A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, def),
					A3(
						$author$project$NoUnsortedRecords$checkRecord,
						config,
						context,
						A5(
							$author$project$NoUnsortedRecords$recordDefToCheckable,
							context,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(type_),
							true,
							hasTypeFromParent,
							def)));
			case 'GenericRecord':
				var def = _v0.b;
				return A2(
					checkFields,
					A2(
						$elm$core$List$map,
						$stil4m$elm_syntax$Elm$Syntax$Node$value,
						$stil4m$elm_syntax$Elm$Syntax$Node$value(def)),
					A3(
						$author$project$NoUnsortedRecords$checkRecord,
						config,
						context,
						A5(
							$author$project$NoUnsortedRecords$recordDefToCheckable,
							context,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(type_),
							false,
							hasTypeFromParent,
							$stil4m$elm_syntax$Elm$Syntax$Node$value(def))));
			case 'FunctionTypeAnnotation':
				var fromA = _v0.a;
				var toA = _v0.b;
				var _v1 = function () {
					var _v2 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, hasTypeFromParent);
					if ((_v2.$ === 'Just') && (_v2.a.$ === 'FunctionType')) {
						var from = _v2.a.a.from;
						var to = _v2.a.a.to;
						return _Utils_Tuple2(
							$elm$core$Maybe$Just(
								$author$project$NoUnsortedRecords$DereferencedType(from)),
							$elm$core$Maybe$Just(
								$author$project$NoUnsortedRecords$DereferencedType(to)));
					} else {
						return _Utils_Tuple2($elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
					}
				}();
				var fromType = _v1.a;
				var toType = _v1.b;
				return _Utils_ap(
					A2(go, fromType, fromA),
					A2(go, toType, toA));
			case 'Tupled':
				var types_ = _v0.a;
				return $elm$core$List$concat(
					A3(
						$elm$core$List$map2,
						go,
						A2($author$project$NoUnsortedRecords$getTupleTypes, types_, hasTypeFromParent),
						types_));
			case 'Typed':
				var types_ = _v0.b;
				var typeVars = function () {
					var _v3 = A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$getType, hasTypeFromParent);
					_v3$2:
					while (true) {
						if (_v3.$ === 'Just') {
							switch (_v3.a.$) {
								case 'NamedType':
									var _v4 = _v3.a;
									var ts = _v4.b;
									return A2(
										$elm$core$List$map,
										A2($elm$core$Basics$composeL, $elm$core$Maybe$Just, $author$project$NoUnsortedRecords$DereferencedType),
										ts);
								case 'ListType':
									var t = _v3.a.a;
									return _List_fromArray(
										[
											$elm$core$Maybe$Just(
											$author$project$NoUnsortedRecords$DereferencedType(t))
										]);
								default:
									break _v3$2;
							}
						} else {
							break _v3$2;
						}
					}
					return A2(
						$elm$core$List$map,
						$elm$core$Basics$always($elm$core$Maybe$Nothing),
						types_);
				}();
				return $elm$core$List$concat(
					A3($elm$core$List$map2, go, typeVars, types_));
			case 'GenericType':
				return _List_Nil;
			default:
				return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$makeRecordAccessType = F2(
	function (hasType, accessFunc) {
		return function (f) {
			return A2(
				$elm$core$Maybe$map,
				function (t) {
					return $author$project$NoUnsortedRecords$DereferencedType(
						$author$project$NoUnsortedRecords$RecordType(
							{
								canonical: false,
								fields: _List_fromArray(
									[
										_Utils_Tuple2(
										f,
										$author$project$NoUnsortedRecords$getType(t))
									]),
								generic: $elm$core$Maybe$Just(
									A2($author$project$NoUnsortedRecords$TypeVar, $elm$core$Maybe$Nothing, 'record access field ' + f))
							}));
				},
				hasType);
		}(
			$author$project$Util$makeAccessFunc(accessFunc));
	});
var $author$project$NoUnsortedRecords$recordSettersToCheckable = F4(
	function (context, fullRange, hasAllFields, hasType) {
		var types = $author$project$NoUnsortedRecords$getRecordFieldTypes(hasType);
		var fallback = hasAllFields ? $elm$core$Maybe$Just($author$project$NoUnsortedRecords$HasAllFields) : $elm$core$Maybe$Nothing;
		var orderInfo = A2(
			$elm_community$maybe_extra$Maybe$Extra$orElse,
			fallback,
			A2(
				$elm$core$Maybe$map,
				$author$project$NoUnsortedRecords$HasFieldOrder,
				A2(
					$elm$core$Maybe$andThen,
					A2($elm$core$Basics$composeL, $elm$core$Result$toMaybe, $author$project$NoUnsortedRecords$makeFieldOrder),
					hasType)));
		return A2(
			$elm$core$Basics$composeR,
			$elm$core$List$map(
				function (r) {
					var f = $stil4m$elm_syntax$Elm$Syntax$Node$value(
						$stil4m$elm_syntax$Elm$Syntax$Node$value(r).a);
					return {
						field: f,
						range: $stil4m$elm_syntax$Elm$Syntax$Node$range(r),
						type_: A2(
							$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
							function (_v0) {
								return A2(
									$author$project$NoUnsortedRecords$inferExprType,
									context,
									$stil4m$elm_syntax$Elm$Syntax$Node$value(r).b);
							},
							A2($elm$core$Dict$get, f, types))
					};
				}),
			function (fs) {
				return {fields: fs, fullRange: fullRange, orderInfo: orderInfo};
			});
	});
var $author$project$NoUnsortedRecords$checkApplicationChain = F4(
	function (config, local, hasType, es) {
		checkApplicationChain:
		while (true) {
			var checkExpr = A2($author$project$NoUnsortedRecords$checkExpression, config, local);
			if (!es.b) {
				return _List_Nil;
			} else {
				if (!es.b.b) {
					var e = es.a;
					return A2(checkExpr, hasType, e);
				} else {
					var func = es.a;
					var args = es.b;
					var _v12 = $stil4m$elm_syntax$Elm$Syntax$Node$value(func);
					switch (_v12.$) {
						case 'FunctionOrValue':
							var name = _v12.b;
							return A2(
								$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
								function (_v16) {
									return A2(
										$elm$core$List$concatMap,
										checkExpr($elm$core$Maybe$Nothing),
										es);
								},
								A2(
									$elm$core$Maybe$map,
									$elm$core$List$concat,
									A2(
										$elm$core$Maybe$map,
										A2(
											$elm$core$List$map2,
											F2(
												function (e, t) {
													return A2(
														checkExpr,
														$elm$core$Maybe$Just(t),
														e);
												}),
											args),
										A2(
											$elm$core$Maybe$map,
											function (_v13) {
												var argTypes = _v13.a;
												var _return = _v13.b;
												return A2(
													$elm$core$Maybe$withDefault,
													argTypes,
													A2(
														$elm$core$Maybe$map,
														function (typeVars) {
															return A2(
																$elm$core$List$map,
																$author$project$NoUnsortedRecords$assignTypeVars(typeVars),
																argTypes);
														},
														A2(
															$elm$core$Maybe$map,
															$elm_community$dict_extra$Dict$Extra$mapKeys($elm$core$Tuple$second),
															A2(
																$elm$core$Maybe$map,
																$elm$core$Dict$filter(
																	F2(
																		function (_v14, _v15) {
																			var i = _v14.a;
																			return i === 1;
																		})),
																A2(
																	$elm$core$Maybe$map,
																	$elm$core$Tuple$first,
																	A2(
																		$elm$core$Maybe$map,
																		A2($author$project$NoUnsortedRecords$typesMatch, $elm$core$Dict$empty, _return),
																		hasType))))));
											},
											A2(
												$elm$core$Maybe$andThen,
												$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
												A4($author$project$NoUnsortedRecords$findFunctionType, local, hasType, func, name))))));
						case 'PrefixOperator':
							var op = _v12.a;
							return A2(
								$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
								function (_v20) {
									return A2(
										$elm$core$List$concatMap,
										checkExpr($elm$core$Maybe$Nothing),
										es);
								},
								A2(
									$elm$core$Maybe$map,
									$elm$core$List$concat,
									A2(
										$elm$core$Maybe$map,
										A2(
											$elm$core$List$map2,
											F2(
												function (e, t) {
													return A2(
														checkExpr,
														$elm$core$Maybe$Just(t),
														e);
												}),
											args),
										A2(
											$elm$core$Maybe$map,
											function (_v17) {
												var argTypes = _v17.a;
												var _return = _v17.b;
												return A2(
													$elm$core$Maybe$withDefault,
													argTypes,
													A2(
														$elm$core$Maybe$map,
														function (typeVars) {
															return A2(
																$elm$core$List$map,
																$author$project$NoUnsortedRecords$assignTypeVars(typeVars),
																argTypes);
														},
														A2(
															$elm$core$Maybe$map,
															$elm_community$dict_extra$Dict$Extra$mapKeys($elm$core$Tuple$second),
															A2(
																$elm$core$Maybe$map,
																$elm$core$Dict$filter(
																	F2(
																		function (_v18, _v19) {
																			var i = _v18.a;
																			return i === 1;
																		})),
																A2(
																	$elm$core$Maybe$map,
																	$elm$core$Tuple$first,
																	A2(
																		$elm$core$Maybe$map,
																		A2($author$project$NoUnsortedRecords$typesMatch, $elm$core$Dict$empty, _return),
																		hasType))))));
											},
											A2(
												$elm$core$Maybe$andThen,
												$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
												A2($author$project$NoUnsortedRecords$findOperatorType, local.context, op))))));
						case 'ParenthesizedExpression':
							var func_ = _v12.a;
							var $temp$config = config,
								$temp$local = local,
								$temp$hasType = hasType,
								$temp$es = A2($elm$core$List$cons, func_, args);
							config = $temp$config;
							local = $temp$local;
							hasType = $temp$hasType;
							es = $temp$es;
							continue checkApplicationChain;
						case 'RecordAccessFunction':
							var accessFunc = _v12.a;
							return function (f) {
								return A2($elm$core$List$concatMap, f, args);
							}(
								checkExpr(
									A2($author$project$NoUnsortedRecords$makeRecordAccessType, hasType, accessFunc)));
						default:
							return A2(
								$elm$core$List$concatMap,
								checkExpr($elm$core$Maybe$Nothing),
								es);
					}
				}
			}
		}
	});
var $author$project$NoUnsortedRecords$checkExpression = F4(
	function (config, local, hasType, node) {
		var go = A2($author$project$NoUnsortedRecords$checkExpression, config, local);
		var checkFields = F3(
			function (typeInfo, fields, _v10) {
				var parentError = _v10.a;
				var canonicalTypeInfoFromParent = _v10.b;
				return _Utils_ap(
					parentError,
					A2(
						$elm$core$List$concatMap,
						function (_v8) {
							var field = _v8.a;
							var e = _v8.b;
							var f = $stil4m$elm_syntax$Elm$Syntax$Node$value(field);
							return function (t) {
								return A2(go, t, e);
							}(
								A2(
									$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
									function (_v9) {
										return A2($elm$core$Dict$get, f, typeInfo);
									},
									A2(
										$elm$core$Maybe$map,
										$author$project$NoUnsortedRecords$dereferenceType(local.context),
										A2($elm$core$Dict$get, f, canonicalTypeInfoFromParent))));
						},
						fields));
			});
		var _v4 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		switch (_v4.$) {
			case 'Negation':
				var e = _v4.a;
				return A2(go, hasType, e);
			case 'ParenthesizedExpression':
				var e = _v4.a;
				return A2(go, hasType, e);
			case 'ListExpr':
				var es = _v4.a;
				var type_ = $author$project$NoUnsortedRecords$getListType(hasType);
				return A2(
					$elm$core$List$concatMap,
					go(type_),
					es);
			case 'Application':
				var es = _v4.a;
				return A4($author$project$NoUnsortedRecords$checkApplicationChain, config, local, hasType, es);
			case 'OperatorApplication':
				var op = _v4.a;
				var e1 = _v4.c;
				var e2 = _v4.d;
				return A4(
					$author$project$NoUnsortedRecords$checkOperatorApplication,
					A3($author$project$NoUnsortedRecords$checkApplicationChain, config, local, hasType),
					op,
					e1,
					e2);
			case 'IfBlock':
				var pred = _v4.a;
				var thenE = _v4.b;
				var elseE = _v4.c;
				return _Utils_ap(
					A2(
						go,
						$elm$core$Maybe$Just(
							$author$project$NoUnsortedRecords$DereferencedType(
								A2(
									$author$project$NoUnsortedRecords$NamedType,
									_Utils_Tuple2(
										_List_fromArray(
											['Basics']),
										'Bool'),
									_List_Nil))),
						pred),
					_Utils_ap(
						A2(go, hasType, thenE),
						A2(go, hasType, elseE)));
			case 'TupledExpression':
				var es = _v4.a;
				return $elm$core$List$concat(
					A3(
						$elm$core$List$map2,
						go,
						A2($author$project$NoUnsortedRecords$getTupleTypes, es, hasType),
						es));
			case 'CaseExpression':
				var expression = _v4.a.expression;
				var cases = _v4.a.cases;
				var caseType = A2($author$project$NoUnsortedRecords$inferExprType, local, expression);
				return _Utils_ap(
					A2(go, $elm$core$Maybe$Nothing, expression),
					_Utils_ap(
						A2(
							$elm$core$List$concatMap,
							function (_v5) {
								var p = _v5.a;
								var e = _v5.b;
								return function (newBindings) {
									return A4(
										$author$project$NoUnsortedRecords$checkExpression,
										config,
										_Utils_update(
											local,
											{
												localFunctions: A2($elm$core$Dict$union, local.localFunctions, newBindings)
											}),
										hasType,
										e);
								}(
									$elm$core$Dict$fromList(
										A3($author$project$NoUnsortedRecords$bindingsInPatternWithType, local.context, p, caseType)));
							},
							cases),
						A2(
							$elm$core$List$concatMap,
							A2(
								$elm$core$Basics$composeL,
								A3($author$project$NoUnsortedRecords$checkPattern, config, local.context, caseType),
								$elm$core$Tuple$first),
							cases)));
			case 'LambdaExpression':
				var args = _v4.a.args;
				var expression = _v4.a.expression;
				return A5($author$project$NoUnsortedRecords$checkFunctionArgsAndExpr, config, local, hasType, args, expression);
			case 'LetExpression':
				var declarations = _v4.a.declarations;
				var expression = _v4.a.expression;
				var _v6 = A2(
					$elm$core$Tuple$mapFirst,
					A2($elm$core$Basics$composeL, $elm$core$Dict$fromList, $elm$core$List$concat),
					$elm$core$List$unzip(
						A2(
							$elm$core$List$map,
							A2(
								$elm$core$Basics$composeL,
								A2($author$project$NoUnsortedRecords$checkLetDeclaration, config, local),
								$stil4m$elm_syntax$Elm$Syntax$Node$value),
							declarations)));
				var newBindings = _v6.a;
				var decsToCheck = _v6.b;
				var newContext = _Utils_update(
					local,
					{
						localFunctions: A2($elm$core$Dict$union, local.localFunctions, newBindings)
					});
				return _Utils_ap(
					A4($author$project$NoUnsortedRecords$checkExpression, config, newContext, hasType, expression),
					A2(
						$elm$core$List$concatMap,
						function (f) {
							return f(newContext);
						},
						decsToCheck));
			case 'RecordExpr':
				var recordSetters = _v4.a;
				var ts = $author$project$NoUnsortedRecords$getRecordFieldTypes(hasType);
				return A3(
					checkFields,
					ts,
					A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, recordSetters),
					A3(
						$author$project$NoUnsortedRecords$checkRecord,
						config,
						local.context,
						A5(
							$author$project$NoUnsortedRecords$recordSettersToCheckable,
							local,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
							true,
							hasType,
							recordSetters)));
			case 'RecordUpdateExpression':
				var recordSetters = _v4.b;
				var updateType = A2(
					$elm_community$maybe_extra$Maybe$Extra$orElseLazy,
					function (_v7) {
						return A2($author$project$NoUnsortedRecords$inferExprType, local, node);
					},
					hasType);
				var ts = $author$project$NoUnsortedRecords$getRecordFieldTypes(updateType);
				return A3(
					checkFields,
					ts,
					A2($elm$core$List$map, $stil4m$elm_syntax$Elm$Syntax$Node$value, recordSetters),
					A3(
						$author$project$NoUnsortedRecords$checkRecord,
						config,
						local.context,
						A5(
							$author$project$NoUnsortedRecords$recordSettersToCheckable,
							local,
							$stil4m$elm_syntax$Elm$Syntax$Node$range(node),
							false,
							updateType,
							recordSetters)));
			case 'RecordAccess':
				var e = _v4.a;
				var accessFunc = _v4.b;
				return A2(
					go,
					A2(
						$author$project$NoUnsortedRecords$makeRecordAccessType,
						hasType,
						$stil4m$elm_syntax$Elm$Syntax$Node$value(accessFunc)),
					e);
			default:
				return _List_Nil;
		}
	});
var $author$project$NoUnsortedRecords$checkFunctionArgsAndExpr = F5(
	function (config, local, hasType, args, expr) {
		var _v2 = A2(
			$elm_community$maybe_extra$Maybe$Extra$withDefaultLazy,
			function (_v3) {
				return _Utils_Tuple2(
					A2(
						$elm$core$List$map,
						$elm$core$Basics$always($elm$core$Maybe$Nothing),
						args),
					$elm$core$Maybe$Nothing);
			},
			A2(
				$elm$core$Maybe$map,
				A2(
					$elm$core$Tuple$mapBoth,
					$elm$core$List$map($elm$core$Maybe$Just),
					$elm$core$Maybe$Just),
				A2(
					$elm$core$Maybe$andThen,
					$author$project$NoUnsortedRecords$partiallyApplyArgsAndTypes(args),
					A2($elm$core$Maybe$map, $author$project$NoUnsortedRecords$flattenFunctionType, hasType))));
		var argTypes = _v2.a;
		var exprType = _v2.b;
		var newBindings = $elm$core$Dict$fromList(
			$elm$core$List$concat(
				A3(
					$elm$core$List$map2,
					$author$project$NoUnsortedRecords$bindingsInPatternWithType(local.context),
					args,
					argTypes)));
		return _Utils_ap(
			A4(
				$author$project$NoUnsortedRecords$checkExpression,
				config,
				_Utils_update(
					local,
					{
						localFunctions: A2($elm$core$Dict$union, local.localFunctions, newBindings)
					}),
				exprType,
				expr),
			$elm$core$List$concat(
				A3(
					$elm$core$List$map2,
					A2($author$project$NoUnsortedRecords$checkPattern, config, local.context),
					argTypes,
					args)));
	});
var $author$project$NoUnsortedRecords$checkFunctionDeclaration = F3(
	function (config, local, func) {
		var hasType = A2(
			$elm$core$Maybe$map,
			$elm$core$Tuple$second,
			A2($author$project$NoUnsortedRecords$getFunctionBinding, local.context, func));
		var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(func.declaration);
		var _arguments = _v1._arguments;
		var expression = _v1.expression;
		return function (errsInAnnot) {
			return _Utils_ap(
				errsInAnnot,
				A5($author$project$NoUnsortedRecords$checkFunctionArgsAndExpr, config, local, hasType, _arguments, expression));
		}(
			A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				A2(
					$elm$core$Maybe$map,
					A2(
						$elm$core$Basics$composeL,
						A2(
							$elm$core$Basics$composeL,
							A3($author$project$NoUnsortedRecords$checkTypeAnnotation, config, local.context, $elm$core$Maybe$Nothing),
							function ($) {
								return $.typeAnnotation;
							}),
						$stil4m$elm_syntax$Elm$Syntax$Node$value),
					func.signature)));
	});
var $author$project$NoUnsortedRecords$checkLetDeclaration = F3(
	function (config, local, d) {
		return A2(
			$elm$core$Tuple$pair,
			A2($author$project$NoUnsortedRecords$bindingsFromLetDeclaration, local, d),
			function () {
				if (d.$ === 'LetFunction') {
					var f = d.a;
					return function (local_) {
						return A3($author$project$NoUnsortedRecords$checkFunctionDeclaration, config, local_, f);
					};
				} else {
					var p = d.a;
					var e = d.b;
					return function (local_) {
						return _Utils_ap(
							A4($author$project$NoUnsortedRecords$checkExpression, config, local_, $elm$core$Maybe$Nothing, e),
							A4(
								$author$project$NoUnsortedRecords$checkPattern,
								config,
								local.context,
								A2($author$project$NoUnsortedRecords$inferExprType, local_, e),
								p));
					};
				}
			}());
	});
var $author$project$NoUnsortedRecords$declarationEnterVisitor = F3(
	function (config, context, node) {
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Node$value(node);
		if (_v0.$ === 'FunctionDeclaration') {
			var f = _v0.a;
			return A3(
				$author$project$NoUnsortedRecords$checkFunctionDeclaration,
				config,
				{context: context, localFunctions: $elm$core$Dict$empty},
				f);
		} else {
			return _List_Nil;
		}
	});
var $jfmengels$elm_review$Review$Rule$withDeclarationEnterVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					declarationVisitorsOnEnter: A2($elm$core$List$cons, visitor, schema.declarationVisitorsOnEnter)
				}));
	});
var $author$project$NoUnsortedRecords$moduleVisitor = F2(
	function (config, schema) {
		return A2(
			$jfmengels$elm_review$Review$Rule$withDeclarationEnterVisitor,
			F2(
				function (d, c) {
					return c.fileIsIgnored ? _Utils_Tuple2(_List_Nil, c) : _Utils_Tuple2(
						A3($author$project$NoUnsortedRecords$declarationEnterVisitor, config, c, d),
						c);
				}),
			schema);
	});
var $author$project$NoUnsortedRecords$rule = function (config) {
	return $jfmengels$elm_review$Review$Rule$fromProjectRuleSchema(
		$jfmengels$elm_review$Review$Rule$providesFixesForProjectRule(
			$jfmengels$elm_review$Review$Rule$withContextFromImportedModules(
				A2(
					$jfmengels$elm_review$Review$Rule$withModuleContextUsingContextCreator,
					{
						foldProjectContexts: $author$project$NoUnsortedRecords$foldProjectContexts,
						fromModuleToProject: $author$project$NoUnsortedRecords$fromModuleToProject,
						fromProjectToModule: $author$project$NoUnsortedRecords$fromProjectToModule(config)
					},
					A2(
						$jfmengels$elm_review$Review$Rule$withModuleVisitor,
						$author$project$NoUnsortedRecords$moduleVisitor(config),
						A2(
							$jfmengels$elm_review$Review$Rule$withDependenciesProjectVisitor,
							F2(
								function (d, c) {
									return _Utils_Tuple2(
										_List_Nil,
										A3($author$project$NoUnsortedRecords$dependencyVisitor, config, c, d));
								}),
							A2($jfmengels$elm_review$Review$Rule$newProjectRuleSchema, 'NoUnsortedRecords', $author$project$NoUnsortedRecords$initialProjectContext)))))));
};
var $author$project$NoUnsortedRecordsTest$unsortedError = $jfmengels$elm_review$Review$Test$error(
	{
		details: _List_fromArray(
			['Record fields were found out of order.  They should be sorted as specified in the rule configuration.']),
		message: 'Record fields are not sorted.',
		under: '{'
	});
var $author$project$NoUnsortedRecordsTest$ambiguousRecords = A2(
	$elm_explorations$test$Test$describe,
	'ambiguous records',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes ambiguous record that is alphabetical',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na = { a = 1, b = 2, c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails ambiguous record that is not alphabetical',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na = { a = 1, b = 2, c = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na = { b = 2, a = 1, c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'passes ambiguous record that is not alphabetical with option',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$doNotSortAmbiguousRecords($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na = { b = 2, a = 1, c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'passes unambiguous record (because of identical field orders',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { b : Int, c : Int, a : Int }\n\na = { b = 2, c = 3, a = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'reports ambiguous record that is not alphabetical with option',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$author$project$NoUnsortedRecordsTest$ambiguousRecordError,
							_List_fromArray(
								['A.A', 'A.B']),
							'{ b = 2, a = 1, c = 3 }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na = { b = 2, a = 1, c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not report ambiguous records with a single field even with option',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { b : Int, c : Int, a : Int }\ntype alias B = { c : Int, a : Int, b : Int }\n\na r =\n    case r of\n        { b } ->\n            True\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$avoidBadFixes = A2(
	$elm_explorations$test$Test$describe,
	'avoids bad fixes',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'do not splice onto the ends of comments',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Rec =\n    { foo : Int\n    , bar : Int\n    , baz : Int\n    }\n\ntest : Rec -> Rec\ntest r =\n    { r\n        | foo = 2\n        , bar = 1\n        -- comment\n        , baz = 3\n    }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 11},
									start: {column: 5, row: 11}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Rec =\n    { foo : Int\n    , bar : Int\n    , baz : Int\n    }\n\ntest : Rec -> Rec\ntest r =\n    { r\n        | bar = 1\n        -- comment\n        , foo = 2\n        , baz = 3\n    }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$customTypeArgs = A2(
	$elm_explorations$test$Test$describe,
	'record is an argument of a type',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'fields are in sorted order',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are not in sorted order',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 8, row: 5},
									start: {column: 7, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguates by constructor for expressions',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 8, row: 7},
									start: {column: 7, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguates by constructor arg index for expressions',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { foo = 2, bar = 1, baz = 3 } "hello" { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 10, row: 6},
									start: {column: 9, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { bar = 1, foo = 2, baz = 3 } "hello" { bar = 2, foo = 1, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 48, row: 6},
									start: {column: 47, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { bar = 1, foo = 2, baz = 3 } "hello" { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguates by constructor arg index for patterns',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { foo, bar } _ {foo, bar} -> False\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 14, row: 9},
									start: {column: 13, row: 9}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { bar, foo } _ {bar, foo} -> False\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 29, row: 9},
									start: {column: 28, row: 9}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { bar, foo } _ {foo, bar} -> False\n'));
			})
		]));
var $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$dependencyModules = _List_fromArray(
	[
		{
		aliases: _List_fromArray(
			[
				{
				args: _List_Nil,
				comment: ' A parser can run into situations where there is no way to make progress.\nWhen that happens, I record the `row` and `col` where you got stuck and the\nparticular `problem` you ran into. That is a `DeadEnd`!\n\n**Note:** I count rows and columns like a text editor. The beginning is `row=1`\nand `col=1`. As I chomp characters, the `col` increments. When I reach a `\\n`\ncharacter, I increment the `row` and set `col=1`.\n',
				name: 'DeadEnd',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Record,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'row',
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
							_Utils_Tuple2(
							'col',
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
							_Utils_Tuple2(
							'problem',
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Problem', _List_Nil))
						]),
					$elm$core$Maybe$Nothing)
			},
				{
				args: _List_fromArray(
					['a']),
				comment: ' A `Parser` helps turn a `String` into nicely structured data. For example,\nwe can [`run`](#run) the [`int`](#int) parser to turn `String` to `Int`:\n\n    run int "123456" == Ok 123456\n    run int "3.1415" == Err ...\n\nThe cool thing is that you can combine `Parser` values to handle much more\ncomplex scenarios.\n',
				name: 'Parser',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Never', _List_Nil),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Problem', _List_Nil),
							$elm$project_metadata_utils$Elm$Type$Var('a')
						]))
			}
			]),
		binops: _List_fromArray(
			[
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' **Skip** values in a parser pipeline. For example, maybe we want to parse\nsome JavaScript variables:\n\n    var : Parser String\n    var =\n      getChompedString <|\n        succeed ()\n          |. chompIf isStartChar\n          |. chompWhile isInnerChar\n\n    isStartChar : Char -> Bool\n    isStartChar char =\n      Char.isAlpha char || char == \'_\' || char == \'$\'\n\n    isInnerChar : Char -> Bool\n    isInnerChar char =\n      isStartChar char || Char.isDigit char\n\n`chompIf isStartChar` can chomp one character and produce a `()` value.\n`chompWhile isInnerChar` can chomp zero or more characters and produce a `()`\nvalue. The `(|.)` operators are saying to still chomp all the characters, but\nskip the two `()` values that get produced. No one cares about them.\n',
				name: '|.',
				precedence: 6,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('keep')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('ignore')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('keep')
								]))))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' **Keep** values in a parser pipeline. For example, we could say:\n\n    type alias Point = { x : Float, y : Float }\n\n    point : Parser Point\n    point =\n      succeed Point\n        |. symbol "("\n        |. spaces\n        |= float\n        |. spaces\n        |. symbol ","\n        |. spaces\n        |= float\n        |. spaces\n        |. symbol ")"\n\nAll the parsers in this pipeline will chomp characters and produce values. So\n`symbol "("` will chomp one paren and produce a `()` value. Similarly, `float`\nwill chomp some digits and produce a `Float` value. The `(|.)` and `(|=)`\noperators just decide whether we give the values to the `Point` function.\n\nSo in this case, we skip the `()` from `symbol "("`, we skip the `()` from\n`spaces`, we keep the `Float` from `float`, etc.\n',
				name: '|=',
				precedence: 5,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								$elm$project_metadata_utils$Elm$Type$Var('b'))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			}
			]),
		comment: '\n\n# Parsers\n@docs Parser, run\n\n# Building Blocks\n@docs int, float, number, symbol, keyword, variable, end\n\n# Pipelines\n@docs succeed, (|=), (|.), lazy, andThen, problem\n\n# Branches\n@docs oneOf, map, backtrackable, commit, token\n\n# Loops\n@docs sequence, Trailing, loop, Step\n\n# Whitespace\n@docs spaces, lineComment, multiComment, Nestable\n\n# Chompers\n@docs getChompedString, chompIf, chompWhile, chompUntil, chompUntilEndOr, mapChompedString\n\n# Errors\n@docs DeadEnd, Problem, deadEndsToString\n\n# Indentation\n@docs withIndent, getIndent\n\n# Positions\n@docs getPosition, getRow, getCol, getOffset, getSource\n',
		name: 'Parser',
		unions: _List_fromArray(
			[
				{
				args: _List_Nil,
				comment: ' Not all languages handle multi-line comments the same. Multi-line comments\nin C-style syntax are `NotNestable`, meaning they can be implemented like this:\n\n    js : Parser ()\n    js =\n      symbol "/*"\n        |. chompUntil "*/"\n\nIn fact, `multiComment "/*" "*/" NotNestable` *is* implemented like that! It is\nvery simple, but it does not allow you to nest comments like this:\n\n```javascript\n/*\nline1\n/* line2 */\nline3\n*/\n```\n\nIt would stop on the first `*/`, eventually throwing a syntax error on the\nsecond `*/`. This can be pretty annoying in long files.\n\nLanguages like Elm allow you to nest multi-line comments, but your parser needs\nto be a bit fancier to handle this. After you start a comment, you have to\ndetect if there is another one inside it! And then you have to make sure all\nthe `{-` and `-}` match up properly! Saying `multiComment "{-" "-}" Nestable`\ndoes all that for you.\n',
				name: 'Nestable',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('NotNestable', _List_Nil),
						_Utils_Tuple2('Nestable', _List_Nil)
					])
			},
				{
				args: _List_Nil,
				comment: ' When you run into a `DeadEnd`, I record some information about why you\ngot stuck. This data is useful for producing helpful error messages. This is\nhow [`deadEndsToString`](#deadEndsToString) works!\n\n**Note:** If you feel limited by this type (i.e. having to represent custom\nproblems as strings) I highly recommend switching to `Parser.Advanced`. It\nlets you define your own `Problem` type. It can also track "context" which\ncan improve error messages a ton! This is how the Elm compiler produces\nrelatively nice parse errors, and I am excited to see those techniques applied\nelsewhere!\n',
				name: 'Problem',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Expecting',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])),
						_Utils_Tuple2('ExpectingInt', _List_Nil),
						_Utils_Tuple2('ExpectingHex', _List_Nil),
						_Utils_Tuple2('ExpectingOctal', _List_Nil),
						_Utils_Tuple2('ExpectingBinary', _List_Nil),
						_Utils_Tuple2('ExpectingFloat', _List_Nil),
						_Utils_Tuple2('ExpectingNumber', _List_Nil),
						_Utils_Tuple2('ExpectingVariable', _List_Nil),
						_Utils_Tuple2(
						'ExpectingSymbol',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])),
						_Utils_Tuple2(
						'ExpectingKeyword',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])),
						_Utils_Tuple2('ExpectingEnd', _List_Nil),
						_Utils_Tuple2('UnexpectedChar', _List_Nil),
						_Utils_Tuple2(
						'Problem',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])),
						_Utils_Tuple2('BadRepeat', _List_Nil)
					])
			},
				{
				args: _List_fromArray(
					['state', 'a']),
				comment: ' Decide what steps to take next in your [`loop`](#loop).\n\nIf you are `Done`, you give the result of the whole `loop`. If you decide to\n`Loop` around again, you give a new state to work from. Maybe you need to add\nan item to a list? Or maybe you need to track some information about what you\njust saw?\n\n**Note:** It may be helpful to learn about [finite-state machines][fsm] to get\na broader intuition about using `state`. I.e. You may want to create a `type`\nthat describes four possible states, and then use `Loop` to transition between\nthem as you consume characters.\n\n[fsm]: https://en.wikipedia.org/wiki/Finite-state_machine\n',
				name: 'Step',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Loop',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('state')
							])),
						_Utils_Tuple2(
						'Done',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							]))
					])
			},
				{
				args: _List_Nil,
				comment: ' Whats the deal with trailing commas? Are they `Forbidden`?\nAre they `Optional`? Are they `Mandatory`? Welcome to [shapes\nclub](https://poorlydrawnlines.com/comic/shapes-club/)!\n',
				name: 'Trailing',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('Forbidden', _List_Nil),
						_Utils_Tuple2('Optional', _List_Nil),
						_Utils_Tuple2('Mandatory', _List_Nil)
					])
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Parse one thing `andThen` parse another thing. This is useful when you want\nto check on what you just parsed. For example, maybe you want U.S. zip codes\nand `int` is not suitable because it does not allow leading zeros. You could\nsay:\n\n    zipCode : Parser String\n    zipCode =\n      getChompedString (chompWhile Char.isDigit)\n        |> andThen checkZipCode\n\n    checkZipCode : String -> Parser String\n    checkZipCode code =\n      if String.length code == 5 then\n        succeed code\n      else\n        problem "a U.S. zip code has exactly 5 digits"\n\nFirst we chomp digits `andThen` we check if it is a valid U.S. zip code. We\n`succeed` if it has exactly five digits and report a `problem` if not.\n\nCheck out [`examples/DoubleQuoteString.elm`](https://github.com/elm/parser/blob/master/examples/DoubleQuoteString.elm)\nfor another example, this time using `andThen` to verify unicode code points.\n\n**Note:** If you are using `andThen` recursively and blowing the stack, check\nout the [`loop`](#loop) function to limit stack usage.\n',
				name: 'andThen',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' It is quite tricky to use `backtrackable` well! It can be very useful, but\nalso can degrade performance and error message quality.\n\nRead [this document](https://github.com/elm/parser/blob/master/semantics.md)\nto learn how `oneOf`, `backtrackable`, and `commit` work and interact with\neach other. It is subtle and important!\n',
				name: 'backtrackable',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Chomp one character if it passes the test.\n\n    chompUpper : Parser ()\n    chompUpper =\n      chompIf Char.isUpper\n\nSo this can chomp a character like `T` and produces a `()` value.\n',
				name: 'chompIf',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Chomp until you see a certain string. You could define C-style multi-line\ncomments like this:\n\n    comment : Parser ()\n    comment =\n      symbol "/*"\n        |. chompUntil "*/"\n\nI recommend using [`multiComment`](#multiComment) for this particular scenario\nthough. It can be trickier than it looks!\n',
				name: 'chompUntil',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Chomp until you see a certain string or until you run out of characters to\nchomp! You could define single-line comments like this:\n\n    elm : Parser ()\n    elm =\n      symbol "--"\n        |. chompUntilEndOr "\\n"\n\nA file may end with a single-line comment, so the file can end before you see\na newline. Tricky!\n\nI recommend just using [`lineComment`](#lineComment) for this particular\nscenario.\n',
				name: 'chompUntilEndOr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Chomp zero or more characters if they pass the test. This is commonly\nuseful for chomping whitespace or variable names:\n\n    whitespace : Parser ()\n    whitespace =\n      chompWhile (\\c -> c == \' \' || c == \'\\t\' || c == \'\\n\' || c == \'\\r\')\n\n    elmVar : Parser String\n    elmVar =\n      getChompedString <|\n        succeed ()\n          |. chompIf Char.isLower\n          |. chompWhile (\\c -> Char.isAlphaNum c || c == \'_\')\n\n**Note:** a `chompWhile` parser always succeeds! This can lead to tricky\nsituations, especially if you define your whitespace with it. In that case,\nyou could accidentally interpret `letx` as the keyword `let` followed by\n"spaces" followed by the variable `x`. This is why the `keyword` and `number`\nparsers peek ahead, making sure they are not followed by anything unexpected.\n',
				name: 'chompWhile',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' `commit` is almost always paired with `backtrackable` in some way, and it\nis tricky to use well.\n\nRead [this document](https://github.com/elm/parser/blob/master/semantics.md)\nto learn how `oneOf`, `backtrackable`, and `commit` work and interact with\neach other. It is subtle and important!\n',
				name: 'commit',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Turn all the `DeadEnd` data into a string that is easier for people to\nread.\n\n**Note:** This is just a baseline of quality. It cannot do anything with colors.\nIt is not interactivite. It just turns the raw data into strings. I really hope\nfolks will check out the source code for some inspiration on how to turn errors\ninto `Html` with nice colors and interaction! The `Parser.Advanced` module lets\nyou work with context as well, which really unlocks another level of quality!\nThe "context" technique is how the Elm compiler can say "I think I am parsing a\nlist, so I was expecting a closing `]` here." Telling users what the parser\n_thinks_ is happening can be really helpful!\n',
				name: 'deadEndsToString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.DeadEnd', _List_Nil)
							])),
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil))
			},
				{
				comment: ' Check if you have reached the end of the string you are parsing.\n\n    justAnInt : Parser Int\n    justAnInt =\n      succeed identity\n        |= int\n        |. end\n\n    -- run justAnInt "90210" == Ok 90210\n    -- run justAnInt "1 + 2" == Err ...\n    -- run int       "1 + 2" == Ok 1\n\nParsers can succeed without parsing the whole string. Ending your parser\nwith `end` guarantees that you have successfully parsed the whole string.\n',
				name: 'end',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
						]))
			},
				{
				comment: ' Parse floats.\n\n    run float "123"       == Ok 123\n    run float "3.1415"    == Ok 3.1415\n    run float "0.1234"    == Ok 0.1234\n    run float ".1234"     == Ok 0.1234\n    run float "1e-42"     == Ok 1e-42\n    run float "6.022e23"  == Ok 6.022e23\n    run float "6.022E23"  == Ok 6.022e23\n    run float "6.022e+23" == Ok 6.022e23\n\nIf you want to disable literals like `.123` (like in Elm) you could write\nsomething like this:\n\n    elmFloat : Parser Float\n    elmFloat =\n      oneOf\n        [ symbol "."\n            |. problem "floating point numbers must start with a digit, like 0.25"\n        , float\n        ]\n\n**Note:** If you want a parser for both `Int` and `Float` literals, check out\n[`number`](#number) below. It will be faster than using `oneOf` to combining\n`int` and `float` yourself.\n',
				name: 'float',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
						]))
			},
				{
				comment: ' Sometimes parsers like `int` or `variable` cannot do exactly what you\nneed. The "chomping" family of functions is meant for that case! Maybe you\nneed to parse [valid PHP variables][php] like `$x` and `$txt`:\n\n    php : Parser String\n    php =\n      getChompedString <|\n        succeed ()\n          |. chompIf (\\c -> c == \'$\')\n          |. chompIf (\\c -> Char.isAlpha c || c == \'_\')\n          |. chompWhile (\\c -> Char.isAlphaNum c || c == \'_\')\n\nThe idea is that you create a bunch of chompers that validate the underlying\ncharacters. Then `getChompedString` extracts the underlying `String` efficiently.\n\n**Note:** Maybe it is helpful to see how you can use [`getOffset`](#getOffset)\nand [`getSource`](#getSource) to implement this function:\n\n    getChompedString : Parser a -> Parser String\n    getChompedString parser =\n      succeed String.slice\n        |= getOffset\n        |. parser\n        |= getOffset\n        |= getSource\n\n[php]: https://www.w3schools.com/php/php_variables.asp\n',
				name: 'getChompedString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			},
				{
				comment: ' This is a more efficient version of `map Tuple.second getPosition`. This\ncan be useful in combination with [`withIndent`](#withIndent) and\n[`getIndent`](#getIndent), like this:\n\n    checkIndent : Parser ()\n    checkIndent =\n      succeed (\\indent column -> indent <= column)\n        |= getIndent\n        |= getCol\n        |> andThen checkIndentHelp\n\n    checkIndentHelp : Bool -> Parser ()\n    checkIndentHelp isIndented =\n      if isIndented then\n        succeed ()\n      else\n        problem "expecting more spaces"\n\nSo the `checkIndent` parser only succeeds when you are "deeper" than the\ncurrent indent level. You could use this to parse Elm-style `let` expressions.\n',
				name: 'getCol',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' When someone said `withIndent` earlier, what number did they put in there?\n\n- `getIndent` results in `0`, the default value\n- `withIndent 4 getIndent` results in `4`\n\nSo you are just asking about things you said earlier. These numbers do not leak\nout of `withIndent`, so say we have:\n\n    succeed Tuple.pair\n      |= withIndent 4 getIndent\n      |= getIndent\n\nAssuming there are no `withIndent` above this, you would get `(4,0)` from this.\n',
				name: 'getIndent',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Editors think of code as a grid, but behind the scenes it is just a flat\narray of UTF-16 characters. `getOffset` tells you your index in that flat\narray. So if you chomp `"\\n\\n\\n\\n"` you are on row 5, column 1, and offset 4.\n\n**Note:** JavaScript uses a somewhat odd version of UTF-16 strings, so a single\ncharacter may take two slots. So in JavaScript, `\'abc\'.length === 3` but\n`\'\'.length === 6`. Try it out! And since Elm runs in JavaScript, the offset\nmoves by those rules.\n',
				name: 'getOffset',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Code editors treat code like a grid, with rows and columns. The start is\n`row=1` and `col=1`. As you chomp characters, the `col` increments. When you\nrun into a `\\n` character, the `row` increments and `col` goes back to `1`.\n\nIn the Elm compiler, I track the start and end position of every expression\nlike this:\n\n    type alias Located a =\n      { start : (Int, Int)\n      , value : a\n      , end : (Int, Int)\n      }\n\n    located : Parser a -> Parser (Located a)\n    located parser =\n      succeed Located\n        |= getPosition\n        |= parser\n        |= getPosition\n\nSo if there is a problem during type inference, I use this saved position\ninformation to underline the exact problem!\n\n**Note:** Tabs count as one character, so if you are parsing something like\nPython, I recommend sorting that out *after* parsing. So if I wanted the `^^^^`\nunderline like in Elm, I would find the `row` in the source code and do\nsomething like this:\n\n    makeUnderline : String -> Int -> Int -> String\n    makeUnderline row minCol maxCol =\n      String.toList row\n        |> List.indexedMap (toUnderlineChar minCol maxCol)\n        |> String.fromList\n\n    toUnderlineChar : Int -> Int -> Int -> Char -> Char\n    toUnderlineChar minCol maxCol col char =\n      if minCol <= col && col <= maxCol then\n        \'^\'\n      else if char == \'\\t\' then\n        \'\\t\'\n      else\n        \' \'\n\nSo it would preserve any tabs from the source line. There are tons of other\nways to do this though. The point is just that you handle the tabs after\nparsing but before anyone looks at the numbers in a context where tabs may\nequal 2, 4, or 8.\n',
				name: 'getPosition',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))
						]))
			},
				{
				comment: ' This is a more efficient version of `map Tuple.first getPosition`. Maybe\nyou just want to track the line number for some reason? This lets you do that.\n\nSee [`getPosition`](#getPosition) for an explanation of rows and columns.\n',
				name: 'getRow',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Get the full string that is being parsed. You could use this to define\n`getChompedString` or `mapChompedString` if you wanted:\n\n    getChompedString : Parser a -> Parser String\n    getChompedString parser =\n      succeed String.slice\n        |= getOffset\n        |. parser\n        |= getOffset\n        |= getSource\n',
				name: 'getSource',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
						]))
			},
				{
				comment: ' Parse integers.\n\n    run int "1"    == Ok 1\n    run int "1234" == Ok 1234\n\n    run int "-789" == Err ...\n    run int "0123" == Err ...\n    run int "1.34" == Err ...\n    run int "1e31" == Err ...\n    run int "123a" == Err ...\n    run int "0x1A" == Err ...\n\nIf you want to handle a leading `+` or `-` you should do it with a custom\nparser like this:\n\n    myInt : Parser Int\n    myInt =\n      oneOf\n        [ succeed negate\n            |. symbol "-"\n            |= int\n        , int\n        ]\n\n**Note:** If you want a parser for both `Int` and `Float` literals, check out\n[`number`](#number) below. It will be faster than using `oneOf` to combining\n`int` and `float` yourself.\n',
				name: 'int',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Parse keywords like `let`, `case`, and `type`.\n\n    run (keyword "let") "let"     == Ok ()\n    run (keyword "let") "var"     == Err ... (ExpectingKeyword "let") ...\n    run (keyword "let") "letters" == Err ... (ExpectingKeyword "let") ...\n\n**Note:** Notice the third case there! `keyword` actually looks ahead one\ncharacter to make sure it is not a letter, number, or underscore. The goal is\nto help with parsers like this:\n\n    succeed identity\n      |. keyword "let"\n      |. spaces\n      |= elmVar\n      |. spaces\n      |. symbol "="\n\nThe trouble is that `spaces` may chomp zero characters (to handle expressions\nlike `[1,2]` and `[ 1 , 2 ]`) and in this case, it would mean `letters` could\nbe parsed as `let ters` and then wonder where the equals sign is! Check out the\n[`token`](#token) docs if you need to customize this!\n',
				name: 'keyword',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Helper to define recursive parsers. Say we want a parser for simple\nboolean expressions:\n\n    true\n    false\n    (true || false)\n    (true || (true || false))\n\nNotice that a boolean expression might contain *other* boolean expressions.\nThat means we will want to define our parser in terms of itself:\n\n    type Boolean\n      = MyTrue\n      | MyFalse\n      | MyOr Boolean Boolean\n\n    boolean : Parser Boolean\n    boolean =\n      oneOf\n        [ succeed MyTrue\n            |. keyword "true"\n        , succeed MyFalse\n            |. keyword "false"\n        , succeed MyOr\n            |. symbol "("\n            |. spaces\n            |= lazy (\\_ -> boolean)\n            |. spaces\n            |. symbol "||"\n            |. spaces\n            |= lazy (\\_ -> boolean)\n            |. spaces\n            |. symbol ")"\n        ]\n\n**Notice that `boolean` uses `boolean` in its definition!** In Elm, you can\nonly define a value in terms of itself it is behind a function call. So\n`lazy` helps us define these self-referential parsers. (`andThen` can be used\nfor this as well!)\n',
				name: 'lazy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Parse single-line comments:\n\n    elm : Parser ()\n    elm =\n      lineComment "--"\n\n    js : Parser ()\n    js =\n      lineComment "//"\n\n    python : Parser ()\n    python =\n      lineComment "#"\n\nThis parser is defined like this:\n\n    lineComment : String -> Parser ()\n    lineComment str =\n      symbol str\n        |. chompUntilEndOr "\\n"\n\nSo it will consume the remainder of the line. If the file ends before you see\na newline, that is fine too.\n',
				name: 'lineComment',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' A parser that can loop indefinitely. This can be helpful when parsing\nrepeated structures, like a bunch of statements:\n\n    statements : Parser (List Stmt)\n    statements =\n      loop [] statementsHelp\n\n    statementsHelp : List Stmt -> Parser (Step (List Stmt) (List Stmt))\n    statementsHelp revStmts =\n      oneOf\n        [ succeed (\\stmt -> Loop (stmt :: revStmts))\n            |= statement\n            |. spaces\n            |. symbol ";"\n            |. spaces\n        , succeed ()\n            |> map (\\_ -> Done (List.reverse revStmts))\n        ]\n\n    -- statement : Parser Stmt\n\nNotice that the statements are tracked in reverse as we `Loop`, and we reorder\nthem only once we are `Done`. This is a very common pattern with `loop`!\n\nCheck out [`examples/DoubleQuoteString.elm`](https://github.com/elm/parser/blob/master/examples/DoubleQuoteString.elm)\nfor another example.\n\n**IMPORTANT NOTE:** Parsers like `succeed ()` and `chompWhile Char.isAlpha` can\nsucceed without consuming any characters. So in some cases you may want to use\n[`getOffset`](#getOffset) to ensure that each step actually consumed characters.\nOtherwise you could end up in an infinite loop!\n\n**Note:** Anything you can write with `loop`, you can also write as a parser\nthat chomps some characters `andThen` calls itself with new arguments. The\nproblem with calling `andThen` recursively is that it grows the stack, so you\ncannot do it indefinitely. So `loop` is important because enables tail-call\nelimination, allowing you to parse however many repeats you want.\n',
				name: 'loop',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('state'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('state'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Parser',
								_List_fromArray(
									[
										A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Parser.Step',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('state'),
												$elm$project_metadata_utils$Elm$Type$Var('a')
											]))
									]))),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Transform the result of a parser. Maybe you have a value that is\nan integer or `null`:\n\n    nullOrInt : Parser (Maybe Int)\n    nullOrInt =\n      oneOf\n        [ map Just int\n        , map (\\_ -> Nothing) (keyword "null")\n        ]\n\n    -- run nullOrInt "0"    == Ok (Just 0)\n    -- run nullOrInt "13"   == Ok (Just 13)\n    -- run nullOrInt "null" == Ok Nothing\n    -- run nullOrInt "zero" == Err ...\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' This works just like [`getChompedString`](#getChompedString) but gives\na bit more flexibility. For example, maybe you want to parse Elm doc comments\nand get (1) the full comment and (2) all of the names listed in the docs.\n\nYou could implement `mapChompedString` like this:\n\n    mapChompedString : (String -> a -> b) -> Parser a -> Parser String\n    mapChompedString func parser =\n      succeed (\\start value end src -> func (String.slice start end src) value)\n        |= getOffset\n        |= parser\n        |= getOffset\n        |= getSource\n\n',
				name: 'mapChompedString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Parse multi-line comments. So if you wanted to parse Elm whitespace or\nJS whitespace, you could say:\n\n    elm : Parser ()\n    elm =\n      loop 0 <| ifProgress <|\n        oneOf\n          [ lineComment "--"\n          , multiComment "{-" "-}" Nestable\n          , spaces\n          ]\n\n    js : Parser ()\n    js =\n      loop 0 <| ifProgress <|\n        oneOf\n          [ lineComment "//"\n          , multiComment "/*" "*/" NotNestable\n          , chompWhile (\\c -> c == \' \' || c == \'\\n\' || c == \'\\r\' || c == \'\\t\')\n          ]\n\n    ifProgress : Parser a -> Int -> Parser (Step Int ())\n    ifProgress parser offset =\n      succeed identity\n        |. parser\n        |= getOffset\n        |> map (\\newOffset -> if offset == newOffset then Done () else Loop newOffset)\n\n**Note:** The fact that `spaces` comes last in the definition of `elm` is very\nimportant! It can succeed without consuming any characters, so if it were the\nfirst option, it would always succeed and bypass the others! (Same is true of\n`chompWhile` in `js`.) This possibility of success without consumption is also\nwhy wee need the `ifProgress` helper. It detects if there is no more whitespace\nto consume.\n',
				name: 'multiComment',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Nestable', _List_Nil),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Parser',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
									])))))
			},
				{
				comment: ' Parse a bunch of different kinds of numbers without backtracking. A parser\nfor Elm would need to handle integers, floats, and hexadecimal like this:\n\n    type Expr\n      = Variable String\n      | Int Int\n      | Float Float\n      | Apply Expr Expr\n\n    elmNumber : Parser Expr\n    elmNumber =\n      number\n        { int = Just Int\n        , hex = Just Int    -- 0x001A is allowed\n        , octal = Nothing   -- 0o0731 is not\n        , binary = Nothing  -- 0b1101 is not\n        , float = Just Float\n        }\n\nIf you wanted to implement the [`float`](#float) parser, it would be like this:\n\n    float : Parser Float\n    float =\n      number\n        { int = Just toFloat\n        , hex = Nothing\n        , octal = Nothing\n        , binary = Nothing\n        , float = Just identity\n        }\n\nNotice that it actually is processing `int` results! This is because `123`\nlooks like an integer to me, but maybe it looks like a float to you. If you had\n`int = Nothing`, floats would need a decimal like `1.0` in every case. If you\nlike explicitness, that may actually be preferable!\n\n**Note:** This function does not check for weird trailing characters in the\ncurrent implementation, so parsing `123abc` can succeed up to `123` and then\nmove on. This is helpful for people who want to parse things like `40px` or\n`3m`, but it requires a bit of extra code to rule out trailing characters in\nother cases.\n',
				name: 'number',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'int',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'hex',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'octal',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'binary',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'float',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Maybe.Maybe',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										])))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' If you are parsing JSON, the values can be strings, floats, booleans,\narrays, objects, or null. You need a way to pick `oneOf` them! Here is a\nsample of what that code might look like:\n\n    type Json\n      = Number Float\n      | Boolean Bool\n      | Null\n\n    json : Parser Json\n    json =\n      oneOf\n        [ map Number float\n        , map (\\_ -> Boolean True) (keyword "true")\n        , map (\\_ -> Boolean False) (keyword "false")\n        , map (\\_ -> Null) keyword "null"\n        ]\n\nThis parser will keep trying parsers until `oneOf` them starts chomping\ncharacters. Once a path is chosen, it does not come back and try the others.\n\n**Note:** I highly recommend reading [this document][semantics] to learn how\n`oneOf` and `backtrackable` interact. It is subtle and important!\n\n[semantics]: https://github.com/elm/parser/blob/master/semantics.md\n',
				name: 'oneOf',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Parser',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Indicate that a parser has reached a dead end. "Everything was going fine\nuntil I ran into this problem." Check out the [`andThen`](#andThen) docs to see\nan example usage.\n',
				name: 'problem',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Try a parser. Here are some examples using the [`keyword`](#keyword)\nparser:\n\n    run (keyword "true") "true"  == Ok ()\n    run (keyword "true") "True"  == Err ...\n    run (keyword "true") "false" == Err ...\n    run (keyword "true") "true!" == Ok ()\n\nNotice the last case! A `Parser` will chomp as much as possible and not worry\nabout the rest. Use the [`end`](#end) parser to ensure you made it to the end\nof the string!\n',
				name: 'run',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.DeadEnd', _List_Nil)
										])),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Handle things like lists and records, but you can customize the details\nhowever you need. Say you want to parse C-style code blocks:\n\n    import Parser exposing (Parser, Trailing(..))\n\n    block : Parser (List Stmt)\n    block =\n      Parser.sequence\n        { start = "{"\n        , separator = ";"\n        , end = "}"\n        , spaces = spaces\n        , item = statement\n        , trailing = Mandatory -- demand a trailing semi-colon\n        }\n\n    -- statement : Parser Stmt\n\n**Note:** If you need something more custom, do not be afraid to check\nout the implementation and customize it for your case. It is better to\nget nice error messages with a lower-level implementation than to try\nto hack high-level parsers to do things they are not made for.\n',
				name: 'sequence',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'start',
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)),
								_Utils_Tuple2(
								'separator',
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)),
								_Utils_Tuple2(
								'end',
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)),
								_Utils_Tuple2(
								'spaces',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Parser',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
										]))),
								_Utils_Tuple2(
								'item',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Parser',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('a')
										]))),
								_Utils_Tuple2(
								'trailing',
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Trailing', _List_Nil))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])))
			},
				{
				comment: ' Parse zero or more `\' \'`, `\'\\n\'`, and `\'\\r\'` characters.\n\nThe implementation is pretty simple:\n\n    spaces : Parser ()\n    spaces =\n      chompWhile (\\c -> c == \' \' || c == \'\\n\' || c == \'\\r\')\n\nSo if you need something different (like tabs) just define an alternative with\nthe necessary tweaks! Check out [`lineComment`](#lineComment) and\n[`multiComment`](#multiComment) for more complex situations.\n',
				name: 'spaces',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
						]))
			},
				{
				comment: ' A parser that succeeds without chomping any characters.\n\n    run (succeed 90210  ) "mississippi" == Ok 90210\n    run (succeed 3.141  ) "mississippi" == Ok 3.141\n    run (succeed ()     ) "mississippi" == Ok ()\n    run (succeed Nothing) "mississippi" == Ok Nothing\n\nSeems weird on its own, but it is very useful in combination with other\nfunctions. The docs for [`(|=)`](#|=) and [`andThen`](#andThen) have some neat\nexamples.\n',
				name: 'succeed',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Parse symbols like `(` and `,`.\n\n    run (symbol "[") "[" == Ok ()\n    run (symbol "[") "4" == Err ... (ExpectingSymbol "[") ...\n\n**Note:** This is good for stuff like brackets and semicolons, but it probably\nshould not be used for binary operators like `+` and `-` because you can find\nyourself in weird situations. For example, is `3--4` a typo? Or is it `3 - -4`?\nI have had better luck with `chompWhile isSymbol` and sorting out which\noperator it is afterwards.\n',
				name: 'symbol',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Parse exactly the given string, without any regard to what comes next.\n\nA potential pitfall when parsing keywords is getting tricked by variables that\nstart with a keyword, like `let` in `letters` or `import` in `important`. This\nis especially likely if you have a whitespace parser that can consume zero\ncharcters. So the [`keyword`](#keyword) parser is defined with `token` and a\ntrick to peek ahead a bit:\n\n    keyword : String -> Parser ()\n    keyword kwd =\n      succeed identity\n        |. backtrackable (token kwd)\n        |= oneOf\n            [ map (\\_ -> True) (backtrackable (chompIf isVarChar))\n            , succeed False\n            ]\n        |> andThen (checkEnding kwd)\n\n    checkEnding : String -> Bool -> Parser ()\n    checkEnding kwd isBadEnding =\n      if isBadEnding then\n        problem ("expecting the `" ++ kwd ++ "` keyword")\n      else\n        commit ()\n\n    isVarChar : Char -> Bool\n    isVarChar char =\n      Char.isAlphaNum char || char == \'_\'\n\nThis definition is specially designed so that (1) if you really see `let` you\ncommit to that path and (2) if you see `letters` instead you can backtrack and\ntry other options. If I had just put a `backtrackable` around the whole thing\nyou would not get (1) anymore.\n',
				name: 'token',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Create a parser for variables. If we wanted to parse type variables in Elm,\nwe could try something like this:\n\n    import Char\n    import Parser exposing (..)\n    import Set\n\n    typeVar : Parser String\n    typeVar =\n      variable\n        { start = Char.isLower\n        , inner = \\c -> Char.isAlphaNum c || c == \'_\'\n        , reserved = Set.fromList [ "let", "in", "case", "of" ]\n        }\n\nThis is saying it _must_ start with a lower-case character. After that,\ncharacters can be letters, numbers, or underscores. It is also saying that if\nyou run into any of these reserved names, it is definitely not a variable.\n',
				name: 'variable',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'start',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
								_Utils_Tuple2(
								'inner',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
								_Utils_Tuple2(
								'reserved',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Set.Set',
									_List_fromArray(
										[
											A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
										])))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Parser',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			},
				{
				comment: ' Some languages are indentation sensitive. Python cares about tabs. Elm\ncares about spaces sometimes. `withIndent` and `getIndent` allow you to manage\n"indentation state" yourself, however is necessary in your scenario.\n',
				name: 'withIndent',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			}
			])
	},
		{
		aliases: _List_fromArray(
			[
				{
				args: _List_fromArray(
					['context', 'problem']),
				comment: ' Say you are parsing a function named `viewHealthData` that contains a list.\nYou might get a `DeadEnd` like this:\n\n```elm\n{ row = 18\n, col = 22\n, problem = UnexpectedComma\n, contextStack =\n    [ { row = 14\n      , col = 1\n      , context = Definition "viewHealthData"\n      }\n    , { row = 15\n      , col = 4\n      , context = List\n      }\n    ]\n}\n```\n\nWe have a ton of information here! So in the error message, we can say that I\nran into an issue when parsing a list in the definition of `viewHealthData`. It\nlooks like there is an extra comma. Or maybe something even better!\n\nFurthermore, many parsers just put a mark where the problem manifested. By\ntracking the `row` and `col` of the context, we can show a much larger region\nas a way of indicating I thought I was parsing this thing that starts over\nhere. Otherwise you can get very confusing error messages on a missing `]` or\n`}` or `)` because I need more indentation on something unrelated.\n\n**Note:** Rows and columns are counted like a text editor. The beginning is `row=1`\nand `col=1`. The `col` increments as characters are chomped. When a `\\n` is chomped,\n`row` is incremented and `col` starts over again at `1`.\n',
				name: 'DeadEnd',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Record,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'row',
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
							_Utils_Tuple2(
							'col',
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
							_Utils_Tuple2(
							'problem',
							$elm$project_metadata_utils$Elm$Type$Var('problem')),
							_Utils_Tuple2(
							'contextStack',
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										A2(
										$elm$project_metadata_utils$Elm$Type$Record,
										_List_fromArray(
											[
												_Utils_Tuple2(
												'row',
												A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
												_Utils_Tuple2(
												'col',
												A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)),
												_Utils_Tuple2(
												'context',
												$elm$project_metadata_utils$Elm$Type$Var('context'))
											]),
										$elm$core$Maybe$Nothing)
									])))
						]),
					$elm$core$Maybe$Nothing)
			}
			]),
		binops: _List_fromArray(
			[
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Just like the [`(|.)`](Parser#|.) from the `Parser` module.\n',
				name: '|.',
				precedence: 6,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('keep')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('ignore')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('keep')
								]))))
			},
				{
				associativity: $elm$project_metadata_utils$Elm$Docs$Left,
				comment: ' Just like the [`(|=)`](Parser#|=) from the `Parser` module.\n',
				name: '|=',
				precedence: 5,
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								A2(
								$elm$project_metadata_utils$Elm$Type$Lambda,
								$elm$project_metadata_utils$Elm$Type$Var('a'),
								$elm$project_metadata_utils$Elm$Type$Var('b'))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			}
			]),
		comment: '\n\n# Parsers\n@docs Parser, run, DeadEnd, inContext, Token\n\n* * *\n**Everything past here works just like in the\n[`Parser`](/packages/elm/parser/latest/Parser) module, except that `String`\narguments become `Token` arguments, and you need to provide a `Problem` for\ncertain scenarios.**\n* * *\n\n# Building Blocks\n@docs int, float, number, symbol, keyword, variable, end\n\n# Pipelines\n@docs succeed, (|=), (|.), lazy, andThen, problem\n\n# Branches\n@docs oneOf, map, backtrackable, commit, token\n\n# Loops\n@docs sequence, Trailing, loop, Step\n\n# Whitespace\n@docs spaces, lineComment, multiComment, Nestable\n\n# Chompers\n@docs getChompedString, chompIf, chompWhile, chompUntil, chompUntilEndOr, mapChompedString\n\n# Indentation\n@docs withIndent, getIndent\n\n# Positions\n@docs getPosition, getRow, getCol, getOffset, getSource\n',
		name: 'Parser.Advanced',
		unions: _List_fromArray(
			[
				{
				args: _List_Nil,
				comment: ' Works just like [`Parser.Nestable`](Parser#nestable) to help distinguish\nbetween unnestable `/*` `*/` comments like in JS and nestable `{-` `-}`\ncomments like in Elm.\n',
				name: 'Nestable',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('NotNestable', _List_Nil),
						_Utils_Tuple2('Nestable', _List_Nil)
					])
			},
				{
				args: _List_fromArray(
					['context', 'problem', 'value']),
				comment: ' An advanced `Parser` gives two ways to improve your error messages:\n\n- `problem` &mdash; Instead of all errors being a `String`, you can create a\ncustom type like `type Problem = BadIndent | BadKeyword String` and track\nproblems much more precisely.\n- `context` &mdash; Error messages can be further improved when precise\nproblems are paired with information about where you ran into trouble. By\ntracking the context, instead of saying I found a bad keyword you can say\nI found a bad keyword when parsing a list and give folks a better idea of\nwhat the parser thinks it is doing.\n\nI recommend starting with the simpler [`Parser`][parser] module though, and\nwhen you feel comfortable and want better error messages, you can create a type\nalias like this:\n\n```elm\nimport Parser.Advanced\n\ntype alias MyParser a =\n  Parser.Advanced.Parser Context Problem a\n\ntype Context = Definition String | List | Record\n\ntype Problem = BadIndent | BadKeyword String\n```\n\nAll of the functions from `Parser` should exist in `Parser.Advanced` in some\nform, allowing you to switch over pretty easily.\n\n[parser]: /packages/elm/parser/latest/Parser\n',
				name: 'Parser',
				tags: _List_Nil
			},
				{
				args: _List_fromArray(
					['state', 'a']),
				comment: ' Just like [`Parser.Step`](Parser#Step)\n',
				name: 'Step',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Loop',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('state')
							])),
						_Utils_Tuple2(
						'Done',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('a')
							]))
					])
			},
				{
				args: _List_fromArray(
					['x']),
				comment: ' With the simpler `Parser` module, you could just say `symbol ","` and\nparse all the commas you wanted. But now that we have a custom type for our\nproblems, we actually have to specify that as well. So anywhere you just used\na `String` in the simpler module, you now use a `Token Problem` in the advanced\nmodule:\n\n    type Problem\n      = ExpectingComma\n      | ExpectingListEnd\n\n    comma : Token Problem\n    comma =\n      Token "," ExpectingComma\n\n    listEnd : Token Problem\n    listEnd =\n      Token "]" ExpectingListEnd\n\nYou can be creative with your custom type. Maybe you want a lot of detail.\nMaybe you want looser categories. It is a custom type. Do what makes sense for\nyou!\n',
				name: 'Token',
				tags: _List_fromArray(
					[
						_Utils_Tuple2(
						'Token',
						_List_fromArray(
							[
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
								$elm$project_metadata_utils$Elm$Type$Var('x')
							]))
					])
			},
				{
				args: _List_Nil,
				comment: ' Whats the deal with trailing commas? Are they `Forbidden`?\nAre they `Optional`? Are they `Mandatory`? Welcome to [shapes\nclub](https://poorlydrawnlines.com/comic/shapes-club/)!\n',
				name: 'Trailing',
				tags: _List_fromArray(
					[
						_Utils_Tuple2('Forbidden', _List_Nil),
						_Utils_Tuple2('Optional', _List_Nil),
						_Utils_Tuple2('Mandatory', _List_Nil)
					])
			}
			]),
		values: _List_fromArray(
			[
				{
				comment: ' Just like [`Parser.andThen`](Parser#andThen)\n',
				name: 'andThen',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Just like [`Parser.backtrackable`](Parser#backtrackable)\n',
				name: 'backtrackable',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.chompIf`](Parser#chompIf) except you provide a problem\nin case a character cannot be chomped.\n',
				name: 'chompIf',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
								]))))
			},
				{
				comment: ' Just like [`Parser.chompUntil`](Parser#chompUntil) except you provide a\n`Token` in case you chomp all the way to the end of the input without finding\nwhat you need.\n',
				name: 'chompUntil',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.chompUntilEndOr`](Parser#chompUntilEndOr)\n',
				name: 'chompUntilEndOr',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.chompWhile`](Parser#chompWhile)\n',
				name: 'chompWhile',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
						A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil)),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.commit`](Parser#commit)\n',
				name: 'commit',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.end`](Parser#end) except you provide the problem that\narises when the parser is not at the end of the input.\n',
				name: 'end',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.float`](Parser#float) where you have to handle negation\nyourself. The only difference is that you provide a two potential problems:\n\n    float : x -> x -> Parser c x Float\n    float expecting invalid =\n      number\n        { int = Ok toFloat\n        , hex = Err invalid\n        , octal = Err invalid\n        , binary = Err invalid\n        , float = Ok identity\n        , invalid = invalid\n        , expecting = expecting\n        }\n\nYou can use problems like `ExpectingFloat` and `InvalidNumber`.\n',
				name: 'float',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil)
								]))))
			},
				{
				comment: ' Just like [`Parser.getChompedString`](Parser#getChompedString)\n',
				name: 'getChompedString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.getCol`](Parser#getCol)\n',
				name: 'getCol',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Just like [`Parser.getIndent`](Parser#getIndent)\n',
				name: 'getIndent',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Just like [`Parser.getOffset`](Parser#getOffset)\n',
				name: 'getOffset',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Just like [`Parser.getPosition`](Parser#getPosition)\n',
				name: 'getPosition',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							$elm$project_metadata_utils$Elm$Type$Tuple(
							_List_fromArray(
								[
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))
						]))
			},
				{
				comment: ' Just like [`Parser.getRow`](Parser#getRow)\n',
				name: 'getRow',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
						]))
			},
				{
				comment: ' Just like [`Parser.getSource`](Parser#getSource)\n',
				name: 'getSource',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
						]))
			},
				{
				comment: ' This is how you mark that you are in a certain context. For example, here\nis a rough outline of some code that uses `inContext` to mark when you are\nparsing a specific definition:\n\n    import Char\n    import Parser.Advanced exposing (..)\n    import Set\n\n    type Context\n      = Definition String\n      | List\n\n    definition : Parser Context Problem Expr\n    definition =\n      functionName\n        |> andThen definitionBody\n\n    definitionBody : String -> Parser Context Problem Expr\n    definitionBody name =\n      inContext (Definition name) <|\n        succeed (Function name)\n          |= arguments\n          |. symbol (Token "=" ExpectingEquals)\n          |= expression\n\n    functionName : Parser c Problem String\n    functionName =\n      variable\n        { start = Char.isLower\n        , inner = Char.isAlphaNum\n        , reserved = Set.fromList ["let","in"]\n        , expecting = ExpectingFunctionName\n        }\n\nFirst we parse the function name, and then we parse the rest of the definition.\nImportantly, we call `inContext` so that any dead end that occurs in\n`definitionBody` will get this extra context information. That way you can say\nthings like, I was expecting an equals sign in the `view` definition. Context!\n',
				name: 'inContext',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('context'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('context'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('context'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Just like [`Parser.int`](Parser#int) where you have to handle negation\nyourself. The only difference is that you provide a two potential problems:\n\n    int : x -> x -> Parser c x Int\n    int expecting invalid =\n      number\n        { int = Ok identity\n        , hex = Err invalid\n        , octal = Err invalid\n        , binary = Err invalid\n        , float = Err invalid\n        , invalid = invalid\n        , expecting = expecting\n        }\n\nYou can use problems like `ExpectingInt` and `InvalidNumber`.\n',
				name: 'int',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('x'),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil)
								]))))
			},
				{
				comment: ' Just like [`Parser.keyword`](Parser#keyword) except you provide a `Token`\nto clearly indicate your custom type of problems:\n\n    let_ : Parser Context Problem ()\n    let_ =\n      symbol (Token "let" ExpectingLet)\n\nNote that this would fail to chomp `letter` because of the subsequent\ncharacters. Use `token` if you do not want that last letter check.\n',
				name: 'keyword',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.lazy`](Parser#lazy)\n',
				name: 'lazy',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.lineComment`](Parser#lineComment) except you provide a\n`Token` describing the starting symbol.\n',
				name: 'lineComment',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.loop`](Parser#loop)\n',
				name: 'loop',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('state'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('state'),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Advanced.Parser',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('c'),
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										A2(
										$elm$project_metadata_utils$Elm$Type$Type,
										'Parser.Advanced.Step',
										_List_fromArray(
											[
												$elm$project_metadata_utils$Elm$Type$Var('state'),
												$elm$project_metadata_utils$Elm$Type$Var('a')
											]))
									]))),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Just like [`Parser.map`](Parser#map)\n',
				name: 'map',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						$elm$project_metadata_utils$Elm$Type$Var('a'),
						$elm$project_metadata_utils$Elm$Type$Var('b')),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Just like [`Parser.mapChompedString`](Parser#mapChompedString)\n',
				name: 'mapChompedString',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							$elm$project_metadata_utils$Elm$Type$Var('a'),
							$elm$project_metadata_utils$Elm$Type$Var('b'))),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('b')
								]))))
			},
				{
				comment: ' Just like [`Parser.multiComment`](Parser#multiComment) except with a\n`Token` for the open and close symbols.\n',
				name: 'multiComment',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Token',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('x')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Lambda,
							A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Advanced.Nestable', _List_Nil),
							A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Advanced.Parser',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('c'),
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
									])))))
			},
				{
				comment: ' Just like [`Parser.number`](Parser#number) where you have to handle\nnegation yourself. The only difference is that you provide all the potential\nproblems.\n',
				name: 'number',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'int',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'hex',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'octal',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'binary',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'float',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Result.Result',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											A2(
											$elm$project_metadata_utils$Elm$Type$Lambda,
											A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Float', _List_Nil),
											$elm$project_metadata_utils$Elm$Type$Var('a'))
										]))),
								_Utils_Tuple2(
								'invalid',
								$elm$project_metadata_utils$Elm$Type$Var('x')),
								_Utils_Tuple2(
								'expecting',
								$elm$project_metadata_utils$Elm$Type$Var('x'))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.oneOf`](Parser#oneOf)\n',
				name: 'oneOf',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'List.List',
						_List_fromArray(
							[
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'Parser.Advanced.Parser',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('c'),
										$elm$project_metadata_utils$Elm$Type$Var('x'),
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.problem`](Parser#problem) except you provide a custom\ntype for your problem.\n',
				name: 'problem',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('x'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' This works just like [`Parser.run`](/packages/elm/parser/latest/Parser#run).\nThe only difference is that when it fails, it has much more precise information\nfor each dead end.\n',
				name: 'run',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Result.Result',
							_List_fromArray(
								[
									A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'List.List',
									_List_fromArray(
										[
											A2(
											$elm$project_metadata_utils$Elm$Type$Type,
											'Parser.Advanced.DeadEnd',
											_List_fromArray(
												[
													$elm$project_metadata_utils$Elm$Type$Var('c'),
													$elm$project_metadata_utils$Elm$Type$Var('x')
												]))
										])),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			},
				{
				comment: ' Just like [`Parser.sequence`](Parser#sequence) except with a `Token` for\nthe start, separator, and end. That way you can specify your custom type of\nproblem for when something is not found.\n',
				name: 'sequence',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'start',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Advanced.Token',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x')
										]))),
								_Utils_Tuple2(
								'separator',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Advanced.Token',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x')
										]))),
								_Utils_Tuple2(
								'end',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Advanced.Token',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('x')
										]))),
								_Utils_Tuple2(
								'spaces',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Advanced.Parser',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c'),
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
										]))),
								_Utils_Tuple2(
								'item',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Parser.Advanced.Parser',
									_List_fromArray(
										[
											$elm$project_metadata_utils$Elm$Type$Var('c'),
											$elm$project_metadata_utils$Elm$Type$Var('x'),
											$elm$project_metadata_utils$Elm$Type$Var('a')
										]))),
								_Utils_Tuple2(
								'trailing',
								A2($elm$project_metadata_utils$Elm$Type$Type, 'Parser.Advanced.Trailing', _List_Nil))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								A2(
								$elm$project_metadata_utils$Elm$Type$Type,
								'List.List',
								_List_fromArray(
									[
										$elm$project_metadata_utils$Elm$Type$Var('a')
									]))
							])))
			},
				{
				comment: ' Just like [`Parser.spaces`](Parser#spaces)\n',
				name: 'spaces',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Type,
					'Parser.Advanced.Parser',
					_List_fromArray(
						[
							$elm$project_metadata_utils$Elm$Type$Var('c'),
							$elm$project_metadata_utils$Elm$Type$Var('x'),
							$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
						]))
			},
				{
				comment: ' Just like [`Parser.succeed`](Parser#succeed)\n',
				name: 'succeed',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					$elm$project_metadata_utils$Elm$Type$Var('a'),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Var('a')
							])))
			},
				{
				comment: ' Just like [`Parser.symbol`](Parser#symbol) except you provide a `Token` to\nclearly indicate your custom type of problems:\n\n    comma : Parser Context Problem ()\n    comma =\n      symbol (Token "," ExpectingComma)\n\n',
				name: 'symbol',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.token`](Parser#token) except you provide a `Token`\nspecifying your custom type of problems.\n',
				name: 'token',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Token',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('x')
							])),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								$elm$project_metadata_utils$Elm$Type$Tuple(_List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.variable`](Parser#variable) except you specify the\nproblem yourself.\n',
				name: 'variable',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2(
						$elm$project_metadata_utils$Elm$Type$Record,
						_List_fromArray(
							[
								_Utils_Tuple2(
								'start',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
								_Utils_Tuple2(
								'inner',
								A2(
									$elm$project_metadata_utils$Elm$Type$Lambda,
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Char.Char', _List_Nil),
									A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Bool', _List_Nil))),
								_Utils_Tuple2(
								'reserved',
								A2(
									$elm$project_metadata_utils$Elm$Type$Type,
									'Set.Set',
									_List_fromArray(
										[
											A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
										]))),
								_Utils_Tuple2(
								'expecting',
								$elm$project_metadata_utils$Elm$Type$Var('x'))
							]),
						$elm$core$Maybe$Nothing),
					A2(
						$elm$project_metadata_utils$Elm$Type$Type,
						'Parser.Advanced.Parser',
						_List_fromArray(
							[
								$elm$project_metadata_utils$Elm$Type$Var('c'),
								$elm$project_metadata_utils$Elm$Type$Var('x'),
								A2($elm$project_metadata_utils$Elm$Type$Type, 'String.String', _List_Nil)
							])))
			},
				{
				comment: ' Just like [`Parser.withIndent`](Parser#withIndent)\n',
				name: 'withIndent',
				tipe: A2(
					$elm$project_metadata_utils$Elm$Type$Lambda,
					A2($elm$project_metadata_utils$Elm$Type$Type, 'Basics.Int', _List_Nil),
					A2(
						$elm$project_metadata_utils$Elm$Type$Lambda,
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								])),
						A2(
							$elm$project_metadata_utils$Elm$Type$Type,
							'Parser.Advanced.Parser',
							_List_fromArray(
								[
									$elm$project_metadata_utils$Elm$Type$Var('c'),
									$elm$project_metadata_utils$Elm$Type$Var('x'),
									$elm$project_metadata_utils$Elm$Type$Var('a')
								]))))
			}
			])
	}
	]);
var $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$elmJson = $elm$project_metadata_utils$Elm$Project$Package(
	{
		deps: _List_fromArray(
			[
				_Utils_Tuple2(
				$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$packageName('elm/core'),
				$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$constraint('1.0.0 <= v < 2.0.0'))
			]),
		elm: $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$constraint('0.19.0 <= v < 0.20.0'),
		exposed: $elm$project_metadata_utils$Elm$Project$ExposedList(
			_List_fromArray(
				[
					$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Parser'),
					$jfmengels$elm_review$Review$Test$Dependencies$Unsafe$moduleName('Parser.Advanced')
				])),
		license: A2(
			$elm$core$Maybe$withDefault,
			$elm$project_metadata_utils$Elm$License$bsd3,
			$elm$project_metadata_utils$Elm$License$fromString('BSD-3-Clause')),
		name: $jfmengels$elm_review$Review$Test$Dependencies$Unsafe$packageName('elm/parser'),
		summary: 'a parsing library, focused on simplicity and great error messages',
		testDeps: _List_Nil,
		version: A2(
			$elm$core$Maybe$withDefault,
			$elm$project_metadata_utils$Elm$Version$one,
			$elm$project_metadata_utils$Elm$Version$fromString('1.1.0'))
	});
var $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$dependency = A3($jfmengels$elm_review$Review$Project$Dependency$create, 'elm/parser', $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$elmJson, $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$dependencyModules);
var $jfmengels$elm_review$Review$Test$Dependencies$elmParser = $jfmengels$elm_review$Review$Test$Dependencies$ElmParser$dependency;
var $author$project$NoUnsortedRecordsTest$dependencySupport = A2(
	$elm_explorations$test$Test$describe,
	'dependency support',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'will sort based on type alias in dependency with annotation',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na : DeadEnd\na = { row = 2 , col = 1, problem = BadRepeat}\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A3(
						$jfmengels$elm_review$Review$Test$runWithProjectData,
						A2($jfmengels$elm_review$Review$Project$addDependency, $jfmengels$elm_review$Review$Test$Dependencies$elmParser, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore),
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na : DeadEnd\na = { problem = BadRepeat, col = 1, row = 2 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'will sort based on type alias in dependency without',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na = { row = 2 , col = 1, problem = BadRepeat}\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A3(
						$jfmengels$elm_review$Review$Test$runWithProjectData,
						A2($jfmengels$elm_review$Review$Project$addDependency, $jfmengels$elm_review$Review$Test$Dependencies$elmParser, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore),
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na = { problem = BadRepeat, col = 1, row = 2 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'will disambiguate based on dependency function signature (including list type)',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : Problem }\n\na = deadEndsToString [ { row = 2 , col = 1, problem = BadRepeat} ]\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 25, row: 7},
									start: {column: 24, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A3(
						$jfmengels$elm_review$Review$Test$runWithProjectData,
						A2($jfmengels$elm_review$Review$Project$addDependency, $jfmengels$elm_review$Review$Test$Dependencies$elmParser, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore),
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : Problem }\n\na = deadEndsToString [ { problem = BadRepeat, col = 1, row = 2 } ]\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'will disambiguate based on field type',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { col : Int, row : Int, problem : Problem }\na = { row = 2 , col = 1, problem = BadRepeat}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { row : Int, col : Int, problem : Problem }\na = { problem = BadRepeat, col = 1, row = 2 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A3(
						$jfmengels$elm_review$Review$Test$runWithProjectData,
						A2($jfmengels$elm_review$Review$Project$addDependency, $jfmengels$elm_review$Review$Test$Dependencies$elmParser, $jfmengels$elm_review$Review$Test$Dependencies$projectWithElmCore),
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { col : Int, row : Int, problem : Problem }\na = { problem = BadRepeat, col = 1, row = 2 }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$disambiguatesByHasAllFields = A2(
	$elm_explorations$test$Test$describe,
	'disambiguates by whether all fields must be present',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { foo = 1, bar = 2, baz = 3}\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not match any when all fields must be present',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na = { bar = 2 , baz = 3}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na = { baz = 3, bar = 2 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is ambiguous with record updates',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | bar = 2, baz = 3, foo = 1 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 8, row: 7},
									start: {column: 7, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | baz = 3, bar = 2, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is ambiguous with record updates not sorting',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$doNotSortAmbiguousRecords($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | baz = 3, bar = 2, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'patterns do not match any when all fields must be present',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { bar : Int , baz : Int} -> Bool\na _ = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { baz : Int, bar : Int } -> Bool\na _ = True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'patterns match when all fields must be present',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { foo : Int, baz : Int , bar : Int} -> Bool\na _ = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { bar : Int, foo : Int, baz : Int } -> Bool\na _ = True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is ambiguous with generic records',
			function (_v7) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | bar : Int, baz : Int, foo : Int } -> Bool\na _ = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | baz : Int, bar : Int, foo : Int } -> Bool\na _ = True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is ambiguous with generic records not sorting',
			function (_v8) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$doNotSortAmbiguousRecords($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | baz : Int, bar : Int, foo : Int } -> Bool\na _ = True\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$disambiguatesByKnownFunctionArgTypes = A2(
	$elm_explorations$test$Test$describe,
	'disambiguates by known function arg types',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation in same module',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 13, row: 10},
									start: {column: 12, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation in other module',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrorsForModules,
					_List_fromArray(
						[
							_Utils_Tuple2(
							'A',
							_List_fromArray(
								[
									A2(
									$jfmengels$elm_review$Review$Test$whenFixed,
									'module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n',
									A2(
										$jfmengels$elm_review$Review$Test$atExactly,
										{
											end: {column: 13, row: 8},
											start: {column: 12, row: 8}
										},
										$author$project$NoUnsortedRecordsTest$unsortedError))
								]))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n', 'module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { bar = 2, foo = 1, baz = 3 }\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not keep unexposed functions',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$doNotSortAmbiguousRecords($author$project$NoUnsortedRecords$defaults)),
						_List_fromArray(
							['module B exposing (A)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n', 'module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = B.foo { bar = 2, foo = 1, baz = 3 }\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does understand unexposed alias from an exposed function',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (foo)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n', 'module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation in custom type pattern',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom = Custom A\n\nfunc : Custom -> Bool\nfunc c =\n    case c of\n        Custom { foo, bar, baz } -> True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 17, row: 11},
									start: {column: 16, row: 11}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom = Custom A\n\nfunc : Custom -> Bool\nfunc c =\n    case c of\n        Custom { bar, foo, baz } -> True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does understand unexposed alias from an exposed constructor',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (Custom(..))\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype Custom = Custom A\n', 'module A exposing (..)\n\nimport B exposing (Custom(..))\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = Custom { foo = 1, bar = 2, baz = 3 }\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not understand unexposed constructor',
			function (_v6) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (A)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype Custom = Custom A\n', 'module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = B.Custom { bar = 2, baz = 3, foo = 1}\n'])));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does understand imported record constructor',
			function (_v7) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (A)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int } }\n\ntype Custom = Custom A\n', 'module A exposing (..)\n\nimport B exposing (A)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = A { foo = 1, bar = 2, baz = 3}\n'])));
			})
		]));
var $author$project$NoUnsortedRecordsTest$disambiguatesByTypeAnnotation = A2(
	$elm_explorations$test$Test$describe,
	'disambiguates using type annotation',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'disambiguation is possible because of type annotation',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : A\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguation is possible because of type annotation with type vars',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\n\ntype alias B a = { bar : Int, foo : a, baz : Int }\n\na : A Int\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\n\ntype alias B a = { bar : Int, foo : a, baz : Int }\n\na : A Int\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguation is possible because of complex type annotation',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> String -> ( Int, String, List A )\na i s = ( i, s, [ { foo = 1, bar = 2, baz = 3 } ] )\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 20, row: 8},
									start: {column: 19, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> String -> ( Int, String, List A )\na i s = ( i, s, [ { bar = 2, foo = 1, baz = 3 } ] )\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'disambiguation of pattern is possible because of type annotation',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> A -> Int -> Bool\na i1 { foo, bar, baz } i2 = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 7, row: 8},
									start: {column: 6, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> A -> Int -> Bool\na i1 { bar, foo, baz } i2 = True\n'));
			})
		]));
var $author$project$NoUnsortedRecords$reportUnknownRecordsWithoutFix = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{sortUnknown: $author$project$NoUnsortedRecords$ReportOnly}));
};
var $author$project$NoUnsortedRecords$GenericFieldsLast = {$: 'GenericFieldsLast'};
var $author$project$NoUnsortedRecords$sortGenericFieldsLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{sortGenerics: $author$project$NoUnsortedRecords$GenericFieldsLast}));
};
var $author$project$NoUnsortedRecordsTest$unknownRecordError = function (under) {
	return $jfmengels$elm_review$Review$Test$error(
		{
			details: _List_fromArray(
				['This record did not correspond with any known alias or custom type argument record, so whether or not its fields are sorted could not be determined!', 'Create a type alias for this record type, or remove reportUnknownRecordsWithoutFix from your rule configuration.']),
			message: 'Unknown record encountered.',
			under: under
		});
};
var $author$project$NoUnsortedRecordsTest$genericRecordSupport = A2(
	$elm_explorations$test$Test$describe,
	'generic records',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'without additional fields',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic {}\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic {}\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'without additional fields without type annotation',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 5},
									start: {column: 5, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, y = 2, z = 3, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields last',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { foo = 1, bar = 2, baz = 3 , x = 0, y = 2, z = 3}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$sortGenericFieldsLast($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields without type signature',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { x = 0, y = 2, z = 3, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 5},
									start: {column: 5, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields that have canonical order',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields that have canonical order last',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { foo = 1, bar = 2, baz = 3 , yi = 3, er = 2, san = 0}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$sortGenericFieldsLast($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'with additional fields that have canonical order without annotation',
			function (_v7) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics that have canonical order',
			function (_v8) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 {})\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 {})\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics that have canonical order with additional nesting',
			function (_v9) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { y = 2, x = 6, yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics that have canonical order with additional nesting at end',
			function (_v10) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { foo = 1, bar = 2, baz = 3 , yi = 3, er = 2, san = 0, y = 2, x = 6}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$sortGenericFieldsLast($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics without canonical order',
			function (_v11) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { x = 6, y = 2, yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics without canonical order ambiguous',
			function (_v12) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$author$project$NoUnsortedRecordsTest$ambiguousRecordError,
							_List_fromArray(
								['A.Generic (A.Generic2)', 'A.Generic2 (A.Generic)']),
							'{ san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'nested generics without canonical order report only',
			function (_v13) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							$author$project$NoUnsortedRecordsTest$unknownRecordError('{ san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }'),
							$author$project$NoUnsortedRecordsTest$unknownRecordError('{ x : Int, y : Int }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportUnknownRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'prefers canonical match over generic + unknown',
			function (_v14) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not prefer canonical match over generic + canonical',
			function (_v15) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$author$project$NoUnsortedRecordsTest$ambiguousRecordError,
							_List_fromArray(
								['A.A', 'A.Generic (A.B)']),
							'{ bar = 2, foo = 1, baz = 3 }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not recurse infinitely when not all fields must be present',
			function (_v16) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias Generic a =\n    { a | unrelated : Int, foo : Int }\n\nfunc x =\n    case x of\n        { bar, baz, foo } ->\n            True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles weird Elm nested generic behavior',
			function (_v17) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias Gen1 a =\n    { a | y : Int, x : Int }\n\n\ntype alias Gen2 b =\n    { b | x : Char, y : String }\n\ntype alias OtherRec = { y : String, x : Char }\n\na : Gen2 (Gen1 { x : String, y : Float })\na =\n    { x = \'a\' , y = "bar"}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 14},
									start: {column: 5, row: 14}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Gen1 a =\n    { a | y : Int, x : Int }\n\n\ntype alias Gen2 b =\n    { b | x : Char, y : String }\n\ntype alias OtherRec = { y : String, x : Char }\n\na : Gen2 (Gen1 { x : String, y : Float })\na =\n    { y = "bar", x = \'a\' }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$inExpressions = A2(
	$elm_explorations$test$Test$describe,
	'expressions are sorted',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'sorts expressions',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na = { a = 3 , b = 1, c = 2}\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na = { b = 1, c = 2, a = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts multiline expressions',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na =\n    { a = 3\n    \n    , b = 1, c = 2\n    }\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na =\n    { b = 1\n    , c = 2\n    , a = 3\n    }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$inPatterns = A2(
	$elm_explorations$test$Test$describe,
	'patterns are sorted',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'sorts patterns',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na { bar, baz, foo } = True\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na { foo, baz, bar } = True\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$inTypeAnnotations = A2(
	$elm_explorations$test$Test$describe,
	'type annotations are sorted (when not custom types or type aliases)',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'sorts type annotations',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na : { a : Int , b : Int, c : Int} -> Bool\na _ = True\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na : { b : Int, c : Int, a : Int } -> Bool\na _ = True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'sorts multiline type annotations',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na :\n    { a : Int\n    \n    , b : Int, c : Int\n    }\n    -> Bool\na _ =\n    True\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na :\n    { b : Int\n    , c : Int\n    , a : Int\n    }\n    -> Bool\na _ =\n    True\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$localBindingSupport = A2(
	$elm_explorations$test$Test$describe,
	'disambiguates using local bindings',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation in let block',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc =\n    let\n        foo : A -> Bool\n        foo _ = True\n    in\n    foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 10, row: 12},
									start: {column: 9, row: 12}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc =\n    let\n        foo : A -> Bool\n        foo _ = True\n    in\n    foo { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation on function arg',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc foo = foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 17, row: 7},
									start: {column: 16, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc foo = foo { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'possible because of lambda arg',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc = \\foo -> foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 21, row: 7},
									start: {column: 20, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc = \\foo -> foo { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'works with record pattern',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { field : Int, foo : (A -> Bool) } -> Bool\nfunc { field, foo } = foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 28, row: 7},
									start: {column: 27, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { field : Int, foo : (A -> Bool) } -> Bool\nfunc { field, foo } = foo { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'works with named pattern',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\ntype Custom = Custom In (A -> Bool)\n\nfunc : Custom -> Bool\nfunc (Custom field foo) = foo { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 32, row: 8},
									start: {column: 31, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\ntype Custom = Custom In (A -> Bool)\n\nfunc : Custom -> Bool\nfunc (Custom field foo) = foo { bar = 2, foo = 1, baz = 3 }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$operatorSupport = A2(
	$elm_explorations$test$Test$describe,
	'operator support',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'understands |> operator application',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { foo = 1, bar = 2, baz = 3 } |> foo\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 10},
									start: {column: 8, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 } |> foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles parentheses',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { foo = 1, bar = 2, baz = 3 } |> (foo)\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 10},
									start: {column: 8, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 } |> (foo)\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'understands <| operator application',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo <| { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 16, row: 10},
									start: {column: 15, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo <| { bar = 2, foo = 1, baz = 3 }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$recordConstructorSupport = A2(
	$elm_explorations$test$Test$describe,
	'using record constructors',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'possible because of type annotation of field for record constructor',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { foo = 2, bar = 1, baz = 3 } { foo = 2, bar = 1, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 8, row: 9},
									start: {column: 7, row: 9}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { bar = 1, foo = 2, baz = 3 } { bar = 1, foo = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 38, row: 9},
									start: {column: 37, row: 9}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { bar = 1, foo = 2, baz = 3 } { foo = 2, bar = 1, baz = 3 }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$simpleTypeInferenceSupport = A2(
	$elm_explorations$test$Test$describe,
	'infers record field types',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : List (List Int), baz : Char }\ntype alias B = { bar : List (List String), foo : Int, baz : Char }\n\nfunc = { foo = 3, bar = [ [], ([3, 4]) ], baz = \'2\' }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : List (List Int), baz : Char }\ntype alias B = { bar : List (List String), foo : Int, baz : Char }\n\nfunc = { bar = [ [], ([3, 4]) ], foo = 3, baz = \'2\' }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not incorrectly infer Nothings',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Maybe Int, bar : Maybe Float }\n\na = { foo = Nothing, bar = Nothing }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not incorrectly infer nested Nothings',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Maybe Int, bar : Maybe Float }, er : Int }\n\na = { yi = { foo = Nothing, bar = Nothing }, er = 2 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'infers lambdas',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int -> Int, baz : Char }\ntype alias B = { bar : Int, foo : Int, baz : Char }\n\nfunc = { foo = 3, bar = \\i -> i + 1, baz = \'2\' }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int -> Int, baz : Char }\ntype alias B = { bar : Int, foo : Int, baz : Char }\n\nfunc = { bar = \\i -> i + 1, foo = 3, baz = \'2\' }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type with record types',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc = { foo = { a = 3, b = "b" }, bar = 2, baz = { a = 2, b = "r" }.a }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc = { bar = 2, foo = { a = 3, b = "b" }, baz = { a = 2, b = "r" }.a }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'infers let destructuring types',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc =\n    let\n        { foo, bar, baz } = A 1 "string" 3\n    in\n    { foo = foo, bar = bar, baz = baz }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 10, row: 8},
									start: {column: 9, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc =\n    let\n        { bar, foo, baz } = A 1 "string" 3\n    in\n    { foo = foo, bar = bar, baz = baz }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'infers case pattern types',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case {foo = 1, bar = s, baz = 2} of\n        {foo, bar, baz} ->\n            True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 10, row: 9},
									start: {column: 9, row: 9}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case {foo = 1, bar = s, baz = 2} of\n        {bar, foo, baz} ->\n            True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'assigns case pattern bindings',
			function (_v7) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case s of\n        "True" -> True\n        "False" -> False\n        str -> {foo = 1, bar = str, baz = 2}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 17, row: 11},
									start: {column: 16, row: 11}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case s of\n        "True" -> True\n        "False" -> False\n        str -> {bar = str, foo = 1, baz = 2}\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'infers record update with binding',
			function (_v8) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nr : A\nr = { foo = 1, bar = 2, baz = 3 }\n\nfunc =\n    { r | foo = 2 , baz = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 10},
									start: {column: 5, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nr : A\nr = { foo = 1, bar = 2, baz = 3 }\n\nfunc =\n    { r | baz = 1, foo = 2 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'unifies record types',
			function (_v9) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : String, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc r =\n    case List.head [ { r | baz = 1 }, { r | bar = 1 }, { r | foo = "string" } ] of\n        Just { foo, bar, baz } -> True\n        Nothing -> False\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 15, row: 8},
									start: {column: 14, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : String, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc r =\n    case List.head [ { r | baz = 1 }, { r | bar = 1 }, { r | foo = "string" } ] of\n        Just { bar, baz, foo } -> True\n        Nothing -> False\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'assigns type vars when necessary',
			function (_v10) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : A\nfunc =\n    identity { foo = 1, bar = 2, baz = 3}\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'assigns type vars when necessary 2',
			function (_v11) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : a -> A\nfunc =\n    always { foo = 1, bar = 2, baz = 3}\n'));
			})
		]));
var $author$project$NoUnsortedRecords$treatAllSubrecordsAsCanonical = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{subrecordTreatment: $author$project$NoUnsortedRecords$AlwaysCanonical}));
};
var $author$project$NoUnsortedRecords$CustomTypeArgsAlwaysCanonical = {$: 'CustomTypeArgsAlwaysCanonical'};
var $author$project$NoUnsortedRecords$treatCustomTypeRecordsAsCanonical = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{subrecordTreatment: $author$project$NoUnsortedRecords$CustomTypeArgsAlwaysCanonical}));
};
var $author$project$NoUnsortedRecords$AlwaysUnknown = {$: 'AlwaysUnknown'};
var $author$project$NoUnsortedRecords$treatSubrecordsAsUnknown = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{subrecordTreatment: $author$project$NoUnsortedRecords$AlwaysUnknown}));
};
var $author$project$NoUnsortedRecordsTest$subrecords = A2(
	$elm_explorations$test$Test$describe,
	'subrecords',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in larger record',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 24, row: 5},
									start: {column: 23, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are not sorted by default from constructor when not part of constructor',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted from constructor when not part of constructor with setting',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatCustomTypeRecordsAsCanonical($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias Rec = { yi : { bar : Int, baz : Int, foo : Int }, er : Int }\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\nfunc = { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in larger record with type annotation',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 24, row: 6},
									start: {column: 23, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in sub sub record',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1} }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 19, row: 5},
									start: {column: 18, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 34, row: 5},
									start: {column: 33, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in larger record with nested expression',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc = { yi = (0, [ { foo = 1, bar = 2, baz = 3 } ]), er = 1 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 22, row: 5},
									start: {column: 21, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc = { yi = (0, [ { bar = 2, foo = 1, baz = 3 } ]), er = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in type annotations',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { yi : { bar : Int, foo : Int, baz : Int } , er : Int}\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { er : Int, yi : { foo : Int, bar : Int, baz : Int } }\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 26, row: 5},
									start: {column: 25, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { er : Int, yi : { bar : Int, foo : Int, baz : Int } }\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in sub sub record of type annotation',
			function (_v7) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { yi : { bar : Int, foo : Int, baz : Int } , er : Int} }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 19, row: 5},
									start: {column: 18, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { er : Int, yi : { foo : Int, bar : Int, baz : Int } } }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 36, row: 5},
									start: {column: 35, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { er : Int, yi : { bar : Int, foo : Int, baz : Int } } }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted by default in larger record with nested expression in type annotation',
			function (_v8) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc : { yi : (Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\nfunc = { yi = (0, []), er = 1 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 27, row: 5},
									start: {column: 26, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc : { yi : (Int, List { bar : Int, foo : Int, baz : Int }), er : Int }\nfunc = { yi = (0, []), er = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are not sorted with setting in larger record',
			function (_v9) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { yi = { bar = 2, baz = 3, foo = 1 } , er = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatSubrecordsAsUnknown($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { bar = 2, baz = 3, foo = 1 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are not sorted with setting in larger record with type annotation',
			function (_v10) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { yi = { bar = 2, baz = 3, foo = 1 } , er = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatSubrecordsAsUnknown($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { bar = 2, baz = 3, foo = 1 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are not sorted for custom types with setting',
			function (_v11) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatSubrecordsAsUnknown($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { bar = 2, baz = 3, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted with setting when not in context from alias',
			function (_v12) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { foo = 1 , bar = 2, baz = 3}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatAllSubrecordsAsCanonical($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are sorted with setting when not in context from constructor',
			function (_v13) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype A = A { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { foo = 1 , bar = 2, baz = 3}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$treatAllSubrecordsAsCanonical($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype A = A { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handle ambiguity with subrecords with setting',
			function (_v14) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$author$project$NoUnsortedRecordsTest$ambiguousRecordError,
							_List_fromArray(
								['A.A arg0', 'A.B arg0']),
							'{ bar = 2, baz = 3, foo = 1 }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix(
								$author$project$NoUnsortedRecords$treatAllSubrecordsAsCanonical($author$project$NoUnsortedRecords$defaults))),
						'module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = { bar = 2, baz = 3, foo = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'do not take priority',
			function (_v15) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\ntype alias B = { baz : Int, bar : Int, foo : Int }\n\nfunc = { baz = 3 , bar = 2, foo = 1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportAmbiguousRecordsWithoutFix(
								$author$project$NoUnsortedRecords$treatAllSubrecordsAsCanonical($author$project$NoUnsortedRecords$defaults))),
						'module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\ntype alias B = { baz : Int, bar : Int, foo : Int }\n\nfunc = { foo = 1, bar = 2, baz = 3 }\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$typeVarSupport = A2(
	$elm_explorations$test$Test$describe,
	'handles type variables',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'in custom types',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Maybe A\na = Just { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 11, row: 8},
									start: {column: 10, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Maybe A\na = Just { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in non-dependency custom types',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom a = Custom a\n\na : Custom A\na = Custom { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 13, row: 10},
									start: {column: 12, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom a = Custom a\n\na : Custom A\na = Custom { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'in aliases',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias Mebbe a = a\n\na : Mebbe A\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 10},
									start: {column: 5, row: 10}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias Mebbe a = a\n\na : Mebbe A\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can match with type vars',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { foo : String, bar : Int, baz : Int }\nfunc =\n    { foo = "foo", bar = 1, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { foo : String, bar : Int, baz : Int }\nfunc =\n    { bar = 1, foo = "foo", baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can assign type vars',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A a b = { foo : a, bar : b, baz : Maybe Int }\ntype alias B a = { bar : a, foo : a, baz : Maybe Int }\n\nfunc : { foo : String, bar : Int, baz : Maybe a }\nfunc =\n    { foo = "foo", bar = 1, baz = Nothing }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 8},
									start: {column: 5, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A a b = { foo : a, bar : b, baz : Maybe Int }\ntype alias B a = { bar : a, foo : a, baz : Maybe Int }\n\nfunc : { foo : String, bar : Int, baz : Maybe a }\nfunc =\n    { bar = 1, foo = "foo", baz = Nothing }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not recurse infinitely by a typevar being assigned to itself',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias C z = { y : z }\n\nc : C a -> a\nc = .y\n\nfoo : { a | field : Int } -> C x -> Int\nfoo _ _ = 0\n\nrecord =\n    { f = foo (c 1) (c 2) }\n'));
			})
		]));
var $author$project$NoUnsortedRecords$typecheckAllRecords = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{typecheckUnambiguousRecords: true}));
};
var $author$project$NoUnsortedRecordsTest$typecheckUnambiguous = A2(
	$elm_explorations$test$Test$describe,
	'unambiguous records',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'are not type-checked by default',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { foo = 1.1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, foo = 1.1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'are type-checked with option',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, baz = 3 , foo = 1.1}\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 5},
									start: {column: 8, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$typecheckAllRecords($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, foo = 1.1, baz = 3 }\n'));
			})
		]));
var $author$project$NoUnsortedRecords$doNotSortUnknownRecords = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedRecords$RuleConfig(
		_Utils_update(
			r,
			{sortUnknown: $author$project$NoUnsortedRecords$DoNotSort}));
};
var $author$project$NoUnsortedRecordsTest$unknownRecords = A2(
	$elm_explorations$test$Test$describe,
	'unknown records',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes unknown record that is alphabetical',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na = { a = 1, b = 2, c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails unknown record that is not alphabetical',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2($jfmengels$elm_review$Review$Test$whenFixed, 'module A exposing (..)\n\na = { a = 1 , b = 2, c = 3}\n', $author$project$NoUnsortedRecordsTest$unsortedError)
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'passes unknown record that is not alphabetical with option',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$doNotSortUnknownRecords($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'reports unknown record that is not alphabetical with option',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							$author$project$NoUnsortedRecordsTest$unknownRecordError('{ c = 3, b = 2, a = 1 }')
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportUnknownRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not report unknown record with single field even with option',
			function (_v4) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportUnknownRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\na = { c = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not report unit record even with option',
			function (_v5) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule(
							$author$project$NoUnsortedRecords$reportUnknownRecordsWithoutFix($author$project$NoUnsortedRecords$defaults)),
						'module A exposing (..)\n\na = {}\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$usesRecordFieldTypes = A2(
	$elm_explorations$test$Test$describe,
	'uses record field types',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by field type',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { foo = 2, bar = 1, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 12, row: 8},
									start: {column: 11, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { bar = 2, foo = 1, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 47, row: 8},
									start: {column: 46, row: 8}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by field type without alias',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { foo = 2, bar = 1, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 12, row: 7},
									start: {column: 11, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { bar = 2, foo = 1, baz = 3 } }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 47, row: 7},
									start: {column: 46, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { foo : Int, bar : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { bar : Int, foo : Int, baz : Int } -> Bool\nfunc { foo, bar, baz } = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 7, row: 7},
									start: {column: 6, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { bar : Int, foo : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type via record access',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { foo = 2, bar = 1, baz = 3 }.bar\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 7},
									start: {column: 8, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { bar = 1, foo = 2, baz = 3 }.bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type via record access function',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { foo = 2, bar = 1, baz = 3 } |> .bar\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 7},
									start: {column: 8, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { bar = 1, foo = 2, baz = 3 } |> .bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'can disambiguate by type with record types',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { foo : { a : Int, b : String }, bar : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 9, row: 6},
									start: {column: 8, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError)),
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { bar : Int, foo : { a : Int, b : String }, baz : Int } -> Bool\nfunc { foo, bar, baz } = True\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 7, row: 7},
									start: {column: 6, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { bar : Int, foo : { a : Int, b : String }, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n'));
			})
		]));
var $author$project$NoUnsortedRecordsTest$withAlias = A2(
	$elm_explorations$test$Test$describe,
	'record corresponds to a known alias',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'fields are in sorted order with type annotation',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are in sorted order without type annotation',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are in order to multiple matching aliases',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are not in sorted order with type annotation',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 6},
									start: {column: 5, row: 6}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are not in sorted order without type annotation',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 5},
									start: {column: 5, row: 5}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fields are not in order to multiple matching aliases with degenerate orders',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n',
							A2(
								$jfmengels$elm_review$Review$Test$atExactly,
								{
									end: {column: 6, row: 7},
									start: {column: 5, row: 7}
								},
								$author$project$NoUnsortedRecordsTest$unsortedError))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						'module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not keep unexposed aliases',
			function (_v6) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$runOnModules,
						$author$project$NoUnsortedRecords$rule($author$project$NoUnsortedRecords$defaults),
						_List_fromArray(
							['module B exposing (foo)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n', 'module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 }\n'])));
			})
		]));
var $author$project$NoUnsortedRecordsTest$all = A2(
	$elm_explorations$test$Test$describe,
	'NoUnsortedRecords',
	_List_fromArray(
		[$author$project$NoUnsortedRecordsTest$unknownRecords, $author$project$NoUnsortedRecordsTest$ambiguousRecords, $author$project$NoUnsortedRecordsTest$withAlias, $author$project$NoUnsortedRecordsTest$inTypeAnnotations, $author$project$NoUnsortedRecordsTest$inExpressions, $author$project$NoUnsortedRecordsTest$inPatterns, $author$project$NoUnsortedRecordsTest$avoidBadFixes, $author$project$NoUnsortedRecordsTest$disambiguatesByHasAllFields, $author$project$NoUnsortedRecordsTest$disambiguatesByTypeAnnotation, $author$project$NoUnsortedRecordsTest$customTypeArgs, $author$project$NoUnsortedRecordsTest$disambiguatesByKnownFunctionArgTypes, $author$project$NoUnsortedRecordsTest$typeVarSupport, $author$project$NoUnsortedRecordsTest$recordConstructorSupport, $author$project$NoUnsortedRecordsTest$usesRecordFieldTypes, $author$project$NoUnsortedRecordsTest$operatorSupport, $author$project$NoUnsortedRecordsTest$dependencySupport, $author$project$NoUnsortedRecordsTest$genericRecordSupport, $author$project$NoUnsortedRecordsTest$localBindingSupport, $author$project$NoUnsortedRecordsTest$simpleTypeInferenceSupport, $author$project$NoUnsortedRecordsTest$subrecords, $author$project$NoUnsortedRecordsTest$typecheckUnambiguous]));
var $author$project$NoUnsortedTopLevelDeclarations$RuleConfig = function (a) {
	return {$: 'RuleConfig', a: a};
};
var $elm_community$string_extra$String$Extra$changeCase = F2(
	function (mutator, word) {
		return A2(
			$elm$core$Maybe$withDefault,
			'',
			A2(
				$elm$core$Maybe$map,
				function (_v0) {
					var head = _v0.a;
					var tail = _v0.b;
					return A2(
						$elm$core$String$cons,
						mutator(head),
						tail);
				},
				$elm$core$String$uncons(word)));
	});
var $elm_community$string_extra$String$Extra$decapitalize = function (word) {
	return A2($elm_community$string_extra$String$Extra$changeCase, $elm$core$Char$toLower, word);
};
var $elm$core$Set$foldl = F3(
	function (func, initialState, _v0) {
		var dict = _v0.a;
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (key, _v1, state) {
					return A2(func, key, state);
				}),
			initialState,
			dict);
	});
var $elm$core$Set$map = F2(
	function (func, set) {
		return $elm$core$Set$fromList(
			A3(
				$elm$core$Set$foldl,
				F2(
					function (x, xs) {
						return A2(
							$elm$core$List$cons,
							func(x),
							xs);
					}),
				_List_Nil,
				set));
	});
var $author$project$NoUnsortedTopLevelDeclarations$alphabetically = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							return A2(
								$elm$core$Basics$compare,
								$elm$core$Set$toList(
									A2($elm$core$Set$map, $elm_community$string_extra$String$Extra$decapitalize, d1.namesBound)),
								$elm$core$Set$toList(
									A2($elm$core$Set$map, $elm_community$string_extra$String$Extra$decapitalize, d2.namesBound)));
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarations$accumulateImportRange = F2(
	function (i, context) {
		return _Utils_update(
			context,
			{
				moduleImportRange: A3(
					$elm_community$maybe_extra$Maybe$Extra$unpack,
					function (_v0) {
						return $elm$core$Maybe$Just(
							$stil4m$elm_syntax$Elm$Syntax$Node$range(i));
					},
					function (r) {
						return $elm$core$Maybe$Just(
							$stil4m$elm_syntax$Elm$Syntax$Range$combine(
								_List_fromArray(
									[
										r,
										$stil4m$elm_syntax$Elm$Syntax$Node$range(i)
									])));
					},
					context.moduleImportRange)
			});
	});
var $stil4m$elm_syntax$Elm$Syntax$Range$compare = F2(
	function (left, right) {
		var _v0 = A2($stil4m$elm_syntax$Elm$Syntax$Range$compareLocations, left.start, right.start);
		if (_v0.$ === 'EQ') {
			return A2($stil4m$elm_syntax$Elm$Syntax$Range$compareLocations, left.end, right.end);
		} else {
			var order = _v0;
			return order;
		}
	});
var $author$project$NoUnsortedTopLevelDeclarations$Function = {$: 'Function'};
var $author$project$NoUnsortedTopLevelDeclarations$Port = {$: 'Port'};
var $author$project$NoUnsortedTopLevelDeclarations$Type = {$: 'Type'};
var $elm_community$list_extra$List$Extra$last = function (items) {
	last:
	while (true) {
		if (!items.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			if (!items.b.b) {
				var x = items.a;
				return $elm$core$Maybe$Just(x);
			} else {
				var rest = items.b;
				var $temp$items = rest;
				items = $temp$items;
				continue last;
			}
		}
	}
};
var $elm_community$list_extra$List$Extra$splitWhen = F2(
	function (predicate, list) {
		return A2(
			$elm$core$Maybe$map,
			function (i) {
				return A2($elm_community$list_extra$List$Extra$splitAt, i, list);
			},
			A2($elm_community$list_extra$List$Extra$findIndex, predicate, list));
	});
var $author$project$NoUnsortedTopLevelDeclarations$getDecInfo = F3(
	function (exports, d, _v0) {
		var acc = _v0.a;
		var unparsedDocComments = _v0.b;
		var _v1 = A2(
			$elm$core$Tuple$mapFirst,
			$elm_community$list_extra$List$Extra$last,
			A2(
				$elm$core$Maybe$withDefault,
				_Utils_Tuple2(unparsedDocComments, _List_Nil),
				A2(
					$elm_community$list_extra$List$Extra$splitWhen,
					function (c) {
						return _Utils_eq(
							A2(
								$stil4m$elm_syntax$Elm$Syntax$Range$compare,
								$stil4m$elm_syntax$Elm$Syntax$Node$range(c),
								$stil4m$elm_syntax$Elm$Syntax$Node$range(d)),
							$elm$core$Basics$GT);
					},
					unparsedDocComments)));
		var immediatelyPreviousDocComment = _v1.a;
		var remainingDocComments = _v1.b;
		return A2(
			$elm$core$Tuple$mapFirst,
			A2(
				$elm_community$maybe_extra$Maybe$Extra$unwrap,
				acc,
				function (tld) {
					return A2($elm$core$List$cons, tld, acc);
				}),
			_Utils_Tuple2(
				function () {
					var _v2 = $stil4m$elm_syntax$Elm$Syntax$Node$value(d);
					switch (_v2.$) {
						case 'FunctionDeclaration':
							var declaration = _v2.a.declaration;
							return $elm$core$Maybe$Just(
								function (_v3) {
									var name = _v3.name;
									var expression = _v3.expression;
									return {
										dependentOnBindings: $author$project$Util$findAllNamesIn(expression),
										exposedOrder: A2(
											$elm$core$Maybe$andThen,
											$elm_community$list_extra$List$Extra$elemIndex(
												$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
											exports),
										glued: $elm$core$Maybe$Nothing,
										namesBound: $elm$core$Set$singleton(
											$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
										range: $stil4m$elm_syntax$Elm$Syntax$Node$range(d),
										type_: $author$project$NoUnsortedTopLevelDeclarations$Function
									};
								}(
									$stil4m$elm_syntax$Elm$Syntax$Node$value(declaration)));
						case 'AliasDeclaration':
							var name = _v2.a.name;
							return $elm$core$Maybe$Just(
								{
									dependentOnBindings: $elm$core$Set$empty,
									exposedOrder: A2(
										$elm$core$Maybe$andThen,
										$elm_community$list_extra$List$Extra$elemIndex(
											$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
										exports),
									glued: $elm$core$Maybe$Nothing,
									namesBound: $elm$core$Set$singleton(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
									range: $stil4m$elm_syntax$Elm$Syntax$Node$range(d),
									type_: $author$project$NoUnsortedTopLevelDeclarations$Type
								});
						case 'CustomTypeDeclaration':
							var name = _v2.a.name;
							return $elm$core$Maybe$Just(
								{
									dependentOnBindings: $elm$core$Set$empty,
									exposedOrder: A2(
										$elm$core$Maybe$andThen,
										$elm_community$list_extra$List$Extra$elemIndex(
											$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
										exports),
									glued: $elm$core$Maybe$Nothing,
									namesBound: $elm$core$Set$singleton(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
									range: $stil4m$elm_syntax$Elm$Syntax$Node$range(d),
									type_: $author$project$NoUnsortedTopLevelDeclarations$Type
								});
						case 'PortDeclaration':
							var name = _v2.a.name;
							return $elm$core$Maybe$Just(
								{
									dependentOnBindings: $elm$core$Set$empty,
									exposedOrder: $elm$core$Maybe$Nothing,
									glued: $elm$core$Maybe$Nothing,
									namesBound: $elm$core$Set$singleton(
										$stil4m$elm_syntax$Elm$Syntax$Node$value(name)),
									range: A3(
										$elm_community$maybe_extra$Maybe$Extra$unwrap,
										$stil4m$elm_syntax$Elm$Syntax$Node$range(d),
										function (c) {
											return $stil4m$elm_syntax$Elm$Syntax$Range$combine(
												_List_fromArray(
													[
														$stil4m$elm_syntax$Elm$Syntax$Node$range(c),
														$stil4m$elm_syntax$Elm$Syntax$Node$range(d)
													]));
										},
										immediatelyPreviousDocComment),
									type_: $author$project$NoUnsortedTopLevelDeclarations$Port
								});
						default:
							return $elm$core$Maybe$Nothing;
					}
				}(),
				remainingDocComments));
	});
var $author$project$NoUnsortedTopLevelDeclarations$declarationVisitor = F3(
	function (_v0, decs, context) {
		var glues = _v0.a.glues;
		var sortBy = _v0.a.sortBy;
		var applyGlues = F3(
			function (ds, i, d) {
				return _Utils_update(
					d,
					{
						glued: A2(
							$elm_community$list_extra$List$Extra$findMap,
							function (g) {
								return A2(
									g,
									_Utils_Tuple2(i, d),
									ds);
							},
							glues)
					});
			});
		return A5(
			$author$project$Util$checkSortingWithGlue,
			context.extractSource,
			'Top-level declarations',
			sortBy,
			context.errorRange,
			function (ds) {
				return A2(
					$elm$core$List$indexedMap,
					applyGlues(ds),
					ds);
			}(
				$elm$core$List$reverse(
					function (docCommentsWithoutModule) {
						return A3(
							$elm$core$List$foldl,
							$author$project$NoUnsortedTopLevelDeclarations$getDecInfo(context.exports),
							_Utils_Tuple2(_List_Nil, docCommentsWithoutModule),
							decs);
					}(
						A3(
							$elm_community$maybe_extra$Maybe$Extra$unwrap,
							_List_Nil,
							function (_v1) {
								var c = _v1.a;
								var cs = _v1.b;
								var _v2 = A2(
									$elm$core$Maybe$map,
									$stil4m$elm_syntax$Elm$Syntax$Range$compare(
										$stil4m$elm_syntax$Elm$Syntax$Node$range(c)),
									context.moduleImportRange);
								if (_v2.$ === 'Just') {
									if (_v2.a.$ === 'GT') {
										var _v3 = _v2.a;
										return context.unparsedDocComments;
									} else {
										return cs;
									}
								} else {
									return A2(
										$elm$core$List$any,
										$elm$core$String$startsWith('@docs'),
										$elm$core$String$lines(
											$stil4m$elm_syntax$Elm$Syntax$Node$value(c))) ? cs : context.unparsedDocComments;
								}
							},
							$elm_community$list_extra$List$Extra$uncons(context.unparsedDocComments))).a)));
	});
var $author$project$NoUnsortedTopLevelDeclarations$getModuleExports = F2(
	function (m, context) {
		var r = $stil4m$elm_syntax$Elm$Syntax$Node$range(m);
		var errorRange = function () {
			var _v2 = $stil4m$elm_syntax$Elm$Syntax$Node$value(m);
			if (_v2.$ === 'PortModule') {
				return _Utils_update(
					r,
					{
						end: {column: r.start.column + 11, row: r.start.row}
					});
			} else {
				return _Utils_update(
					r,
					{
						end: {column: r.start.column + 6, row: r.start.row}
					});
			}
		}();
		var _v0 = $stil4m$elm_syntax$Elm$Syntax$Module$exposingList(
			$stil4m$elm_syntax$Elm$Syntax$Node$value(m));
		if (_v0.$ === 'All') {
			return _Utils_update(
				context,
				{errorRange: errorRange});
		} else {
			var exports = _v0.a;
			return _Utils_update(
				context,
				{
					errorRange: errorRange,
					exports: $elm$core$Maybe$Just(
						A2(
							$elm$core$List$map,
							function (e) {
								var _v1 = $stil4m$elm_syntax$Elm$Syntax$Node$value(e);
								switch (_v1.$) {
									case 'InfixExpose':
										var s = _v1.a;
										return s;
									case 'FunctionExpose':
										var s = _v1.a;
										return s;
									case 'TypeOrAliasExpose':
										var s = _v1.a;
										return s;
									default:
										var name = _v1.a.name;
										return name;
								}
							},
							exports))
				});
		}
	});
var $author$project$NoUnsortedTopLevelDeclarations$getUnparsedDocComments = F2(
	function (comments, context) {
		return _Utils_update(
			context,
			{
				unparsedDocComments: A2(
					$elm$core$List$filter,
					A2(
						$elm$core$Basics$composeR,
						$stil4m$elm_syntax$Elm$Syntax$Node$value,
						function (c) {
							return A2($elm$core$String$startsWith, '{-|', c) && A2($elm$core$String$endsWith, '-}', c);
						}),
					comments)
			});
	});
var $author$project$NoUnsortedTopLevelDeclarations$initialContext = $jfmengels$elm_review$Review$Rule$withSourceCodeExtractor(
	$jfmengels$elm_review$Review$Rule$initContextCreator(
		F2(
			function (extractSource, _v0) {
				return {errorRange: $stil4m$elm_syntax$Elm$Syntax$Range$emptyRange, exports: $elm$core$Maybe$Nothing, extractSource: extractSource, moduleImportRange: $elm$core$Maybe$Nothing, unparsedDocComments: _List_Nil};
			})));
var $jfmengels$elm_review$Review$Rule$withCommentsVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					commentsVisitors: A2($elm$core$List$cons, visitor, schema.commentsVisitors)
				}));
	});
var $jfmengels$elm_review$Review$Rule$withDeclarationListVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					declarationListVisitors: A2($elm$core$List$cons, visitor, schema.declarationListVisitors)
				}));
	});
var $jfmengels$elm_review$Review$Rule$withImportVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					importVisitors: A2($elm$core$List$cons, visitor, schema.importVisitors)
				}));
	});
var $jfmengels$elm_review$Review$Rule$withModuleDefinitionVisitor = F2(
	function (visitor, _v0) {
		var schema = _v0.a;
		return $jfmengels$elm_review$Review$Rule$ModuleRuleSchema(
			_Utils_update(
				schema,
				{
					moduleDefinitionVisitors: A2($elm$core$List$cons, visitor, schema.moduleDefinitionVisitors)
				}));
	});
var $author$project$NoUnsortedTopLevelDeclarations$rule = function (_v0) {
	var r = _v0.a;
	return $jfmengels$elm_review$Review$Rule$fromModuleRuleSchema(
		$jfmengels$elm_review$Review$Rule$providesFixesForModuleRule(
			A2(
				$jfmengels$elm_review$Review$Rule$withDeclarationListVisitor,
				F2(
					function (ds, c) {
						return _Utils_Tuple2(
							A3(
								$author$project$NoUnsortedTopLevelDeclarations$declarationVisitor,
								$author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
									_Utils_update(
										r,
										{
											glues: $elm$core$List$reverse(r.glues),
											sortBy: $elm$core$List$reverse(r.sortBy)
										})),
								ds,
								c),
							c);
					}),
				A2(
					$jfmengels$elm_review$Review$Rule$withImportVisitor,
					F2(
						function (i, context) {
							return _Utils_Tuple2(
								_List_Nil,
								A2($author$project$NoUnsortedTopLevelDeclarations$accumulateImportRange, i, context));
						}),
					A2(
						$jfmengels$elm_review$Review$Rule$withCommentsVisitor,
						F2(
							function (cs, context) {
								return _Utils_Tuple2(
									_List_Nil,
									A2($author$project$NoUnsortedTopLevelDeclarations$getUnparsedDocComments, cs, context));
							}),
						A2(
							$jfmengels$elm_review$Review$Rule$withModuleDefinitionVisitor,
							F2(
								function (m, c) {
									return _Utils_Tuple2(
										_List_Nil,
										A2($author$project$NoUnsortedTopLevelDeclarations$getModuleExports, m, c));
								}),
							A2($jfmengels$elm_review$Review$Rule$newModuleRuleSchemaUsingContextCreator, 'NoUnsortedTopLevelDeclarations', $author$project$NoUnsortedTopLevelDeclarations$initialContext)))))));
};
var $author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations = $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
	{glues: _List_Nil, sortBy: _List_Nil});
var $author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError = function (portModule) {
	return $jfmengels$elm_review$Review$Test$error(
		{
			details: _List_fromArray(
				['Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration.']),
			message: 'Top-level declarations are not sorted.',
			under: portModule ? 'port module' : 'module'
		});
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$docCommentDetectionTests = A2(
	$elm_explorations$test$Test$describe,
	'correctly attaches doc comments',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'when before imports',
			function (_v0) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\n{-| before import\n-}\n\nimport Dict\n\na = 1\n\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-| before import\n-}\n\nimport Dict\n\nport z : () -> Int\n\na = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'when after imports',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\nimport Dict\n\na = 1\n\n{-| after import\n-}\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\nimport Dict\n\n{-| after import\n-}\nport z : () -> Int\n\na = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no import, but two before',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\n{-| doc1\n-}\n\na = 1\n\n{-| doc2\n-}\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\nport z : () -> Int\n\na = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no import, but parsed doc commment',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\na = 1\n\nb = 1\n\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\na = 1\n\nport z : () -> Int\n\nb = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no import, but @docs in comment',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\n{-|\n\n## Expose\n\n@docs a, b\n\n-}\n\na = 1\n\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-|\n\n## Expose\n\n@docs a, b\n\n-}\n\nport z : () -> Int\n\na = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no import, no @docs in comment, so assume it\'s for port',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\na = 1\n\n{-| nothing\n-}\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-| nothing\n-}\nport z : () -> Int\n\na = 1\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'multiple ports etc',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing (..)\n\n{-| module\n-}\n\n{-| a\n-}\na = 1\n\n{-| b\n-}\nb = 1\n\n{-| f\n-}\nport f : () -> Int\n\n{-| G\n-}\ntype G = G\n\nport s : () -> Int\n\n{-| z\n-}\nport z : () -> Int\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'port module A exposing (..)\n\n{-| module\n-}\n\n{-| z\n-}\nport z : () -> Int\n\n{-| G\n-}\ntype G = G\n\n{-| b\n-}\nb = 1\n\nport s : () -> Int\n\n{-| f\n-}\nport f : () -> Int\n\n{-| a\n-}\na = 1\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.exposedOrder, d2.exposedOrder);
							if (_v1.a.$ === 'Just') {
								if (_v1.b.$ === 'Just') {
									var i1 = _v1.a.a;
									var i2 = _v1.b.a;
									return A2($elm$core$Basics$compare, i1, i2);
								} else {
									var _v2 = _v1.b;
									return $elm$core$Basics$LT;
								}
							} else {
								if (_v1.b.$ === 'Just') {
									var _v3 = _v1.a;
									return $elm$core$Basics$GT;
								} else {
									var _v4 = _v1.a;
									var _v5 = _v1.b;
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterFirstDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarations$portsFirst = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.type_, d2.type_);
							if (_v1.a.$ === 'Port') {
								if (_v1.b.$ === 'Port') {
									var _v2 = _v1.a;
									var _v3 = _v1.b;
									return $elm$core$Basics$EQ;
								} else {
									var _v4 = _v1.a;
									return $elm$core$Basics$LT;
								}
							} else {
								if (_v1.b.$ === 'Port') {
									var _v5 = _v1.b;
									return $elm$core$Basics$GT;
								} else {
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesAfterFirstDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesAfterFirstDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\nhelp =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not dependencies',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\nhelp =\n    foo x\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\nz =\n    zed help y\n\ny =\n    help\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\ny =\n    help\n\nz =\n    zed help y\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterLastDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterLast, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesAfterLastDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesAfterLastDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\nhelp =\n    foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not dependencies',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\nz =\n    zed help y\n\nhelp =\n    foo x\n\ny =\n    help\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesAfterLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeFirstDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesBeforeFirstDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesBeforeFirstDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not dependencies',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not a dependency if in exactly one func',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nhelp =\n    foo\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeFirstDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\ny =\n    help\n\nz =\n    zed help y\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeLastDependent = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeLast, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									function (_v2) {
										var numberUsedIn = _v2.b;
										return numberUsedIn > 1;
									},
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesBeforeLastDependentTests = A2(
	$elm_explorations$test$Test$describe,
	'glueDependenciesBeforeLastDependent',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nhelp =\n    foo\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not dependencies',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered and removes cycles',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\nhelp =\n    foo x\n\ny =\n    help\n\nz =\n    zed help y\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueDependenciesBeforeLastDependent(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedAfterFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									A2(
										$elm$core$Basics$composeL,
										$elm$core$Basics$eq(1),
										$elm$core$Tuple$second),
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueHelpersAfterTests = A2(
	$elm_explorations$test$Test$describe,
	'glueHelpersAfter',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    foo\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not helpers',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport calledInB : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\ncalledInB =\n    foo\n\ndalledInB =\n    foo\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n\ndalledInB =\n    foo\n\ncalledInB =\n    foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'chains properly and ignores mutual dependencies',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    calledInBHelp foo\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nmutualDep2 =\n    bar mutualDep3\n\nmutualDep3 =\n    mutualDep1\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nmutualDep3 =\n    mutualDep1\n\nb =\n    bar calledInB\n\nmutualDep2 =\n    bar mutualDep3\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nz =\n    zed\n\ncalledInB =\n    calledInBHelp foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles mutual recursion when one is not viable for gluing',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\naHelp =\n    a\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersAfter(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\ntype alias Z =\n    A\n\naHelp =\n    a\n\nb =\n    bar\n\nz =\n    zed\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				glues: A2(
					$elm$core$List$cons,
					F2(
						function (_v1, ds) {
							var i = _v1.a;
							var d = _v1.b;
							return (_Utils_eq(d.exposedOrder, $elm$core$Maybe$Nothing) && _Utils_eq(d.type_, $author$project$NoUnsortedTopLevelDeclarations$Function)) ? A2(
								$elm$core$Maybe$map,
								A2($elm$core$Basics$composeL, $author$project$Util$GluedBeforeFirst, $elm$core$Tuple$first),
								A2(
									$author$project$Util$validate,
									A2(
										$elm$core$Basics$composeL,
										$elm$core$Basics$eq(1),
										$elm$core$Tuple$second),
									A2(
										$author$project$Util$findDependencies,
										_Utils_Tuple2(i, d),
										ds))) : $elm$core$Maybe$Nothing;
						}),
					r.glues)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$glueHelpersBeforeTests = A2(
	$elm_explorations$test$Test$describe,
	'glueHelpersBefore',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    foo\n\nb =\n    bar calledInB\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'ports are not helpers',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport calledInB : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'is not helper if used in multiple funcs',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo calledInB\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    foo\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'does not glue to self',
			function (_v3) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    calledInB\n\nb =\n    bar calledInB\n\nz =\n    z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when not ordered',
			function (_v4) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    foo\n\ndalledInB =\n    foo\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n\ndalledInB =\n    foo\n\ncalledInB =\n    foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'chains properly and ignores mutual dependencies',
			function (_v5) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInBHelp =\n    bar\n\ncalledInB =\n    calledInBHelp foo\n\nb =\n    bar calledInB\n\nmutualDep1 =\n    mutualDep2\n\nmutualDep2 =\n    bar mutualDep3\n\nmutualDep3 =\n    mutualDep1\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nmutualDep3 =\n    mutualDep1\n\nb =\n    bar calledInB\n\nmutualDep2 =\n    bar mutualDep3\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nz =\n    zed\n\ncalledInB =\n    calledInBHelp foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'handles mutual recursion when one is not viable for gluing',
			function (_v6) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\naHelp =\n    a\n\na =\n    aHelp\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$glueHelpersBefore(
								$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
									$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\naHelp =\n    a\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$glues = A2(
	$elm_explorations$test$Test$describe,
	'glues',
	_List_fromArray(
		[$author$project$NoUnsortedTopLevelDeclarationsTest$glueHelpersBeforeTests, $author$project$NoUnsortedTopLevelDeclarationsTest$glueHelpersAfterTests, $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesBeforeFirstDependentTests, $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesAfterFirstDependentTests, $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesBeforeLastDependentTests, $author$project$NoUnsortedTopLevelDeclarationsTest$glueDependenciesAfterLastDependentTests]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$alphabeticallyTests = A2(
	$elm_explorations$test$Test$describe,
	'alphabetically',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'module A exposing (..)\nbar =\n    x\nbaz =\n    y\nfoo =\n    z\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unordered',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n{-| A\n-}\n\n{-| bar\n-}\nbar =\n    x\n\n{-| baz\n-}\nbaz =\n    y\n\n{-| foo\n-}\nfoo =\n    z\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'module A exposing (..)\n{-| A\n-}\n\n{-| foo\n-}\nfoo =\n    z\n\n{-| bar\n-}\nbar =\n    x\n\n{-| baz\n-}\nbaz =\n    y\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered with types and aliases',
			function (_v2) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'module A exposing (..)\ntype A\n    = A\n\na =\n    foo\n\nb =\n    bar\n\nz =\n    zed\n\ntype alias Z =\n    A\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unordered with types and aliases',
			function (_v3) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing (..)\n\n{-| This is fine in this order too.\n-}\ntype Bar = Bar\n\nbar =\n    x\n\nbaz =\n    y\n{-| foo\n-}\nfoo =\n    z\n{-| This isn\'t!\n-}\ntype alias Zed = {}\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'module A exposing (..)\n\n{-| This is fine in this order too.\n-}\ntype Bar = Bar\n\nbar =\n    x\n\n{-| This isn\'t!\n-}\ntype alias Zed = {}\n{-| foo\n-}\nfoo =\n    z\nbaz =\n    y\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateFirst = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.exposedOrder, d2.exposedOrder);
							if (_v1.a.$ === 'Just') {
								if (_v1.b.$ === 'Just') {
									var i1 = _v1.a.a;
									var i2 = _v1.b.a;
									return A2($elm$core$Basics$compare, i1, i2);
								} else {
									var _v2 = _v1.b;
									return $elm$core$Basics$GT;
								}
							} else {
								if (_v1.b.$ === 'Just') {
									var _v3 = _v1.a;
									return $elm$core$Basics$LT;
								} else {
									var _v4 = _v1.a;
									var _v5 = _v1.b;
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$exposedOrderWithPrivateFirstTests = A2(
	$elm_explorations$test$Test$describe,
	'exposedOrderWithPrivateFirst',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\nz =\n    zed\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\nz =\n    zed\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$exposedOrderWithPrivateLastTests = A2(
	$elm_explorations$test$Test$describe,
	'exposedOrderWithPrivateLast',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'falls back to second sorting',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))),
						'module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nz =\n    zed\n\nb =\n    bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v2) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'module A exposing\n    ( a, A\n    , Z\n    )\n\n{-|\n\n@docs a, A\n@docs Z\n\n-}\n\na =\n    foo\n\n{-| A\n-}\ntype A\n    = A\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(false))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))),
						'module A exposing\n    ( a, A\n    , Z\n    )\n\n{-|\n\n@docs a, A\n@docs Z\n\n-}\n\nb =\n    bar\n\nz =\n    zed\n{-| A\n-}\ntype A\n    = A\n\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$typesFirst = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.type_, d2.type_);
							if (_v1.a.$ === 'Type') {
								if (_v1.b.$ === 'Type') {
									var _v2 = _v1.a;
									var _v3 = _v1.b;
									return $elm$core$Basics$EQ;
								} else {
									var _v4 = _v1.a;
									return $elm$core$Basics$LT;
								}
							} else {
								if (_v1.b.$ === 'Type') {
									var _v5 = _v1.b;
									return $elm$core$Basics$GT;
								} else {
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$portsFirstTests = A2(
	$elm_explorations$test$Test$describe,
	'portsFirst',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst(
										$author$project$NoUnsortedTopLevelDeclarations$portsFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$portsLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.type_, d2.type_);
							if (_v1.a.$ === 'Port') {
								if (_v1.b.$ === 'Port') {
									var _v2 = _v1.a;
									var _v3 = _v1.b;
									return $elm$core$Basics$EQ;
								} else {
									var _v4 = _v1.a;
									return $elm$core$Basics$GT;
								}
							} else {
								if (_v1.b.$ === 'Port') {
									var _v5 = _v1.b;
									return $elm$core$Basics$LT;
								} else {
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$portsLastTests = A2(
	$elm_explorations$test$Test$describe,
	'portsLast',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst(
										$author$project$NoUnsortedTopLevelDeclarations$portsLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\nport b: String -> Cmd msg\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\nport b: String -> Cmd msg\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst(
										$author$project$NoUnsortedTopLevelDeclarations$portsLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations))))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$typesFirstTests = A2(
	$elm_explorations$test$Test$describe,
	'typesFirst',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n{-| Z\n-}\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\nc =\n    bar\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n{-| Z\n-}\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\nc =\n    bar\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesFirst($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n{-| Z\n-}\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarations$typesLast = function (_v0) {
	var r = _v0.a;
	return $author$project$NoUnsortedTopLevelDeclarations$RuleConfig(
		_Utils_update(
			r,
			{
				sortBy: A2(
					$elm$core$List$cons,
					F2(
						function (d1, d2) {
							var _v1 = _Utils_Tuple2(d1.type_, d2.type_);
							if (_v1.a.$ === 'Type') {
								if (_v1.b.$ === 'Type') {
									var _v2 = _v1.a;
									var _v3 = _v1.b;
									return $elm$core$Basics$EQ;
								} else {
									var _v4 = _v1.a;
									return $elm$core$Basics$GT;
								}
							} else {
								if (_v1.b.$ === 'Type') {
									var _v5 = _v1.b;
									return $elm$core$Basics$LT;
								} else {
									return $elm$core$Basics$EQ;
								}
							}
						}),
					r.sortBy)
			}));
};
var $author$project$NoUnsortedTopLevelDeclarationsTest$typesLastTests = A2(
	$elm_explorations$test$Test$describe,
	'typesLast',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'passes when ordered',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nz =\n    zed\n\na =\n    foo\n\nport b: String -> Cmd msg\n\nc =\n    bar\n\ntype A\n    = A\n\ntype alias Z =\n    A\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'fails when unsorted',
			function (_v1) {
				return A2(
					$jfmengels$elm_review$Review$Test$expectErrors,
					_List_fromArray(
						[
							A2(
							$jfmengels$elm_review$Review$Test$whenFixed,
							'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nz =\n    zed\n\na =\n    foo\n\nport b: String -> Cmd msg\n\nc =\n    bar\n\ntype A\n    = A\n\ntype alias Z =\n    A\n',
							$author$project$NoUnsortedTopLevelDeclarationsTest$unsortedError(true))
						]),
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically(
								$author$project$NoUnsortedTopLevelDeclarations$exposedOrderWithPrivateLast(
									$author$project$NoUnsortedTopLevelDeclarations$typesLast($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)))),
						'port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\ntype A\n    = A\n\nz =\n    zed\n\nport b: String -> Cmd msg\n\ntype alias Z =\n    A\n\na =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$orderings = A2(
	$elm_explorations$test$Test$describe,
	'orderings',
	_List_fromArray(
		[$author$project$NoUnsortedTopLevelDeclarationsTest$alphabeticallyTests, $author$project$NoUnsortedTopLevelDeclarationsTest$exposedOrderWithPrivateLastTests, $author$project$NoUnsortedTopLevelDeclarationsTest$exposedOrderWithPrivateFirstTests, $author$project$NoUnsortedTopLevelDeclarationsTest$typesFirstTests, $author$project$NoUnsortedTopLevelDeclarationsTest$typesLastTests, $author$project$NoUnsortedTopLevelDeclarationsTest$portsFirstTests, $author$project$NoUnsortedTopLevelDeclarationsTest$portsLastTests]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$passes = A2(
	$elm_explorations$test$Test$describe,
	'passes when',
	_List_fromArray(
		[
			A2(
			$elm_explorations$test$Test$test,
			'single declaration',
			function (_v0) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule(
							$author$project$NoUnsortedTopLevelDeclarations$alphabetically($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations)),
						'module A exposing (..)\nf =\n    foo\n'));
			}),
			A2(
			$elm_explorations$test$Test$test,
			'no orderings',
			function (_v1) {
				return $jfmengels$elm_review$Review$Test$expectNoErrors(
					A2(
						$jfmengels$elm_review$Review$Test$run,
						$author$project$NoUnsortedTopLevelDeclarations$rule($author$project$NoUnsortedTopLevelDeclarations$sortTopLevelDeclarations),
						'module A exposing (..)\nf =\n    foo\n'));
			})
		]));
var $author$project$NoUnsortedTopLevelDeclarationsTest$all = A2(
	$elm_explorations$test$Test$describe,
	'NoUnsortedTopLevelDeclarations',
	_List_fromArray(
		[$author$project$NoUnsortedTopLevelDeclarationsTest$passes, $author$project$NoUnsortedTopLevelDeclarationsTest$orderings, $author$project$NoUnsortedTopLevelDeclarationsTest$glues, $author$project$NoUnsortedTopLevelDeclarationsTest$docCommentDetectionTests]));
var $elm$core$Debug$todo = _Debug_todo;
var $author$project$Runner$checkHelperReplaceMe___ = function (_v0) {
	return _Debug_todo(
		'Runner',
		{
			start: {line: 36, column: 5},
			end: {line: 36, column: 15}
		})('The regex for replacing this Debug.todo with some real code must have failed since you see this message!\n\nPlease report this bug: https://github.com/mpizenberg/elm-test-rs/issues/new\n');
};
var $author$project$Runner$check = value => value && value.__elmTestSymbol === __elmTestSymbol ? $elm$core$Maybe$Just(value) : $elm$core$Maybe$Nothing;
var $author$project$Runner$tests = A2(
	$elm$core$List$filterMap,
	$elm$core$Basics$identity,
	_List_fromArray(
		[
			$author$project$Runner$check($author$project$NoUnsortedCasesTest$all),
			$author$project$Runner$check($author$project$NoUnsortedRecordsTest$all),
			$author$project$Runner$check($author$project$NoUnsortedTopLevelDeclarationsTest$all),
			$author$project$Runner$check($author$project$NoUnsortedLetDeclarationsTest$all)
		]));
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$AskTestsCount = {$: 'AskTestsCount'};
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$ReceiveRunTest = function (a) {
	return {$: 'ReceiveRunTest', a: a};
};
var $elm$core$Platform$Sub$batch = _Platform_batch;
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$Model = F2(
	function (ports, testRunners) {
		return {ports: ports, testRunners: testRunners};
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Plain = {$: 'Plain'};
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$empty = $elm$core$Result$Ok(
	{kind: $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Plain, runners: $elm$core$Array$empty});
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Only = {$: 'Only'};
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Skipping = {$: 'Skipping'};
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$filterRunners = F2(
	function (filter, runners) {
		if (filter.$ === 'Nothing') {
			return runners;
		} else {
			var pattern = filter.a;
			return A2(
				$elm$core$List$filter,
				function (r) {
					return A2(
						$elm$core$List$any,
						$elm$core$String$contains(pattern),
						r.labels);
				},
				runners);
		}
	});
var $elm_explorations$test$Test$Runner$Invalid = function (a) {
	return {$: 'Invalid', a: a};
};
var $elm_explorations$test$Test$Runner$Only = function (a) {
	return {$: 'Only', a: a};
};
var $elm_explorations$test$Test$Runner$Plain = function (a) {
	return {$: 'Plain', a: a};
};
var $elm_explorations$test$Test$Runner$Skipping = function (a) {
	return {$: 'Skipping', a: a};
};
var $elm_explorations$test$Test$Runner$countRunnables = function (runnable) {
	countRunnables:
	while (true) {
		if (runnable.$ === 'Runnable') {
			return 1;
		} else {
			var runner = runnable.b;
			var $temp$runnable = runner;
			runnable = $temp$runnable;
			continue countRunnables;
		}
	}
};
var $elm_explorations$test$Test$Runner$countAllRunnables = A2(
	$elm$core$List$foldl,
	A2($elm$core$Basics$composeR, $elm_explorations$test$Test$Runner$countRunnables, $elm$core$Basics$add),
	0);
var $elm_explorations$test$Test$Runner$Labeled = F2(
	function (a, b) {
		return {$: 'Labeled', a: a, b: b};
	});
var $elm_explorations$test$Test$Runner$Runnable = function (a) {
	return {$: 'Runnable', a: a};
};
var $elm_explorations$test$Test$Runner$Thunk = function (a) {
	return {$: 'Thunk', a: a};
};
var $elm_explorations$test$Test$Runner$emptyDistribution = function (seed) {
	return {all: _List_Nil, only: _List_Nil, seed: seed, skipped: _List_Nil};
};
var $elm_explorations$test$Test$Runner$fnvHash = F2(
	function (a, b) {
		return ((a ^ b) * 16777619) >>> 0;
	});
var $elm_explorations$test$Test$Runner$fnvHashString = F2(
	function (hash, str) {
		return A3(
			$elm$core$List$foldl,
			$elm_explorations$test$Test$Runner$fnvHash,
			hash,
			A2(
				$elm$core$List$map,
				$elm$core$Char$toCode,
				$elm$core$String$toList(str)));
	});
var $elm_explorations$test$Test$Runner$fnvInit = 2166136261;
var $elm$random$Random$Generator = function (a) {
	return {$: 'Generator', a: a};
};
var $elm$random$Random$Seed = F2(
	function (a, b) {
		return {$: 'Seed', a: a, b: b};
	});
var $elm$random$Random$next = function (_v0) {
	var state0 = _v0.a;
	var incr = _v0.b;
	return A2($elm$random$Random$Seed, ((state0 * 1664525) + incr) >>> 0, incr);
};
var $elm$random$Random$peel = function (_v0) {
	var state = _v0.a;
	var word = (state ^ (state >>> ((state >>> 28) + 4))) * 277803737;
	return ((word >>> 22) ^ word) >>> 0;
};
var $elm$random$Random$int = F2(
	function (a, b) {
		return $elm$random$Random$Generator(
			function (seed0) {
				var _v0 = (_Utils_cmp(a, b) < 0) ? _Utils_Tuple2(a, b) : _Utils_Tuple2(b, a);
				var lo = _v0.a;
				var hi = _v0.b;
				var range = (hi - lo) + 1;
				if (!((range - 1) & range)) {
					return _Utils_Tuple2(
						(((range - 1) & $elm$random$Random$peel(seed0)) >>> 0) + lo,
						$elm$random$Random$next(seed0));
				} else {
					var threshhold = (((-range) >>> 0) % range) >>> 0;
					var accountForBias = function (seed) {
						accountForBias:
						while (true) {
							var x = $elm$random$Random$peel(seed);
							var seedN = $elm$random$Random$next(seed);
							if (_Utils_cmp(x, threshhold) < 0) {
								var $temp$seed = seedN;
								seed = $temp$seed;
								continue accountForBias;
							} else {
								return _Utils_Tuple2((x % range) + lo, seedN);
							}
						}
					};
					return accountForBias(seed0);
				}
			});
	});
var $elm$random$Random$map3 = F4(
	function (func, _v0, _v1, _v2) {
		var genA = _v0.a;
		var genB = _v1.a;
		var genC = _v2.a;
		return $elm$random$Random$Generator(
			function (seed0) {
				var _v3 = genA(seed0);
				var a = _v3.a;
				var seed1 = _v3.b;
				var _v4 = genB(seed1);
				var b = _v4.a;
				var seed2 = _v4.b;
				var _v5 = genC(seed2);
				var c = _v5.a;
				var seed3 = _v5.b;
				return _Utils_Tuple2(
					A3(func, a, b, c),
					seed3);
			});
	});
var $elm$random$Random$step = F2(
	function (_v0, seed) {
		var generator = _v0.a;
		return generator(seed);
	});
var $elm$random$Random$independentSeed = $elm$random$Random$Generator(
	function (seed0) {
		var makeIndependentSeed = F3(
			function (state, b, c) {
				return $elm$random$Random$next(
					A2($elm$random$Random$Seed, state, (1 | (b ^ c)) >>> 0));
			});
		var gen = A2($elm$random$Random$int, 0, 4294967295);
		return A2(
			$elm$random$Random$step,
			A4($elm$random$Random$map3, makeIndependentSeed, gen, gen, gen),
			seed0);
	});
var $elm$random$Random$initialSeed = function (x) {
	var _v0 = $elm$random$Random$next(
		A2($elm$random$Random$Seed, 0, 1013904223));
	var state1 = _v0.a;
	var incr = _v0.b;
	var state2 = (state1 + x) >>> 0;
	return $elm$random$Random$next(
		A2($elm$random$Random$Seed, state2, incr));
};
var $elm$random$Random$maxInt = 2147483647;
var $elm_explorations$test$Test$Runner$batchDistribute = F4(
	function (hashed, runs, test, prev) {
		var next = A4($elm_explorations$test$Test$Runner$distributeSeedsHelp, hashed, runs, prev.seed, test);
		return {
			all: _Utils_ap(prev.all, next.all),
			only: _Utils_ap(prev.only, next.only),
			seed: next.seed,
			skipped: _Utils_ap(prev.skipped, next.skipped)
		};
	});
var $elm_explorations$test$Test$Runner$distributeSeedsHelp = F4(
	function (hashed, runs, seed, test) {
		switch (test.$) {
			case 'ElmTestVariant__UnitTest':
				var aRun = test.a;
				return {
					all: _List_fromArray(
						[
							$elm_explorations$test$Test$Runner$Runnable(
							$elm_explorations$test$Test$Runner$Thunk(
								function (_v1) {
									return aRun(_Utils_Tuple0);
								}))
						]),
					only: _List_Nil,
					seed: seed,
					skipped: _List_Nil
				};
			case 'ElmTestVariant__FuzzTest':
				var aRun = test.a;
				var _v2 = A2($elm$random$Random$step, $elm$random$Random$independentSeed, seed);
				var firstSeed = _v2.a;
				var nextSeed = _v2.b;
				return {
					all: _List_fromArray(
						[
							$elm_explorations$test$Test$Runner$Runnable(
							$elm_explorations$test$Test$Runner$Thunk(
								function (_v3) {
									return A2(aRun, firstSeed, runs);
								}))
						]),
					only: _List_Nil,
					seed: nextSeed,
					skipped: _List_Nil
				};
			case 'ElmTestVariant__Labeled':
				var description = test.a;
				var subTest = test.b;
				if (hashed) {
					var next = A4($elm_explorations$test$Test$Runner$distributeSeedsHelp, true, runs, seed, subTest);
					return {
						all: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.all),
						only: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.only),
						seed: next.seed,
						skipped: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.skipped)
					};
				} else {
					var intFromSeed = A2(
						$elm$random$Random$step,
						A2($elm$random$Random$int, 0, $elm$random$Random$maxInt),
						seed).a;
					var hashedSeed = $elm$random$Random$initialSeed(
						A2(
							$elm_explorations$test$Test$Runner$fnvHash,
							intFromSeed,
							A2($elm_explorations$test$Test$Runner$fnvHashString, $elm_explorations$test$Test$Runner$fnvInit, description)));
					var next = A4($elm_explorations$test$Test$Runner$distributeSeedsHelp, true, runs, hashedSeed, subTest);
					return {
						all: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.all),
						only: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.only),
						seed: seed,
						skipped: A2(
							$elm$core$List$map,
							$elm_explorations$test$Test$Runner$Labeled(description),
							next.skipped)
					};
				}
			case 'ElmTestVariant__Skipped':
				var subTest = test.a;
				var next = A4($elm_explorations$test$Test$Runner$distributeSeedsHelp, hashed, runs, seed, subTest);
				return {all: _List_Nil, only: _List_Nil, seed: next.seed, skipped: next.all};
			case 'ElmTestVariant__Only':
				var subTest = test.a;
				var next = A4($elm_explorations$test$Test$Runner$distributeSeedsHelp, hashed, runs, seed, subTest);
				return _Utils_update(
					next,
					{only: next.all});
			default:
				var tests = test.a;
				return A3(
					$elm$core$List$foldl,
					A2($elm_explorations$test$Test$Runner$batchDistribute, hashed, runs),
					$elm_explorations$test$Test$Runner$emptyDistribution(seed),
					tests);
		}
	});
var $elm_explorations$test$Test$Runner$distributeSeeds = $elm_explorations$test$Test$Runner$distributeSeedsHelp(false);
var $elm_explorations$test$Test$Runner$runThunk = _Test_runThunk;
var $elm_explorations$test$Test$Runner$run = function (_v0) {
	var fn = _v0.a;
	var _v1 = $elm_explorations$test$Test$Runner$runThunk(fn);
	if (_v1.$ === 'Ok') {
		var test = _v1.a;
		return test;
	} else {
		var message = _v1.a;
		return _List_fromArray(
			[
				$elm_explorations$test$Expect$fail('This test failed because it threw an exception: \"' + (message + '\"'))
			]);
	}
};
var $elm_explorations$test$Test$Runner$fromRunnableTreeHelp = F2(
	function (labels, runner) {
		fromRunnableTreeHelp:
		while (true) {
			if (runner.$ === 'Runnable') {
				var runnable = runner.a;
				return _List_fromArray(
					[
						{
						labels: labels,
						run: function (_v1) {
							return $elm_explorations$test$Test$Runner$run(runnable);
						}
					}
					]);
			} else {
				var label = runner.a;
				var subRunner = runner.b;
				var $temp$labels = A2($elm$core$List$cons, label, labels),
					$temp$runner = subRunner;
				labels = $temp$labels;
				runner = $temp$runner;
				continue fromRunnableTreeHelp;
			}
		}
	});
var $elm_explorations$test$Test$Runner$fromRunnableTree = $elm_explorations$test$Test$Runner$fromRunnableTreeHelp(_List_Nil);
var $elm_explorations$test$Test$Runner$fromTest = F3(
	function (runs, seed, test) {
		if (runs < 1) {
			return $elm_explorations$test$Test$Runner$Invalid(
				'Test runner run count must be at least 1, not ' + $elm$core$String$fromInt(runs));
		} else {
			var distribution = A3($elm_explorations$test$Test$Runner$distributeSeeds, runs, seed, test);
			return $elm$core$List$isEmpty(distribution.only) ? ((!$elm_explorations$test$Test$Runner$countAllRunnables(distribution.skipped)) ? $elm_explorations$test$Test$Runner$Plain(
				A2($elm$core$List$concatMap, $elm_explorations$test$Test$Runner$fromRunnableTree, distribution.all)) : $elm_explorations$test$Test$Runner$Skipping(
				A2($elm$core$List$concatMap, $elm_explorations$test$Test$Runner$fromRunnableTree, distribution.all))) : $elm_explorations$test$Test$Runner$Only(
				A2($elm$core$List$concatMap, $elm_explorations$test$Test$Runner$fromRunnableTree, distribution.only));
		}
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$fromTest = F2(
	function (masterTest, _v0) {
		var initialSeed = _v0.initialSeed;
		var fuzzRuns = _v0.fuzzRuns;
		var filter = _v0.filter;
		var _v1 = A3(
			$elm_explorations$test$Test$Runner$fromTest,
			fuzzRuns,
			$elm$random$Random$initialSeed(initialSeed),
			masterTest);
		switch (_v1.$) {
			case 'Plain':
				var runnerList = _v1.a;
				return $elm$core$Result$Ok(
					{
						kind: $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Plain,
						runners: $elm$core$Array$fromList(
							A2($mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$filterRunners, filter, runnerList))
					});
			case 'Only':
				var runnerList = _v1.a;
				return $elm$core$Result$Ok(
					{
						kind: $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Only,
						runners: $elm$core$Array$fromList(runnerList)
					});
			case 'Skipping':
				var runnerList = _v1.a;
				return $elm$core$Result$Ok(
					{
						kind: $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$Skipping,
						runners: $elm$core$Array$fromList(
							A2($mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$filterRunners, filter, runnerList))
					});
			default:
				var error = _v1.a;
				return $elm$core$Result$Err(error);
		}
	});
var $elm$core$Platform$Cmd$batch = _Platform_batch;
var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$init = F3(
	function (maybeConcatenatedTest, ports, flags) {
		if (maybeConcatenatedTest.$ === 'Nothing') {
			return _Utils_Tuple2(
				A2($mpizenberg$elm_test_runner$ElmTestRunner$Runner$Model, ports, $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$empty),
				$elm$core$Platform$Cmd$none);
		} else {
			var concatenatedTest = maybeConcatenatedTest.a;
			return _Utils_Tuple2(
				A2(
					$mpizenberg$elm_test_runner$ElmTestRunner$Runner$Model,
					ports,
					A2($mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$fromTest, concatenatedTest, flags)),
				$elm$core$Platform$Cmd$none);
		}
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$kindToString = function (kind) {
	switch (kind.$) {
		case 'Plain':
			return 'Plain';
		case 'Only':
			return 'Only';
		default:
			return 'Skipping';
	}
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$Failed = function (a) {
	return {$: 'Failed', a: a};
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$Passed = function (a) {
	return {$: 'Passed', a: a};
};
var $elm_explorations$test$Test$Runner$getDistributionReport = function (expectation) {
	if (expectation.$ === 'Pass') {
		var distributionReport = expectation.a.distributionReport;
		return distributionReport;
	} else {
		var distributionReport = expectation.a.distributionReport;
		return distributionReport;
	}
};
var $elm_explorations$test$Test$Runner$getFailureReason = function (expectation) {
	if (expectation.$ === 'Pass') {
		return $elm$core$Maybe$Nothing;
	} else {
		var record = expectation.a;
		return $elm$core$Maybe$Just(
			{description: record.description, given: record.given, reason: record.reason});
	}
};
var $elm_explorations$test$Test$Runner$Failure$TODO = {$: 'TODO'};
var $elm_explorations$test$Test$Runner$isTodo = function (expectation) {
	if (expectation.$ === 'Pass') {
		return false;
	} else {
		var reason = expectation.a.reason;
		return _Utils_eq(reason, $elm_explorations$test$Test$Runner$Failure$TODO);
	}
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$accumOutcomes = F2(
	function (expectation, outcomes) {
		var distributionReport = $elm_explorations$test$Test$Runner$getDistributionReport(expectation);
		var _v0 = $elm_explorations$test$Test$Runner$getFailureReason(expectation);
		if (_v0.$ === 'Nothing') {
			return _Utils_update(
				outcomes,
				{
					distributionReports: A2($elm$core$List$cons, distributionReport, outcomes.distributionReports)
				});
		} else {
			var failure = _v0.a;
			return $elm_explorations$test$Test$Runner$isTodo(expectation) ? _Utils_update(
				outcomes,
				{
					todos: A2($elm$core$List$cons, failure.description, outcomes.todos)
				}) : _Utils_update(
				outcomes,
				{
					distributionReports: A2($elm$core$List$cons, distributionReport, outcomes.distributionReports),
					failures: A2($elm$core$List$cons, failure, outcomes.failures)
				});
		}
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$initOutcomes = {distributionReports: _List_Nil, failures: _List_Nil, todos: _List_Nil};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$getOutcomes = function (expectations) {
	return A3($elm$core$List$foldl, $mpizenberg$elm_test_runner$ElmTestRunner$Result$accumOutcomes, $mpizenberg$elm_test_runner$ElmTestRunner$Result$initOutcomes, expectations);
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$fromExpectations = F2(
	function (labels, expectations) {
		var outcomes = $mpizenberg$elm_test_runner$ElmTestRunner$Result$getOutcomes(expectations);
		return ($elm$core$List$isEmpty(outcomes.todos) && $elm$core$List$isEmpty(outcomes.failures)) ? $mpizenberg$elm_test_runner$ElmTestRunner$Result$Passed(
			{distributionReports: outcomes.distributionReports, duration: 0, labels: labels, logs: _List_Nil}) : $mpizenberg$elm_test_runner$ElmTestRunner$Result$Failed(
			{distributionReports: outcomes.distributionReports, duration: 0, failures: outcomes.failures, labels: labels, logs: _List_Nil, todos: outcomes.todos});
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$run = F2(
	function (id, runners) {
		return A2(
			$elm$core$Maybe$map,
			function (result) {
				return A2($mpizenberg$elm_test_runner$ElmTestRunner$Result$fromExpectations, result.labels, result.expectations);
			},
			A2(
				$elm$core$Maybe$map,
				function (runner) {
					return {
						expectations: runner.run(_Utils_Tuple0),
						labels: runner.labels
					};
				},
				A2($elm$core$Array$get, id, runners)));
	});
var $elm$json$Json$Encode$list = F2(
	function (func, entries) {
		return _Json_wrap(
			A3(
				$elm$core$List$foldl,
				_Json_addEntry(func),
				_Json_emptyArray(_Utils_Tuple0),
				entries));
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDict_ListString_Int = function (a) {
	var encodeDict_ListString_IntTuple = function (_v0) {
		var a1 = _v0.a;
		var a2 = _v0.b;
		return $elm$json$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'A1',
					A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a1)),
					_Utils_Tuple2(
					'A2',
					$elm$json$Json$Encode$int(a2))
				]));
	};
	return A2(
		$elm$json$Json$Encode$list,
		encodeDict_ListString_IntTuple,
		$elm$core$Dict$toList(a));
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_distributionCount_Dict_ListString_Int_runsElapsed_Int_ = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'distributionCount',
				$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDict_ListString_Int(a.distributionCount)),
				_Utils_Tuple2(
				'runsElapsed',
				$elm$json$Json$Encode$int(a.runsElapsed))
			]));
};
var $elm$json$Json$Encode$float = _Json_wrap;
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_distributionCount_Dict_ListString_Int_runsElapsed_Int_badLabel_String_badLabelPercentage_Float_expectedDistribution_String_ = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'distributionCount',
				$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDict_ListString_Int(a.distributionCount)),
				_Utils_Tuple2(
				'runsElapsed',
				$elm$json$Json$Encode$int(a.runsElapsed)),
				_Utils_Tuple2(
				'badLabel',
				$elm$json$Json$Encode$string(a.badLabel)),
				_Utils_Tuple2(
				'badLabelPercentage',
				$elm$json$Json$Encode$float(a.badLabelPercentage)),
				_Utils_Tuple2(
				'expectedDistribution',
				$elm$json$Json$Encode$string(a.expectedDistribution))
			]));
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDistributionReport = function (a) {
	switch (a.$) {
		case 'NoDistribution':
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('NoDistribution'))
					]));
		case 'DistributionToReport':
			var a1 = a.a;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('DistributionToReport')),
						_Utils_Tuple2(
						'A1',
						$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_distributionCount_Dict_ListString_Int_runsElapsed_Int_(a1))
					]));
		case 'DistributionCheckSucceeded':
			var a1 = a.a;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('DistributionCheckSucceeded')),
						_Utils_Tuple2(
						'A1',
						$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_distributionCount_Dict_ListString_Int_runsElapsed_Int_(a1))
					]));
		default:
			var a1 = a.a;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('DistributionCheckFailed')),
						_Utils_Tuple2(
						'A1',
						$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_distributionCount_Dict_ListString_Int_runsElapsed_Int_badLabel_String_badLabelPercentage_Float_expectedDistribution_String_(a1))
					]));
	}
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_labels_ListString_duration_Float_logs_ListString_distributionReports_ListDistributionReport_ = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'labels',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.labels)),
				_Utils_Tuple2(
				'duration',
				$elm$json$Json$Encode$float(a.duration)),
				_Utils_Tuple2(
				'logs',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.logs)),
				_Utils_Tuple2(
				'distributionReports',
				A2($elm$json$Json$Encode$list, $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDistributionReport, a.distributionReports))
			]));
};
var $elm$json$Json$Encode$null = _Json_encodeNull;
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeMaybe = F2(
	function (f, a) {
		if (a.$ === 'Just') {
			var b = a.a;
			return f(b);
		} else {
			return $elm$json$Json$Encode$null;
		}
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeInvalidReason = function (a) {
	return $elm$json$Json$Encode$string(
		function () {
			switch (a.$) {
				case 'EmptyList':
					return 'EmptyList';
				case 'NonpositiveFuzzCount':
					return 'NonpositiveFuzzCount';
				case 'InvalidFuzzer':
					return 'InvalidFuzzer';
				case 'BadDescription':
					return 'BadDescription';
				case 'DuplicatedName':
					return 'DuplicatedName';
				case 'DistributionInsufficient':
					return 'DistributionInsufficient';
				default:
					return 'DistributionBug';
			}
		}());
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeRecord_expected_String_actual_String_extra_ListString_missing_ListString_ = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'expected',
				$elm$json$Json$Encode$string(a.expected)),
				_Utils_Tuple2(
				'actual',
				$elm$json$Json$Encode$string(a.actual)),
				_Utils_Tuple2(
				'extra',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.extra)),
				_Utils_Tuple2(
				'missing',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.missing))
			]));
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeReason = function (a) {
	switch (a.$) {
		case 'Custom':
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('Custom'))
					]));
		case 'Equality':
			var a1 = a.a;
			var a2 = a.b;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('Equality')),
						_Utils_Tuple2(
						'A1',
						$elm$json$Json$Encode$string(a1)),
						_Utils_Tuple2(
						'A2',
						$elm$json$Json$Encode$string(a2))
					]));
		case 'Comparison':
			var a1 = a.a;
			var a2 = a.b;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('Comparison')),
						_Utils_Tuple2(
						'A1',
						$elm$json$Json$Encode$string(a1)),
						_Utils_Tuple2(
						'A2',
						$elm$json$Json$Encode$string(a2))
					]));
		case 'ListDiff':
			var a1 = a.a;
			var a2 = a.b;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('ListDiff')),
						_Utils_Tuple2(
						'A1',
						A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a1)),
						_Utils_Tuple2(
						'A2',
						A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a2))
					]));
		case 'CollectionDiff':
			var a1 = a.a;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('CollectionDiff')),
						_Utils_Tuple2(
						'A1',
						$mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeRecord_expected_String_actual_String_extra_ListString_missing_ListString_(a1))
					]));
		case 'TODO':
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('TODO'))
					]));
		default:
			var a1 = a.a;
			return $elm$json$Json$Encode$object(
				_List_fromArray(
					[
						_Utils_Tuple2(
						'Constructor',
						$elm$json$Json$Encode$string('Invalid')),
						_Utils_Tuple2(
						'A1',
						$mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeInvalidReason(a1))
					]));
	}
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeFailure = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'given',
				A2($mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeMaybe, $elm$json$Json$Encode$string, a.given)),
				_Utils_Tuple2(
				'description',
				$elm$json$Json$Encode$string(a.description)),
				_Utils_Tuple2(
				'reason',
				$mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeReason(a.reason))
			]));
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encode = $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encodeFailure;
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeFailure = $mpizenberg$elm_test_runner$ElmTestRunner$Failure$encode;
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_labels_ListString_duration_Float_logs_ListString_todos_ListString_failures_ListFailure_distributionReports_ListDistributionReport_ = function (a) {
	return $elm$json$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'labels',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.labels)),
				_Utils_Tuple2(
				'duration',
				$elm$json$Json$Encode$float(a.duration)),
				_Utils_Tuple2(
				'logs',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.logs)),
				_Utils_Tuple2(
				'todos',
				A2($elm$json$Json$Encode$list, $elm$json$Json$Encode$string, a.todos)),
				_Utils_Tuple2(
				'failures',
				A2($elm$json$Json$Encode$list, $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeFailure, a.failures)),
				_Utils_Tuple2(
				'distributionReports',
				A2($elm$json$Json$Encode$list, $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeDistributionReport, a.distributionReports))
			]));
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeTestResult = function (a) {
	if (a.$ === 'Passed') {
		var a1 = a.a;
		return $elm$json$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'Constructor',
					$elm$json$Json$Encode$string('Passed')),
					_Utils_Tuple2(
					'A1',
					$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_labels_ListString_duration_Float_logs_ListString_distributionReports_ListDistributionReport_(a1))
				]));
	} else {
		var a1 = a.a;
		return $elm$json$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'Constructor',
					$elm$json$Json$Encode$string('Failed')),
					_Utils_Tuple2(
					'A1',
					$mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeRecord_labels_ListString_duration_Float_logs_ListString_todos_ListString_failures_ListFailure_distributionReports_ListDistributionReport_(a1))
				]));
	}
};
var $mpizenberg$elm_test_runner$ElmTestRunner$Result$encode = $mpizenberg$elm_test_runner$ElmTestRunner$Result$encodeTestResult;
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$sendTestResult = F3(
	function (ports, id, maybeResult) {
		return A2(
			$elm$core$Maybe$withDefault,
			$elm$core$Platform$Cmd$none,
			A2(
				$elm$core$Maybe$map,
				function (res) {
					return ports.sendResult(
						{id: id, result: res});
				},
				A2($elm$core$Maybe$map, $mpizenberg$elm_test_runner$ElmTestRunner$Result$encode, maybeResult)));
	});
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$update = F2(
	function (msg, model) {
		var _v0 = _Utils_Tuple2(msg, model.testRunners);
		if (_v0.a.$ === 'AskTestsCount') {
			if (_v0.b.$ === 'Ok') {
				var _v1 = _v0.a;
				var kind = _v0.b.a.kind;
				var runners = _v0.b.a.runners;
				return _Utils_Tuple2(
					model,
					model.ports.sendTestsCount(
						{
							kind: $mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$kindToString(kind),
							testsCount: $elm$core$Array$length(runners)
						}));
			} else {
				var _v2 = _v0.a;
				var err = _v0.b.a;
				return _Utils_Tuple2(
					model,
					model.ports.sendTestsCount(
						{kind: 'Invalid' + err, testsCount: 0}));
			}
		} else {
			if (_v0.b.$ === 'Ok') {
				var id = _v0.a.a;
				var runners = _v0.b.a.runners;
				return _Utils_Tuple2(
					model,
					A3(
						$mpizenberg$elm_test_runner$ElmTestRunner$Runner$sendTestResult,
						model.ports,
						id,
						A2($mpizenberg$elm_test_runner$ElmTestRunner$SeededRunners$run, id, runners)));
			} else {
				return _Utils_Tuple2(
					model,
					_Debug_todo(
						'ElmTestRunner.Runner',
						{
							start: {line: 155, column: 22},
							end: {line: 155, column: 32}
						})('There is no test to run, how did we get here?'));
			}
		}
	});
var $elm$core$Platform$worker = _Platform_worker;
var $mpizenberg$elm_test_runner$ElmTestRunner$Runner$worker = F2(
	function (ports, masterTest) {
		var askTestsCount = ports.askTestsCount;
		var receiveRunTest = ports.receiveRunTest;
		return $elm$core$Platform$worker(
			{
				init: A2($mpizenberg$elm_test_runner$ElmTestRunner$Runner$init, masterTest, ports),
				subscriptions: function (_v0) {
					return $elm$core$Platform$Sub$batch(
						_List_fromArray(
							[
								askTestsCount(
								$elm$core$Basics$always($mpizenberg$elm_test_runner$ElmTestRunner$Runner$AskTestsCount)),
								receiveRunTest($mpizenberg$elm_test_runner$ElmTestRunner$Runner$ReceiveRunTest)
							]));
				},
				update: $mpizenberg$elm_test_runner$ElmTestRunner$Runner$update
			});
	});
var $author$project$Runner$main = function () {
	var concatenatedTest = function () {
		var _v0 = $author$project$Runner$tests;
		if (!_v0.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			return $elm$core$Maybe$Just(
				$elm_explorations$test$Test$concat($author$project$Runner$tests));
		}
	}();
	return A2(
		$mpizenberg$elm_test_runner$ElmTestRunner$Runner$worker,
		{askTestsCount: $author$project$Runner$askTestsCount, receiveRunTest: $author$project$Runner$receiveRunTest, sendResult: $author$project$Runner$sendResult, sendTestsCount: $author$project$Runner$sendTestsCount},
		concatenatedTest);
}();
_Platform_export({'Runner':{'init':$author$project$Runner$main(
	A2(
		$elm$json$Json$Decode$andThen,
		function (initialSeed) {
			return A2(
				$elm$json$Json$Decode$andThen,
				function (fuzzRuns) {
					return A2(
						$elm$json$Json$Decode$andThen,
						function (filter) {
							return $elm$json$Json$Decode$succeed(
								{filter: filter, fuzzRuns: fuzzRuns, initialSeed: initialSeed});
						},
						A2(
							$elm$json$Json$Decode$field,
							'filter',
							$elm$json$Json$Decode$oneOf(
								_List_fromArray(
									[
										$elm$json$Json$Decode$null($elm$core$Maybe$Nothing),
										A2($elm$json$Json$Decode$map, $elm$core$Maybe$Just, $elm$json$Json$Decode$string)
									]))));
				},
				A2($elm$json$Json$Decode$field, 'fuzzRuns', $elm$json$Json$Decode$int));
		},
		A2($elm$json$Json$Decode$field, 'initialSeed', $elm$json$Json$Decode$int)))(0)}});}(this));