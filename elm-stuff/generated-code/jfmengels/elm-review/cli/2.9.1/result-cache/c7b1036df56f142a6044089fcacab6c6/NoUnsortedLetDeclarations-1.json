{"aR":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b7":3530670207,"ce":0}},"c_":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b7":3530670207,"ce":0}},"ew":{"$":1},"b1":{"$":1},"I":{"$":-1,"a":1,"b":"src/Util.elm","c":{"bT":2652841245,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":46,"bp":334},"cj":{"bb":25,"bp":332}},"b":"( lowestPriorityEdges, higherPriorityEdges ) =\n                            -- Get all edges\n                            Graph.edges graph\n                                -- Group them by priority\n                                |> DictX.groupBy .label\n                                |> Dict.values\n                                -- Select lowest priority edges\n                                |> ListX.unconsLast\n                                |> Maybe.withDefault ( [], [] )\n                                |> Tuple.mapBoth\n                                    (List.map (\\{ from, to } -> ( from, to ))\n                                        >> Set.fromList\n                                    )\n                                    List.concat"},{"$":1,"a":{"bV":{"bb":48,"bp":349},"cj":{"bb":25,"bp":336}},"b":"ns : List (Graph.Node a)\n                        ns =\n                            Graph.nodes graph"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":24,"bp":331},"cj":{"bb":21,"bp":331}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":130,"bp":462},"cj":{"bb":9,"bp":450}},"b":"glueLevel : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> List (List (NodeContext { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } Int)) -> List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n        glueLevel sorted glued =\n            case glued of\n                [] ->\n                    sorted\n\n                g :: gs ->\n                    let\n                        asList : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n                        asList =\n                            List.map .node g\n                                |> sort\n                    in\n                    (if List.isEmpty sorted then\n                        -- Initial unglued items\n                        asList\n\n                     else\n                        -- Glue items\n                        List.partition (MaybeX.unwrap False isGluedToFirst << .glued << .label) asList\n                            |> (\\( toFirst, toLast ) ->\n                                    List.foldl\n                                        (\\d { toGlue, inserted } ->\n                                            insertGlued toGlue d\n                                                |> (\\r -> { r | inserted = inserted ++ r.inserted })\n                                        )\n                                        { toGlue = toFirst, inserted = [] }\n                                        sorted\n                                        |> .inserted\n                                        |> List.foldr\n                                            (\\d { toGlue, inserted } ->\n                                                insertGlued toGlue d\n                                                    |> (\\r -> { r | inserted = r.inserted ++ inserted })\n                                            )\n                                            { toGlue = toLast, inserted = [] }\n                                        |> .inserted\n                               )\n                    )\n                        |> (\\sorted_ -> glueLevel sorted_ gs)"},{"$":1,"a":{"bV":{"bb":18,"bp":475},"cj":{"bb":9,"bp":468}},"b":"insertGlued : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } -> { toGlue : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }), inserted : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) }\n        insertGlued glued ({ label } as dec) =\n            -- Keep only glued that are glued to this name\n            List.partition\n                (.label\n                    >> .glued\n                    >> MaybeX.unwrap False (not << Set.isEmpty << Set.intersect label.namesBound << gluedTo)\n                )\n                glued\n                -- Split into glued before and after\n                |> Tuple.mapFirst (List.partition (MaybeX.unwrap False isGluedBefore << .glued << .label))\n                -- Flatten\n                |> (\\( ( gluedBefore, gluedAfter ), toGlue ) -> { toGlue = toGlue, inserted = gluedBefore ++ dec :: gluedAfter })"},{"$":1,"a":{"bV":{"bb":62,"bp":515},"cj":{"bb":9,"bp":477}},"b":"sort : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n        sort =\n            List.sortWith\n                (\\d1 d2 ->\n                    -- Sort stably\n                    (\\() -> compare d1.id d2.id)\n                        |> fallbackCompareFor (compareByOrderings orderings d1.label d2.label)\n                )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":449},"cj":{"bb":5,"bp":449}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":33,"bp":600},"cj":{"bb":9,"bp":597}},"b":"edges : List (Edge Int)\n        edges =\n            -- There can be duplicate edges, but that is fine, since the graph only keeps one\n            List.concatMap\n                (\\{ id, label } ->\n                    MaybeX.unwrap [] (Set.toList << gluedTo) label.glued\n                        |> List.filterMap\n                            (\\n ->\n                                Dict.get n namesToNodeId\n                                    |> Maybe.map (\\from -> { from = from, to = id, label = 0 })\n                            )\n                )\n                ds"},{"$":1,"a":{"bV":{"bb":19,"bp":614},"cj":{"bb":9,"bp":602}},"b":"namesToNodeId : Dict String Int\n        namesToNodeId =\n            List.concatMap (\\{ id, label } -> List.map (\\n -> ( n, id )) <| Set.toList label.namesBound) ds\n                |> Dict.fromList"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":596},"cj":{"bb":5,"bp":596}},"d_":"NoUnsortedLetDeclarations","ff":0}]},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-1,"a":1,"b":"src/NoUnsortedRecords.elm","c":{"bT":208393452,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":39,"bp":929},"cj":{"bb":17,"bp":885}},"b":"functionFromOperator : Elm.Docs.Binop -> ( String, Type )\n                functionFromOperator { name, tipe } =\n                    docTypeToType moduleName\n                        { constrainedTypeVarsAreRespected = True\n                        , subrecordIsAlsoCanonical = Nothing\n                        }\n                        tipe\n                        |> Tuple.pair name"},{"$":1,"a":{"bV":{"bb":22,"bp":941},"cj":{"bb":17,"bp":931}},"b":"functionFromValue : Elm.Docs.Value -> ( String, Type )\n                functionFromValue { name, tipe } =\n                    docTypeToType moduleName\n                        { constrainedTypeVarsAreRespected = True\n                        , subrecordIsAlsoCanonical = Nothing\n                        }\n                        tipe\n                        |> Tuple.pair name"},{"$":1,"a":{"bV":{"bb":29,"bp":961},"cj":{"bb":17,"bp":943}},"b":"functionsFromCustomType : Elm.Docs.Union -> ( List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } ), List ( String, KnownRecord ) )\n                functionsFromCustomType { name, args, tags } =\n                    List.foldl\n                        (\\t ( fAcc, rAcc ) ->\n                            makeConstructor\n                                (List.map (TypeVar Nothing) args\n                                    |> NamedType ( moduleName, name )\n                                    |> DereferencedType\n                                    |> assignTypeVars (makePositionalArgTypeVars args)\n                                    |> getType\n                                    |> TypeWithPositionalVars\n                                )\n                                args\n                                t\n                                |> (\\( n, type_, rs ) ->\n                                        ( ( n, { customTypeName = Just name, type_ = type_ } ) :: fAcc\n                                        , rs ++ rAcc\n                                        )\n                                   )\n                        )\n                        ( [], [] )\n                        tags"},{"$":1,"a":{"bV":{"bb":29,"bp":984},"cj":{"bb":17,"bp":963}},"b":"makeAlias : Elm.Docs.Alias -> ( String, TypeWithPositionalVars )\n                makeAlias { name, args, tipe } =\n                    ( name\n                    , docTypeToTypeWithPositionalVars moduleName\n                        -- Constrained type vars aren't respected for type aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        args\n                        tipe\n                    )"},{"$":1,"a":{"bV":{"bb":43,"bp":993},"cj":{"bb":17,"bp":986}},"b":"makeConstructor : TypeWithPositionalVars -> List String -> ( String, List Elm.Type.Type ) -> ( String, TypeWithPositionalVars, List ( String, KnownRecord ) )\n                makeConstructor return typeVars ( name, arguments ) =\n                    List.map\n                        (docTypeToTypeWithPositionalVars moduleName\n                            { constrainedTypeVarsAreRespected = True\n\n                            -- Arguments only have order if config says so\n                            , subrecordIsAlsoCanonical =\n                                subrecordCanonicityForField subrecordTreatment\n                            }\n                            typeVars\n                        )\n                        arguments\n                        |> (\\ts ->\n                                ( name\n                                , makeFunctionTypeWithPositionalVars return ts\n                                , makeCustomTypeSubrecords subrecordTreatment name ts\n                                )\n                           )"},{"$":1,"a":{"bV":{"bb":43,"bp":1002},"cj":{"bb":17,"bp":995}},"b":"moduleName : ModuleName\n                moduleName =\n                    String.split \".\" mod.name"},{"$":1,"a":{"bV":{"bb":46,"bp":1006},"cj":{"bb":17,"bp":1004}},"b":"( newAliasRecords, newRecordConstructors ) =\n                    List.map recordFromTypeAlias aliases\n                        |> List.unzip\n                        |> Tuple.mapBoth (Dict.fromList << List.concat) (Dict.fromList << List.concat)"},{"$":1,"a":{"bV":{"bb":103,"bp":1018},"cj":{"bb":17,"bp":1015}},"b":"( newConstructors, newRecords ) =\n                    List.foldl\n                        (\\u ( fAcc, rAcc ) ->\n                            functionsFromCustomType u\n                                |> (\\( fs, rs ) -> ( fs ++ fAcc, rs ++ rAcc ))\n                        )\n                        ( [], [] )\n                        unions\n                        |> Tuple.mapBoth\n                            (Dict.fromList\n                                >> Dict.union newRecordConstructors\n                                >> validate (not << Dict.isEmpty)\n                                >> Maybe.map (Tuple.pair moduleName)\n                            )\n                            (Dict.fromList\n                                >> Dict.union newAliasRecords\n                                >> validate (not << Dict.isEmpty)\n                                >> Maybe.map (Tuple.pair moduleName)\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":1038},"cj":{"bb":17,"bp":1020}},"b":"newFunctions : Maybe ( ModuleName, Dict String Type )\n                newFunctions =\n                    List.map functionFromValue values\n                        |> Dict.fromList\n                        |> Dict.union newOperators\n                        |> validate (not << Dict.isEmpty)\n                        |> Maybe.map (Tuple.pair moduleName)"},{"$":1,"a":{"bV":{"bb":61,"bp":1051},"cj":{"bb":17,"bp":1045}},"b":"recordFromTypeAlias : Elm.Docs.Alias -> ( List ( String, KnownRecord ), List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } ) )\n                recordFromTypeAlias { name, args, tipe } =\n                    case tipe of\n                        Elm.Type.Record fields Nothing ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, False )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , [ ( name\n                                , { customTypeName = Nothing\n                                  , type_ =\n                                        List.map\n                                            (Tuple.second\n                                                >> docTypeToTypeWithPositionalVars moduleName\n                                                    -- Constrained type vars do apply to record constructors\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Arguments only have order if config says so\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                    }\n                                                    args\n                                            )\n                                            fields\n                                            |> makeFunctionTypeWithPositionalVars\n                                                (docTypeToTypeWithPositionalVars moduleName\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Return type *does* have order\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                    }\n                                                    args\n                                                    tipe\n                                                )\n                                  }\n                                )\n                              ]\n                            )\n\n                        Elm.Type.Record fields (Just _) ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, True )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , -- No constructors for generic records\n                              []\n                            )\n\n                        _ ->\n                            ( [], [] )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":16,"bp":884},"cj":{"bb":13,"bp":884}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":36,"bp":1597},"cj":{"bb":17,"bp":1595}},"b":"aliasInfo : ( String, TypeWithPositionalVars )\n                aliasInfo =\n                    ( n\n                    , typeAnnotToTypeWithPositionalVars context\n                        -- Constrained type vars are not respected for aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        (List.map Node.value generics)\n                        typeAnnotation\n                    )"},{"$":1,"a":{"bV":{"bb":22,"bp":1609},"cj":{"bb":17,"bp":1599}},"b":"n : String\n                n =\n                    Node.value name"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":16,"bp":1594},"cj":{"bb":13,"bp":1594}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":47,"bp":2177},"cj":{"bb":9,"bp":2175}},"b":"checkFields : List ( Node String, Node TypeAnnotation ) -> ( List (Error {}), Dict String Type ) -> List (Error {})\n        checkFields fields ( parentError, canonicalTypeInfoFromParent ) =\n            parentError\n                ++ List.concatMap\n                    (\\( field, a ) ->\n                        Dict.get (Node.value field) canonicalTypeInfoFromParent\n                            |> Maybe.map (dereferenceType context)\n                            |> (\\t -> checkTypeAnnotation config context t a)\n                    )\n                    fields"},{"$":1,"a":{"bV":{"bb":27,"bp":2188},"cj":{"bb":9,"bp":2179}},"b":"go : Maybe DereferencedType -> Node TypeAnnotation -> List (Error {})\n        go =\n            checkTypeAnnotation config context"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":2174},"cj":{"bb":5,"bp":2174}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":41,"bp":2256},"cj":{"bb":9,"bp":2254}},"b":"checkFields : Dict String DereferencedType -> List ( Node String, Node Expression ) -> ( List (Error {}), Dict String Type ) -> List (Error {})\n        checkFields typeInfo fields ( parentError, canonicalTypeInfoFromParent ) =\n            parentError\n                ++ List.concatMap\n                    (\\( field, e ) ->\n                        let\n                            f : String\n                            f =\n                                Node.value field\n                        in\n                        Dict.get f canonicalTypeInfoFromParent\n                            |> Maybe.map (dereferenceType local.context)\n                            |> MaybeX.orElseLazy (\\() -> Dict.get f typeInfo)\n                            |> (\\t -> go t e)\n                    )\n                    fields"},{"$":1,"a":{"bV":{"bb":27,"bp":2273},"cj":{"bb":9,"bp":2258}},"b":"go : Maybe DereferencedType -> Node Expression -> List (Error {})\n        go =\n            checkExpression config local"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":2253},"cj":{"bb":5,"bp":2253}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":79,"bp":2370},"cj":{"bb":17,"bp":2366}},"b":"ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes updateType"},{"$":1,"a":{"bV":{"bb":51,"bp":2374},"cj":{"bb":17,"bp":2372}},"b":"updateType : Maybe DereferencedType\n                updateType =\n                    -- Get type from updated var if we don't have a good annotation\n                    hasType\n                        |> MaybeX.orElseLazy (\\() -> inferExprType local node)"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":16,"bp":2365},"cj":{"bb":13,"bp":2365}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":40,"bp":2848},"cj":{"bb":9,"bp":2846}},"b":"orderInfo : Maybe OrderInfo\n        orderInfo =\n            Maybe.andThen (Result.toMaybe << makeFieldOrder) hasType\n                |> Maybe.map HasFieldOrder"},{"$":1,"a":{"bV":{"bb":43,"bp":2853},"cj":{"bb":9,"bp":2850}},"b":"types : Dict String DereferencedType\n        types =\n            getRecordFieldTypes hasType"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":2845},"cj":{"bb":5,"bp":2845}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":40,"bp":2886},"cj":{"bb":9,"bp":2884}},"b":"orderInfo : Maybe OrderInfo\n        orderInfo =\n            Maybe.andThen (Result.toMaybe << makeFieldOrder) hasType\n                |> Maybe.map HasFieldOrder\n                |> MaybeX.orElse fallback"},{"$":1,"a":{"bV":{"bb":42,"bp":2892},"cj":{"bb":9,"bp":2888}},"b":"types : Dict String DereferencedType\n        types =\n            getRecordFieldTypes hasType"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":2875},"cj":{"bb":5,"bp":2875}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":63,"bp":2949},"cj":{"bb":9,"bp":2941}},"b":"alphabetical : Field -> Field -> Order\n        alphabetical f1 f2 =\n            compare f1.field f2.field"},{"$":1,"a":{"bV":{"bb":21,"bp":3009},"cj":{"bb":9,"bp":2951}},"b":"byFieldOrder : Dict String Int -> Field -> Field -> Order\n        byFieldOrder ord f1 f2 =\n            let\n                o : String -> Int\n                o f =\n                    Dict.get f ord\n                        |> Maybe.withDefault -1\n            in\n            compare (o f1.field) (o f2.field)"},{"$":1,"a":{"bV":{"bb":38,"bp":3013},"cj":{"bb":9,"bp":3011}},"b":"checkSortingBy : (Field -> Field -> Order) -> List (Error {})\n        checkSortingBy o =\n            checkSorting context.extractSource \"Record fields\" [ o ] errorRange fields"},{"$":1,"a":{"bV":{"bb":46,"bp":3023},"cj":{"bb":9,"bp":3015}},"b":"errorRange : Range\n        errorRange =\n            let\n                s : Location\n                s =\n                    fullRange.start\n            in\n            -- Assume opening `{` is just the first character of the range.\n            { start = s, end = { s | column = s.column + 1 } }"},{"$":1,"a":{"bV":{"bb":87,"bp":3027},"cj":{"bb":9,"bp":3025}},"b":"handleUnknown : (Field -> Field -> Order) -> List (Error {})\n        handleUnknown whenAlphabetical =\n            case sortUnknown of\n                Alphabetically ->\n                    -- Unknown record, so sort alphabetically if config says to\n                    checkSortingBy whenAlphabetical\n\n                ReportOnly ->\n                    -- Unknown record, so report without fixes\n                    unknownRecordError record fullRange\n\n                DoNotSort ->\n                    -- Unknown record; don't sort it\n                    []"},{"$":1,"a":{"bV":{"bb":23,"bp":3042},"cj":{"bb":9,"bp":3029}},"b":"matchingOrders :\n            ( List\n                { typeName : List ( ModuleName, String )\n                , fieldOrder : Dict String Int\n                , hasUnknownFields : Bool\n                , canonicalFieldTypes : Dict String Type\n                , isSubrecord : Bool\n                }\n            , Bool\n            )\n        matchingOrders =\n            findMatchingTypes config context orderInfo fields\n                |> List.map\n                    (\\{ typeName, fieldOrder, isSubrecord } ->\n                        makeOrder sortGenerics fields fieldOrder\n                            |> (\\o ->\n                                    ( Dict.toList o.fieldOrder\n                                    , { typeName = typeName\n                                      , fieldOrder = o.fieldOrder\n                                      , hasUnknownFields = o.hasUnknownFields\n                                      , canonicalFieldTypes = o.canonicalFieldTypes\n                                      , isSubrecord = isSubrecord\n                                      }\n                                    )\n                               )\n                    )\n                -- Dedupe by field order\n                |> DictX.fromListDedupe\n                    (\\o1 o2 ->\n                        (if o1.hasUnknownFields then\n                            -- Prefer matches without unknown fields\n                            o2\n\n                         else\n                            o1\n                        )\n                            |> (\\o ->\n                                    -- Keep only matching field types between duplicate orders\n                                    { o | canonicalFieldTypes = keepOnlyMatchingFieldTypes o.canonicalFieldTypes o2.canonicalFieldTypes }\n                               )\n                    )\n                |> Dict.values\n                |> List.partition .hasUnknownFields\n                |> Tuple.mapBoth (List.partition .isSubrecord) (List.partition .isSubrecord)\n                |> (\\os ->\n                        case os of\n                            -- Prefer matches without unknown fields and that are not subrecords\n                            ( ( unknownIsSubrecord, [] ), ( [], [] ) ) ->\n                                ( unknownIsSubrecord, True )\n\n                            ( ( _, unknownNotSubrecord ), ( [], [] ) ) ->\n                                ( unknownNotSubrecord, True )\n\n                            ( _, ( noUnknownIsSubrecord, [] ) ) ->\n                                ( noUnknownIsSubrecord, False )\n\n                            ( _, ( _, noUnknownNotSubrecord ) ) ->\n                                ( noUnknownNotSubrecord, False )\n                   )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":2940},"cj":{"bb":5,"bp":2940}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":3188},"cj":{"bb":9,"bp":3183}},"b":"hasAllFields : Bool\n        hasAllFields =\n            case info of\n                Just HasAllFields ->\n                    True\n\n                _ ->\n                    False"},{"$":1,"a":{"bV":{"bb":26,"bp":3224},"cj":{"bb":9,"bp":3217}},"b":"toFieldOrder : Maybe Generic -> KnownRecord -> FieldOrder\n        toFieldOrder generic { order } =\n            FieldOrder\n                { canonical = order\n                , generic = generic\n                }"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3162},"cj":{"bb":5,"bp":3162}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":33,"bp":3264},"cj":{"bb":9,"bp":3261}},"b":"checkTypes : KnownRecord -> Bool\n        checkTypes { order } =\n            List.foldl\n                (\\{ field, type_ } ( varAcc, matchAcc ) ->\n                    let\n                        assignedVars : Dict ( Int, String ) Type\n                        assignedVars =\n                            -- Only keep type variables assigned on the known record, since fields are independent\n                            -- For example, { a = Nothing, b = Nothing } should not require `a` and `b` to have the\n                            -- same type variable (but it does for the known record if they are both `Maybe var`)\n                            Dict.filter (\\( i, _ ) _ -> i == 2) varAcc\n                    in\n                    Dict.get field order\n                        |> Maybe.map (dereferenceType context << Tuple.second)\n                        |> Maybe.map2 (typesMatch assignedVars) type_\n                        -- If any `Nothing`s were encountered, we're missing type info\n                        |> Maybe.withDefault ( assignedVars, True )\n                        |> Tuple.mapSecond ((&&) matchAcc)\n                )\n                ( Dict.empty, True )\n                fields\n                |> Tuple.second"},{"$":1,"a":{"bV":{"bb":32,"bp":3287},"cj":{"bb":9,"bp":3266}},"b":"matchFields : Dict String Field\n        matchFields =\n            List.map (\\f -> ( f.field, f )) fields\n                |> Dict.fromList"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3260},"cj":{"bb":5,"bp":3260}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":44,"bp":3368},"cj":{"bb":9,"bp":3347}},"b":"checkListOfTypes : Dict ( Int, String ) Type -> List Type -> List Type -> ( Dict ( Int, String ) Type, Bool )\n        checkListOfTypes typeVars t1s t2s =\n            if List.length t1s /= List.length t2s then\n                ( typeVars, False )\n\n            else\n                ListX.zip t1s t2s\n                    |> List.foldl\n                        (\\( t1_, t2_ ) ( varAcc, matchAcc ) ->\n                            go varAcc t1_ t2_\n                                |> Tuple.mapSecond ((&&) matchAcc)\n                        )\n                        ( typeVars, True )"},{"$":1,"a":{"bV":{"bb":43,"bp":3382},"cj":{"bb":9,"bp":3370}},"b":"go : Dict ( Int, String ) Type -> Type -> Type -> ( Dict ( Int, String ) Type, Bool )\n        go typeVars type1 type2 =\n            case ( type1, type2 ) of\n                ( TypeVar c n, t ) ->\n                    matchTypeVars 1 typeVars c n t\n\n                ( t, TypeVar c n ) ->\n                    matchTypeVars 2 typeVars c n t\n\n                ( ListType t1, ListType t2 ) ->\n                    go typeVars t1 t2\n\n                ( TupleType t1s, TupleType t2s ) ->\n                    -- Tuples must be same size\n                    checkListOfTypes typeVars t1s t2s\n\n                ( FunctionType f1, FunctionType f2 ) ->\n                    checkListOfTypes typeVars [ f1.from, f1.to ] [ f1.from, f2.to ]\n\n                ( UnitType, UnitType ) ->\n                    ( typeVars, True )\n\n                ( NamedType n1 args1, NamedType n2 args2 ) ->\n                    checkListOfTypes typeVars args1 args2\n                        |> Tuple.mapSecond ((&&) (n1 == n2))\n\n                ( RecordType r1, RecordType r2 ) ->\n                    -- Divide fields into those that are present in both and those that are missing\n                    Dict.merge\n                        (\\f t1 acc -> { acc | only1 = ( f, t1 ) :: acc.only1 })\n                        (\\_ t1 t2 acc -> { acc | both = ( t1, t2 ) :: acc.both })\n                        (\\f t2 acc -> { acc | only2 = ( f, t2 ) :: acc.only2 })\n                        (Dict.fromList r1.fields)\n                        (Dict.fromList r2.fields)\n                        { only1 = [], both = [], only2 = [] }\n                        |> validateRecordMatch typeVars r1.generic r2.generic\n\n                _ ->\n                    ( typeVars, False )"},{"$":1,"a":{"bV":{"bb":21,"bp":3400},"cj":{"bb":9,"bp":3384}},"b":"matchTypeVars : Int -> Dict ( Int, String ) Type -> Maybe Typeclass -> String -> Type -> ( Dict ( Int, String ) Type, Bool )\n        matchTypeVars side typeVars typeclass name type_ =\n            case ( Dict.get ( side, name ) typeVars, type_ ) of\n                ( Just t, _ ) ->\n                    -- If the type var has been assigned, check if that type matches\n                    -- Remove the matched typevar, because if the same exists within it refers to a different value\n                    go (Dict.remove ( side, name ) typeVars) t type_\n                        |> Tuple.mapFirst (Dict.insert ( side, name ) t)\n\n                ( Nothing, TypeVar _ _ ) ->\n                    -- Handle base case.  This isn't right, but not worth going to the effort of matching typeclasses and the like\n                    ( typeVars, True )\n\n                ( Nothing, _ ) ->\n                    if\n                        Maybe.map (matchesTypeClass type_) typeclass\n                            |> Maybe.withDefault True\n                    then\n                        ( Dict.insert ( side, name ) type_ typeVars, True )\n\n                    else\n                        ( typeVars, False )"},{"$":1,"a":{"bV":{"bb":40,"bp":3440},"cj":{"bb":9,"bp":3402}},"b":"validateRecordMatch : Dict ( Int, String ) Type -> Maybe Type -> Maybe Type -> { only1 : List ( String, Type ), both : List ( Type, Type ), only2 : List ( String, Type ) } -> ( Dict ( Int, String ) Type, Bool )\n        validateRecordMatch typeVars generic1 generic2 { only1, only2, both } =\n            -- Fields in both must match\n            List.unzip both\n                |> (\\( l1s, l2s ) -> checkListOfTypes typeVars l1s l2s)\n                |> (\\( vars, matchAcc ) ->\n                        validate (not << List.isEmpty) only1\n                            |> Maybe.map2 (\\g fs -> go vars (RecordType { canonical = False, generic = Nothing, fields = fs }) g) generic2\n                            |> Maybe.withDefault ( vars, List.isEmpty only1 )\n                            |> Tuple.mapSecond ((&&) matchAcc)\n                   )\n                |> (\\( vars, matchAcc ) ->\n                        validate (not << List.isEmpty) only2\n                            |> Maybe.map2 (\\g fs -> go vars (RecordType { canonical = False, generic = Nothing, fields = fs }) g) generic1\n                            |> Maybe.withDefault ( vars, List.isEmpty only2 )\n                            |> Tuple.mapSecond ((&&) matchAcc)\n                   )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3346},"cj":{"bb":5,"bp":3346}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":26,"bp":3473},"cj":{"bb":9,"bp":3450}},"b":"typeIsAppendable : Type -> Bool\n        typeIsAppendable t =\n            case t of\n                NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True\n\n                ListType _ ->\n                    True\n\n                _ ->\n                    -- Nothing else is appendable\n                    False"},{"$":1,"a":{"bV":{"bb":26,"bp":3486},"cj":{"bb":9,"bp":3475}},"b":"typeIsComparable : Type -> Bool\n        typeIsComparable t =\n            case t of\n                NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True\n\n                NamedType ( [ \"Char\" ], \"Char\" ) [] ->\n                    True\n\n                NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True\n\n                NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True\n\n                ListType t_ ->\n                    typeIsComparable t_\n\n                TupleType ts ->\n                    List.all typeIsComparable ts\n\n                _ ->\n                    -- Nothing else is comparable\n                    False"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3449},"cj":{"bb":5,"bp":3449}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":22,"bp":3527},"cj":{"bb":9,"bp":3520}},"b":"go : String -> Node Expression -> Maybe Type\n        go typeVarPrefix node =\n            case Node.value node of\n                UnitExpr ->\n                    -- Mr. Incredible says UNIT IS UNIT.\n                    Just UnitType\n\n                Integer _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []\n\n                Hex _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []\n\n                Floatable _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Float\" ) []\n\n                Literal _ ->\n                    Just <| NamedType ( [ \"String\" ], \"String\" ) []\n\n                CharLiteral _ ->\n                    Just <| NamedType ( [ \"Char\" ], \"Char\" ) []\n\n                TupledExpression es ->\n                    List.indexedMap (\\i e -> go (typeVarPrefix ++ \"Tuple Expression \" ++ String.fromInt i) e) es\n                        |> MaybeX.combine\n                        |> Maybe.map TupleType\n\n                ListExpr es ->\n                    if List.isEmpty es then\n                        -- An empty list can be anything\n                        Just (ListType (TypeVar Nothing <| typeVarPrefix ++ \"inferred empty list typevar\"))\n\n                    else\n                        -- Have to check all and unify\n                        List.indexedMap (\\i e -> go (typeVarPrefix ++ \"List Element \" ++ String.fromInt i) e) es\n                            |> MaybeX.values\n                            |> unifyTypes\n                            |> Maybe.map ListType\n\n                RecordExpr rs ->\n                    rs\n                        |> List.map\n                            (\\n ->\n                                let\n                                    ( f, e ) =\n                                        Node.value n\n                                in\n                                go (typeVarPrefix ++ \"Record Field \" ++ Node.value f) e\n                                    |> Maybe.map (Tuple.pair (Node.value f))\n                            )\n                        |> MaybeX.combine\n                        |> Maybe.map (\\fields -> RecordType { generic = Nothing, fields = fields, canonical = False })\n\n                FunctionOrValue _ name ->\n                    findFunctionType local Nothing node name\n                        |> makeFunc typeVarPrefix\n\n                ParenthesizedExpression e ->\n                    -- Type is just whatever is in parentheses\n                    go typeVarPrefix e\n\n                Negation e ->\n                    go typeVarPrefix e\n\n                IfBlock _ e1 e2 ->\n                    -- Try to infer either side and unify\n                    [ go (typeVarPrefix ++ \"If Block True\") e1, go (typeVarPrefix ++ \"If Block False\") e2 ]\n                        |> MaybeX.values\n                        |> unifyTypes\n\n                PrefixOperator p ->\n                    findOperatorType local.context p\n                        |> makeFunc typeVarPrefix\n\n                CaseExpression { cases } ->\n                    -- Try to infer all cases and unify\n                    List.indexedMap (\\i ( _, e ) -> go (typeVarPrefix ++ \"Case Expression \" ++ String.fromInt i) e) cases\n                        |> MaybeX.values\n                        |> unifyTypes\n\n                Application es ->\n                    inferApplicationChain local es\n                        |> Maybe.map getType\n\n                LambdaExpression { args, expression } ->\n                    let\n                        unwrapArgs : List String -> Maybe Type\n                        unwrapArgs xs =\n                            ListX.uncons xs\n                                |> MaybeX.unpack (\\() -> go typeVarPrefix expression)\n                                    (\\( x, xs_ ) ->\n                                        unwrapArgs xs_\n                                            |> Maybe.map (\\t -> FunctionType { from = TypeVar Nothing <| typeVarPrefix ++ x, to = t })\n                                    )\n                    in\n                    List.indexedMap (\\i _ -> \"lambda arg\" ++ String.fromInt i) args\n                        |> unwrapArgs\n\n                RecordAccess e accessFunc ->\n                    go typeVarPrefix e\n                        |> Maybe.map DereferencedType\n                        |> getRecordFieldTypes\n                        |> (\\ts ->\n                                Node.value accessFunc\n                                    |> makeAccessFunc\n                                    |> (\\f -> Dict.get f ts)\n                           )\n                        |> Maybe.map getType\n\n                GLSLExpression _ ->\n                    Nothing\n\n                RecordAccessFunction accessFunc ->\n                    -- We know the expression being accessed is a record with a field of the type of the total expression\n                    makeAccessFunc accessFunc\n                        |> (\\f ->\n                                Just <|\n                                    FunctionType\n                                        { from =\n                                            RecordType\n                                                -- This is, in essence, a generic record with one field\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"record access inferred for \" ++ f\n                                                , canonical = False\n                                                , fields = [ ( f, TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f ) ]\n                                                }\n                                        , to = TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f\n                                        }\n                           )\n\n                Operator _ ->\n                    Nothing\n\n                OperatorApplication op _ e1 e2 ->\n                    -- Handle a few known operators\n                    checkOperatorApplication (inferApplicationChain local) op e1 e2\n                        |> Maybe.map getType\n\n                LetExpression { declarations, expression } ->\n                    let\n                        newBindings : Dict String Type\n                        newBindings =\n                            List.concatMap (bindingsFromLetDeclaration local << Node.value) declarations\n                                |> Dict.fromList\n                    in\n                    inferExprType { local | localFunctions = Dict.union local.localFunctions newBindings } expression\n                        |> Maybe.map (prefixTypeVars typeVarPrefix)\n                        |> Maybe.map getType\n\n                RecordUpdateExpression var fs ->\n                    findFunctionType local Nothing var (Node.value var)\n                        |> makeFunc typeVarPrefix\n                        |> MaybeX.orElseLazy\n                            (\\() ->\n                                MaybeX.traverse ((\\( f, e ) -> go (typeVarPrefix ++ \"Record Update Field \" ++ Node.value f) e |> Maybe.map (Tuple.pair (Node.value f))) << Node.value) fs\n                                    |> Maybe.map\n                                        (\\fields ->\n                                            RecordType\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"inferred update generic\"\n                                                , canonical = False\n                                                , fields = fields\n                                                }\n                                        )\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":3691},"cj":{"bb":9,"bp":3529}},"b":"makeFunc : String -> Maybe (List DereferencedType) -> Maybe Type\n        makeFunc typeVarPrefix =\n            Maybe.map (List.map (prefixTypeVars typeVarPrefix))\n                >> Maybe.andThen ListX.unconsLast\n                >> Maybe.map\n                    (Tuple.mapBoth getType (List.map getType)\n                        >> (\\( r, ts ) -> makeFunctionType r ts)\n                    )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3519},"cj":{"bb":5,"bp":3519}},"d_":"NoUnsortedLetDeclarations","ff":0},{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":32,"bp":3704},"cj":{"bb":9,"bp":3702}},"b":"getReturnType : List (Node Expression) -> ( List DereferencedType, DereferencedType ) -> DereferencedType\n        getReturnType args ( argTypes, returnType ) =\n            List.map inferExpr args\n                |> ListX.zip argTypes\n                |> List.foldl\n                    (\\( t1, t2 ) typeVars ->\n                        Maybe.map (typesMatch typeVars t1) t2\n                            |> Maybe.map Tuple.first\n                            |> Maybe.withDefault typeVars\n                    )\n                    Dict.empty\n                |> Dict.filter (\\( i, _ ) _ -> i == 1)\n                |> DictX.mapKeys Tuple.second\n                |> (\\typeVars -> assignTypeVars typeVars returnType)"},{"$":1,"a":{"bV":{"bb":69,"bp":3719},"cj":{"bb":9,"bp":3706}},"b":"inferExpr : Node Expression -> Maybe DereferencedType\n        inferExpr =\n            inferExprType local"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":3701},"cj":{"bb":5,"bp":3701}},"d_":"NoUnsortedLetDeclarations","ff":0}]},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-1,"a":1,"b":"src/NoUnsortedLetDeclarations.elm","c":{"bT":3093415870,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":63,"bp":757},"cj":{"bb":17,"bp":756}},"b":"applyGlues : List LetDec -> Int -> LetDec -> LetDec\n                applyGlues ds i d =\n                    { d | glued = ListX.findMap (\\g -> g ( i, d ) ds) glues }"},{"$":1,"a":{"bV":{"bb":30,"bp":816},"cj":{"bb":17,"bp":769}},"b":"( exprsToDecs, exprs ) =\n                    List.foldl step ( [], [] ) lb.declarations"},{"$":1,"a":{"bV":{"bb":78,"bp":820},"cj":{"bb":17,"bp":818}},"b":"step :\n                    Node LetDeclaration\n                    -> ( List (List (Node Expression) -> LetDec), List (Node Expression) )\n                    -> ( List (List (Node Expression) -> LetDec), List (Node Expression) )\n                step d ( dAcc, eAcc ) =\n                    case Node.value d of\n                        LetFunction { declaration } ->\n                            let\n                                { expression, arguments } =\n                                    Node.value declaration\n\n                                name : String\n                                name =\n                                    Node.value (Node.value declaration).name\n                            in\n                            ( (\\es ->\n                                { range = Node.range d\n                                , namesBound = Set.singleton name\n                                , usedInExpression = countUsesIn lb.expression name >= 1\n                                , usedInOtherDecs = List.any (\\e -> countUsesIn e name >= 1) es\n                                , args = List.concatMap allBindingsInPattern arguments\n                                , glued = Nothing\n                                , dependentOnBindings = findAllNamesIn expression\n                                }\n                              )\n                                :: dAcc\n                            , expression :: eAcc\n                            )\n\n                        LetDestructuring p expression ->\n                            let\n                                bs : List String\n                                bs =\n                                    allBindingsInPattern p\n                            in\n                            ( (\\es ->\n                                { range = Node.range d\n                                , namesBound = Set.fromList bs\n                                , usedInExpression = List.any ((\\numUses -> numUses > 0) << countUsesIn lb.expression) bs\n                                , usedInOtherDecs = List.any (\\e -> List.any ((\\numUses -> numUses > 0) << countUsesIn e) bs) es\n                                , args = []\n                                , glued = Nothing\n                                , dependentOnBindings = findAllNamesIn expression\n                                }\n                              )\n                                :: dAcc\n                            , expression :: eAcc\n                            )"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":16,"bp":755},"cj":{"bb":13,"bp":755}},"d_":"NoUnsortedLetDeclarations","ff":0}]},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-1,"a":0,"b":"src/NoUnsortedCases.elm","c":{"bT":4024434763,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":50,"bp":988},"cj":{"bb":9,"bp":986}},"b":"findConstructorOrder : String -> List (Node Pattern) -> ModuleName -> Maybe SortablePattern\n        findConstructorOrder constructor ps moduleName =\n            -- Get types for the module\n            Dict.get moduleName context.customTypes\n                -- Find the type that the constructor belongs to\n                |> Maybe.andThen\n                    (DictX.find\n                        (\\_ { constructors } ->\n                            Set.member constructor constructors\n                        )\n                    )\n                -- Find its constructor order\n                |> Maybe.andThen\n                    (\\( matchedType, { declarationOrder } ) ->\n                        ListX.elemIndex constructor declarationOrder\n                            |> Maybe.map\n                                (\\order ->\n                                    Constructor\n                                        { type_ = ( moduleName, matchedType )\n                                        , order = order\n                                        , subpatterns = List.map go ps\n                                        }\n                                )\n                    )"},{"$":1,"a":{"bV":{"bb":34,"bp":992},"cj":{"bb":9,"bp":990}},"b":"go : Node Pattern -> Maybe SortablePattern\n        go =\n            getSortablePattern ruleConfig context"},{"$":1,"a":{"bV":{"bb":22,"bp":1025},"cj":{"bb":9,"bp":1002}},"b":"n : Node Pattern\n        n =\n            getActualPattern node"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":985},"cj":{"bb":5,"bp":985}},"d_":"NoUnsortedLetDeclarations","ff":0}]},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"src/NoUnsortedTopLevelDeclarations.elm","c":{"bT":1130522341,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Let declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedTopLevelDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":806},"cj":{"bb":9,"bp":804}},"b":"errorRange : Range\n        errorRange =\n            case Node.value m of\n                Module.PortModule _ ->\n                    -- Assume that the `port module` of a module is just the first 11 chars\n                    { r | end = { row = r.start.row, column = r.start.column + 11 } }\n\n                _ ->\n                    -- Assume that the `module` of a module is just the first 6 chars\n                    -- Effect modules aren't a thing\n                    { r | end = { row = r.start.row, column = r.start.column + 6 } }"},{"$":1,"a":{"bV":{"bb":85,"bp":818},"cj":{"bb":9,"bp":808}},"b":"r : Range\n        r =\n            Node.range m"}]}},"a4":"Let declarations are not sorted.","dh":false,"dY":{"bV":{"bb":8,"bp":803},"cj":{"bb":5,"bp":803}},"d_":"NoUnsortedLetDeclarations","ff":0}]},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedRecordsTest.elm","c":{"bT":87950215,"bd":{"$":0},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-1,"a":1,"b":"tests/NoUnsortedLetDeclarationsTest.elm","c":{"bT":1771235242,"bd":{"$":0},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-1,"a":0,"b":"tests/NoUnsortedCasesTest.elm","c":{"bT":1657986532,"bd":{"$":0},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedTopLevelDeclarationsTest.elm","c":{"bT":3507466519,"bd":{"$":0},"b7":3530670207,"c7":false,"ce":0},"d":{"$":-2},"e":{"$":-2}}}},"dZ":{"$":0,"a":{"bT":{"$":0,"a":3715779789},"bd":{"$":0},"b7":3530670207,"ce":0}}}
