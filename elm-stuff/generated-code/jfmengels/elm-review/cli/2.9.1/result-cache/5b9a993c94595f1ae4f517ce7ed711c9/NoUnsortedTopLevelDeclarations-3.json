{"aQ":{"$":0,"a":{"bT":{"$":0,"a":3538679505},"bd":{"$":0},"b5":3530670207,"cc":0}},"c_":{"$":0,"a":{"bT":{"$":0,"a":3538679505},"bd":{"$":0},"b5":3530670207,"cc":0}},"ev":{"$":1},"b$":{"$":1},"I":{"$":-1,"a":1,"b":"src/Util.elm","c":{"bT":2652841245,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":15,"bp":122},"ch":{"bb":1,"bp":33}},"b":"{-| Specify how something is glued to another (by name).\n-}\ntype GluedTo\n    = GluedBeforeFirst (Set String)\n    | GluedAfterFirst (Set String)\n    | GluedBeforeLast (Set String)\n    | GluedAfterLast (Set String)"},{"$":1,"a":{"bV":{"bb":65,"bp":197},"ch":{"bb":1,"bp":181}},"b":"{-| Given context and a list of ordering functions, check if a list is sorted\nand generate errors if it isn't. Ordering functions are applied in order, with\nties being broken by the next function in the list. Earlier ordering functions\nwill never be invalidated by later ones (i.e. there is no transitivity\nassumptions made between ordering functions).\n-}\ncheckSorting : (Range -> String) -> String -> List ({ a | range : Range } -> { a | range : Range } -> Order) -> Range -> List { a | range : Range } -> List (Error {})\ncheckSorting extractSource errorConcerns orderings errorRange ds =\n    let\n        indexed : List (Graph.Node { a | range : Range })\n        indexed =\n            List.indexedMap (\\i d -> { id = i, label = d }) ds\n    in\n    (case orderings of\n        [ o ] ->\n            -- If there is only one sorting function, we needn't worry about\n            -- weird transitivity issues, so simply sort stably.\n            List.sortWith\n                (\\d1 d2 ->\n                    (\\() -> compare d1.id d2.id)\n                        |> fallbackCompareFor (o d1.label d2.label)\n                )\n                indexed\n\n        os ->\n            -- Otherwise, generate all pairwise edges, then eliminate cycles by\n            -- ignoring lower priority sorts first.\n            genEdges os indexed\n                |> Graph.fromNodesAndEdges indexed\n                |> eliminateCycles indexed\n                |> Graph.topologicalSort\n                |> List.map .node\n    )\n        -- Check if sorted\n        |> (\\sorted ->\n                if List.map .id sorted /= List.map .id indexed then\n                    -- Generate a fix if unsorted\n                    List.map (\\{ id, label } -> ( id, label.range )) sorted\n                        |> createFix extractSource\n                        |> unsortedError errorConcerns errorRange\n                        |> List.singleton\n\n                else\n                    []\n           )"},{"$":1,"a":{"bV":{"bb":77,"bp":211},"ch":{"bb":1,"bp":200}},"b":"{-| Given context and a list of ordering functions, check if a list is sorted\nand generate errors if it isn't.\n-}\ncheckSortingWithGlue : (Range -> String) -> String -> List ({ a | namesBound : Set String, glued : Maybe GluedTo, range : Range } -> { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } -> Order) -> Range -> List { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } -> List (Error {})\ncheckSortingWithGlue extractSource errorConcerns orderings errorRange ds =\n    let\n        insertGlued : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } -> { toGlue : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }), inserted : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) }\n        insertGlued glued ({ label } as dec) =\n            -- Keep only glued that are glued to this name\n            List.partition\n                (.label\n                    >> .glued\n                    >> MaybeX.unwrap False (not << Set.isEmpty << Set.intersect label.namesBound << gluedTo)\n                )\n                glued\n                -- Split into glued before and after\n                |> Tuple.mapFirst (List.partition (MaybeX.unwrap False isGluedBefore << .glued << .label))\n                -- Flatten\n                |> (\\( ( gluedBefore, gluedAfter ), toGlue ) -> { toGlue = toGlue, inserted = gluedBefore ++ dec :: gluedAfter })\n\n        indexed : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n        indexed =\n            List.indexedMap (\\i d -> { id = i, label = d }) ds\n\n        sort : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n        sort =\n            List.sortWith\n                (\\d1 d2 ->\n                    -- Sort stably\n                    (\\() -> compare d1.id d2.id)\n                        |> fallbackCompareFor (compareByOrderings orderings d1.label d2.label)\n                )\n\n        glueLevel : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range }) -> List (List (NodeContext { a | namesBound : Set String, glued : Maybe GluedTo, range : Range } Int)) -> List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n        glueLevel sorted glued =\n            case glued of\n                [] ->\n                    sorted\n\n                g :: gs ->\n                    let\n                        asList : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo, range : Range })\n                        asList =\n                            List.map .node g\n                                |> sort\n                    in\n                    (if List.isEmpty sorted then\n                        -- Initial unglued items\n                        asList\n\n                     else\n                        -- Glue items\n                        List.partition (MaybeX.unwrap False isGluedToFirst << .glued << .label) asList\n                            |> (\\( toFirst, toLast ) ->\n                                    List.foldl\n                                        (\\d { toGlue, inserted } ->\n                                            insertGlued toGlue d\n                                                |> (\\r -> { r | inserted = inserted ++ r.inserted })\n                                        )\n                                        { toGlue = toFirst, inserted = [] }\n                                        sorted\n                                        |> .inserted\n                                        |> List.foldr\n                                            (\\d { toGlue, inserted } ->\n                                                insertGlued toGlue d\n                                                    |> (\\r -> { r | inserted = r.inserted ++ inserted })\n                                            )\n                                            { toGlue = toLast, inserted = [] }\n                                        |> .inserted\n                               )\n                    )\n                        |> (\\sorted_ -> glueLevel sorted_ gs)\n    in\n    gluedListToDAG indexed\n        -- Sort by dependency (gluing)\n        |> Graph.heightLevels\n        -- Glue each level\n        |> glueLevel []\n        -- Check if sorted\n        |> (\\sorted ->\n                if List.map .id sorted /= List.map .id indexed then\n                    -- Generate a fix if unsorted\n                    List.map (\\{ id, label } -> ( id, label.range )) sorted\n                        |> createFix extractSource\n                        |> unsortedError errorConcerns errorRange\n                        |> List.singleton\n\n                else\n                    []\n           )"},{"$":1,"a":{"bV":{"bb":28,"bp":224},"ch":{"bb":1,"bp":214}},"b":"{-| Count the uses of a given name in the scope of an expression.\n-}\ncountUsesIn : Node Expression -> String -> Int\ncountUsesIn expr name =\n    case Node.value expr of\n        -- If the name is qualified, it isn't a variable\n        FunctionOrValue [] n ->\n            if n == name then\n                1\n\n            else\n                0\n\n        _ ->\n            subexpressions expr\n                -- Count and sum in one pass\n                |> List.foldl (\\e -> (+) (countUsesIn e name)) 0"},{"$":1,"a":{"bV":{"bb":23,"bp":268},"ch":{"bb":1,"bp":245}},"b":"{-| Use the first order, or use the second order if the first is `Just EQ`. This\nis lazy in the second comparison and written for use in pipeline-style code.\n-}\nfallbackCompareWithUnsortableFor : Maybe Order -> (() -> Maybe Order) -> Maybe Order\nfallbackCompareWithUnsortableFor comp fallback =\n    case comp of\n        Just EQ ->\n            fallback ()\n\n        ltOrGtOrNothing ->\n            ltOrGtOrNothing"},{"$":1,"a":{"bV":{"bb":13,"bp":315},"ch":{"bb":1,"bp":271}},"b":"{-| Find all (local) names used in an expression.\n-}\nfindAllNamesIn : Node Expression -> Set String\nfindAllNamesIn expr =\n    case Node.value expr of\n        -- If the name is qualified, it isn't a variable\n        FunctionOrValue [] n ->\n            Set.singleton n\n\n        _ ->\n            subexpressions expr\n                |> List.foldl (\\e -> Set.union (findAllNamesIn e)) Set.empty"},{"$":1,"a":{"bV":{"bb":14,"bp":377},"ch":{"bb":1,"bp":318}},"b":"{-| Find all dependencies of a declaration.\n-}\nfindDependencies : ( Int, { a | dependentOnBindings : Set String, namesBound : Set String } ) -> List { a | dependentOnBindings : Set String, namesBound : Set String } -> ( Set String, Int )\nfindDependencies ( decI, d ) ds =\n    ListX.indexedFoldl\n        (\\i { dependentOnBindings, namesBound } (( glueAcc, numberUsedIn ) as acc) ->\n            -- Cannot glue to itself\n            if i == decI || (Set.isEmpty <| Set.intersect d.namesBound dependentOnBindings) then\n                acc\n\n            else\n                ( Set.union glueAcc namesBound, numberUsedIn + 1 )\n        )\n        ( Set.empty, 0 )\n        ds"},{"$":1,"a":{"bV":{"bb":76,"bp":414},"ch":{"bb":1,"bp":380}},"b":"{-| Work around `elm-syntax` sometimes including a period in record access\nfunctions.\n-}\nmakeAccessFunc : String -> String\nmakeAccessFunc accessFunc =\n    if String.startsWith \".\" accessFunc then\n        -- Work around elm-syntax behavior\n        String.dropLeft 1 accessFunc\n\n    else\n        accessFunc"},{"$":1,"a":{"bV":{"bb":17,"bp":432},"ch":{"bb":1,"bp":417}},"b":"{-| Keep a value only if it passes a predicate. Like `Maybe.Extra.filter`, but\ndoes not take a `Maybe` as input.\n-}\nvalidate : (a -> Bool) -> a -> Maybe a\nvalidate pred x =\n    if pred x then\n        Just x\n\n    else\n        Nothing"},{"$":1,"a":{"bV":{"bb":34,"bp":441},"ch":{"bb":1,"bp":435}},"b":"{-| Given a list of ordering functions for breaking ties, order to things.\n-}\ncompareByOrderings : List (a -> a -> Order) -> a -> a -> Order\ncompareByOrderings orderings d1 d2 =\n    let\n        go : List (a -> a -> Order) -> Order\n        go os =\n            case os of\n                [] ->\n                    EQ\n\n                o :: os_ ->\n                    (\\() -> go os_)\n                        |> fallbackCompareFor (o d1 d2)\n    in\n    go orderings"},{"$":1,"a":{"bV":{"bb":13,"bp":533},"ch":{"bb":1,"bp":444}},"b":"{-| Given a source code extractor and a sorted list of ranges (with original\nindices), create fixes to resort the source code to the list.\n-}\ncreateFix : (Range -> String) -> List ( Int, Range ) -> List Fix\ncreateFix extractSource sorted =\n    let\n        applyFix : Int -> ( Int, Range ) -> List Fix\n        applyFix newIndex ( oldIndex, range ) =\n            if newIndex == oldIndex then\n                []\n\n            else\n                ListX.find ((==) newIndex << Tuple.first) sorted\n                    |> Maybe.map Tuple.second\n                    |> Maybe.map\n                        (\\oldRange ->\n                            extractSource range\n                                |> Fix.replaceRangeBy oldRange\n                                |> List.singleton\n                        )\n                    |> Maybe.withDefault []\n    in\n    List.indexedMap applyFix sorted\n        |> List.concat"},{"$":1,"a":{"bV":{"bb":15,"bp":551},"ch":{"bb":1,"bp":536}},"b":"{-| Given a graph with edges labeled by priority (larger number is lower\npriority, convert it to an acyclic graph by removing edges, with the guarantee\nthat all lower-priority edges will be removed before any of higher priority\nare.\n-}\neliminateCycles : List (Graph.Node a) -> Graph a Int -> AcyclicGraph a Int\neliminateCycles nodes g =\n    -- Check if it is acyclic\n    Graph.stronglyConnectedComponents g\n        |> ResultX.extract\n            (List.map\n                -- If not, for each strongly-connected subgraph\n                (\\graph ->\n                    let\n                        ns : List (Graph.Node a)\n                        ns =\n                            Graph.nodes graph\n\n                        ( lowestPriorityEdges, higherPriorityEdges ) =\n                            -- Get all edges\n                            Graph.edges graph\n                                -- Group them by priority\n                                |> DictX.groupBy .label\n                                |> Dict.values\n                                -- Select lowest priority edges\n                                |> ListX.unconsLast\n                                |> Maybe.withDefault ( [], [] )\n                                |> Tuple.mapBoth\n                                    (List.map (\\{ from, to } -> ( from, to ))\n                                        >> Set.fromList\n                                    )\n                                    List.concat\n                    in\n                    Set.filter\n                        -- Filter low priority edges by removing any that by the insertion of just that edge create a cyclic subgraph\n                        (\\( from, to ) ->\n                            Graph.fromNodesAndEdges ns ({ from = from, to = to, label = -1 } :: higherPriorityEdges)\n                                |> Graph.checkAcyclic\n                                |> ResultX.isErr\n                        )\n                        lowestPriorityEdges\n                        |> (\\s ->\n                                if Set.isEmpty s then\n                                    -- Don't risk the infinite loop and delete them all if none of them appeared cyclic individually\n                                    lowestPriorityEdges\n\n                                else\n                                    s\n                           )\n                )\n                >> List.foldl Set.union Set.empty\n                -- Eliminate all identified edges and rebuild graph\n                >> (\\toRemove ->\n                        Graph.edges g\n                            |> List.filter (\\{ from, to } -> not <| Set.member ( from, to ) toRemove)\n                            |> Graph.fromNodesAndEdges nodes\n                            -- Repeat the process if necessary\n                            |> eliminateCycles nodes\n                   )\n            )"},{"$":1,"a":{"bV":{"bb":18,"bp":569},"ch":{"bb":1,"bp":554}},"b":"{-| Generate edges for every pairwise combination of nodes, along with their\npriority (lower number is higher priority).\n-}\ngenEdges : List ({ a | range : Range } -> { a | range : Range } -> Order) -> List (Graph.Node { a | range : Range }) -> List (Edge Int)\ngenEdges orderings indexed =\n    let\n        genEdge : List ( Int, { a | range : Range } -> { a | range : Range } -> Order ) -> ( Graph.Node { a | range : Range }, Graph.Node { a | range : Range } ) -> Maybe (Edge Int)\n        genEdge os ( d1, d2 ) =\n            case os of\n                ( priority, o ) :: os_ ->\n                    case o d1.label d2.label of\n                        EQ ->\n                            genEdge os_ ( d1, d2 )\n\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = priority }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = priority }\n\n                [] ->\n                    -- Unsortable, so simply use original order\n                    case compare d1.id d2.id of\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = 0 }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = 0 }\n\n                        EQ ->\n                            -- This should never happen\n                            Nothing\n    in\n    ListX.uniquePairs indexed\n        |> List.filterMap (genEdge <| List.indexedMap Tuple.pair orderings)"},{"$":1,"a":{"bV":{"bb":18,"bp":587},"ch":{"bb":1,"bp":572}},"b":"{-| Given a list of glued TLDs, remove any glues that are cyclic by converting\nit to a directed acyclic graph, where edges indicate gluing dependencies (i.e.\nA -> B means B is glued to A).\n-}\ngluedListToDAG : List (Graph.Node { a | namesBound : Set String, glued : Maybe GluedTo }) -> AcyclicGraph { a | namesBound : Set String, glued : Maybe GluedTo } Int\ngluedListToDAG ds =\n    let\n        namesToNodeId : Dict String Int\n        namesToNodeId =\n            List.concatMap (\\{ id, label } -> List.map (\\n -> ( n, id )) <| Set.toList label.namesBound) ds\n                |> Dict.fromList\n\n        edges : List (Edge Int)\n        edges =\n            -- There can be duplicate edges, but that is fine, since the graph only keeps one\n            List.concatMap\n                (\\{ id, label } ->\n                    MaybeX.unwrap [] (Set.toList << gluedTo) label.glued\n                        |> List.filterMap\n                            (\\n ->\n                                Dict.get n namesToNodeId\n                                    |> Maybe.map (\\from -> { from = from, to = id, label = 0 })\n                            )\n                )\n                ds\n    in\n    Graph.fromNodesAndEdges ds edges\n        |> eliminateCycles ds"},{"$":1,"a":{"bV":{"bb":30,"bp":617},"ch":{"bb":1,"bp":590}},"b":"{-| Extract what names something is glued to.\n-}\ngluedTo : GluedTo -> Set String\ngluedTo g =\n    case g of\n        GluedBeforeFirst ns ->\n            ns\n\n        GluedAfterFirst ns ->\n            ns\n\n        GluedBeforeLast ns ->\n            ns\n\n        GluedAfterLast ns ->\n            ns"},{"$":1,"a":{"bV":{"bb":11,"bp":634},"ch":{"bb":1,"bp":620}},"b":"{-| Check if something is glued before or after that to which it is glued.\n-}\nisGluedBefore : GluedTo -> Bool\nisGluedBefore g =\n    case g of\n        GluedBeforeFirst _ ->\n            True\n\n        GluedAfterFirst _ ->\n            False\n\n        GluedBeforeLast _ ->\n            True\n\n        GluedAfterLast _ ->\n            False"},{"$":1,"a":{"bV":{"bb":10,"bp":646},"ch":{"bb":1,"bp":637}},"b":"{-| Check if something is glued to the first or last of its glued list.\n-}\nisGluedToFirst : GluedTo -> Bool\nisGluedToFirst g =\n    case g of\n        GluedBeforeFirst _ ->\n            True\n\n        GluedAfterFirst _ ->\n            True\n\n        GluedBeforeLast _ ->\n            False\n\n        GluedAfterLast _ ->\n            False"},{"$":1,"a":{"bV":{"bb":16,"bp":658},"ch":{"bb":1,"bp":649}},"b":"{-| Get all immediate child expressions of an expression.\n-}\nsubexpressions : Node Expression -> List (Node Expression)\nsubexpressions expr =\n    case Node.value expr of\n        LetExpression letBlock ->\n            let\n                subExprs : Node LetDeclaration -> Node Expression\n                subExprs n =\n                    case Node.value n of\n                        LetFunction { declaration } ->\n                            Node.value declaration\n                                |> .expression\n\n                        LetDestructuring _ e ->\n                            e\n            in\n            letBlock.expression\n                :: List.map subExprs letBlock.declarations\n\n        ListExpr es ->\n            es\n\n        TupledExpression es ->\n            es\n\n        RecordExpr setters ->\n            List.map (Tuple.second << Node.value) setters\n\n        RecordUpdateExpression record updaters ->\n            Node.map (FunctionOrValue []) record\n                :: List.map (Tuple.second << Node.value) updaters\n\n        Application es ->\n            es\n\n        CaseExpression caseBlock ->\n            caseBlock.expression\n                :: List.map Tuple.second caseBlock.cases\n\n        OperatorApplication _ _ e1 e2 ->\n            [ e1, e2 ]\n\n        IfBlock predExpr thenExpr elseExpr ->\n            [ predExpr, thenExpr, elseExpr ]\n\n        LambdaExpression { expression } ->\n            [ expression ]\n\n        RecordAccess record _ ->\n            [ record ]\n\n        ParenthesizedExpression e ->\n            [ e ]\n\n        Negation e ->\n            [ e ]\n\n        UnitExpr ->\n            []\n\n        Integer _ ->\n            []\n\n        Hex _ ->\n            []\n\n        Floatable _ ->\n            []\n\n        Literal _ ->\n            []\n\n        CharLiteral _ ->\n            []\n\n        GLSLExpression _ ->\n            []\n\n        RecordAccessFunction _ ->\n            []\n\n        FunctionOrValue _ _ ->\n            []\n\n        Operator _ ->\n            []\n\n        PrefixOperator _ ->\n            []"},{"$":1,"a":{"bV":{"bb":19,"bp":671},"ch":{"bb":1,"bp":661}},"b":"{-| Given a range and a fix, create an unsorted case error.\n-}\nunsortedError : String -> Range -> List Fix -> Error {}\nunsortedError errorConcerns =\n    Rule.errorWithFix\n        { message = errorConcerns ++ \" are not sorted.\"\n        , details =\n            [ errorConcerns ++ \" were found out of order.  They should be sorted as specified in the rule configuration.\"\n            ]\n        }"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-1,"a":1,"b":"src/NoUnsortedRecords.elm","c":{"bT":2645047545,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":22,"bp":370},"ch":{"bb":1,"bp":353}},"b":"{-| The default configuration, with the following behavior:\n\n  - Unknown records (those that match no known canonical order) are sorted\n    alphabetically\n  - Ambiguous records (those that match more than one canonical order) are\n    sorted alphabetically\n  - Generic fields of generic records are sorted before the canonical ones.\n  - Subrecords are treated as having canonical order only when associated with\n    their outer record/constructor.\n  - Typechecking is only used to disambiguate records, i.e. a record will not\n    _not_ match a canonical record just because the rule thinks it has the wrong\n    type. For instance, `{ foo = 1, bar = 2 }` will match\n    `{ foo : String, bar : String }` if no other records exist with the fields\n    `foo` and `bar`. This is to protect against incorrect type inference by this\n    rule.\n\nUse `reportUnknownRecordsWithoutFix`, etc. to alter this behavior, e.g.\n\n    config =\n        [ NoUnsortedRecords.rule\n            (NoUnsortedRecords.defaults\n                |> NoUnsortedRecords.reportAmbiguousRecordsWithoutFix\n            )\n        ]\n\n-}\ndefaults : RuleConfig\ndefaults =\n    RuleConfig\n        { sortUnknown = Alphabetically\n        , sortAmbiguous = Alphabetically\n        , sortGenerics = GenericFieldsFirst\n        , subrecordTreatment = CanonicalWhenSubrecord\n        , typecheckUnambiguousRecords = False\n        }"},{"$":1,"a":{"bV":{"bb":24,"bp":377},"ch":{"bb":1,"bp":373}},"b":"{-| By default, generic fields are placed before others; this alters that\nbehavior to place them at the end instead, e.g.\n\n    type alias A =\n        { z : Int, y : Int, x : Int }\n\n    type alias Generic record =\n        { record | foo : Int, bar : Int, baz : Int }\n\n    rec : Generic A\n    rec =\n        { foo = 1, bar = 2, baz = 3, z = 4, y = 5, x = 6 }\n\n-}\nsortGenericFieldsLast : RuleConfig -> RuleConfig\nsortGenericFieldsLast (RuleConfig r) =\n    RuleConfig { r | sortGenerics = GenericFieldsLast }"},{"$":1,"a":{"bV":{"bb":16,"bp":385},"ch":{"bb":1,"bp":380}},"b":"{-| By default, records that match multiple known aliases with different field\norders are sorted alphabetically. (If the field orders of the various matches\nare identical, then it is not ambiguous.) This disables that behavior, leaving\nthem in their base sorting instead.\n-}\ndoNotSortAmbiguousRecords : RuleConfig -> RuleConfig\ndoNotSortAmbiguousRecords (RuleConfig r) =\n    RuleConfig { r | sortAmbiguous = DoNotSort }"},{"$":1,"a":{"bV":{"bb":10,"bp":422},"ch":{"bb":1,"bp":388}},"b":"{-| By default, records that match multiple known aliases with different field\norders are sorted alphabetically. (If the field orders of the various matches\nare identical, then it is not ambiguous.) This disables that behavior, reporting\nthem as ambiguous without automatically fixing them. This is useful if you want\nto catch ambiguous records and e.g. provide type annotations to make them\nunambiguous.\n-}\nreportAmbiguousRecordsWithoutFix : RuleConfig -> RuleConfig\nreportAmbiguousRecordsWithoutFix (RuleConfig r) =\n    RuleConfig { r | sortAmbiguous = ReportOnly }"},{"$":1,"a":{"bV":{"bb":58,"bp":434},"ch":{"bb":1,"bp":425}},"b":"{-| By default, records that do not match any known aliases or custom types are\nsorted alphabetically. This disables that behavior, leaving them in their base\nsorting.\n-}\ndoNotSortUnknownRecords : RuleConfig -> RuleConfig\ndoNotSortUnknownRecords (RuleConfig r) =\n    RuleConfig { r | sortUnknown = DoNotSort }"},{"$":1,"a":{"bV":{"bb":58,"bp":463},"ch":{"bb":1,"bp":437}},"b":"{-| By default, records that do not match any known aliases or custom types are\nsorted alphabetically. This disables that behavior, reporting them as unknown\nwithout automatically fixing them.\n\nNote that this will effectively forbid the use of _ad hoc_/anonymous records!\n\n-}\nreportUnknownRecordsWithoutFix : RuleConfig -> RuleConfig\nreportUnknownRecordsWithoutFix (RuleConfig r) =\n    RuleConfig { r | sortUnknown = ReportOnly }"},{"$":1,"a":{"bV":{"bb":74,"bp":486},"ch":{"bb":1,"bp":466}},"b":"{-| By default, anonymous records within known records and within custom type\nconstructors are sorted by their declaration order when encountered in the\ncontext of their outer record/constructor. This disables that behavior,\ntreating them the same as any other unknown record.\n\nFor example:\n\n    type A\n        = A { foo : Int, bar : Int, baz : Int }\n\n    type alias Rec =\n        { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\n    thisWillBeUnknown =\n        A { bar = 1, baz = 2, foo = 3 }\n\n    and =\n        { yi =\n            -- This will also be unknown\n            { bar = 1, baz = 2, foo = 3 }\n        , er = 1\n        }\n\n-}\ntreatSubrecordsAsUnknown : RuleConfig -> RuleConfig\ntreatSubrecordsAsUnknown (RuleConfig r) =\n    RuleConfig { r | subrecordTreatment = AlwaysUnknown }"},{"$":1,"a":{"bV":{"bb":47,"bp":517},"ch":{"bb":1,"bp":511}},"b":"{-| By default, anonymous records within known records and within custom type\nconstructors are sorted by their declaration order when encountered in the\ncontext of their outer record/constructor. This extends that behavior to sort\ncustom type args even when encountered alone (i.e. not in the context of their\nconstructor. This was the behavior prior to version `1.1.0` and thus this\nsetting is provided for compatibility. Note that canonical records will always\ntake priority, however.\n\nFor example:\n\n    type A\n        = A { foo : Int, bar : Int, baz : Int }\n\n    thisWillHaveCanonicalOrder =\n        -- Even though it does not appear in the context of `A`\n        { foo = 3, bar = 1, baz = 2 }\n\n-}\ntreatCustomTypeRecordsAsCanonical : RuleConfig -> RuleConfig\ntreatCustomTypeRecordsAsCanonical (RuleConfig r) =\n    RuleConfig { r | subrecordTreatment = CustomTypeArgsAlwaysCanonical }"},{"$":1,"a":{"bV":{"bb":49,"bp":527},"ch":{"bb":1,"bp":520}},"b":"{-| By default, typechecking is only used to disambiguate records. This alters\nthat behavior to typecheck _all_ records. For instance, this will force\n`{ foo = 1, bar = 2 }` to be an \"unknown\" record if\n`{ foo : String, bar : String }` is known. This should probably be left turned\noff, unless you wish to help find examples of incorrect type inference by this\nrule.\n-}\ntypecheckAllRecords : RuleConfig -> RuleConfig\ntypecheckAllRecords (RuleConfig r) =\n    RuleConfig { r | typecheckUnambiguousRecords = True }"},{"$":1,"a":{"bV":{"bb":48,"bp":539},"ch":{"bb":1,"bp":530}},"b":"{-| Report that an ambiguous record was encountered, along with a list of\nmatching type aliases.\n-}\nambiguousRecordError : RecordToCheck -> List (List String) -> Range -> List (Error {})\nambiguousRecordError { fields } matching range =\n    let\n        prettyGeneric : List String -> String\n        prettyGeneric s =\n            case s of\n                [] ->\n                    \"\"\n\n                [ x ] ->\n                    x\n\n                x :: xs ->\n                    x ++ \" (\" ++ prettyGeneric xs ++ \")\"\n    in\n    case fields of\n        _ :: _ :: _ ->\n            [ Rule.error\n                { message = \"Ambiguous record encountered.\"\n                , details =\n                    [ \"This record could be one of several possible record aliases, so whether or not its fields are sorted could not be determined!\"\n                    , \"Try adding a type annotation, or remove reportAmbiguousRecordsWithoutFix from your rule configuration.\"\n                    , \"The record matched the following possible aliases: \" ++ String.join \", \" (List.map prettyGeneric (List.sort matching))\n                    ]\n                }\n                range\n            ]\n\n        _ ->\n            -- Do not report 0 or 1 field records\n            []"},{"$":1,"a":{"bV":{"bb":50,"bp":551},"ch":{"bb":1,"bp":542}},"b":"{-| Convert a type annotation into a record definition (and whether or not the\nrecord is generic) if it is one.\n-}\nannotToFields : Node TypeAnnotation -> Maybe ( RecordDefinition, Bool )\nannotToFields annot =\n    case Node.value annot of\n        TypeAnnotation.Record fields ->\n            Just ( fields, False )\n\n        GenericRecord _ fields ->\n            Just ( Node.value fields, True )\n\n        _ ->\n            Nothing"},{"$":1,"a":{"bV":{"bb":56,"bp":570},"ch":{"bb":1,"bp":554}},"b":"{-| Assign a list of positional type vars.\n-}\nassignPositionalTypeVars : List Type -> TypeWithPositionalVars -> Type\nassignPositionalTypeVars ts t =\n    List.indexedMap (\\i -> Tuple.pair (\"positional arg \" ++ String.fromInt i)) ts\n        |> Dict.fromList\n        |> (\\vars -> assignTypeVars vars (DereferencedType <| getTypeWithPositionalVars t))\n        |> getType"},{"$":1,"a":{"bV":{"bb":6,"bp":579},"ch":{"bb":1,"bp":573}},"b":"{-| Assign type vars to a type.\n-}\nassignTypeVars : Dict String Type -> DereferencedType -> DereferencedType\nassignTypeVars typeVars type_ =\n    let\n        go : Type -> Type\n        go t =\n            case t of\n                FunctionType { from, to } ->\n                    FunctionType { from = go from, to = go to }\n\n                TupleType ts ->\n                    TupleType <| List.map go ts\n\n                ListType t_ ->\n                    ListType <| go t_\n\n                NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )\n\n                RecordType r ->\n                    RecordType\n                        { r\n                            | fields = List.map (Tuple.mapSecond go) r.fields\n                            , generic = Maybe.map go r.generic\n                        }\n\n                TypeVar _ var ->\n                    Dict.get var typeVars\n                        |> Maybe.withDefault t\n\n                UnitType ->\n                    UnitType\n    in\n    DereferencedType <| go <| getType type_"},{"$":1,"a":{"bV":{"bb":70,"bp":585},"ch":{"bb":1,"bp":582}},"b":"{-| Get (a best guess) at the bindings from a let declaration.\n-}\nbindingsFromLetDeclaration : LocalContext -> LetDeclaration -> List ( String, Type )\nbindingsFromLetDeclaration local d =\n    case d of\n        LetFunction f ->\n            getFunctionBinding local.context f\n                |> Maybe.map (Tuple.mapSecond getType)\n                |> MaybeX.orElseLazy\n                    (\\() ->\n                        Node.value f.declaration\n                            |> (\\{ name, expression } ->\n                                    inferExprType local expression\n                                        |> Maybe.map getType\n                                        |> Maybe.map (Tuple.pair (Node.value name))\n                               )\n                    )\n                |> Maybe.map List.singleton\n                |> Maybe.withDefault []\n\n        LetDestructuring p e ->\n            -- Try to infer type of e for type info, since destructuring can't have type annotations\n            inferExprType local e\n                |> bindingsInPatternWithType local.context p"},{"$":1,"a":{"bV":{"bb":6,"bp":595},"ch":{"bb":1,"bp":588}},"b":"{-| Get all new bindings and their types from a pattern.\n-}\nbindingsInPatternWithType : ModuleContext -> Node Pattern -> Maybe DereferencedType -> List ( String, Type )\nbindingsInPatternWithType context pattern type_ =\n    let\n        go : Node Pattern -> Maybe DereferencedType -> List ( String, Type )\n        go =\n            bindingsInPatternWithType context\n\n        makeType : String -> Maybe DereferencedType -> List ( String, Type )\n        makeType n t =\n            Maybe.map getType t\n                |> Maybe.map (List.singleton << Tuple.pair n)\n                |> Maybe.withDefault []\n    in\n    case Node.value pattern of\n        ListPattern ps ->\n            getListType type_\n                |> (\\t -> List.concatMap (\\p -> go p t) ps)\n\n        TuplePattern ps ->\n            getTupleTypes ps type_\n                |> List.map2 go ps\n                |> List.concat\n\n        RecordPattern ps ->\n            getRecordFieldTypes type_\n                |> (\\ts ->\n                        List.map\n                            (\\p ->\n                                Dict.get (Node.value p) ts\n                                    |> makeType (Node.value p)\n                            )\n                            ps\n                   )\n                |> List.concat\n\n        NamedPattern { name } ps ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } type_ pattern name\n                |> Maybe.map (List.map2 (\\p t -> go p (Just t)) ps)\n                |> Maybe.map List.concat\n                -- No type info\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (\\p -> go p Nothing) ps)\n\n        UnConsPattern p ps ->\n            -- `p` has type in list, and `ps` is overall list type\n            getListType type_\n                |> (\\t -> go p t ++ go ps type_)\n\n        VarPattern name ->\n            -- Bind `name` to the overall type\n            makeType name type_\n\n        AsPattern p name ->\n            -- Bind `name` to overall type and then descend\n            makeType (Node.value name) type_ ++ go p type_\n\n        ParenthesizedPattern p ->\n            -- Parentheses don't affect type\n            go p type_\n\n        _ ->\n            -- No bindings in:\n            -- AllPattern\n            -- UnitPattern\n            -- CharPattern\n            -- StringPattern\n            -- IntPattern\n            -- HexPattern\n            -- FloatPattern\n            []"},{"$":1,"a":{"bV":{"bb":10,"bp":604},"ch":{"bb":1,"bp":598}},"b":"{-| Check a chain of expressions being applied to the first one, as we can glean\nadditional info from any stored function types we have.\n-}\ncheckApplicationChain : RuleConfig -> LocalContext -> Maybe DereferencedType -> List (Node Expression) -> List (Error {})\ncheckApplicationChain config local hasType es =\n    let\n        checkExpr : Maybe DereferencedType -> Node Expression -> List (Error {})\n        checkExpr =\n            checkExpression config local\n    in\n    case es of\n        [] ->\n            []\n\n        [ e ] ->\n            checkExpr hasType e\n\n        func :: args ->\n            case Node.value func of\n                FunctionOrValue _ name ->\n                    findFunctionType local hasType func name\n                        |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                        |> Maybe.map\n                            (\\( argTypes, return ) ->\n                                -- Assign type vars\n                                Maybe.map (typesMatch Dict.empty return) hasType\n                                    |> Maybe.map Tuple.first\n                                    |> Maybe.map (Dict.filter (\\( i, _ ) _ -> i == 1))\n                                    |> Maybe.map (DictX.mapKeys Tuple.second)\n                                    |> Maybe.map (\\typeVars -> List.map (assignTypeVars typeVars) argTypes)\n                                    |> Maybe.withDefault argTypes\n                            )\n                        |> Maybe.map (List.map2 (\\e t -> checkExpr (Just t) e) args)\n                        |> Maybe.map List.concat\n                        -- Couldn't find the function type, so type info is gone now\n                        |> MaybeX.withDefaultLazy (\\() -> List.concatMap (checkExpr Nothing) es)\n\n                PrefixOperator op ->\n                    findOperatorType local.context op\n                        |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                        |> Maybe.map\n                            (\\( argTypes, return ) ->\n                                -- Assign type vars\n                                Maybe.map (typesMatch Dict.empty return) hasType\n                                    |> Maybe.map Tuple.first\n                                    |> Maybe.map (Dict.filter (\\( i, _ ) _ -> i == 1))\n                                    |> Maybe.map (DictX.mapKeys Tuple.second)\n                                    |> Maybe.map (\\typeVars -> List.map (assignTypeVars typeVars) argTypes)\n                                    |> Maybe.withDefault argTypes\n                            )\n                        |> Maybe.map (List.map2 (\\e t -> checkExpr (Just t) e) args)\n                        |> Maybe.map List.concat\n                        -- Couldn't find the function type, so type info is gone now\n                        |> MaybeX.withDefaultLazy (\\() -> List.concatMap (checkExpr Nothing) es)\n\n                ParenthesizedExpression func_ ->\n                    -- Unwrap the parentheses\n                    checkApplicationChain config local hasType (func_ :: args)\n\n                RecordAccessFunction accessFunc ->\n                    checkExpr (makeRecordAccessType hasType accessFunc)\n                        -- Assume there is only one argument, because if not, it's a type error\n                        |> (\\f -> List.concatMap f args)\n\n                _ ->\n                    -- * This is valid application, but we can't infer the type\n                    -- LambdaExpression Lambda\n                    -- * These are possibly valid, but can't infer the \"return\" type of the block\n                    -- Application (List (Node Expression))\n                    -- LetExpression LetBlock\n                    -- CaseExpression CaseBlock\n                    -- IfBlock (Node Expression) (Node Expression) (Node Expression)\n                    -- OperatorApplication String InfixDirection (Node Expression) (Node Expression)\n                    -- RecordAccess (Node Expression) (Node String)\n                    -- * Cannot apply args to non-functions\n                    -- UnitExpr\n                    -- GLSLExpression String\n                    -- List.concatMap (checkExpr Nothing) es\n                    -- RecordUpdateExpression (Node String) (List (Node RecordSetter))\n                    -- ListExpr (List (Node Expression))\n                    -- RecordExpr (List (Node RecordSetter))\n                    -- Literal String\n                    -- CharLiteral Char\n                    -- TupledExpression (List (Node Expression))\n                    -- Integer Int\n                    -- Hex Int\n                    -- Floatable Float\n                    -- Operator String\n                    -- Negation (Node Expression)\n                    List.concatMap (checkExpr Nothing) es"},{"$":1,"a":{"bV":{"bb":31,"bp":612},"ch":{"bb":1,"bp":607}},"b":"{-| Descend into subexpressions, keeping as much type information as possible.\n-}\ncheckExpression : RuleConfig -> LocalContext -> Maybe DereferencedType -> Node Expression -> List (Error {})\ncheckExpression config local hasType node =\n    let\n        go : Maybe DereferencedType -> Node Expression -> List (Error {})\n        go =\n            checkExpression config local\n\n        checkFields : Dict String DereferencedType -> List ( Node String, Node Expression ) -> ( List (Error {}), Dict String Type ) -> List (Error {})\n        checkFields typeInfo fields ( parentError, canonicalTypeInfoFromParent ) =\n            parentError\n                ++ List.concatMap\n                    (\\( field, e ) ->\n                        let\n                            f : String\n                            f =\n                                Node.value field\n                        in\n                        Dict.get f canonicalTypeInfoFromParent\n                            |> Maybe.map (dereferenceType local.context)\n                            |> MaybeX.orElseLazy (\\() -> Dict.get f typeInfo)\n                            |> (\\t -> go t e)\n                    )\n                    fields\n    in\n    case Node.value node of\n        -- Simple patterns simply descend into sub expressions of, unwrapping type if necessary\n        Negation e ->\n            -- Negation doesn't change a type\n            go hasType e\n\n        ParenthesizedExpression e ->\n            -- Parentheses don't change a type\n            go hasType e\n\n        ListExpr es ->\n            let\n                -- Lists must have a list type\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) es\n\n        Application es ->\n            -- Try to pull type info from known functions\n            checkApplicationChain config local hasType es\n\n        OperatorApplication op _ e1 e2 ->\n            -- Handle a few known operators\n            checkOperatorApplication (checkApplicationChain config local hasType) op e1 e2\n\n        IfBlock pred thenE elseE ->\n            -- List predicate must have type Bool and branches have same type as overall\n            go (Just <| DereferencedType <| NamedType ( [ \"Basics\" ], \"Bool\" ) []) pred ++ go hasType thenE ++ go hasType elseE\n\n        TupledExpression es ->\n            -- Tuples must have a tuple type\n            List.map2 go (getTupleTypes es hasType) es\n                |> List.concat\n\n        CaseExpression { expression, cases } ->\n            -- Try to infer type of case expression for patterns\n            -- Branches have same type as overall\n            let\n                caseType : Maybe DereferencedType\n                caseType =\n                    inferExprType local expression\n            in\n            go Nothing expression\n                ++ List.concatMap\n                    (\\( p, e ) ->\n                        bindingsInPatternWithType local.context p caseType\n                            |> Dict.fromList\n                            |> (\\newBindings ->\n                                    checkExpression config { local | localFunctions = Dict.union local.localFunctions newBindings } hasType e\n                               )\n                    )\n                    cases\n                ++ List.concatMap (checkPattern config local.context caseType << Tuple.first) cases\n\n        LambdaExpression { args, expression } ->\n            -- Check as a function\n            checkFunctionArgsAndExpr config local hasType args expression\n\n        LetExpression { declarations, expression } ->\n            -- Create new bindings from any that have type info\n            let\n                ( newBindings, decsToCheck ) =\n                    List.map (checkLetDeclaration config local << Node.value) declarations\n                        |> List.unzip\n                        |> Tuple.mapFirst (Dict.fromList << List.concat)\n\n                newContext : LocalContext\n                newContext =\n                    { local | localFunctions = Dict.union local.localFunctions newBindings }\n            in\n            checkExpression config newContext hasType expression\n                ++ List.concatMap (\\f -> f newContext) decsToCheck\n\n        RecordExpr recordSetters ->\n            -- A record expression has to have all fields of the known record\n            let\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes hasType\n            in\n            recordSettersToCheckable local (Node.range node) True hasType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)\n\n        RecordUpdateExpression _ recordSetters ->\n            -- A record update must have the same type as the record, so type is useful\n            -- A record update expression does not have to have all fields of the known record\n            let\n                updateType : Maybe DereferencedType\n                updateType =\n                    -- Get type from updated var if we don't have a good annotation\n                    hasType\n                        |> MaybeX.orElseLazy (\\() -> inferExprType local node)\n\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes updateType\n            in\n            recordSettersToCheckable local (Node.range node) False updateType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)\n\n        RecordAccess e accessFunc ->\n            go (makeRecordAccessType hasType <| Node.value accessFunc) e\n\n        _ ->\n            -- The following neither have subexpressions nor are a record and so are dead ends\n            -- UnitExpr\n            -- PrefixOperator String\n            -- Operator String\n            -- Integer Int\n            -- Hex Int\n            -- Floatable Float\n            -- GLSLExpression String\n            -- RecordAccessFunction String\n            -- Literal String\n            -- CharLiteral Char\n            -- FunctionOrValue ModuleName String\n            []"},{"$":1,"a":{"bV":{"bb":19,"bp":620},"ch":{"bb":1,"bp":615}},"b":"{-| Check the arguments to a function (for unsorted patterns) and its\nexpression, possibly having been given a type annotation.\n-}\ncheckFunctionArgsAndExpr : RuleConfig -> LocalContext -> Maybe DereferencedType -> List (Node Pattern) -> Node Expression -> List (Error {})\ncheckFunctionArgsAndExpr config local hasType args expr =\n    let\n        ( argTypes, exprType ) =\n            Maybe.map flattenFunctionType hasType\n                |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                |> Maybe.map (Tuple.mapBoth (List.map Just) Just)\n                |> MaybeX.withDefaultLazy (\\() -> ( List.map (always Nothing) args, Nothing ))\n\n        newBindings : Dict String Type\n        newBindings =\n            List.map2 (bindingsInPatternWithType local.context) args argTypes\n                |> List.concat\n                |> Dict.fromList\n    in\n    checkExpression config { local | localFunctions = Dict.union local.localFunctions newBindings } exprType expr\n        ++ List.concat (List.map2 (checkPattern config local.context) argTypes args)"},{"$":1,"a":{"bV":{"bb":39,"bp":638},"ch":{"bb":1,"bp":623}},"b":"{-| Check a function declaration for unsorted record signatures, patterns, or\nexpressions.\n-}\ncheckFunctionDeclaration : RuleConfig -> LocalContext -> Function -> List (Error {})\ncheckFunctionDeclaration config local func =\n    let\n        { arguments, expression } =\n            Node.value func.declaration\n\n        hasType : Maybe DereferencedType\n        hasType =\n            getFunctionBinding local.context func\n                |> Maybe.map Tuple.second\n    in\n    Maybe.map (checkTypeAnnotation config local.context Nothing << .typeAnnotation << Node.value) func.signature\n        |> Maybe.withDefault []\n        |> (\\errsInAnnot -> errsInAnnot ++ checkFunctionArgsAndExpr config local hasType arguments expression)"},{"$":1,"a":{"bV":{"bb":17,"bp":647},"ch":{"bb":1,"bp":641}},"b":"{-| Generate a list of bindings from a `let` declaration as well as check them\nfor errors (when provided with the new context that includes all new `let`\nbindings. Note that type inference isn't performed with new bindings.\n-}\ncheckLetDeclaration : RuleConfig -> LocalContext -> LetDeclaration -> ( List ( String, Type ), LocalContext -> List (Error {}) )\ncheckLetDeclaration config local d =\n    (case d of\n        LetFunction f ->\n            \\local_ -> checkFunctionDeclaration config local_ f\n\n        LetDestructuring p e ->\n            -- Try to infer type of e for type info, since destructuring can't have type annotations\n            \\local_ -> checkExpression config local_ Nothing e ++ checkPattern config local.context (inferExprType local_ e) p\n    )\n        |> Tuple.pair (bindingsFromLetDeclaration local d)"},{"$":1,"a":{"bV":{"bb":28,"bp":653},"ch":{"bb":1,"bp":650}},"b":"{-| Handle the few common operators we expect to see records passed through.\n-}\ncheckOperatorApplication : (List (Node Expression) -> a) -> String -> Node Expression -> Node Expression -> a\ncheckOperatorApplication checkApp op e1 e2 =\n    case op of\n        \"|>\" ->\n            checkApp [ e2, e1 ]\n\n        \"<|\" ->\n            checkApp [ e1, e2 ]\n\n        _ ->\n            -- Other operators, we don't know (or rather care) what they do, so just treat them like functions\n            checkApp [ Node Range.emptyRange <| PrefixOperator op, e1, e2 ]"},{"$":1,"a":{"bV":{"bb":34,"bp":660},"ch":{"bb":1,"bp":656}},"b":"{-| Descend into pattern, keeping as much type information as possible.\n-}\ncheckPattern : RuleConfig -> ModuleContext -> Maybe DereferencedType -> Node Pattern -> List (Error {})\ncheckPattern config context hasType node =\n    let\n        go : Maybe DereferencedType -> Node Pattern -> List (Error {})\n        go =\n            checkPattern config context\n    in\n    case Node.value node of\n        TuplePattern ps ->\n            -- Tuples must have a tuple type\n            List.map2 go (getTupleTypes ps hasType) ps\n                |> List.concat\n\n        UnConsPattern p ps ->\n            let\n                -- Uncons has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            go type_ p ++ go type_ ps\n\n        ListPattern ps ->\n            let\n                -- List pattern has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) ps\n\n        AsPattern p _ ->\n            -- As pattern does not change type\n            go hasType p\n\n        ParenthesizedPattern p ->\n            -- Parentheses do not change type\n            go hasType p\n\n        NamedPattern { name } pats ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } hasType node name\n                |> Maybe.map (List.map2 (\\p t -> go (Just t) p) pats)\n                |> Maybe.map List.concat\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (go Nothing) pats)\n\n        RecordPattern fields ->\n            recordPatternToCheckable (Node.range node) hasType fields\n                |> checkRecord config context\n                -- No such thing as subrecords for patterns, so we can just return the errors\n                |> Tuple.first\n\n        _ ->\n            -- Neither can descend into nor check:\n            -- AllPattern\n            -- UnitPattern\n            -- CharPattern Char\n            -- StringPattern String\n            -- IntPattern Int\n            -- HexPattern Int\n            -- FloatPattern Float\n            -- VarPattern String\n            []"},{"$":1,"a":{"bV":{"bb":6,"bp":680},"ch":{"bb":1,"bp":663}},"b":"{-| Once a record has been reduced to a standard format, check its sorting,\nreturning a list of canonical field types, if any were found.\n-}\ncheckRecord : RuleConfig -> ModuleContext -> RecordToCheck -> ( List (Error {}), Dict String Type )\ncheckRecord ((RuleConfig { sortUnknown, sortAmbiguous, sortGenerics }) as config) context ({ fullRange, orderInfo, fields } as record) =\n    let\n        errorRange : Range\n        errorRange =\n            let\n                s : Location\n                s =\n                    fullRange.start\n            in\n            -- Assume opening `{` is just the first character of the range.\n            { start = s, end = { s | column = s.column + 1 } }\n\n        matchingOrders :\n            ( List\n                { typeName : List ( ModuleName, String )\n                , fieldOrder : Dict String Int\n                , hasUnknownFields : Bool\n                , canonicalFieldTypes : Dict String Type\n                , isSubrecord : Bool\n                }\n            , Bool\n            )\n        matchingOrders =\n            findMatchingTypes config context orderInfo fields\n                |> List.map\n                    (\\{ typeName, fieldOrder, isSubrecord } ->\n                        makeOrder sortGenerics fields fieldOrder\n                            |> (\\o ->\n                                    ( Dict.toList o.fieldOrder\n                                    , { typeName = typeName\n                                      , fieldOrder = o.fieldOrder\n                                      , hasUnknownFields = o.hasUnknownFields\n                                      , canonicalFieldTypes = o.canonicalFieldTypes\n                                      , isSubrecord = isSubrecord\n                                      }\n                                    )\n                               )\n                    )\n                -- Dedupe by field order\n                |> DictX.fromListDedupe\n                    (\\o1 o2 ->\n                        (if o1.hasUnknownFields then\n                            -- Prefer matches without unknown fields\n                            o2\n\n                         else\n                            o1\n                        )\n                            |> (\\o ->\n                                    -- Keep only matching field types between duplicate orders\n                                    { o | canonicalFieldTypes = keepOnlyMatchingFieldTypes o.canonicalFieldTypes o2.canonicalFieldTypes }\n                               )\n                    )\n                |> Dict.values\n                |> List.partition .hasUnknownFields\n                |> Tuple.mapBoth (List.partition .isSubrecord) (List.partition .isSubrecord)\n                |> (\\os ->\n                        case os of\n                            -- Prefer matches without unknown fields and that are not subrecords\n                            ( ( unknownIsSubrecord, [] ), ( [], [] ) ) ->\n                                ( unknownIsSubrecord, True )\n\n                            ( ( _, unknownNotSubrecord ), ( [], [] ) ) ->\n                                ( unknownNotSubrecord, True )\n\n                            ( _, ( noUnknownIsSubrecord, [] ) ) ->\n                                ( noUnknownIsSubrecord, False )\n\n                            ( _, ( _, noUnknownNotSubrecord ) ) ->\n                                ( noUnknownNotSubrecord, False )\n                   )\n\n        alphabetical : Field -> Field -> Order\n        alphabetical f1 f2 =\n            compare f1.field f2.field\n\n        byFieldOrder : Dict String Int -> Field -> Field -> Order\n        byFieldOrder ord f1 f2 =\n            let\n                o : String -> Int\n                o f =\n                    Dict.get f ord\n                        |> Maybe.withDefault -1\n            in\n            compare (o f1.field) (o f2.field)\n\n        checkSortingBy : (Field -> Field -> Order) -> List (Error {})\n        checkSortingBy o =\n            checkSorting context.extractSource \"Record fields\" [ o ] errorRange fields\n\n        handleUnknown : (Field -> Field -> Order) -> List (Error {})\n        handleUnknown whenAlphabetical =\n            case sortUnknown of\n                Alphabetically ->\n                    -- Unknown record, so sort alphabetically if config says to\n                    checkSortingBy whenAlphabetical\n\n                ReportOnly ->\n                    -- Unknown record, so report without fixes\n                    unknownRecordError record fullRange\n\n                DoNotSort ->\n                    -- Unknown record; don't sort it\n                    []\n    in\n    case matchingOrders of\n        ( [], _ ) ->\n            -- Completely unknown record, so no type data\n            -- Sort alphabetically if config says to\n            ( handleUnknown alphabetical, Dict.empty )\n\n        ( [ { fieldOrder, canonicalFieldTypes } ], True ) ->\n            -- Generic with unknown fields, so sort accordingly and use what type info we have\n            ( handleUnknown (byFieldOrder fieldOrder), canonicalFieldTypes )\n\n        ( [ { fieldOrder, canonicalFieldTypes } ], False ) ->\n            -- Unambiguous record\n            ( checkSortingBy <| byFieldOrder fieldOrder, canonicalFieldTypes )\n\n        ( ambiguous, _ ) ->\n            --Ambiguous record\n            let\n                unambiguousFieldTypes : Dict String Type\n                unambiguousFieldTypes =\n                    -- Keep any fields that have identical types despite the ambiguity\n                    List.foldl (\\{ canonicalFieldTypes } acc -> keepOnlyMatchingFieldTypes canonicalFieldTypes acc)\n                        Dict.empty\n                        ambiguous\n            in\n            case sortAmbiguous of\n                Alphabetically ->\n                    -- Sort alphabetically if config says to\n                    ( checkSortingBy alphabetical, unambiguousFieldTypes )\n\n                ReportOnly ->\n                    -- Report without fixes if config says to\n                    ( ambiguousRecordError record (List.map (List.map (\\( m, n ) -> String.join \".\" <| m ++ [ n ]) << .typeName) ambiguous) fullRange\n                    , unambiguousFieldTypes\n                    )\n\n                DoNotSort ->\n                    -- Do not sort if config says not to\n                    ( [], unambiguousFieldTypes )"},{"$":1,"a":{"bV":{"bb":6,"bp":711},"ch":{"bb":1,"bp":683}},"b":"{-| Descend into type annotations, checking for unsorted records.\n-}\ncheckTypeAnnotation : RuleConfig -> ModuleContext -> Maybe DereferencedType -> Node TypeAnnotation -> List (Error {})\ncheckTypeAnnotation config context hasTypeFromParent type_ =\n    let\n        go : Maybe DereferencedType -> Node TypeAnnotation -> List (Error {})\n        go =\n            checkTypeAnnotation config context\n\n        checkFields : List ( Node String, Node TypeAnnotation ) -> ( List (Error {}), Dict String Type ) -> List (Error {})\n        checkFields fields ( parentError, canonicalTypeInfoFromParent ) =\n            parentError\n                ++ List.concatMap\n                    (\\( field, a ) ->\n                        Dict.get (Node.value field) canonicalTypeInfoFromParent\n                            |> Maybe.map (dereferenceType context)\n                            |> (\\t -> checkTypeAnnotation config context t a)\n                    )\n                    fields\n    in\n    case Node.value type_ of\n        -- Records are simply records\n        Record def ->\n            (recordDefToCheckable context (Node.range type_) True hasTypeFromParent def\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value def)\n\n        GenericRecord _ def ->\n            (recordDefToCheckable context (Node.range type_) False hasTypeFromParent (Node.value def)\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value <| Node.value def)\n\n        -- Descend into functions, tuples, and custom types\n        FunctionTypeAnnotation fromA toA ->\n            let\n                ( fromType, toType ) =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (FunctionType { from, to }) ->\n                            ( Just <| DereferencedType from, Just <| DereferencedType to )\n\n                        _ ->\n                            ( Nothing, Nothing )\n            in\n            go fromType fromA ++ go toType toA\n\n        Tupled types_ ->\n            -- Tuples must have a tuple type\n            List.map2 go (getTupleTypes types_ hasTypeFromParent) types_\n                |> List.concat\n\n        Typed _ types_ ->\n            let\n                typeVars : List (Maybe DereferencedType)\n                typeVars =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (NamedType _ ts) ->\n                            List.map (Just << DereferencedType) ts\n\n                        Just (ListType t) ->\n                            [ Just <| DereferencedType t ]\n\n                        _ ->\n                            List.map (always Nothing) types_\n            in\n            List.map2 go typeVars types_\n                |> List.concat\n\n        -- Generic and unit types are dead ends\n        GenericType _ ->\n            []\n\n        Unit ->\n            []"},{"$":1,"a":{"bV":{"bb":6,"bp":720},"ch":{"bb":1,"bp":714}},"b":"{-| Visit each TLD and check it in turn.\n-}\ndeclarationEnterVisitor : RuleConfig -> ModuleContext -> Node Declaration -> List (Error {})\ndeclarationEnterVisitor config context node =\n    case Node.value node of\n        FunctionDeclaration f ->\n            checkFunctionDeclaration config { context = context, localFunctions = Dict.empty } f\n\n        _ ->\n            []"},{"$":1,"a":{"bV":{"bb":14,"bp":736},"ch":{"bb":1,"bp":723}},"b":"{-| Visit declarations, storing record field orders.\n-}\ndeclarationListVisitor :\n    RuleConfig\n    ->\n        { moduleName : ModuleName\n        , lookupTable : ModuleNameLookupTable\n        , aliases : Dict ModuleName (Dict String TypeWithPositionalVars)\n        , canonicalRecords : Dict ModuleName (Dict String KnownRecord)\n        , constructors : Dict ModuleName (Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars })\n        , functionTypes : Dict ModuleName (Dict String Type)\n        , exposingList : Maybe ExposedNames\n        , fileIsIgnored : Bool\n        }\n    -> List (Node Declaration)\n    ->\n        { aliases : Dict ModuleName (Dict String TypeWithPositionalVars)\n        , canonicalRecords : Dict ModuleName (Dict String KnownRecord)\n        , constructors : Dict ModuleName (Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars })\n        , functionTypes : Dict ModuleName (Dict String Type)\n        , exposed :\n            { aliases : Dict String TypeWithPositionalVars\n            , canonicalRecords : Dict String KnownRecord\n            , constructors : Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars }\n            , functionTypes : Dict String Type\n            }\n        }\ndeclarationListVisitor (RuleConfig { subrecordTreatment }) context declarations =\n    -- Find aliases, canonical records, and function types and store them\n    List.foldl (processDeclaration subrecordTreatment context)\n        { aliases = []\n        , canonicalRecords = []\n        , constructors = []\n        , functionTypes = []\n        , exposedAliases = []\n        , exposedCanonicalRecords = []\n        , exposedConstructors = []\n        , exposedFunctionTypes = []\n        }\n        declarations\n        |> (\\r ->\n                if context.fileIsIgnored then\n                    { aliases = Dict.empty\n                    , canonicalRecords = Dict.empty\n                    , constructors = Dict.empty\n                    , functionTypes = Dict.empty\n                    , exposed =\n                        { aliases =\n                            Dict.fromList r.exposedAliases\n                        , canonicalRecords =\n                            Dict.fromList r.exposedCanonicalRecords\n                        , constructors =\n                            Dict.fromList r.exposedConstructors\n                        , functionTypes =\n                            Dict.fromList r.exposedFunctionTypes\n                        }\n                    }\n\n                else\n                    { aliases =\n                        validate (not << List.isEmpty) r.aliases\n                            |> Maybe.map Dict.fromList\n                            |> MaybeX.unwrap context.aliases (\\v -> Dict.insert context.moduleName v context.aliases)\n                    , canonicalRecords =\n                        validate (not << List.isEmpty) r.canonicalRecords\n                            |> Maybe.map Dict.fromList\n                            |> MaybeX.unwrap context.canonicalRecords (\\v -> Dict.insert context.moduleName v context.canonicalRecords)\n                    , constructors =\n                        validate (not << List.isEmpty) r.constructors\n                            |> Maybe.map Dict.fromList\n                            |> MaybeX.unwrap context.constructors (\\v -> Dict.insert context.moduleName v context.constructors)\n                    , functionTypes =\n                        validate (not << List.isEmpty) r.functionTypes\n                            |> Maybe.map Dict.fromList\n                            |> MaybeX.unwrap context.functionTypes (\\v -> Dict.insert context.moduleName v context.functionTypes)\n                    , exposed =\n                        { aliases =\n                            Dict.fromList r.exposedAliases\n                        , canonicalRecords =\n                            Dict.fromList r.exposedCanonicalRecords\n                        , constructors =\n                            Dict.fromList r.exposedConstructors\n                        , functionTypes =\n                            Dict.fromList r.exposedFunctionTypes\n                        }\n                    }\n           )"},{"$":1,"a":{"bV":{"bb":6,"bp":747},"ch":{"bb":1,"bp":739}},"b":"{-| Visit all dependencies and store type order from them.\n-}\ndependencyVisitor : RuleConfig -> ProjectContext -> Dict String Dependency -> ProjectContext\ndependencyVisitor (RuleConfig { subrecordTreatment }) =\n    let\n        step : Elm.Docs.Module -> ProjectContext -> ProjectContext\n        step ({ aliases, binops, unions, values } as mod) acc =\n            let\n                recordFromTypeAlias : Elm.Docs.Alias -> ( List ( String, KnownRecord ), List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } ) )\n                recordFromTypeAlias { name, args, tipe } =\n                    case tipe of\n                        Elm.Type.Record fields Nothing ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, False )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , [ ( name\n                                , { customTypeName = Nothing\n                                  , type_ =\n                                        List.map\n                                            (Tuple.second\n                                                >> docTypeToTypeWithPositionalVars moduleName\n                                                    -- Constrained type vars do apply to record constructors\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Arguments only have order if config says so\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                    }\n                                                    args\n                                            )\n                                            fields\n                                            |> makeFunctionTypeWithPositionalVars\n                                                (docTypeToTypeWithPositionalVars moduleName\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Return type *does* have order\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                    }\n                                                    args\n                                                    tipe\n                                                )\n                                  }\n                                )\n                              ]\n                            )\n\n                        Elm.Type.Record fields (Just _) ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, True )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , -- No constructors for generic records\n                              []\n                            )\n\n                        _ ->\n                            ( [], [] )\n\n                makeAlias : Elm.Docs.Alias -> ( String, TypeWithPositionalVars )\n                makeAlias { name, args, tipe } =\n                    ( name\n                    , docTypeToTypeWithPositionalVars moduleName\n                        -- Constrained type vars aren't respected for type aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        args\n                        tipe\n                    )\n\n                makeConstructor : TypeWithPositionalVars -> List String -> ( String, List Elm.Type.Type ) -> ( String, TypeWithPositionalVars, List ( String, KnownRecord ) )\n                makeConstructor return typeVars ( name, arguments ) =\n                    List.map\n                        (docTypeToTypeWithPositionalVars moduleName\n                            { constrainedTypeVarsAreRespected = True\n\n                            -- Arguments only have order if config says so\n                            , subrecordIsAlsoCanonical =\n                                subrecordCanonicityForField subrecordTreatment\n                            }\n                            typeVars\n                        )\n                        arguments\n                        |> (\\ts ->\n                                ( name\n                                , makeFunctionTypeWithPositionalVars return ts\n                                , makeCustomTypeSubrecords subrecordTreatment name ts\n                                )\n                           )\n\n                functionsFromCustomType : Elm.Docs.Union -> ( List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } ), List ( String, KnownRecord ) )\n                functionsFromCustomType { name, args, tags } =\n                    List.foldl\n                        (\\t ( fAcc, rAcc ) ->\n                            makeConstructor\n                                (List.map (TypeVar Nothing) args\n                                    |> NamedType ( moduleName, name )\n                                    |> DereferencedType\n                                    |> assignTypeVars (makePositionalArgTypeVars args)\n                                    |> getType\n                                    |> TypeWithPositionalVars\n                                )\n                                args\n                                t\n                                |> (\\( n, type_, rs ) ->\n                                        ( ( n, { customTypeName = Just name, type_ = type_ } ) :: fAcc\n                                        , rs ++ rAcc\n                                        )\n                                   )\n                        )\n                        ( [], [] )\n                        tags\n\n                functionFromValue : Elm.Docs.Value -> ( String, Type )\n                functionFromValue { name, tipe } =\n                    docTypeToType moduleName\n                        { constrainedTypeVarsAreRespected = True\n                        , subrecordIsAlsoCanonical = Nothing\n                        }\n                        tipe\n                        |> Tuple.pair name\n\n                functionFromOperator : Elm.Docs.Binop -> ( String, Type )\n                functionFromOperator { name, tipe } =\n                    docTypeToType moduleName\n                        { constrainedTypeVarsAreRespected = True\n                        , subrecordIsAlsoCanonical = Nothing\n                        }\n                        tipe\n                        |> Tuple.pair name\n\n                moduleName : ModuleName\n                moduleName =\n                    String.split \".\" mod.name\n\n                newAliases : Maybe ( ModuleName, Dict String TypeWithPositionalVars )\n                newAliases =\n                    List.map makeAlias aliases\n                        |> validate (not << List.isEmpty)\n                        |> Maybe.map Dict.fromList\n                        |> Maybe.map (Tuple.pair moduleName)\n\n                ( newAliasRecords, newRecordConstructors ) =\n                    List.map recordFromTypeAlias aliases\n                        |> List.unzip\n                        |> Tuple.mapBoth (Dict.fromList << List.concat) (Dict.fromList << List.concat)\n\n                ( newConstructors, newRecords ) =\n                    List.foldl\n                        (\\u ( fAcc, rAcc ) ->\n                            functionsFromCustomType u\n                                |> (\\( fs, rs ) -> ( fs ++ fAcc, rs ++ rAcc ))\n                        )\n                        ( [], [] )\n                        unions\n                        |> Tuple.mapBoth\n                            (Dict.fromList\n                                >> Dict.union newRecordConstructors\n                                >> validate (not << Dict.isEmpty)\n                                >> Maybe.map (Tuple.pair moduleName)\n                            )\n                            (Dict.fromList\n                                >> Dict.union newAliasRecords\n                                >> validate (not << Dict.isEmpty)\n                                >> Maybe.map (Tuple.pair moduleName)\n                            )\n\n                newOperators : Dict String Type\n                newOperators =\n                    List.map functionFromOperator binops\n                        |> Dict.fromList\n\n                newFunctions : Maybe ( ModuleName, Dict String Type )\n                newFunctions =\n                    List.map functionFromValue values\n                        |> Dict.fromList\n                        |> Dict.union newOperators\n                        |> validate (not << Dict.isEmpty)\n                        |> Maybe.map (Tuple.pair moduleName)\n            in\n            { acc\n                | aliases = MaybeX.unwrap acc.aliases (\\( k, v ) -> Dict.insert k v acc.aliases) newAliases\n                , canonicalRecords = MaybeX.unwrap acc.canonicalRecords (\\( k, v ) -> Dict.insert k v acc.canonicalRecords) newRecords\n                , constructors = MaybeX.unwrap acc.constructors (\\( k, v ) -> Dict.insert k v acc.constructors) newConstructors\n                , functionTypes = MaybeX.unwrap acc.functionTypes (\\( k, v ) -> Dict.insert k v acc.functionTypes) newFunctions\n            }\n    in\n    Dict.foldl\n        (\\_ dep acc ->\n            Dependency.modules dep\n                |> List.foldl step initialProjectContext\n                |> (\\{ aliases, canonicalRecords, constructors, functionTypes } ->\n                        { acc\n                            | aliases = Dict.union aliases acc.aliases\n                            , canonicalRecords = Dict.union canonicalRecords acc.canonicalRecords\n                            , constructors = Dict.union constructors acc.constructors\n                            , functionTypes = Dict.union functionTypes acc.functionTypes\n                        }\n                   )\n        )"},{"$":1,"a":{"bV":{"bb":31,"bp":783},"ch":{"bb":1,"bp":750}},"b":"{-| Canonicalize a type, dereferencing all aliases.\n-}\ndereferenceType : ModuleContext -> Type -> DereferencedType\ndereferenceType context type_ =\n    let\n        dropFields : Set String -> Type -> Type\n        dropFields toDrop t =\n            case t of\n                RecordType r ->\n                    RecordType\n                        { r\n                            | fields = List.filter (\\( f, _ ) -> not <| Set.member f toDrop) r.fields\n                            , generic = Maybe.map (dropFields toDrop) r.generic\n                        }\n\n                notARecord ->\n                    notARecord\n\n        go : Type -> Type\n        go t =\n            case t of\n                FunctionType { from, to } ->\n                    FunctionType { from = go from, to = go to }\n\n                TupleType ts ->\n                    TupleType <| List.map go ts\n\n                ListType t_ ->\n                    ListType <| go t_\n\n                NamedType ( moduleName, name ) ts ->\n                    let\n                        ts_ : List Type\n                        ts_ =\n                            List.map go ts\n                    in\n                    Dict.get moduleName context.aliases\n                        |> Maybe.andThen (Dict.get name)\n                        -- Apply type vars\n                        |> Maybe.map (go << assignPositionalTypeVars ts_)\n                        -- If no aliases match, it must be a custom type\n                        |> Maybe.withDefault (NamedType ( moduleName, name ) ts_)\n\n                RecordType r ->\n                    let\n                        fields : List ( String, Type )\n                        fields =\n                            List.map (Tuple.mapSecond go) r.fields\n                    in\n                    RecordType\n                        { r\n                            | fields = fields\n                            , generic =\n                                Maybe.map go r.generic\n                                    -- Generic records overwrite more \"inner\" fields with their outer ones\n                                    |> Maybe.map (dropFields (Set.fromList <| List.map Tuple.first fields))\n                        }\n\n                _ ->\n                    -- UnitType\n                    -- TypeVar\n                    t\n    in\n    DereferencedType <| go type_"},{"$":1,"a":{"bV":{"bb":28,"bp":821},"ch":{"bb":1,"bp":786}},"b":"{-| A type with all aliases dereferenced.\n-}\ntype DereferencedType\n    = DereferencedType Type"},{"$":1,"a":{"bV":{"bb":6,"bp":836},"ch":{"bb":1,"bp":824}},"b":"{-| Given the current module name and whether or not a top-level record type (if\n`Just`) and subrecords (if `Just True`) found are in canonical order, convert an\n`Elm.Type.Type` to a `Type`.\n-}\ndocTypeToType : ModuleName -> { constrainedTypeVarsAreRespected : Bool, subrecordIsAlsoCanonical : Maybe Bool } -> Elm.Type.Type -> Type\ndocTypeToType moduleName ({ constrainedTypeVarsAreRespected, subrecordIsAlsoCanonical } as settings) type_ =\n    let\n        go : Elm.Type.Type -> Type\n        go =\n            MaybeX.filter identity subrecordIsAlsoCanonical\n                |> (\\subrecordStillCanon ->\n                        docTypeToType moduleName { settings | subrecordIsAlsoCanonical = subrecordStillCanon }\n                   )\n\n        makeList : ModuleName -> String -> List Elm.Type.Type -> Maybe Type\n        makeList mod name args =\n            case ( mod, name, args ) of\n                ( [ \"List\" ], \"List\", [ listType ] ) ->\n                    Just <| ListType <| go listType\n\n                _ ->\n                    Nothing\n    in\n    case type_ of\n        Elm.Type.Lambda from to ->\n            FunctionType { from = go from, to = go to }\n\n        Elm.Type.Tuple ts ->\n            TupleType <| List.map go ts\n\n        Elm.Type.Type qualified args ->\n            -- Can't use module name lookup, so just have to hope this is right.\n            String.split \".\" qualified\n                |> ListX.unconsLast\n                |> Maybe.map\n                    (\\( n, m ) ->\n                        if m == [] then\n                            ( moduleName, n )\n\n                        else\n                            ( m, n )\n                    )\n                |> Maybe.withDefault ( moduleName, qualified )\n                |> (\\( mod, name ) ->\n                        makeList mod name args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( mod, name ) <| List.map go args)\n                   )\n\n        Elm.Type.Record fields generic ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Maybe.map (TypeVar Nothing) generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapSecond go) fields\n                }\n\n        Elm.Type.Var s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":22,"bp":855},"ch":{"bb":1,"bp":839}},"b":"{-| Given the current module name, whether or not a top-level record type (if\n`Just`) and subrecords (if `Just True`) found are in canonical order, and a dict\nof positional type vars, convert an `Elm.Type.Type` to a\n`TypeWithPositionalVars`.\n-}\ndocTypeToTypeWithPositionalVars : ModuleName -> { constrainedTypeVarsAreRespected : Bool, subrecordIsAlsoCanonical : Maybe Bool } -> List String -> Elm.Type.Type -> TypeWithPositionalVars\ndocTypeToTypeWithPositionalVars moduleName settings typeArgs =\n    docTypeToType moduleName settings\n        >> DereferencedType\n        >> assignTypeVars (makePositionalArgTypeVars typeArgs)\n        >> getType\n        >> TypeWithPositionalVars"},{"$":1,"a":{"bV":{"bb":22,"bp":874},"ch":{"bb":1,"bp":858}},"b":"{-| Information on what functions, types/aliases, and fully-exposed types with constructors are exposed by the module.\n-}\ntype alias ExposedNames =\n    { functions : Set String\n    , types : Set String\n    , openTypes : Set String\n    }"},{"$":1,"a":{"bV":{"bb":10,"bp":1072},"ch":{"bb":1,"bp":877}},"b":"{-| A single field of a record, to check for sorting.\n-}\ntype alias Field =\n    { field : String, type_ : Maybe DereferencedType, range : Range }"},{"$":1,"a":{"bV":{"bb":34,"bp":1086},"ch":{"bb":1,"bp":1075}},"b":"{-| Define a canonical ordering (and type) for fields.\n-}\ntype FieldOrder\n    = FieldOrder\n        { canonical : Dict String ( Int, Type )\n        , generic : Maybe Generic\n        }"},{"$":1,"a":{"bV":{"bb":13,"bp":1125},"ch":{"bb":1,"bp":1089}},"b":"{-| Given context, its return type, its module lookup node, and its name, find\nany type info stored for a function, canonicalizing the result and returning a\nlist of arg types (and finally the return type).\n-}\nfindFunctionType : LocalContext -> Maybe DereferencedType -> Node a -> String -> Maybe (List DereferencedType)\nfindFunctionType { context, localFunctions } type_ moduleNode name =\n    let\n        getTypeVars : Maybe DereferencedType -> List Type\n        getTypeVars t =\n            case Maybe.map getType t of\n                Just (NamedType _ ts) ->\n                    ts\n\n                _ ->\n                    []\n    in\n    moduleNameFor context.lookupTable moduleNode\n        |> Maybe.map\n            (\\moduleName ->\n                if moduleName == [] then\n                    context.moduleName\n\n                else\n                    moduleName\n            )\n        |> Maybe.andThen\n            (\\moduleName ->\n                if MaybeX.unwrap False (Char.isUpper << Tuple.first) <| String.uncons name then\n                    -- Constructor, not a function, which cannot be defined in local context\n                    Dict.get moduleName context.constructors\n                        |> Maybe.andThen (Dict.get name)\n                        |> Maybe.map .type_\n                        |> Maybe.map (assignPositionalTypeVars (getTypeVars type_))\n\n                else\n                    Dict.get moduleName context.functionTypes\n                        |> Maybe.andThen (Dict.get name)\n                        |> MaybeX.orElseLazy (\\() -> Dict.get name localFunctions)\n            )\n        |> Maybe.map (flattenFunctionType << dereferenceType context)"},{"$":1,"a":{"bV":{"bb":15,"bp":1174},"ch":{"bb":1,"bp":1128}},"b":"{-| Given context of known types, any information that would help find the\nappropriate canonical ordering, and a list of fields, return all matching field\norders.\n-}\nfindMatchingTypes : RuleConfig -> ModuleContext -> Maybe OrderInfo -> List Field -> List { typeName : List ( ModuleName, String ), fieldOrder : FieldOrder, isSubrecord : Bool }\nfindMatchingTypes config context info matchFields =\n    let\n        getMatches : List Field -> List { typeName : List ( ModuleName, String ), fieldOrder : FieldOrder, isSubrecord : Bool }\n        getMatches fs =\n            let\n                { canonicalMatches, genericMatches } =\n                    if List.isEmpty fs then\n                        { canonicalMatches = [], genericMatches = [] }\n\n                    else\n                        searchOrders config context hasAllFields fs\n            in\n            List.map\n                (\\( name, k ) ->\n                    { typeName = [ name ]\n                    , fieldOrder = toFieldOrder Nothing k\n                    , isSubrecord = k.isSubrecord\n                    }\n                )\n                canonicalMatches\n                ++ List.concatMap makeGeneric genericMatches\n\n        toFieldOrder : Maybe Generic -> KnownRecord -> FieldOrder\n        toFieldOrder generic { order } =\n            FieldOrder\n                { canonical = order\n                , generic = generic\n                }\n\n        makeGeneric : { type_ : ( ( ModuleName, String ), KnownRecord ), missing : List Field } -> List { typeName : List ( ModuleName, String ), fieldOrder : FieldOrder, isSubrecord : Bool }\n        makeGeneric { type_, missing } =\n            let\n                ( n, rec ) =\n                    type_\n            in\n            getMatches missing\n                |> List.map\n                    (\\{ typeName, fieldOrder, isSubrecord } ->\n                        { typeName = n :: typeName\n                        , fieldOrder = toFieldOrder (Just <| OrderedFields fieldOrder) rec\n                        , isSubrecord = rec.isSubrecord || isSubrecord\n                        }\n                    )\n                |> (\\ls ->\n                        if List.isEmpty ls then\n                            -- Either it's an empty generic or nothing matched; either way just say what fields are missing\n                            [ { typeName = [ n ]\n                              , fieldOrder = toFieldOrder (Just <| UnknownFields <| List.map .field missing) rec\n                              , isSubrecord = rec.isSubrecord\n                              }\n                            ]\n\n                        else\n                            ls\n                   )\n\n        hasAllFields : Bool\n        hasAllFields =\n            case info of\n                Just HasAllFields ->\n                    True\n\n                _ ->\n                    False\n    in\n    case info of\n        Just (HasFieldOrder f) ->\n            -- Don't worry about module name, because this will never be ambiguous\n            [ { typeName = []\n              , fieldOrder = f\n              , isSubrecord = False\n              }\n            ]\n\n        _ ->\n            getMatches matchFields"},{"$":1,"a":{"bV":{"bb":58,"bp":1237},"ch":{"bb":1,"bp":1177}},"b":"{-| Given context and an operator, find any type info stored for an operator,\ncanonicalizing the result.\n-}\nfindOperatorType : ModuleContext -> String -> Maybe (List DereferencedType)\nfindOperatorType context op =\n    DictX.filterMap (\\_ funcs -> DictX.find (\\funcName _ -> op == funcName) funcs) context.functionTypes\n        |> Dict.toList\n        -- There aren't any duplicate operators\n        |> List.head\n        |> Maybe.map\n            (Tuple.second\n                >> Tuple.second\n                >> dereferenceType context\n                >> flattenFunctionType\n            )"},{"$":1,"a":{"bV":{"bb":31,"bp":1261},"ch":{"bb":1,"bp":1240}},"b":"{-| Turn a function into a list of argument types and a return type.\n-}\nflattenFunctionType : DereferencedType -> List DereferencedType\nflattenFunctionType =\n    let\n        go : Type -> List Type\n        go t =\n            case t of\n                FunctionType { from, to } ->\n                    from :: go to\n\n                otherType ->\n                    [ otherType ]\n    in\n    getType\n        >> go\n        >> List.map DereferencedType"},{"$":1,"a":{"bV":{"bb":20,"bp":1277},"ch":{"bb":1,"bp":1264}},"b":"{-| Combine `ProjectContext`s by taking the union of known type info.\n-}\nfoldProjectContexts : ProjectContext -> ProjectContext -> ProjectContext\nfoldProjectContexts newContext prevContext =\n    { aliases =\n        Dict.union newContext.aliases prevContext.aliases\n    , canonicalRecords =\n        Dict.union newContext.canonicalRecords prevContext.canonicalRecords\n    , constructors =\n        Dict.union newContext.constructors prevContext.constructors\n    , functionTypes =\n        Dict.union newContext.functionTypes prevContext.functionTypes\n    }"},{"$":1,"a":{"bV":{"bb":14,"bp":1306},"ch":{"bb":1,"bp":1280}},"b":"{-| Create a `ProjectContext` from a `ModuleContext`, keeping only exposed\nfunctions (since unexposed won't be relevant out of the module).\n-}\nfromModuleToProject : Rule.ContextCreator ModuleContext ProjectContext\nfromModuleToProject =\n    Rule.initContextCreator\n        (\\moduleName { exposed } ->\n            { aliases =\n                if Dict.isEmpty exposed.aliases then\n                    Dict.empty\n\n                else\n                    Dict.singleton moduleName exposed.aliases\n            , canonicalRecords =\n                if Dict.isEmpty exposed.canonicalRecords then\n                    Dict.empty\n\n                else\n                    Dict.singleton moduleName exposed.canonicalRecords\n            , constructors =\n                if Dict.isEmpty exposed.constructors then\n                    Dict.empty\n\n                else\n                    Dict.singleton moduleName exposed.constructors\n            , functionTypes =\n                if Dict.isEmpty exposed.functionTypes then\n                    Dict.empty\n\n                else\n                    Dict.singleton moduleName exposed.functionTypes\n            }\n        )\n        |> Rule.withModuleName"},{"$":1,"a":{"bV":{"bb":6,"bp":1315},"ch":{"bb":1,"bp":1309}},"b":"{-| Create a `ModuleContext` from a `ProjectContext`.\n-}\nfromProjectToModule : RuleConfig -> Rule.ContextCreator ProjectContext ModuleContext\nfromProjectToModule config =\n    Rule.initContextCreator\n        (\\lookupTable sourceCodeExtractor moduleName fileIsIgnored { moduleDefinition, declarations } projectContext ->\n            let\n                { aliases, canonicalRecords, constructors, functionTypes, exposed } =\n                    declarationListVisitor config\n                        { moduleName = moduleName\n                        , lookupTable = lookupTable\n                        , aliases = projectContext.aliases\n                        , canonicalRecords = projectContext.canonicalRecords\n                        , constructors = projectContext.constructors\n                        , functionTypes = projectContext.functionTypes\n                        , exposingList = getExposedNames <| Node.value moduleDefinition\n                        , fileIsIgnored = fileIsIgnored\n                        }\n                        declarations\n            in\n            { aliases = aliases\n            , canonicalRecords = canonicalRecords\n            , constructors = constructors\n            , functionTypes = functionTypes\n            , exposed = exposed\n            , fileIsIgnored = fileIsIgnored\n            , moduleName = moduleName\n            , lookupTable = lookupTable\n            , extractSource = sourceCodeExtractor\n            }\n        )\n        |> Rule.withModuleNameLookupTable\n        |> Rule.withSourceCodeExtractor\n        |> Rule.withModuleName\n        |> Rule.withIsFileIgnored\n        |> Rule.withFullAst"},{"$":1,"a":{"bV":{"bb":13,"bp":1350},"ch":{"bb":1,"bp":1318}},"b":"{-| The type of generic fields in a field order, which may be unknown or have\ncanonical ordering.\n-}\ntype Generic\n    = UnknownFields (List String)\n    | OrderedFields FieldOrder"},{"$":1,"a":{"bV":{"bb":13,"bp":1439},"ch":{"bb":1,"bp":1353}},"b":"{-| Get a set of all names exposed by the modules or `Nothing` if everything is\nexposed.\n-}\ngetExposedNames : Module -> Maybe ExposedNames\ngetExposedNames =\n    let\n        step : Node TopLevelExpose -> ExposedNames -> ExposedNames\n        step e acc =\n            case Node.value e of\n                FunctionExpose name ->\n                    { acc | functions = Set.insert name acc.functions }\n\n                TypeExpose { name } ->\n                    { acc | openTypes = Set.insert name acc.openTypes }\n\n                InfixExpose name ->\n                    { acc | functions = Set.insert name acc.functions }\n\n                TypeOrAliasExpose name ->\n                    { acc | types = Set.insert name acc.types }\n    in\n    Module.exposingList\n        >> (\\l ->\n                case l of\n                    All _ ->\n                        Nothing\n\n                    Explicit es ->\n                        List.foldl step\n                            { functions = Set.empty, types = Set.empty, openTypes = Set.empty }\n                            es\n                            |> Just\n           )"},{"$":1,"a":{"bV":{"bb":16,"bp":1673},"ch":{"bb":1,"bp":1442}},"b":"{-| Get the name and type of a function, if possible.\n-}\ngetFunctionBinding : ModuleContext -> Function -> Maybe ( String, DereferencedType )\ngetFunctionBinding context { signature } =\n    Maybe.map Node.value signature\n        |> Maybe.map\n            (\\{ name, typeAnnotation } ->\n                ( Node.value name\n                , typeAnnotToNoncanonicalType context typeAnnotation\n                    |> dereferenceType context\n                )\n            )"},{"$":1,"a":{"bV":{"bb":15,"bp":1685},"ch":{"bb":1,"bp":1676}},"b":"{-| Get the type a `List` is full of if possible.\n-}\ngetListType : Maybe DereferencedType -> Maybe DereferencedType\ngetListType assocType =\n    case Maybe.map getType assocType of\n        Just (ListType t) ->\n            Just <| DereferencedType t\n\n        _ ->\n            Nothing"},{"$":1,"a":{"bV":{"bb":111,"bp":1704},"ch":{"bb":1,"bp":1688}},"b":"{-| Get all types for a record's fields.\n-}\ngetRecordFieldTypes : Maybe DereferencedType -> Dict String DereferencedType\ngetRecordFieldTypes type_ =\n    case Maybe.map getType type_ of\n        Just (RecordType { fields }) ->\n            Dict.fromList <| List.map (Tuple.mapSecond DereferencedType) fields\n\n        _ ->\n            Dict.empty"},{"$":1,"a":{"bV":{"bb":14,"bp":1718},"ch":{"bb":1,"bp":1707}},"b":"{-| Get all types for a tuple's subexpressions.\n-}\ngetTupleTypes : List a -> Maybe DereferencedType -> List (Maybe DereferencedType)\ngetTupleTypes emptyList assocType =\n    case Maybe.map getType assocType of\n        Just (TupleType ts) ->\n            List.map (Just << DereferencedType) ts\n\n        _ ->\n            List.map (always Nothing) emptyList"},{"$":1,"a":{"bV":{"bb":72,"bp":1731},"ch":{"bb":1,"bp":1721}},"b":"{-| Unwrap a `DereferencedType`.\n-}\ngetType : DereferencedType -> Type\ngetType (DereferencedType t) =\n    t"},{"$":1,"a":{"bV":{"bb":34,"bp":1740},"ch":{"bb":1,"bp":1734}},"b":"{-| Unwrap a `TypeWithPositionalVars`.\n-}\ngetTypeWithPositionalVars : TypeWithPositionalVars -> Type\ngetTypeWithPositionalVars (TypeWithPositionalVars t) =\n    t"},{"$":1,"a":{"bV":{"bb":34,"bp":1754},"ch":{"bb":1,"bp":1743}},"b":"{-| Infer type for a chain of expressions being applied to the first one.\n-}\ninferApplicationChain : LocalContext -> List (Node Expression) -> Maybe DereferencedType\ninferApplicationChain local es =\n    let\n        inferExpr : Node Expression -> Maybe DereferencedType\n        inferExpr =\n            inferExprType local\n\n        getReturnType : List (Node Expression) -> ( List DereferencedType, DereferencedType ) -> DereferencedType\n        getReturnType args ( argTypes, returnType ) =\n            List.map inferExpr args\n                |> ListX.zip argTypes\n                |> List.foldl\n                    (\\( t1, t2 ) typeVars ->\n                        Maybe.map (typesMatch typeVars t1) t2\n                            |> Maybe.map Tuple.first\n                            |> Maybe.withDefault typeVars\n                    )\n                    Dict.empty\n                |> Dict.filter (\\( i, _ ) _ -> i == 1)\n                |> DictX.mapKeys Tuple.second\n                |> (\\typeVars -> assignTypeVars typeVars returnType)\n    in\n    case es of\n        [] ->\n            Nothing\n\n        [ e ] ->\n            inferExpr e\n\n        func :: args ->\n            case Node.value func of\n                FunctionOrValue _ name ->\n                    findFunctionType local Nothing func name\n                        |> MaybeX.orElseLazy (\\() -> Maybe.map flattenFunctionType <| inferExpr func)\n                        |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                        -- Assign type vars\n                        |> Maybe.map (getReturnType args)\n\n                PrefixOperator op ->\n                    findOperatorType local.context op\n                        -- Definitely can't infer an operator type\n                        |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                        |> Maybe.map (getReturnType args)\n\n                ParenthesizedExpression func_ ->\n                    -- Unwrap the parentheses\n                    inferApplicationChain local (func_ :: args)\n\n                RecordAccessFunction accessFunc ->\n                    -- Assume there's only one arg, since it's a type error if not\n                    List.head args\n                        |> Maybe.andThen inferExpr\n                        |> getRecordFieldTypes\n                        |> (\\ts ->\n                                makeAccessFunc accessFunc\n                                    |> (\\f -> Dict.get f ts)\n                           )\n\n                _ ->\n                    -- Try to infer the type\n                    inferExpr func\n                        |> Maybe.map flattenFunctionType\n                        |> Maybe.andThen (partiallyApplyArgsAndTypes args)\n                        |> Maybe.map (getReturnType args)"},{"$":1,"a":{"bV":{"bb":13,"bp":1794},"ch":{"bb":1,"bp":1757}},"b":"{-| Do some half-hearted type inference to help differentiate records.\n-}\ninferExprType : LocalContext -> Node Expression -> Maybe DereferencedType\ninferExprType local =\n    let\n        makeFunc : String -> Maybe (List DereferencedType) -> Maybe Type\n        makeFunc typeVarPrefix =\n            Maybe.map (List.map (prefixTypeVars typeVarPrefix))\n                >> Maybe.andThen ListX.unconsLast\n                >> Maybe.map\n                    (Tuple.mapBoth getType (List.map getType)\n                        >> (\\( r, ts ) -> makeFunctionType r ts)\n                    )\n\n        go : String -> Node Expression -> Maybe Type\n        go typeVarPrefix node =\n            case Node.value node of\n                UnitExpr ->\n                    -- Mr. Incredible says UNIT IS UNIT.\n                    Just UnitType\n\n                Integer _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []\n\n                Hex _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []\n\n                Floatable _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Float\" ) []\n\n                Literal _ ->\n                    Just <| NamedType ( [ \"String\" ], \"String\" ) []\n\n                CharLiteral _ ->\n                    Just <| NamedType ( [ \"Char\" ], \"Char\" ) []\n\n                TupledExpression es ->\n                    List.indexedMap (\\i e -> go (typeVarPrefix ++ \"Tuple Expression \" ++ String.fromInt i) e) es\n                        |> MaybeX.combine\n                        |> Maybe.map TupleType\n\n                ListExpr es ->\n                    if List.isEmpty es then\n                        -- An empty list can be anything\n                        Just (ListType (TypeVar Nothing <| typeVarPrefix ++ \"inferred empty list typevar\"))\n\n                    else\n                        -- Have to check all and unify\n                        List.indexedMap (\\i e -> go (typeVarPrefix ++ \"List Element \" ++ String.fromInt i) e) es\n                            |> MaybeX.values\n                            |> unifyTypes\n                            |> Maybe.map ListType\n\n                RecordExpr rs ->\n                    rs\n                        |> List.map\n                            (\\n ->\n                                let\n                                    ( f, e ) =\n                                        Node.value n\n                                in\n                                go (typeVarPrefix ++ \"Record Field \" ++ Node.value f) e\n                                    |> Maybe.map (Tuple.pair (Node.value f))\n                            )\n                        |> MaybeX.combine\n                        |> Maybe.map (\\fields -> RecordType { generic = Nothing, fields = fields, canonical = False })\n\n                FunctionOrValue _ name ->\n                    findFunctionType local Nothing node name\n                        |> makeFunc typeVarPrefix\n\n                ParenthesizedExpression e ->\n                    -- Type is just whatever is in parentheses\n                    go typeVarPrefix e\n\n                Negation e ->\n                    go typeVarPrefix e\n\n                IfBlock _ e1 e2 ->\n                    -- Try to infer either side and unify\n                    [ go (typeVarPrefix ++ \"If Block True\") e1, go (typeVarPrefix ++ \"If Block False\") e2 ]\n                        |> MaybeX.values\n                        |> unifyTypes\n\n                PrefixOperator p ->\n                    findOperatorType local.context p\n                        |> makeFunc typeVarPrefix\n\n                CaseExpression { cases } ->\n                    -- Try to infer all cases and unify\n                    List.indexedMap (\\i ( _, e ) -> go (typeVarPrefix ++ \"Case Expression \" ++ String.fromInt i) e) cases\n                        |> MaybeX.values\n                        |> unifyTypes\n\n                Application es ->\n                    inferApplicationChain local es\n                        |> Maybe.map getType\n\n                LambdaExpression { args, expression } ->\n                    let\n                        unwrapArgs : List String -> Maybe Type\n                        unwrapArgs xs =\n                            ListX.uncons xs\n                                |> MaybeX.unpack (\\() -> go typeVarPrefix expression)\n                                    (\\( x, xs_ ) ->\n                                        unwrapArgs xs_\n                                            |> Maybe.map (\\t -> FunctionType { from = TypeVar Nothing <| typeVarPrefix ++ x, to = t })\n                                    )\n                    in\n                    List.indexedMap (\\i _ -> \"lambda arg\" ++ String.fromInt i) args\n                        |> unwrapArgs\n\n                RecordAccess e accessFunc ->\n                    go typeVarPrefix e\n                        |> Maybe.map DereferencedType\n                        |> getRecordFieldTypes\n                        |> (\\ts ->\n                                Node.value accessFunc\n                                    |> makeAccessFunc\n                                    |> (\\f -> Dict.get f ts)\n                           )\n                        |> Maybe.map getType\n\n                GLSLExpression _ ->\n                    Nothing\n\n                RecordAccessFunction accessFunc ->\n                    -- We know the expression being accessed is a record with a field of the type of the total expression\n                    makeAccessFunc accessFunc\n                        |> (\\f ->\n                                Just <|\n                                    FunctionType\n                                        { from =\n                                            RecordType\n                                                -- This is, in essence, a generic record with one field\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"record access inferred for \" ++ f\n                                                , canonical = False\n                                                , fields = [ ( f, TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f ) ]\n                                                }\n                                        , to = TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f\n                                        }\n                           )\n\n                Operator _ ->\n                    Nothing\n\n                OperatorApplication op _ e1 e2 ->\n                    -- Handle a few known operators\n                    checkOperatorApplication (inferApplicationChain local) op e1 e2\n                        |> Maybe.map getType\n\n                LetExpression { declarations, expression } ->\n                    let\n                        newBindings : Dict String Type\n                        newBindings =\n                            List.concatMap (bindingsFromLetDeclaration local << Node.value) declarations\n                                |> Dict.fromList\n                    in\n                    inferExprType { local | localFunctions = Dict.union local.localFunctions newBindings } expression\n                        |> Maybe.map (prefixTypeVars typeVarPrefix)\n                        |> Maybe.map getType\n\n                RecordUpdateExpression var fs ->\n                    findFunctionType local Nothing var (Node.value var)\n                        |> makeFunc typeVarPrefix\n                        |> MaybeX.orElseLazy\n                            (\\() ->\n                                MaybeX.traverse ((\\( f, e ) -> go (typeVarPrefix ++ \"Record Update Field \" ++ Node.value f) e |> Maybe.map (Tuple.pair (Node.value f))) << Node.value) fs\n                                    |> Maybe.map\n                                        (\\fields ->\n                                            RecordType\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"inferred update generic\"\n                                                , canonical = False\n                                                , fields = fields\n                                                }\n                                        )\n                            )\n    in\n    go \"\"\n        >> Maybe.map DereferencedType"},{"$":1,"a":{"bV":{"bb":10,"bp":1804},"ch":{"bb":1,"bp":1797}},"b":"{-| The initial project context knows of no types.\n-}\ninitialProjectContext : ProjectContext\ninitialProjectContext =\n    { aliases = Dict.empty\n    , canonicalRecords = Dict.empty\n    , constructors = Dict.empty\n    , functionTypes = Dict.empty\n    }"},{"$":1,"a":{"bV":{"bb":58,"bp":1876},"ch":{"bb":1,"bp":1807}},"b":"{-| Given two dicts of field types, keep only fields that have identical types\nbetween the two.\n-}\nkeepOnlyMatchingFieldTypes : Dict String Type -> Dict String Type -> Dict String Type\nkeepOnlyMatchingFieldTypes d1 d2 =\n    Dict.merge (\\_ _ acc -> acc)\n        (\\field t1 t2 acc ->\n            if t1 == t2 then\n                Dict.insert field t1 acc\n\n            else\n                acc\n        )\n        (\\_ _ acc -> acc)\n        d1\n        d2\n        Dict.empty"},{"$":1,"a":{"bV":{"bb":33,"bp":1942},"ch":{"bb":1,"bp":1879}},"b":"{-| A canonical ordering of fields in a record definition.\n-}\ntype alias KnownRecord =\n    { order : Dict String ( Int, Type )\n    , isGeneric : Bool\n    , isSubrecord : Bool\n    }"},{"$":1,"a":{"bV":{"bb":19,"bp":1952},"ch":{"bb":1,"bp":1945}},"b":"{-| Given how to treat subrecords, the current module names, and a list of\nfields/whether the record is generic, generate all `KnownRecord`s from a\n`Elm.Type.Type`.\n-}\nknownRecordFromDocType : SubrecordCanonicity -> ModuleName -> ( List ( String, Elm.Type.Type ), Bool ) -> List ( String, KnownRecord )\nknownRecordFromDocType subrecordTreatment moduleName ( fields, isGeneric ) =\n    ListX.indexedFoldl\n        (\\i ( f, t ) ->\n            Dict.insert f\n                ( i\n                , docTypeToType moduleName\n                    { -- Constrained type vars don't apply to type aliases\n                      constrainedTypeVarsAreRespected = False\n\n                    -- Subrecords canonical if config says so\n                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                    }\n                    t\n                )\n        )\n        Dict.empty\n        fields\n        |> (\\order ->\n                { order = order\n                , isGeneric = isGeneric\n                , isSubrecord = False\n                }\n           )\n        |> (\\k ->\n                if subrecordTreatment == AlwaysCanonical then\n                    ( \"\", k )\n                        :: List.concatMap (\\( f, ( _, t ) ) -> makeSubrecordsFromType True (\".\" ++ f) t) (Dict.toList k.order)\n\n                else\n                    -- Only create the top level record\n                    [ ( \"\", k ) ]\n           )"},{"$":1,"a":{"bV":{"bb":25,"bp":1961},"ch":{"bb":1,"bp":1955}},"b":"{-| Given how to treat subrecords, the current module names, and a\n`RecordDefinition`/whether the record is generic, generate all `KnownRecord`s\nfrom a type annotation.\n-}\nknownRecordFromTypeAnnot : SubrecordCanonicity -> { context | moduleName : ModuleName, lookupTable : ModuleNameLookupTable } -> ( RecordDefinition, Bool ) -> List ( String, KnownRecord )\nknownRecordFromTypeAnnot subrecordTreatment context ( fields, isGeneric ) =\n    ListX.indexedFoldl\n        (\\i field ->\n            let\n                ( f, t ) =\n                    Node.value field\n            in\n            Dict.insert\n                (Node.value f)\n                ( i\n                , typeAnnotToType context\n                    -- Constrained type vars are not respected for aliases\n                    { constrainedTypeVarsAreRespected = False\n\n                    -- Subrecords canonical if config says so\n                    , subrecordIsAlsoCanonical =\n                        subrecordCanonicityForField subrecordTreatment\n                    }\n                    t\n                )\n        )\n        Dict.empty\n        fields\n        |> (\\order -> { order = order, isGeneric = isGeneric, isSubrecord = False })\n        |> (\\k ->\n                if subrecordTreatment == AlwaysCanonical then\n                    ( \"\", k )\n                        :: List.concatMap (\\( f, ( _, t ) ) -> makeSubrecordsFromType True (\".\" ++ f) t) (Dict.toList k.order)\n\n                else\n                    -- Only create the top level record\n                    [ ( \"\", k ) ]\n           )"},{"$":1,"a":{"bV":{"bb":44,"bp":1999},"ch":{"bb":1,"bp":1964}},"b":"{-| Context within an expression, which may have additional bindings from `let`\ndeclarations and patterns.\n-}\ntype alias LocalContext =\n    { context : ModuleContext\n    , localFunctions : Dict String Type\n    }"},{"$":1,"a":{"bV":{"bb":44,"bp":2037},"ch":{"bb":1,"bp":2002}},"b":"{-| Make subrecords for custom types, if appropriate.\n-}\nmakeCustomTypeSubrecords : SubrecordCanonicity -> String -> List TypeWithPositionalVars -> List ( String, KnownRecord )\nmakeCustomTypeSubrecords subrecordTreatment n ts =\n    (case subrecordTreatment of\n        AlwaysUnknown ->\n            Nothing\n\n        CanonicalWhenSubrecord ->\n            Nothing\n\n        CustomTypeArgsAlwaysCanonical ->\n            Just False\n\n        AlwaysCanonical ->\n            Just True\n    )\n        |> MaybeX.unwrap []\n            (\\recurse ->\n                List.indexedMap\n                    (\\i t ->\n                        getTypeWithPositionalVars t\n                            |> makeSubrecordsFromType recurse (n ++ \" arg\" ++ String.fromInt i)\n                    )\n                    ts\n                    |> List.concat\n            )"},{"$":1,"a":{"bV":{"bb":6,"bp":2044},"ch":{"bb":1,"bp":2040}},"b":"{-| Convert a record type into a field order, assuming no fields are missing\n(since that would be a type error). Returns a list of non-canonical fields\nencountered\n-}\nmakeFieldOrder : DereferencedType -> Result (List ( String, Type )) FieldOrder\nmakeFieldOrder =\n    let\n        go : Type -> Result (List ( String, Type )) FieldOrder\n        go type_ =\n            case type_ of\n                RecordType { canonical, generic, fields } ->\n                    if canonical then\n                        Ok <|\n                            FieldOrder\n                                { canonical =\n                                    List.indexedMap (\\i ( n, t ) -> ( n, ( i, t ) )) fields\n                                        |> Dict.fromList\n                                , generic =\n                                    Maybe.map\n                                        (\\g ->\n                                            case go g of\n                                                Ok o ->\n                                                    OrderedFields o\n\n                                                Err [] ->\n                                                    -- Unit record is always canonical, or else it's a type error, in which case who knows\n                                                    OrderedFields <| FieldOrder { canonical = Dict.empty, generic = Nothing }\n\n                                                Err fs ->\n                                                    List.map Tuple.first fs\n                                                        |> UnknownFields\n                                        )\n                                        generic\n                                }\n\n                    else\n                        Err fields\n\n                _ ->\n                    Err []\n    in\n    go << getType"},{"$":1,"a":{"bV":{"bb":6,"bp":2051},"ch":{"bb":1,"bp":2047}},"b":"{-| Given a return type and a successive list of argument types, create a\nfunction with that type.\n-}\nmakeFunctionType : Type -> List Type -> Type\nmakeFunctionType return ts =\n    case ts of\n        [] ->\n            return\n\n        t :: ts_ ->\n            FunctionType { from = t, to = makeFunctionType return ts_ }"},{"$":1,"a":{"bV":{"bb":85,"bp":2073},"ch":{"bb":1,"bp":2054}},"b":"{-| Given a return type and a successive list of argument types, create a\nfunction with that type, all types having positional vars.\n-}\nmakeFunctionTypeWithPositionalVars : TypeWithPositionalVars -> List TypeWithPositionalVars -> TypeWithPositionalVars\nmakeFunctionTypeWithPositionalVars return ts =\n    makeFunctionType (getTypeWithPositionalVars return) (List.map getTypeWithPositionalVars ts)\n        |> TypeWithPositionalVars"},{"$":1,"a":{"bV":{"bb":13,"bp":2091},"ch":{"bb":1,"bp":2076}},"b":"{-| Given how to sort generics, a list of fields to sort, and a `FieldOrder`,\nreturn an ordering of fields, whether or not any of them were an unknown record\n(via generics), and any canonical field types.\n-}\nmakeOrder : SortGenerics -> List Field -> FieldOrder -> { fieldOrder : Dict String Int, hasUnknownFields : Bool, canonicalFieldTypes : Dict String Type }\nmakeOrder sortGenerics inFields (FieldOrder inOrder) =\n    let\n        genericOffset : Int\n        genericOffset =\n            -- This is an ugly hack to put generic fields first/last,\n            -- but it works as long as a record doesn't have over 1,000,000 fields, which seems safe\n            case sortGenerics of\n                GenericFieldsFirst ->\n                    -1000000\n\n                GenericFieldsLast ->\n                    1000000\n\n        go : Int -> List Field -> FieldOrder -> ( Dict String Int, Bool )\n        go offsetMult fieldsToMake (FieldOrder { canonical, generic }) =\n            let\n                step : Field -> ( List ( String, Int ), List Field ) -> ( List ( String, Int ), List Field )\n                step f ( canAcc, genAcc ) =\n                    case Dict.get f.field canonical of\n                        Just ( i, _ ) ->\n                            ( ( f.field\n                              , i + offsetMult * genericOffset\n                              )\n                                :: canAcc\n                            , genAcc\n                            )\n\n                        Nothing ->\n                            ( canAcc, f :: genAcc )\n            in\n            List.foldl step ( [], [] ) fieldsToMake\n                |> Tuple.mapBoth Dict.fromList\n                    (\\fs ->\n                        case generic of\n                            Just (OrderedFields order) ->\n                                go (offsetMult + 1) fs order\n\n                            Just (UnknownFields fs_) ->\n                                let\n                                    alph : List String\n                                    alph =\n                                        List.sort fs_\n                                in\n                                ( List.map\n                                    (\\f ->\n                                        ( f.field\n                                        , ListX.elemIndex f.field alph\n                                            |> Maybe.withDefault -1\n                                            |> (+) ((offsetMult + 1) * genericOffset)\n                                        )\n                                    )\n                                    fs\n                                    |> Dict.fromList\n                                , True\n                                )\n\n                            Nothing ->\n                                ( Dict.empty, False )\n                    )\n                |> (\\( f1s, ( f2s, unknown ) ) -> ( Dict.union f1s f2s, unknown ))\n    in\n    go 0 inFields (FieldOrder inOrder)\n        |> (\\( fieldOrder, hasUnknownFields ) ->\n                { fieldOrder = fieldOrder, hasUnknownFields = hasUnknownFields, canonicalFieldTypes = Dict.map (\\_ v -> Tuple.second v) inOrder.canonical }\n           )"},{"$":1,"a":{"bV":{"bb":15,"bp":2167},"ch":{"bb":1,"bp":2094}},"b":"{-| Given a list of type vars (as string), create positional type vars from\nthem.\n-}\nmakePositionalArgTypeVars : List String -> Dict String Type\nmakePositionalArgTypeVars =\n    List.indexedMap (\\i s -> ( s, TypeVar Nothing <| \"positional arg \" ++ String.fromInt i ))\n        >> Dict.fromList"},{"$":1,"a":{"bV":{"bb":15,"bp":2246},"ch":{"bb":1,"bp":2170}},"b":"{-| Make a type for a record being accessed\n-}\nmakeRecordAccessType : Maybe DereferencedType -> String -> Maybe DereferencedType\nmakeRecordAccessType hasType accessFunc =\n    -- We know the expression being accessed is a record with a field of the type of the total expression\n    makeAccessFunc accessFunc\n        |> (\\f ->\n                Maybe.map\n                    (\\t ->\n                        DereferencedType <|\n                            RecordType\n                                -- This is, in essence, a generic record with one field\n                                { generic = Just <| TypeVar Nothing <| \"record access field \" ++ f\n                                , canonical = False\n                                , fields = [ ( f, getType t ) ]\n                                }\n                    )\n                    hasType\n           )"},{"$":1,"a":{"bV":{"bb":15,"bp":2397},"ch":{"bb":1,"bp":2249}},"b":"{-| Given whether or not to descend beyond the initial type, a name prefix and a\ntype, generate `KnownRecord`s for records in that type.\n-}\nmakeSubrecordsFromType : Bool -> String -> Type -> List ( String, KnownRecord )\nmakeSubrecordsFromType recurse namePrefix type_ =\n    let\n        go : Maybe String -> Type -> List ( String, KnownRecord )\n        go s =\n            if recurse then\n                makeSubrecordsFromType recurse (MaybeX.unwrap namePrefix (\\subRec -> namePrefix ++ subRec) s)\n\n            else\n                always []\n    in\n    case type_ of\n        FunctionType { from, to } ->\n            go Nothing from ++ go Nothing to\n\n        TupleType ts ->\n            List.concatMap (go Nothing) ts\n\n        ListType t_ ->\n            go Nothing t_\n\n        RecordType { fields, generic } ->\n            ( namePrefix\n            , { order =\n                    ListX.indexedFoldl\n                        (\\i ( f, t ) ->\n                            Dict.insert f\n                                ( i\n                                , t\n                                )\n                        )\n                        Dict.empty\n                        fields\n              , isGeneric = generic /= Nothing\n              , isSubrecord = True\n              }\n            )\n                :: List.concatMap (\\( f, t ) -> go (Just <| \".\" ++ f) t) fields\n\n        _ ->\n            -- UnitType\n            -- TypeVar\n            -- NamedType\n            []"},{"$":1,"a":{"bV":{"bb":59,"bp":2414},"ch":{"bb":1,"bp":2400}},"b":"{-| Make a `TypeVar` from a string.\n-}\nmakeTypeVar : Bool -> String -> Type\nmakeTypeVar constrainedTypeVarsAreRespected s =\n    (if String.startsWith \"number\" s then\n        Just Number\n\n     else if String.startsWith \"appendable\" s then\n        Just Appendable\n\n     else if String.startsWith \"comparable\" s then\n        Just Comparable\n\n     else if String.startsWith \"compappend\" s then\n        Just CompAppend\n\n     else\n        Nothing\n    )\n        -- Sometimes constrained type variables are not respected, like in type aliases\n        |> MaybeX.filter (always <| constrainedTypeVarsAreRespected)\n        |> (\\t -> TypeVar t s)"},{"$":1,"a":{"bV":{"bb":61,"bp":2440},"ch":{"bb":1,"bp":2417}},"b":"{-| Check if a type matches a constrained type variable.\n-}\nmatchesTypeClass : Type -> Typeclass -> Bool\nmatchesTypeClass type_ class =\n    let\n        typeIsComparable : Type -> Bool\n        typeIsComparable t =\n            case t of\n                NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True\n\n                NamedType ( [ \"Char\" ], \"Char\" ) [] ->\n                    True\n\n                NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True\n\n                NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True\n\n                ListType t_ ->\n                    typeIsComparable t_\n\n                TupleType ts ->\n                    List.all typeIsComparable ts\n\n                _ ->\n                    -- Nothing else is comparable\n                    False\n\n        typeIsAppendable : Type -> Bool\n        typeIsAppendable t =\n            case t of\n                NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True\n\n                ListType _ ->\n                    True\n\n                _ ->\n                    -- Nothing else is appendable\n                    False\n\n        typeIsNumber : Type -> Bool\n        typeIsNumber t =\n            case t of\n                NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True\n\n                NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True\n\n                _ ->\n                    -- Nothing else is a number\n                    False\n    in\n    case class of\n        Appendable ->\n            typeIsAppendable type_\n\n        Comparable ->\n            typeIsComparable type_\n\n        CompAppend ->\n            typeIsAppendable type_ && typeIsComparable type_\n\n        Number ->\n            typeIsNumber type_"},{"$":1,"a":{"bV":{"bb":76,"bp":2456},"ch":{"bb":1,"bp":2443}},"b":"{-| The module context.\n\n`aliases` stores all type aliases.\n\n`canonicalRecords` stores known aliased records.\n\n`constructors` are different than functions, as they (might) require type\nvars.\n\n`functionTypes` stores the types of all functions (for type inference), along\nwith any (anonymous) records associated with custom types (by index).\n\n-}\ntype alias ModuleContext =\n    { aliases : Dict ModuleName (Dict String TypeWithPositionalVars)\n    , canonicalRecords : Dict ModuleName (Dict String KnownRecord)\n    , constructors : Dict ModuleName (Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars })\n    , functionTypes : Dict ModuleName (Dict String Type)\n    , exposed :\n        { aliases : Dict String TypeWithPositionalVars\n        , canonicalRecords : Dict String KnownRecord\n        , constructors : Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars }\n        , functionTypes : Dict String Type\n        }\n    , moduleName : ModuleName\n    , fileIsIgnored : Bool\n    , lookupTable : ModuleNameLookupTable\n    , extractSource : Range -> String\n    }"},{"$":1,"a":{"bV":{"bb":58,"bp":2548},"ch":{"bb":1,"bp":2459}},"b":"{-| Visit each module, first getting type aliases from all declarations and then\nchecking all expressions for records.\n-}\nmoduleVisitor : RuleConfig -> Rule.ModuleRuleSchema r ModuleContext -> Rule.ModuleRuleSchema { r | hasAtLeastOneVisitor : () } ModuleContext\nmoduleVisitor config schema =\n    schema\n        |> Rule.withDeclarationEnterVisitor\n            (\\d c ->\n                if c.fileIsIgnored then\n                    ( [], c )\n\n                else\n                    ( declarationEnterVisitor config c d, c )\n            )"},{"$":1,"a":{"bV":{"bb":13,"bp":2569},"ch":{"bb":1,"bp":2551}},"b":"{-| Any info we can glean about the record that might help us figure out what\nits field order should be.\n-}\ntype OrderInfo\n    = HasFieldOrder FieldOrder\n    | HasAllFields"},{"$":1,"a":{"bV":{"bb":70,"bp":2611},"ch":{"bb":1,"bp":2572}},"b":"{-| A list of orders that match a list of fields, including both full matches\nand generic matches (with fields not present in the generic).\n-}\ntype alias OrderMatches =\n    { canonicalMatches : List ( ( ModuleName, String ), KnownRecord )\n    , genericMatches :\n        List\n            { type_ :\n                ( ( ModuleName, String )\n                , KnownRecord\n                )\n            , missing : List Field\n            }\n    }"},{"$":1,"a":{"bV":{"bb":14,"bp":2628},"ch":{"bb":1,"bp":2614}},"b":"{-| Given a list of arguments and a flattened function type, return a list of\nargument types and the final function type.\n-}\npartiallyApplyArgsAndTypes : List a -> List DereferencedType -> Maybe ( List DereferencedType, DereferencedType )\npartiallyApplyArgsAndTypes args types =\n    List.length args\n        |> (\\i -> ListX.splitAt i types)\n        |> (\\( argTypes, return ) ->\n                ListX.unconsLast return\n                    |> Maybe.map\n                        (Tuple.mapBoth getType (List.map getType)\n                            >> (\\( r, ts ) -> makeFunctionType r ts)\n                            >> DereferencedType\n                        )\n                    |> Maybe.map (Tuple.pair argTypes)\n           )"},{"$":1,"a":{"bV":{"bb":37,"bp":2647},"ch":{"bb":1,"bp":2631}},"b":"{-| Prefix a string before type variables so as to disambiguate them for type\nmatching.\n-}\nprefixTypeVars : String -> DereferencedType -> DereferencedType\nprefixTypeVars prefix type_ =\n    let\n        go : Type -> Type\n        go t =\n            case t of\n                FunctionType { from, to } ->\n                    FunctionType { from = go from, to = go to }\n\n                TupleType ts ->\n                    TupleType <| List.map go ts\n\n                ListType t_ ->\n                    ListType <| go t_\n\n                NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )\n\n                RecordType r ->\n                    RecordType\n                        { r\n                            | fields = List.map (Tuple.mapSecond go) r.fields\n                            , generic = Maybe.map go r.generic\n                        }\n\n                TypeVar class var ->\n                    TypeVar class (prefix ++ var)\n\n                UnitType ->\n                    UnitType\n    in\n    DereferencedType <| go <| getType type_"},{"$":1,"a":{"bV":{"bb":20,"bp":2659},"ch":{"bb":1,"bp":2650}},"b":"{-| Given a top-level declaration, accumulate information from it for storing in\nmodule context, determining what to expose or not.\n-}\nprocessDeclaration :\n    SubrecordCanonicity\n    ->\n        { context\n            | moduleName : ModuleName\n            , lookupTable : ModuleNameLookupTable\n            , exposingList : Maybe ExposedNames\n            , fileIsIgnored : Bool\n        }\n    -> Node Declaration\n    ->\n        { aliases : List ( String, TypeWithPositionalVars )\n        , canonicalRecords : List ( String, KnownRecord )\n        , constructors : List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } )\n        , functionTypes : List ( String, Type )\n        , exposedAliases : List ( String, TypeWithPositionalVars )\n        , exposedCanonicalRecords : List ( String, KnownRecord )\n        , exposedConstructors : List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } )\n        , exposedFunctionTypes : List ( String, Type )\n        }\n    ->\n        { aliases : List ( String, TypeWithPositionalVars )\n        , canonicalRecords : List ( String, KnownRecord )\n        , constructors : List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } )\n        , functionTypes : List ( String, Type )\n        , exposedAliases : List ( String, TypeWithPositionalVars )\n        , exposedCanonicalRecords : List ( String, KnownRecord )\n        , exposedConstructors : List ( String, { customTypeName : Maybe String, type_ : TypeWithPositionalVars } )\n        , exposedFunctionTypes : List ( String, Type )\n        }\nprocessDeclaration subrecordTreatment context node acc =\n    let\n        makeConstructorAndSubrecords : TypeWithPositionalVars -> List (Node String) -> ValueConstructor -> ( String, TypeWithPositionalVars, List ( String, KnownRecord ) )\n        makeConstructorAndSubrecords return typeVars { name, arguments } =\n            List.map\n                (typeAnnotToTypeWithPositionalVars context\n                    { constrainedTypeVarsAreRespected = True\n                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                    }\n                    (List.map Node.value typeVars)\n                )\n                arguments\n                |> (\\ts ->\n                        let\n                            n : String\n                            n =\n                                Node.value name\n                        in\n                        ( n\n                        , makeFunctionTypeWithPositionalVars return ts\n                        , makeCustomTypeSubrecords subrecordTreatment n ts\n                        )\n                   )\n\n        skipIfIgnored : (ExposedNames -> Bool) -> r -> (() -> info) -> (info -> r -> r) -> (info -> r -> r) -> r\n        skipIfIgnored checkIfExposed acc_ makeInfo addLocal addExposed =\n            let\n                isExposed : Bool\n                isExposed =\n                    MaybeX.unwrap True checkIfExposed context.exposingList\n            in\n            case ( context.fileIsIgnored, isExposed ) of\n                ( True, False ) ->\n                    acc_\n\n                ( True, True ) ->\n                    addExposed (makeInfo ()) acc_\n\n                ( False, True ) ->\n                    let\n                        info : info\n                        info =\n                            makeInfo ()\n                    in\n                    addExposed info <| addLocal info acc_\n\n                ( False, False ) ->\n                    addLocal (makeInfo ()) acc_\n    in\n    case Node.value node of\n        FunctionDeclaration { signature } ->\n            Maybe.map Node.value signature\n                |> MaybeX.unwrap acc\n                    (\\{ name, typeAnnotation } ->\n                        let\n                            n : String\n                            n =\n                                Node.value name\n                        in\n                        skipIfIgnored (Set.member n << .functions)\n                            acc\n                            -- Function declarations do not have canonical record orders nor do they have type variables (that might be made concrete)\n                            (\\() -> ( n, typeAnnotToNoncanonicalType context typeAnnotation ))\n                            (\\info acc_ -> { acc_ | functionTypes = info :: acc.functionTypes })\n                            (\\info acc_ -> { acc_ | exposedFunctionTypes = info :: acc.exposedFunctionTypes })\n                    )\n\n        CustomTypeDeclaration { name, generics, constructors } ->\n            let\n                n : String\n                n =\n                    Node.value name\n            in\n            skipIfIgnored (Set.member n << .openTypes)\n                acc\n                (\\() ->\n                    List.foldl\n                        (\\c ( fAcc, rAcc ) ->\n                            Node.value c\n                                |> makeConstructorAndSubrecords\n                                    (List.map Node.value generics\n                                        |> (\\gs ->\n                                                List.map (TypeVar Nothing) gs\n                                                    |> NamedType ( [], n )\n                                                    |> DereferencedType\n                                                    |> assignTypeVars (makePositionalArgTypeVars gs)\n                                                    |> getType\n                                                    |> TypeWithPositionalVars\n                                           )\n                                    )\n                                    generics\n                                |> (\\( n_, type_, rs ) ->\n                                        ( ( n_\n                                          , { customTypeName = Just n\n                                            , type_ = type_\n                                            }\n                                          )\n                                            :: fAcc\n                                        , rs ++ rAcc\n                                        )\n                                   )\n                        )\n                        ( [], [] )\n                        constructors\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | constructors = newConstructors ++ acc.constructors\n                        , canonicalRecords = newRecords ++ acc.canonicalRecords\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedConstructors = newConstructors ++ acc.exposedConstructors\n                        , exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                    }\n                )\n\n        AliasDeclaration { name, generics, typeAnnotation } ->\n            let\n                n : String\n                n =\n                    Node.value name\n\n                aliasInfo : ( String, TypeWithPositionalVars )\n                aliasInfo =\n                    ( n\n                    , typeAnnotToTypeWithPositionalVars context\n                        -- Constrained type vars are not respected for aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        (List.map Node.value generics)\n                        typeAnnotation\n                    )\n            in\n            skipIfIgnored (Set.member n << .types)\n                { acc | exposedAliases = aliasInfo :: acc.exposedAliases }\n                (\\() ->\n                    annotToFields typeAnnotation\n                        |> MaybeX.unwrap ( [], [] )\n                            (\\( fields, isGeneric ) ->\n                                ( -- Generic records do not have constructors.\n                                  if isGeneric then\n                                    []\n\n                                  else\n                                    [ ( n\n                                      , { customTypeName = Nothing\n                                        , type_ =\n                                            List.map Node.value generics\n                                                |> (\\vars ->\n                                                        List.map\n                                                            (Node.value\n                                                                >> Tuple.second\n                                                                >> typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                            )\n                                                            fields\n                                                            |> makeFunctionTypeWithPositionalVars\n                                                                (typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                                    typeAnnotation\n                                                                )\n                                                   )\n                                        }\n                                      )\n                                    ]\n                                , knownRecordFromTypeAnnot subrecordTreatment context ( fields, isGeneric )\n                                    |> List.map (Tuple.mapFirst (\\s -> n ++ s))\n                                )\n                            )\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | aliases = aliasInfo :: acc.exposedAliases\n                        , constructors = newConstructors ++ acc.constructors\n                        , canonicalRecords = newRecords ++ acc.canonicalRecords\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedConstructors = newConstructors ++ acc.exposedConstructors\n                        , exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                    }\n                )\n\n        _ ->\n            -- Nothing to do for:\n            -- PortDeclaration\n            -- InfixDeclaration\n            -- Destructuring\n            acc"},{"$":1,"a":{"bV":{"bb":48,"bp":2671},"ch":{"bb":1,"bp":2662}},"b":"{-| The project context.\n\n`aliases` stores all type aliases.\n\n`canonicalRecords` stores known aliased records.\n\n`constructors` are different than functions, as they (might) require type\nvars.\n\n`functionTypes` stores the types of all functions (for type inference).\n\n-}\ntype alias ProjectContext =\n    { aliases : Dict ModuleName (Dict String TypeWithPositionalVars)\n    , canonicalRecords : Dict ModuleName (Dict String KnownRecord)\n    , constructors : Dict ModuleName (Dict String { customTypeName : Maybe String, type_ : TypeWithPositionalVars })\n    , functionTypes : Dict ModuleName (Dict String Type)\n    }"},{"$":1,"a":{"bV":{"bb":23,"bp":2683},"ch":{"bb":1,"bp":2674}},"b":"{-| Given an error range and whether or not a record has all fields of the known\ntype, convert a `RecordDefinition` into a checkable record.\n-}\nrecordDefToCheckable : ModuleContext -> Range -> Bool -> Maybe DereferencedType -> RecordDefinition -> RecordToCheck\nrecordDefToCheckable context fullRange hasAllFields hasTypeFromParent fields =\n    let\n        makeType : Node TypeAnnotation -> Maybe DereferencedType\n        makeType =\n            typeAnnotToNoncanonicalType context\n                >> dereferenceType context\n                >> Just\n\n        orderInfo : Maybe OrderInfo\n        orderInfo =\n            Maybe.andThen (Result.toMaybe << makeFieldOrder) hasTypeFromParent\n                |> Maybe.map HasFieldOrder\n                |> MaybeX.orElse\n                    (if hasAllFields then\n                        Just HasAllFields\n\n                     else\n                        Nothing\n                    )\n    in\n    List.map\n        (\\f ->\n            let\n                ( field, type_ ) =\n                    Node.value f\n            in\n            { field = Node.value field, type_ = makeType type_, range = Node.range f }\n        )\n        fields\n        |> (\\fs ->\n                { fullRange = fullRange\n                , orderInfo = orderInfo\n                , fields = fs\n                }\n           )"},{"$":1,"a":{"bV":{"bb":15,"bp":2752},"ch":{"bb":1,"bp":2686}},"b":"{-| Given an error range and maybe a type, convert a record pattern to a\ncheckable record.\n-}\nrecordPatternToCheckable : Range -> Maybe DereferencedType -> List (Node String) -> RecordToCheck\nrecordPatternToCheckable fullRange hasType =\n    let\n        types : Dict String DereferencedType\n        types =\n            getRecordFieldTypes hasType\n\n        orderInfo : Maybe OrderInfo\n        orderInfo =\n            Maybe.andThen (Result.toMaybe << makeFieldOrder) hasType\n                |> Maybe.map HasFieldOrder\n    in\n    List.map\n        (\\r ->\n            { field = Node.value r\n            , type_ = Dict.get (Node.value r) types\n            , range = Node.range r\n            }\n        )\n        >> (\\fs ->\n                { fullRange = fullRange\n                , orderInfo = orderInfo\n                , fields = fs\n                }\n           )"},{"$":1,"a":{"bV":{"bb":13,"bp":2793},"ch":{"bb":1,"bp":2755}},"b":"{-| Given an error range, whether or not a record has all fields of the known\ntype, and maybe a type, convert a list of record setters to a checkable record.\n-}\nrecordSettersToCheckable : LocalContext -> Range -> Bool -> Maybe DereferencedType -> List (Node RecordSetter) -> RecordToCheck\nrecordSettersToCheckable context fullRange hasAllFields hasType =\n    let\n        fallback : Maybe OrderInfo\n        fallback =\n            if hasAllFields then\n                Just HasAllFields\n\n            else\n                Nothing\n\n        types : Dict String DereferencedType\n        types =\n            getRecordFieldTypes hasType\n\n        orderInfo : Maybe OrderInfo\n        orderInfo =\n            Maybe.andThen (Result.toMaybe << makeFieldOrder) hasType\n                |> Maybe.map HasFieldOrder\n                |> MaybeX.orElse fallback\n    in\n    List.map\n        (\\r ->\n            let\n                f : String\n                f =\n                    Node.value <| Tuple.first <| Node.value r\n            in\n            { field = f\n            , type_ =\n                Dict.get f types\n                    |> MaybeX.orElseLazy (\\() -> inferExprType context <| Tuple.second <| Node.value r)\n            , range = Node.range r\n            }\n        )\n        >> (\\fs ->\n                { fullRange = fullRange\n                , orderInfo = orderInfo\n                , fields = fs\n                }\n           )"},{"$":1,"a":{"bV":{"bb":18,"bp":2837},"ch":{"bb":1,"bp":2796}},"b":"{-| A record type, expression, or pattern, packaged in a standardized format for\nchecking.\n-}\ntype alias RecordToCheck =\n    { fullRange : Range\n    , orderInfo : Maybe OrderInfo\n    , fields : List Field\n    }"},{"$":1,"a":{"bV":{"bb":13,"bp":2867},"ch":{"bb":1,"bp":2840}},"b":"{-| Given context and a predicate to filter valid records, find a list of\nrecords that match a list of fields.\n-}\nsearchOrders : RuleConfig -> ModuleContext -> Bool -> List Field -> OrderMatches\nsearchOrders (RuleConfig { typecheckUnambiguousRecords }) context hasAllFields fields =\n    let\n        matchFields : Dict String Field\n        matchFields =\n            List.map (\\f -> ( f.field, f )) fields\n                |> Dict.fromList\n\n        checkTypes : KnownRecord -> Bool\n        checkTypes { order } =\n            List.foldl\n                (\\{ field, type_ } ( varAcc, matchAcc ) ->\n                    let\n                        assignedVars : Dict ( Int, String ) Type\n                        assignedVars =\n                            -- Only keep type variables assigned on the known record, since fields are independent\n                            -- For example, { a = Nothing, b = Nothing } should not require `a` and `b` to have the\n                            -- same type variable (but it does for the known record if they are both `Maybe var`)\n                            Dict.filter (\\( i, _ ) _ -> i == 2) varAcc\n                    in\n                    Dict.get field order\n                        |> Maybe.map (dereferenceType context << Tuple.second)\n                        |> Maybe.map2 (typesMatch assignedVars) type_\n                        -- If any `Nothing`s were encountered, we're missing type info\n                        |> Maybe.withDefault ( assignedVars, True )\n                        |> Tuple.mapSecond ((&&) matchAcc)\n                )\n                ( Dict.empty, True )\n                fields\n                |> Tuple.second\n\n        missingFieldLimit : KnownRecord -> Int\n        missingFieldLimit =\n            if hasAllFields then\n                always 1\n\n            else\n                Dict.size << .order\n\n        step : ModuleName -> String -> KnownRecord -> OrderMatches -> OrderMatches\n        step moduleName name o acc =\n            if Dict.size (Dict.diff o.order matchFields) >= missingFieldLimit o then\n                -- Too many fields are missing\n                acc\n\n            else if o.isGeneric then\n                { acc\n                    | genericMatches =\n                        { type_ = ( ( moduleName, name ), o )\n                        , missing = Dict.values <| Dict.diff matchFields o.order\n                        }\n                            :: acc.genericMatches\n                }\n\n            else if Dict.isEmpty <| Dict.diff matchFields o.order then\n                -- Record is not generic and has no extra fields, so it is a good match\n                { acc | canonicalMatches = ( ( moduleName, name ), o ) :: acc.canonicalMatches }\n\n            else\n                -- Record was not generic but extra fields were present, so it wasn't a match\n                acc\n    in\n    Dict.foldl\n        (\\moduleName moduleTypes outerAcc ->\n            Dict.foldl\n                (step moduleName)\n                outerAcc\n                moduleTypes\n        )\n        { canonicalMatches = [], genericMatches = [] }\n        context.canonicalRecords\n        |> (\\({ canonicalMatches, genericMatches } as res) ->\n                if typecheckUnambiguousRecords || List.length canonicalMatches + List.length genericMatches > 1 then\n                    -- If there are multiple matches, try to disambiguate by type\n                    { canonicalMatches = List.filter (checkTypes << Tuple.second) canonicalMatches\n                    , genericMatches = List.filter (checkTypes << Tuple.second << .type_) genericMatches\n                    }\n\n                else\n                    res\n           )"},{"$":1,"a":{"bV":{"bb":13,"bp":2913},"ch":{"bb":1,"bp":2870}},"b":"{-| Specify how to handle generic records.\n-}\ntype SortGenerics\n    = GenericFieldsFirst\n    | GenericFieldsLast"},{"$":1,"a":{"bV":{"bb":19,"bp":2932},"ch":{"bb":1,"bp":2916}},"b":"{-| Specify how to handle records without a canonical order.\n-}\ntype SortWithoutCanonicalOrder\n    = Alphabetically\n    | ReportOnly\n    | DoNotSort"},{"$":1,"a":{"bV":{"bb":50,"bp":3081},"ch":{"bb":1,"bp":2935}},"b":"{-| Specify how to deal with subrecords.\n\n  - `CanonicalWhenSubrecord` -- Subrecords have canonical order only when they\n    are part of their larger record/constructor.\n  - `CustomTypeArgsAlwaysCanonical` -- Arguments of custom types are always\n    canonical, but other subrecords are only canonical in place. This was the\n    behavior prior to 1.1.0.\n  - `AlwaysUnknown` -- Always consider subrecords unknown records (unless of\n    course they match something else).\n  - `AlwaysCanonical` -- Check for standalone subrecords as a lower-priority\n    \"known\" record.\n\n-}\ntype SubrecordCanonicity\n    = CanonicalWhenSubrecord\n    | CustomTypeArgsAlwaysCanonical\n    | AlwaysUnknown\n    | AlwaysCanonical"},{"$":1,"a":{"bV":{"bb":13,"bp":3153},"ch":{"bb":1,"bp":3084}},"b":"{-| Return whether or not subrecords should be considered canonical, for\ncreating the type of a field or argument.\n-}\nsubrecordCanonicityForField : SubrecordCanonicity -> Maybe Bool\nsubrecordCanonicityForField subrecordTreatment =\n    case subrecordTreatment of\n        CanonicalWhenSubrecord ->\n            Just True\n\n        CustomTypeArgsAlwaysCanonical ->\n            Just True\n\n        AlwaysUnknown ->\n            Nothing\n\n        AlwaysCanonical ->\n            Just True"},{"$":1,"a":{"bV":{"bb":35,"bp":3236},"ch":{"bb":1,"bp":3156}},"b":"{-| Return whether or not subrecords should be considered canonical, for\ncreating the type of a full record.\n-}\nsubrecordCanonicityForRecord : SubrecordCanonicity -> Maybe Bool\nsubrecordCanonicityForRecord subrecordTreatment =\n    case subrecordTreatment of\n        CanonicalWhenSubrecord ->\n            Just True\n\n        CustomTypeArgsAlwaysCanonical ->\n            Just True\n\n        AlwaysUnknown ->\n            Just False\n\n        AlwaysCanonical ->\n            Just True"},{"$":1,"a":{"bV":{"bb":6,"bp":3252},"ch":{"bb":1,"bp":3239}},"b":"{-| A type that, after being dereferenced, will not contain aliases and stores\nwhether or not records have canonical field order.\n\nNote that `TypeVar` is never concrete, as a `Type` is always made with full info\nabout all type variables, so the only way `TypeVar` can exist is if it's not\nused.\n\n-}\ntype Type\n    = FunctionType { from : Type, to : Type }\n    | TupleType (List Type)\n    | ListType Type\n    | UnitType\n    | NamedType ( ModuleName, String ) (List Type)\n    | RecordType { generic : Maybe Type, canonical : Bool, fields : List ( String, Type ) }\n    | TypeVar (Maybe Typeclass) String"},{"$":1,"a":{"bV":{"bb":13,"bp":3338},"ch":{"bb":1,"bp":3255}},"b":"{-| Wrapper for `typeAnnotToType` when not dealing with aliases.\n-}\ntypeAnnotToNoncanonicalType : { context | moduleName : ModuleName, lookupTable : ModuleNameLookupTable } -> Node TypeAnnotation -> Type\ntypeAnnotToNoncanonicalType context =\n    typeAnnotToType context\n        { constrainedTypeVarsAreRespected = True\n        , subrecordIsAlsoCanonical = Nothing\n        }"},{"$":1,"a":{"bV":{"bb":36,"bp":3442},"ch":{"bb":1,"bp":3341}},"b":"{-| Given context and whether or not a top-level record type (if `Just`) and\nsubrecords (if `Just True`) found are in canonical order, convert a\n`TypeAnnotation` into a `Type`.\n-}\ntypeAnnotToType : { context | moduleName : ModuleName, lookupTable : ModuleNameLookupTable } -> { constrainedTypeVarsAreRespected : Bool, subrecordIsAlsoCanonical : Maybe Bool } -> Node TypeAnnotation -> Type\ntypeAnnotToType context ({ constrainedTypeVarsAreRespected, subrecordIsAlsoCanonical } as settings) annot =\n    let\n        go : Node TypeAnnotation -> Type\n        go =\n            MaybeX.filter identity subrecordIsAlsoCanonical\n                |> (\\subrecordStillCanon ->\n                        typeAnnotToType context { settings | subrecordIsAlsoCanonical = subrecordStillCanon }\n                   )\n\n        makeList : ModuleName -> String -> List (Node TypeAnnotation) -> Maybe Type\n        makeList moduleName name args =\n            case ( moduleName, name, args ) of\n                ( [ \"List\" ], \"List\", [ listType ] ) ->\n                    Just <| ListType <| go listType\n\n                _ ->\n                    Nothing\n    in\n    case Node.value annot of\n        Typed name args ->\n            moduleNameFor context.lookupTable name\n                |> Maybe.withDefault (Tuple.first <| Node.value name)\n                |> (\\moduleName ->\n                        if moduleName == [] then\n                            -- If the module name is empty, then update to current module name\n                            context.moduleName\n\n                        else\n                            moduleName\n                   )\n                |> Tuple.pair (Tuple.second <| Node.value name)\n                |> (\\( n, moduleName ) ->\n                        makeList moduleName n args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( moduleName, n ) <| List.map go args)\n                   )\n\n        Unit ->\n            UnitType\n\n        Tupled ts ->\n            TupleType <| List.map go ts\n\n        Record fs ->\n            RecordType\n                { generic = Nothing\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) fs\n                }\n\n        GenericRecord generic fs ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Just <| TypeVar Nothing <| Node.value generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) <| Node.value fs\n                }\n\n        FunctionTypeAnnotation from to ->\n            FunctionType { from = go from, to = go to }\n\n        GenericType s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":31,"bp":3512},"ch":{"bb":1,"bp":3445}},"b":"{-| Given context, whether or not a top-level record type (if `Just`) and\nsubrecords (if `Just True`) found are in canonical order, and a `Dict` of\npositional type variables, convert a `TypeAnnotation` into a\n`TypeWithPositionalVars`.\n-}\ntypeAnnotToTypeWithPositionalVars : { context | moduleName : ModuleName, lookupTable : ModuleNameLookupTable } -> { constrainedTypeVarsAreRespected : Bool, subrecordIsAlsoCanonical : Maybe Bool } -> List String -> Node TypeAnnotation -> TypeWithPositionalVars\ntypeAnnotToTypeWithPositionalVars context settings typeArgs =\n    typeAnnotToType context settings\n        >> DereferencedType\n        >> assignTypeVars (makePositionalArgTypeVars typeArgs)\n        >> getType\n        >> TypeWithPositionalVars"},{"$":1,"a":{"bV":{"bb":38,"bp":3694},"ch":{"bb":1,"bp":3515}},"b":"{-| A type with positional type variables, e.g. `Ok a` having been created from\n`Result a b`.\n-}\ntype TypeWithPositionalVars\n    = TypeWithPositionalVars Type"},{"$":1,"a":{"bV":{"bb":58,"bp":3762},"ch":{"bb":1,"bp":3697}},"b":"{-| Represent an Elm \"typeclass\" (constrained type variable, like `number`).\n-}\ntype Typeclass\n    = Appendable\n    | Number\n    | Comparable\n    | CompAppend"},{"$":1,"a":{"bV":{"bb":13,"bp":3792},"ch":{"bb":1,"bp":3765}},"b":"{-| Check two `Type`s and see if they are theoretically equivalent (e.g. type\nvars can match anything.\n-}\ntypesMatch : Dict ( Int, String ) Type -> DereferencedType -> DereferencedType -> ( Dict ( Int, String ) Type, Bool )\ntypesMatch inVars (DereferencedType derefType1) (DereferencedType derefType2) =\n    let\n        matchTypeVars : Int -> Dict ( Int, String ) Type -> Maybe Typeclass -> String -> Type -> ( Dict ( Int, String ) Type, Bool )\n        matchTypeVars side typeVars typeclass name type_ =\n            case ( Dict.get ( side, name ) typeVars, type_ ) of\n                ( Just t, _ ) ->\n                    -- If the type var has been assigned, check if that type matches\n                    -- Remove the matched typevar, because if the same exists within it refers to a different value\n                    go (Dict.remove ( side, name ) typeVars) t type_\n                        |> Tuple.mapFirst (Dict.insert ( side, name ) t)\n\n                ( Nothing, TypeVar _ _ ) ->\n                    -- Handle base case.  This isn't right, but not worth going to the effort of matching typeclasses and the like\n                    ( typeVars, True )\n\n                ( Nothing, _ ) ->\n                    if\n                        Maybe.map (matchesTypeClass type_) typeclass\n                            |> Maybe.withDefault True\n                    then\n                        ( Dict.insert ( side, name ) type_ typeVars, True )\n\n                    else\n                        ( typeVars, False )\n\n        checkListOfTypes : Dict ( Int, String ) Type -> List Type -> List Type -> ( Dict ( Int, String ) Type, Bool )\n        checkListOfTypes typeVars t1s t2s =\n            if List.length t1s /= List.length t2s then\n                ( typeVars, False )\n\n            else\n                ListX.zip t1s t2s\n                    |> List.foldl\n                        (\\( t1_, t2_ ) ( varAcc, matchAcc ) ->\n                            go varAcc t1_ t2_\n                                |> Tuple.mapSecond ((&&) matchAcc)\n                        )\n                        ( typeVars, True )\n\n        validateRecordMatch : Dict ( Int, String ) Type -> Maybe Type -> Maybe Type -> { only1 : List ( String, Type ), both : List ( Type, Type ), only2 : List ( String, Type ) } -> ( Dict ( Int, String ) Type, Bool )\n        validateRecordMatch typeVars generic1 generic2 { only1, only2, both } =\n            -- Fields in both must match\n            List.unzip both\n                |> (\\( l1s, l2s ) -> checkListOfTypes typeVars l1s l2s)\n                |> (\\( vars, matchAcc ) ->\n                        validate (not << List.isEmpty) only1\n                            |> Maybe.map2 (\\g fs -> go vars (RecordType { canonical = False, generic = Nothing, fields = fs }) g) generic2\n                            |> Maybe.withDefault ( vars, List.isEmpty only1 )\n                            |> Tuple.mapSecond ((&&) matchAcc)\n                   )\n                |> (\\( vars, matchAcc ) ->\n                        validate (not << List.isEmpty) only2\n                            |> Maybe.map2 (\\g fs -> go vars (RecordType { canonical = False, generic = Nothing, fields = fs }) g) generic1\n                            |> Maybe.withDefault ( vars, List.isEmpty only2 )\n                            |> Tuple.mapSecond ((&&) matchAcc)\n                   )\n\n        go : Dict ( Int, String ) Type -> Type -> Type -> ( Dict ( Int, String ) Type, Bool )\n        go typeVars type1 type2 =\n            case ( type1, type2 ) of\n                ( TypeVar c n, t ) ->\n                    matchTypeVars 1 typeVars c n t\n\n                ( t, TypeVar c n ) ->\n                    matchTypeVars 2 typeVars c n t\n\n                ( ListType t1, ListType t2 ) ->\n                    go typeVars t1 t2\n\n                ( TupleType t1s, TupleType t2s ) ->\n                    -- Tuples must be same size\n                    checkListOfTypes typeVars t1s t2s\n\n                ( FunctionType f1, FunctionType f2 ) ->\n                    checkListOfTypes typeVars [ f1.from, f1.to ] [ f1.from, f2.to ]\n\n                ( UnitType, UnitType ) ->\n                    ( typeVars, True )\n\n                ( NamedType n1 args1, NamedType n2 args2 ) ->\n                    checkListOfTypes typeVars args1 args2\n                        |> Tuple.mapSecond ((&&) (n1 == n2))\n\n                ( RecordType r1, RecordType r2 ) ->\n                    -- Divide fields into those that are present in both and those that are missing\n                    Dict.merge\n                        (\\f t1 acc -> { acc | only1 = ( f, t1 ) :: acc.only1 })\n                        (\\_ t1 t2 acc -> { acc | both = ( t1, t2 ) :: acc.both })\n                        (\\f t2 acc -> { acc | only2 = ( f, t2 ) :: acc.only2 })\n                        (Dict.fromList r1.fields)\n                        (Dict.fromList r2.fields)\n                        { only1 = [], both = [], only2 = [] }\n                        |> validateRecordMatch typeVars r1.generic r2.generic\n\n                _ ->\n                    ( typeVars, False )\n    in\n    go inVars derefType1 derefType2"},{"$":1,"a":{"bV":{"bb":15,"bp":3888},"ch":{"bb":1,"bp":3870}},"b":"{-| Given a list of types, try to reduce them to a single type.\n-}\nunifyTypes : List Type -> Maybe Type\nunifyTypes =\n    List.foldl\n        (\\t acc ->\n            -- Dedupe the slow way because custom types aren't comparable and order doesn't matter\n            if List.member t acc then\n                acc\n\n            else\n                t :: acc\n        )\n        []\n        >> (\\ts ->\n                case ( ts, List.filter ((/=) (TypeVar Nothing \"inferred empty list typevar\")) ts ) of\n                    ( [ t ], _ ) ->\n                        Just t\n\n                    ( _, [] ) ->\n                        Nothing\n\n                    ( _, [ t ] ) ->\n                        Just t\n\n                    ( _, t :: ts_ ) ->\n                        List.foldl (\\t_ acc -> Maybe.andThen (unifyTwoTypes t_) acc) (Just t) ts_\n           )"},{"$":1,"a":{"bV":{"bb":15,"bp":3924},"ch":{"bb":1,"bp":3891}},"b":"{-| Report that an unknown record was encountered without fixes.\n-}\nunknownRecordError : RecordToCheck -> Range -> List (Error {})\nunknownRecordError { fields } range =\n    case fields of\n        _ :: _ :: _ ->\n            [ Rule.error\n                { message = \"Unknown record encountered.\"\n                , details =\n                    [ \"This record did not correspond with any known alias or custom type argument record, so whether or not its fields are sorted could not be determined!\"\n                    , \"Create a type alias for this record type, or remove reportUnknownRecordsWithoutFix from your rule configuration.\"\n                    ]\n                }\n                range\n            ]\n\n        _ ->\n            -- Do not report 0 or 1 field records\n            []"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-1,"a":1,"b":"src/NoUnsortedLetDeclarations.elm","c":{"bT":3093415870,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":6,"bp":174},"ch":{"bb":1,"bp":170}},"b":"{-| Configuration for this rule. Create a new one with `sortLetDeclarations` and use\norderings to create a hierarchy of sorting.\n-}\ntype RuleConfig r\n    = RuleConfig\n        { sortBy : List (LetDec -> LetDec -> Order)\n        , glues : List Glue\n        }"},{"$":1,"a":{"bV":{"bb":40,"bp":183},"ch":{"bb":1,"bp":177}},"b":"{-| Create a new `RuleConfig`. Use the various orderings to then specify\nprimary and fallback orderings.\n-}\nsortLetDeclarations : RuleConfig { noAlphabetical : (), noArgCount : (), noDependency : (), noHelper : (), noUsedInOther : (), noUsedInExpression : () }\nsortLetDeclarations =\n    RuleConfig { sortBy = [], glues = [] }"},{"$":1,"a":{"bV":{"bb":10,"bp":193},"ch":{"bb":1,"bp":186}},"b":"{-| Sort declarations alphabetically by the name of their binding. For\ndestructurings, this will be the name of the actual bindings that are made, in\nalphabetical order. For example, the following is sorted alphabetically:\n\n    let\n        (Opaque a) =\n            i\n\n        ( z, b ) =\n            j\n\n        { c, y } =\n            k\n\n        d =\n            l\n    in\n    x\n\n-}\nalphabetically : RuleConfig { r | noAlphabetical : () } -> RuleConfig r\nalphabetically (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 -> compare (Set.toList d1.namesBound) (Set.toList d2.namesBound))\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":52,"bp":199},"ch":{"bb":1,"bp":196}},"b":"{-| Sort declarations with those used in the expression of the `let` block\ncoming first, then those that aren't. Ties will be broken by the next specified\nordering. For example, the following is sorted by this ordering and then\nalphabetically:\n\n    let\n        -- These are used in the expression\n        x =\n            a\n\n        y =\n            b\n\n        -- These are not\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\n-}\nusedInExpressionFirst : RuleConfig { r | noUsedInExpression : () } -> RuleConfig r\nusedInExpressionFirst (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.usedInExpression, d2.usedInExpression ) of\n                        ( True, False ) ->\n                            LT\n\n                        ( False, True ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":6,"bp":212},"ch":{"bb":1,"bp":202}},"b":"{-| Sort declarations with those used in the expression of the `let` block\ncoming last, with those that aren't coming first. Ties will be broken by the\nnext specified ordering. For example, the following is sorted by this ordering\nand then alphabetically:\n\n    let\n        -- These are not used in the expression\n        x =\n            i\n\n        y =\n            j\n\n        -- These are used in the expression\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n\n-}\nusedInExpressionLast : RuleConfig { r | noUsedInExpression : () } -> RuleConfig r\nusedInExpressionLast (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.usedInExpression, d2.usedInExpression ) of\n                        ( False, True ) ->\n                            LT\n\n                        ( True, False ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":43,"bp":220},"ch":{"bb":1,"bp":215}},"b":"{-| Sort declarations with those used in other declarations coming after those\nthat are not. Ties will be broken by the next specified ordering. For example,\nthe following is sorted by this ordering and then alphabetically:\n\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n\n-}\nusedInOtherDeclarationsLast : RuleConfig { r | noUsedInOther : () } -> RuleConfig r\nusedInOtherDeclarationsLast (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.usedInOtherDecs, d2.usedInOtherDecs ) of\n                        ( False, True ) ->\n                            LT\n\n                        ( True, False ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":250},"ch":{"bb":1,"bp":223}},"b":"{-| Sort declarations with those used in other declarations coming before those\nthat are not. Ties will be broken by the next specified ordering. For example,\nthe following is sorted by this ordering and then alphabetically:\n\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n\n-}\nusedInOtherDeclarationsFirst : RuleConfig { r | noUsedInOther : () } -> RuleConfig r\nusedInOtherDeclarationsFirst (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.usedInOtherDecs, d2.usedInOtherDecs ) of\n                        ( True, False ) ->\n                            LT\n\n                        ( False, True ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":293},"ch":{"bb":1,"bp":253}},"b":"{-| Sort declarations that do not have arguments before those that do. Since no\ntype inference is performed, this does not guarantee that some things that are\nfunctions will not be sorted with values. For example, the following is sorted\nby this ordering and then alphabetically:\n\n    let\n        -- These do not have arguments\n        x =\n            a\n\n        y =\n            b\n\n        -- These do\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n\n-}\nvaluesBeforeFunctions : RuleConfig { r | noArgCount : () } -> RuleConfig r\nvaluesBeforeFunctions (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( List.isEmpty d1.args, List.isEmpty d2.args ) of\n                        ( True, False ) ->\n                            LT\n\n                        ( False, True ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":336},"ch":{"bb":1,"bp":296}},"b":"{-| Sort declarations that do not have arguments after those that do. Since no\ntype inference is performed, this does not guarantee that some things that are\nfunctions will not be sorted with values. For example, the following is sorted\nby this ordering and then alphabetically:\n\n    let\n        -- These have arguments\n        a i =\n            i\n\n        b j =\n            j\n\n        -- These do not\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n\n-}\nvaluesAfterFunctions : RuleConfig { r | noArgCount : () } -> RuleConfig r\nvaluesAfterFunctions (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( List.isEmpty d1.args, List.isEmpty d2.args ) of\n                        ( False, True ) ->\n                            LT\n\n                        ( True, False ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":376},"ch":{"bb":1,"bp":339}},"b":"{-| Helpers are declarations that are _not_ used in the expression that are used\nin exactly one other declaration. This glue attaches them immediately before the\ndeclaration they are used in.\n\nFor example:\n\n    foo input =\n        let\n            step : Int -> Int -> Int\n            step i acc =\n                i + acc\n\n            sum : Int\n            sum =\n                List.foldl step 0 input\n        in\n        sum + 1\n\n-}\nglueHelpersBefore : RuleConfig { r | noHelper : () } -> RuleConfig r\nglueHelpersBefore (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be helpers\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate ((==) 1 << Tuple.second)\n                            |> Maybe.map (GluedBeforeFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":416},"ch":{"bb":1,"bp":379}},"b":"{-| Helpers are declarations that are _not_ used in the expression that are used\nin exactly one other declaration. This glue attaches them immediately after the\ndeclaration they are used in.\n\nFor example:\n\n    foo input =\n        let\n            sum : Int\n            sum =\n                List.foldl step 0 input\n\n            step : Int -> Int -> Int\n            step i acc =\n                i + acc\n        in\n        sum + 1\n\n-}\nglueHelpersAfter : RuleConfig { r | noHelper : () } -> RuleConfig r\nglueHelpersAfter (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be helpers\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate ((==) 1 << Tuple.second)\n                            |> Maybe.map (GluedAfterFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":459},"ch":{"bb":1,"bp":419}},"b":"{-| Dependencies are declarations that are _not_ used in the expression that are\nused in multiple other declarations. This glue attaches them immediately before\nthe first declaration they are used in.\n\nFor example:\n\n    foo =\n        let\n            unwrap =\n                some func\n\n            a x =\n                unwrap x\n\n            b x =\n                unwrap x\n\n            c x =\n                unwrap x\n        in\n        bar\n\n-}\nglueDependenciesBeforeFirstDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesBeforeFirstDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be dependencies\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedBeforeFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":502},"ch":{"bb":1,"bp":462}},"b":"{-| Dependencies are declarations that are _not_ used in the expression that are\nused in multiple other declarations. This glue attaches them immediately after\nthe first declaration they are used in.\n\nFor example:\n\n    foo =\n        let\n            a x =\n                unwrap x\n\n            unwrap =\n                some func\n\n            b x =\n                unwrap x\n\n            c x =\n                unwrap x\n        in\n        bar\n\n-}\nglueDependenciesAfterFirstDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesAfterFirstDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be dependencies\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedAfterFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":540},"ch":{"bb":1,"bp":505}},"b":"{-| Dependencies are declarations that are _not_ used in the expression that are\nused in multiple other declarations. This glue attaches them immediately before\nthe last declaration they are used in.\n\nFor example:\n\n    foo =\n        let\n            a x =\n                unwrap x\n\n            b x =\n                unwrap x\n\n            unwrap =\n                some func\n\n            c x =\n                unwrap x\n        in\n        bar\n\n-}\nglueDependenciesBeforeLastDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesBeforeLastDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be dependencies\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedBeforeLast << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":578},"ch":{"bb":1,"bp":543}},"b":"{-| Dependencies are declarations that are _not_ used in the expression that are\nused in multiple other declarations. This glue attaches them immediately after\nthe last declaration they are used in.\n\nFor example:\n\n    foo =\n        let\n            a x =\n                unwrap x\n\n            b x =\n                unwrap x\n\n            c x =\n                unwrap x\n\n            unwrap =\n                some func\n        in\n        bar\n\n-}\nglueDependenciesAfterLastDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesAfterLastDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only decs not used in expression can be dependencies\n                    if d.usedInExpression == False then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedAfterLast << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":620},"ch":{"bb":1,"bp":581}},"b":"{-| Context for the rule, containing only a source extractor.\n-}\ntype alias Context =\n    { extractSource : Range -> String\n    }"},{"$":1,"a":{"bV":{"bb":10,"bp":662},"ch":{"bb":1,"bp":623}},"b":"{-| Visit expressions, checking `let` blocks for sorting.\n-}\nexpressionVisitor : RuleConfig r -> Node Expression -> Context -> List (Error {})\nexpressionVisitor (RuleConfig { glues, sortBy }) n context =\n    case Node.value n of\n        LetExpression lb ->\n            let\n                ( exprsToDecs, exprs ) =\n                    List.foldl step ( [], [] ) lb.declarations\n\n                errorRange : Range\n                errorRange =\n                    let\n                        r : Range\n                        r =\n                            Node.range n\n                    in\n                    -- Assume that the `let` of a let block is just the first 3 chars\n                    { r | end = { row = r.start.row, column = r.start.column + 3 } }\n\n                step :\n                    Node LetDeclaration\n                    -> ( List (List (Node Expression) -> LetDec), List (Node Expression) )\n                    -> ( List (List (Node Expression) -> LetDec), List (Node Expression) )\n                step d ( dAcc, eAcc ) =\n                    case Node.value d of\n                        LetFunction { declaration } ->\n                            let\n                                { expression, arguments } =\n                                    Node.value declaration\n\n                                name : String\n                                name =\n                                    Node.value (Node.value declaration).name\n                            in\n                            ( (\\es ->\n                                { range = Node.range d\n                                , namesBound = Set.singleton name\n                                , usedInExpression = countUsesIn lb.expression name >= 1\n                                , usedInOtherDecs = List.any (\\e -> countUsesIn e name >= 1) es\n                                , args = List.concatMap allBindingsInPattern arguments\n                                , glued = Nothing\n                                , dependentOnBindings = findAllNamesIn expression\n                                }\n                              )\n                                :: dAcc\n                            , expression :: eAcc\n                            )\n\n                        LetDestructuring p expression ->\n                            let\n                                bs : List String\n                                bs =\n                                    allBindingsInPattern p\n                            in\n                            ( (\\es ->\n                                { range = Node.range d\n                                , namesBound = Set.fromList bs\n                                , usedInExpression = List.any ((\\numUses -> numUses > 0) << countUsesIn lb.expression) bs\n                                , usedInOtherDecs = List.any (\\e -> List.any ((\\numUses -> numUses > 0) << countUsesIn e) bs) es\n                                , args = []\n                                , glued = Nothing\n                                , dependentOnBindings = findAllNamesIn expression\n                                }\n                              )\n                                :: dAcc\n                            , expression :: eAcc\n                            )\n\n                applyGlues : List LetDec -> Int -> LetDec -> LetDec\n                applyGlues ds i d =\n                    { d | glued = ListX.findMap (\\g -> g ( i, d ) ds) glues }\n            in\n            ListX.reverseMap (\\f -> f exprs) exprsToDecs\n                |> (\\ds -> List.indexedMap (applyGlues ds) ds)\n                |> checkSortingWithGlue context.extractSource \"Let declarations\" sortBy errorRange\n\n        _ ->\n            []"},{"$":1,"a":{"bV":{"bb":10,"bp":704},"ch":{"bb":1,"bp":665}},"b":"{-| Given a `LetDec` and a list of other `LetDec`s,\n-}\ntype alias Glue =\n    ( Int, LetDec ) -> List LetDec -> Maybe GluedTo"},{"$":1,"a":{"bV":{"bb":10,"bp":746},"ch":{"bb":1,"bp":707}},"b":"{-| Create a context with a source extractor.\n-}\ninitialContext : Rule.ContextCreator () Context\ninitialContext =\n    Rule.initContextCreator\n        (\\extractSource () -> { extractSource = extractSource })\n        |> Rule.withSourceCodeExtractor"},{"$":1,"a":{"bV":{"bb":15,"bp":827},"ch":{"bb":1,"bp":749}},"b":"{-| A `let` declaration, parsed for full information.\n-}\ntype alias LetDec =\n    { range : Range\n    , namesBound : Set String\n    , usedInExpression : Bool\n    , dependentOnBindings : Set String\n    , usedInOtherDecs : Bool\n    , args : List String\n    , glued : Maybe GluedTo\n    }"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-1,"a":0,"b":"src/NoUnsortedCases.elm","c":{"bT":4024434763,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":248},"ch":{"bb":1,"bp":239}},"b":"{-| The default configuration, with the following behavior:\n\n  - All custom types are sorted. (This can be restricted by using\n    `sortOnlyMatchingTypes`.)\n\n  - Literal patterns (`String`, `Int`, etc.) are sorted in the natural order for their type.\n\n  - Types imported from dependencies are sorted in declaration order, i.e. in the order they appear in the dependency's source file (or more technically in its documentation); this is identical to the behavior of types defined within your own modules.\n\n  - Lists are sorted elementwise, by comparing the elements sequentially at each\n    position (from left to right).\n\n  - Unsortable patterns can be looked beyond to resolve ties, for example:\n\n```\nfunc custom =\n    case custom of\n        Container { field } Bar ->\n            not field\n\n        Container { field } Baz ->\n            field\n\n        Container { field } Foo ->\n            field\n```\n\nwill be sorted to\n\n    func custom =\n        case custom of\n            Container { field } Foo ->\n                field\n\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\nUse `doNotSortLiterals`, `sortListPatternsByLength`, etc. to alter any of this\nbehavior, e.g.\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.doNotSortLiterals\n            |> NoUnsortedCases.sortListPatternsByLength\n            |> NoUnsortedCases.rule\n        ]\n\n-}\ndefaults : RuleConfig\ndefaults =\n    RuleConfig\n        { lookPastUnsortable = True\n        , sortLists = Elementwise\n        , sortLiterals = True\n        , sortTypesFromDependencies = DeclarationOrder\n        , sortablePredicate = \\_ _ -> True\n        }"},{"$":1,"a":{"bV":{"bb":16,"bp":265},"ch":{"bb":1,"bp":251}},"b":"{-| Restrict custom type sorting to only those matching a provided predicate.\nThis function takes two strings, the first being the full module name of a type,\ne.g. `\"Review.Rule\"` and the second being the name of a type, e.g. `\"Rule\"`, and\nreturns a `Bool` indicating whether the type should be sorted (with `True`\nmeaning sortable). For example:\n\nModule Foo:\n\n    module Foo exposing (Foo(..))\n\n    type Foo\n        = Foo\n        | Bar\n        | Baz\n\nModule Main:\n\n    module Main exposing (..)\n\n    type Msg\n        = ButtonPressed\n        | ButtonClicked\n\nModule ReviewConfig:\n\n    onlyMsg moduleName typeName =\n        case ( moduleName, typeName ) of\n            ( \"Main\", \"Msg\" ) ->\n                True\n\n            _ ->\n                False\n\n    config =\n        [ NoUnsortedCases.defaults\n            |> NoUnsortedCases.sortOnlyMatchingTypes onlyMsg\n            |> NoUnsortedCases.rule\n        ]\n\nwill sort the following pattern:\n\n    case msg of\n        ButtonClicked ->\n            ( { model | clicked = True }, Cmd.none )\n\n        ButtonPressed ->\n            ( { model | pressed = True }, Cmd.none )\n\nbut will not sort:\n\n    case foo of\n        Bar ->\n            \"bar\"\n\n        Baz ->\n            \"baz\"\n\n        Foo ->\n            \"foo\"\n\n-}\nsortOnlyMatchingTypes : (String -> String -> Bool) -> RuleConfig -> RuleConfig\nsortOnlyMatchingTypes sortablePredicate (RuleConfig c) =\n    RuleConfig { c | sortablePredicate = sortablePredicate }"},{"$":1,"a":{"bV":{"bb":10,"bp":327},"ch":{"bb":1,"bp":268}},"b":"{-| Change the behavior of the rule to **not** sort literal patterns. If\nliterals are not sorted, case expressions that would require sorting literals\ncannot be sorted and will thus be ignored by the rule.\n-}\ndoNotSortLiterals : RuleConfig -> RuleConfig\ndoNotSortLiterals (RuleConfig c) =\n    RuleConfig { c | sortLiterals = False }"},{"$":1,"a":{"bV":{"bb":61,"bp":393},"ch":{"bb":1,"bp":330}},"b":"{-| Do not sort types from dependencies at all. Note that this will render\nunsortable any patterns requiring types from dependencies to be sorted.\n-}\ndoNotSortTypesFromDependencies : RuleConfig -> RuleConfig\ndoNotSortTypesFromDependencies (RuleConfig c) =\n    RuleConfig { c | sortTypesFromDependencies = DoNotSort }"},{"$":1,"a":{"bV":{"bb":44,"bp":402},"ch":{"bb":1,"bp":396}},"b":"{-| Sort custom types imported from dependencies (including `Basics` types like `Maybe` and `Bool`) alphabetically, rather than by their source order in the dependency's source code.\n-}\nsortTypesFromDependenciesAlphabetically : RuleConfig -> RuleConfig\nsortTypesFromDependenciesAlphabetically (RuleConfig c) =\n    RuleConfig { c | sortTypesFromDependencies = AlphabeticalOrder }"},{"$":1,"a":{"bV":{"bb":69,"bp":505},"ch":{"bb":1,"bp":501}},"b":"{-| Do not look beyond unsortable patterns, rendering the following unsortable:\n\n    func custom =\n        case custom of\n            Container { field } Bar ->\n                not field\n\n            Container { field } Baz ->\n                field\n\n            Container { field } Foo ->\n                field\n\n-}\ndoNotLookPastUnsortable : RuleConfig -> RuleConfig\ndoNotLookPastUnsortable (RuleConfig c) =\n    RuleConfig { c | lookPastUnsortable = False }"},{"$":1,"a":{"bV":{"bb":61,"bp":513},"ch":{"bb":1,"bp":508}},"b":"{-| Sort two patterns by the preservation of control flow, e.g. assuring that\nwildcards are not moved before non-wildcards. If this function returns `EQ`,\nthen the two patterns may have their order switched safely.\n-}\ncompareByControlFlow : RuleConfig -> ( Int, SortablePattern ) -> ( Int, SortablePattern ) -> Order\ncompareByControlFlow config ( i1, pat1 ) ( i2, pat2 ) =\n    let\n        go : SortablePattern -> SortablePattern -> Order\n        go p1 p2 =\n            compareByControlFlow config ( i1, p1 ) ( i2, p2 )\n    in\n    case ( pat1, pat2 ) of\n        -- If both are wildcards, then they do not have defined order\n        ( Wildcard, Wildcard ) ->\n            EQ\n\n        -- Wildcards cannot be moved relative to non-wildcards, so return index order\n        ( Wildcard, _ ) ->\n            compare i1 i2\n\n        ( _, Wildcard ) ->\n            compare i1 i2\n\n        ( Constructor c1, Constructor c2 ) ->\n            let\n                goSubs : List (Maybe SortablePattern) -> List (Maybe SortablePattern) -> () -> Order\n                goSubs pat1s pat2s () =\n                    case ( pat1s, pat2s ) of\n                        -- Wildcards cannot be moved compared to things we can't sort\n                        ( (Just Wildcard) :: _, Nothing :: _ ) ->\n                            compare i1 i2\n\n                        ( Nothing :: _, (Just Wildcard) :: _ ) ->\n                            compare i1 i2\n\n                        ( p1 :: p1s, p2 :: p2s ) ->\n                            -- Check each subpattern sequentially for control flow ordering\n                            goSubs p1s p2s\n                                |> fallbackCompareFor (Maybe.withDefault EQ <| Maybe.map2 go p1 p2)\n\n                        _ ->\n                            -- Either exhausted subpatterns with no problems or a type error\n                            EQ\n            in\n            if c1.order == c2.order then\n                -- If the constructors are the same, then control flow confusion could occur in subpatterns\n                goSubs c1.subpatterns c2.subpatterns ()\n\n            else\n                -- Otherwise, no possibility of control flow confusion, as constructors are different\n                EQ\n\n        -- Lists, Tuples, and Uncons\n        ( ListTupleOrUncons r1, ListTupleOrUncons r2 ) ->\n            if safelySortableListPatterns config r1 r2 then\n                -- Can safely sort them\n                EQ\n\n            else\n                -- Otherwise, enforce ordering\n                compare i1 i2\n\n        -- Anything else is a type error or has no wildcards, so we needn't consider it\n        _ ->\n            EQ"},{"$":1,"a":{"bV":{"bb":50,"bp":532},"ch":{"bb":1,"bp":516}},"b":"{-| Compare two literal types, determining their order (if not a type error).\n-}\ncompareLiteral : LiteralPattern -> LiteralPattern -> Maybe Order\ncompareLiteral l1 l2 =\n    case ( l1, l2 ) of\n        ( CharLiteral c1, CharLiteral c2 ) ->\n            Just <| compare c1 c2\n\n        ( StringLiteral s1, StringLiteral s2 ) ->\n            Just <| compare s1 s2\n\n        ( IntLiteral i1, IntLiteral i2 ) ->\n            Just <| compare i1 i2\n\n        ( FloatLiteral f1, FloatLiteral f2 ) ->\n            Just <| compare f1 f2\n\n        _ ->\n            -- This is a type error, so ignore it\n            Nothing"},{"$":1,"a":{"bV":{"bb":6,"bp":552},"ch":{"bb":1,"bp":539}},"b":"{-| Compare nonempty list/tuple/uncons pattern sorting by checking by length (if\nconfigured to) and element-wise.\n-}\ncompareNonemptyListPatterns : RuleConfig -> ( { subpatterns : List SortablePattern, terminates : Bool }, SortablePattern, List SortablePattern ) -> ( { subpatterns : List SortablePattern, terminates : Bool }, SortablePattern, List SortablePattern ) -> Maybe Order\ncompareNonemptyListPatterns ((RuleConfig { sortLists }) as config) ( r1, p1, p1s ) ( r2, p2, p2s ) =\n    let\n        checkSubs : () -> Maybe Order\n        checkSubs () =\n            case comparePatterns config p1 p2 of\n                Just EQ ->\n                    comparePatterns config\n                        (ListTupleOrUncons { r1 | subpatterns = p1s })\n                        (ListTupleOrUncons { r2 | subpatterns = p2s })\n\n                ltOrGtOrNothing ->\n                    ltOrGtOrNothing\n    in\n    if sortLists == LengthFirst then\n        checkSubs\n            |> fallbackCompareWithUnsortableFor (Just <| comparePatternListLengths r1 r2)\n\n    else\n        checkSubs ()"},{"$":1,"a":{"bV":{"bb":6,"bp":585},"ch":{"bb":1,"bp":555}},"b":"{-| Compare the list lengths of two lists of `SortablePattern`, with the caveat\nthat a list must be infinitely long if it ends in a wildcard, with a shorter\nlist ending in a wildcard being \"longer\" (more specified) than a longer one.\n-}\ncomparePatternListLengths :\n    { subpatterns : List SortablePattern\n    , terminates : Bool\n    }\n    ->\n        { subpatterns : List SortablePattern\n        , terminates : Bool\n        }\n    -> Order\ncomparePatternListLengths p1s p2s =\n    case ( p1s.terminates, p2s.terminates ) of\n        ( False, False ) ->\n            -- Flip comparison if both end in wildcards\n            compare (List.length p2s.subpatterns) (List.length p1s.subpatterns)\n\n        ( False, True ) ->\n            GT\n\n        ( True, False ) ->\n            LT\n\n        ( True, True ) ->\n            -- Compare normally if neither does\n            compare (List.length p1s.subpatterns) (List.length p2s.subpatterns)"},{"$":1,"a":{"bV":{"bb":15,"bp":652},"ch":{"bb":1,"bp":588}},"b":"{-| Compare two sortable patterns, determining their order (if not a type error).\n-}\ncomparePatterns : RuleConfig -> SortablePattern -> SortablePattern -> Maybe Order\ncomparePatterns ((RuleConfig { lookPastUnsortable }) as ruleConfig) pat1 pat2 =\n    let\n        go : SortablePattern -> SortablePattern -> Maybe Order\n        go p1 p2 =\n            comparePatterns ruleConfig p1 p2\n    in\n    case ( pat1, pat2 ) of\n        -- Wildcards can be sorted past if both are wild\n        ( Wildcard, Wildcard ) ->\n            Just EQ\n\n        -- Wildcards cannot be moved relative to non-wildcards, so return Nothing, which ensures that they are not sorted past.\n        ( Wildcard, _ ) ->\n            Nothing\n\n        ( _, Wildcard ) ->\n            Nothing\n\n        -- Literals are simply compared; if sorting literals is turned off, then LiteralPatterns are not created at all\n        ( Literal l1, Literal l2 ) ->\n            compareLiteral l1 l2\n\n        --Constructors are compared by index, then by comparing subpatterns sequentially, failing if a non-sortable subpattern is encountered\n        ( Constructor c1, Constructor c2 ) ->\n            let\n                goSubs : List (Maybe SortablePattern) -> List (Maybe SortablePattern) -> () -> Maybe Order\n                goSubs pat1s pat2s () =\n                    case ( pat1s, pat2s, lookPastUnsortable ) of\n                        ( (Just p1) :: p1s, (Just p2) :: p2s, _ ) ->\n                            goSubs p1s p2s\n                                |> fallbackCompareWithUnsortableFor (go p1 p2)\n\n                        ( Nothing :: p1s, Nothing :: p2s, True ) ->\n                            -- If at the point where arguments are both unsortable, then proceed past if configured to\n                            goSubs p1s p2s ()\n\n                        ( [], [], _ ) ->\n                            -- Both lists of subpatterns exhausted without a \"winner\", so return EQ\n                            Just EQ\n\n                        _ ->\n                            -- Lists should be even, so other cases aren't sortable\n                            Nothing\n            in\n            -- Fallback to subpatterns\n            goSubs c1.subpatterns c2.subpatterns\n                |> fallbackCompareWithUnsortableFor (Just <| compare c1.order c2.order)\n\n        -- Lists, Tuples, and Uncons\n        ( ListTupleOrUncons r1, ListTupleOrUncons r2 ) ->\n            case\n                ( ( r1.subpatterns, r1.terminates )\n                , ( r2.subpatterns, r2.terminates )\n                )\n            of\n                -- If the lists are the same length, infinite ones go later\n                ( ( [], False ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( [], True ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], _ ), ( [], _ ) ) ->\n                    Just EQ\n\n                -- If one list is shorter than another, it goes after if it is infinite or before if it isn't\n                ( ( _ :: _, _ ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( _ :: _, _ ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], True ), ( _ :: _, _ ) ) ->\n                    Just LT\n\n                ( ( [], False ), ( _ :: _, _ ) ) ->\n                    Just GT\n\n                -- Otherwise, compare the lists sequentially\n                ( ( p1 :: p1s, _ ), ( p2 :: p2s, _ ) ) ->\n                    compareNonemptyListPatterns ruleConfig ( r1, p1, p1s ) ( r2, p2, p2s )\n\n        -- Anything else should be a type error, so we needn't consider it\n        _ ->\n            Nothing"},{"$":1,"a":{"bV":{"bb":25,"bp":662},"ch":{"bb":1,"bp":655}},"b":"{-| Visit declarations, storing custom type orders.\n-}\ndeclarationListVisitor :\n    RuleConfig\n    -> List (Node Declaration)\n    ->\n        { moduleName : String\n        , exposedTypes : Maybe (Set String)\n        , customTypes :\n            Dict\n                ModuleName\n                (Dict\n                    String\n                    { constructors : Set String\n                    , declarationOrder : List String\n                    }\n                )\n        }\n    ->\n        { customTypes :\n            Dict\n                ModuleName\n                (Dict\n                    String\n                    { constructors : Set String\n                    , declarationOrder : List String\n                    }\n                )\n        , exposedCustomTypes :\n            Dict\n                String\n                { constructors : Set String\n                , declarationOrder : List String\n                }\n        }\ndeclarationListVisitor (RuleConfig config) declarations { moduleName, exposedTypes, customTypes } =\n    let\n        getCustomType : Node Declaration -> Maybe ( String, { constructors : Set String, declarationOrder : List String } )\n        getCustomType node =\n            case Node.value node of\n                Declaration.CustomTypeDeclaration ({ name } as type_) ->\n                    if config.sortablePredicate moduleName (Node.value name) then\n                        Just\n                            ( Node.value type_.name\n                            , typeConstructors type_\n                            )\n\n                    else\n                        Nothing\n\n                _ ->\n                    Nothing\n\n        typeConstructors : Type -> { constructors : Set String, declarationOrder : List String }\n        typeConstructors type_ =\n            type_.constructors\n                |> List.map (Node.value >> .name >> Node.value)\n                |> (\\cs ->\n                        { constructors = Set.fromList cs\n                        , declarationOrder = cs\n                        }\n                   )\n    in\n    -- Find custom types that were defined in the module\n    List.filterMap getCustomType declarations\n        |> (\\ts ->\n                if List.isEmpty ts then\n                    { customTypes = customTypes\n                    , exposedCustomTypes = Dict.empty\n                    }\n\n                else\n                    { customTypes =\n                        Dict.fromList ts\n                            |> (\\v -> Dict.insert [] v customTypes)\n                    , exposedCustomTypes =\n                        List.filter (\\( typeName, _ ) -> MaybeX.unwrap True (Set.member typeName) exposedTypes) ts\n                            |> Dict.fromList\n                    }\n           )"},{"$":1,"a":{"bV":{"bb":14,"bp":682},"ch":{"bb":1,"bp":669}},"b":"{-| Visit all dependencies and store type order from them.\n-}\ndependencyVisitor : RuleConfig -> Dict String Dependency -> ProjectContext -> ProjectContext\ndependencyVisitor (RuleConfig config) deps context =\n    let\n        docToEntry : String -> Elm.Docs.Union -> Maybe ( String, { constructors : Set String, declarationOrder : List String } )\n        docToEntry moduleName { name, tags } =\n            let\n                constructors : List String\n                constructors =\n                    List.map Tuple.first tags\n            in\n            case ( config.sortablePredicate moduleName name, config.sortTypesFromDependencies ) of\n                ( True, AlphabeticalOrder ) ->\n                    Just\n                        ( name\n                        , { constructors = Set.fromList constructors\n                          , declarationOrder = ListX.stableSortWith compare constructors\n                          }\n                        )\n\n                ( True, _ ) ->\n                    Just\n                        ( name\n                        , { constructors = Set.fromList constructors\n                          , declarationOrder = constructors\n                          }\n                        )\n\n                ( False, _ ) ->\n                    Nothing\n    in\n    if config.sortTypesFromDependencies /= DoNotSort then\n        Dict.foldl\n            (\\_ dep acc ->\n                Dependency.modules dep\n                    |> List.filterMap\n                        (\\{ name, unions } ->\n                            List.filterMap (docToEntry name) unions\n                                |> Dict.fromList\n                                |> (\\ts ->\n                                        if Dict.isEmpty ts then\n                                            Nothing\n\n                                        else\n                                            Just ts\n                                   )\n                                |> Maybe.map\n                                    (Tuple.pair\n                                        -- Convert to a `ModuleName`\n                                        (String.split \".\" name)\n                                    )\n                        )\n                    |> Dict.fromList\n                    |> (\\types -> { acc | customTypes = Dict.union types acc.customTypes })\n            )\n            context\n            deps\n\n    else\n        context"},{"$":1,"a":{"bV":{"bb":6,"bp":690},"ch":{"bb":1,"bp":685}},"b":"{-| Visit all expressions in a module, checking for `case`s and ensuring those\nare sorted properly.\n-}\nexpressionVisitor : RuleConfig -> Node Expression -> ModuleContext -> List (Error {})\nexpressionVisitor config node context =\n    case Node.value node of\n        Expression.CaseExpression { cases } ->\n            let\n                errorRange : Range\n                errorRange =\n                    let\n                        r : Range\n                        r =\n                            Node.range node\n                    in\n                    -- Assume that the `case` of a case block is just the first 4 chars\n                    { r | end = { row = r.start.row, column = r.start.column + 4 } }\n            in\n            -- Convert all patterns to sortable ones, if we can\n            ListX.indexedFoldr\n                (\\i ( p, e ) acc ->\n                    getSortablePattern config context p\n                        |> Maybe.map\n                            (\\sP ->\n                                { pattern = sP\n                                , index = i\n                                , range =\n                                    Range.combine\n                                        [ Node.range p\n                                        , Node.range e\n                                        ]\n                                }\n                            )\n                        |> Maybe.map2 (\\acc_ sP -> sP :: acc_) acc\n                )\n                (Just [])\n                cases\n                |> Maybe.map\n                    (checkSorting context.extractSource\n                        \"Case patterns\"\n                        [ -- Sort by control flow preservation first\n                          \\c1 c2 -> compareByControlFlow config ( c1.index, c1.pattern ) ( c2.index, c2.pattern )\n\n                        -- Then by ordering\n                        , \\c1 c2 -> Maybe.withDefault EQ <| comparePatterns config c1.pattern c2.pattern\n                        ]\n                        errorRange\n                    )\n                |> Maybe.withDefault []\n\n        _ ->\n            -- Nothing to sort in non-case expressions.\n            []"},{"$":1,"a":{"bV":{"bb":31,"bp":707},"ch":{"bb":1,"bp":693}},"b":"{-| Combine `ProjectContext`s by taking the union of known type orders.\n-}\nfoldProjectContexts : ProjectContext -> ProjectContext -> ProjectContext\nfoldProjectContexts newContext prevContext =\n    { customTypes =\n        Dict.union newContext.customTypes prevContext.customTypes\n    }"},{"$":1,"a":{"bV":{"bb":28,"bp":736},"ch":{"bb":1,"bp":710}},"b":"{-| Create a `ProjectContext` from a `ModuleContext`.\n-}\nfromModuleToProject : Rule.ContextCreator ModuleContext ProjectContext\nfromModuleToProject =\n    Rule.initContextCreator\n        (\\moduleName { exposedCustomTypes } ->\n            { customTypes =\n                if Dict.isEmpty exposedCustomTypes then\n                    Dict.empty\n\n                else\n                    Dict.singleton moduleName exposedCustomTypes\n            }\n        )\n        |> Rule.withModuleName"},{"$":1,"a":{"bV":{"bb":13,"bp":764},"ch":{"bb":1,"bp":739}},"b":"{-| Create a `ModuleContext` from a `ProjectContext`.\n-}\nfromProjectToModule : RuleConfig -> Rule.ContextCreator ProjectContext ModuleContext\nfromProjectToModule config =\n    Rule.initContextCreator\n        (\\lookupTable extractSource moduleName fileIsIgnored { declarations, moduleDefinition } projectContext ->\n            let\n                { exposedCustomTypes, customTypes } =\n                    declarationListVisitor config\n                        declarations\n                        { moduleName = String.join \".\" moduleName\n                        , exposedTypes = getExposedTypes <| Node.value moduleDefinition\n                        , customTypes = projectContext.customTypes\n                        }\n            in\n            { customTypes = customTypes\n            , fileIsIgnored = fileIsIgnored\n            , exposedCustomTypes = exposedCustomTypes\n            , lookupTable = lookupTable\n            , extractSource = extractSource\n            }\n        )\n        |> Rule.withModuleNameLookupTable\n        |> Rule.withSourceCodeExtractor\n        |> Rule.withModuleName\n        |> Rule.withIsFileIgnored\n        |> Rule.withFullAst"},{"$":1,"a":{"bV":{"bb":6,"bp":773},"ch":{"bb":1,"bp":767}},"b":"{-| Unwrap a pattern to get at the actual pattern inside of any parentheses or\n`as` patterns.\n-}\ngetActualPattern : Node Pattern -> Node Pattern\ngetActualPattern node =\n    case Node.value node of\n        -- Parenthesized/as patterns we just descend into\n        Pattern.ParenthesizedPattern p ->\n            getActualPattern p\n\n        Pattern.AsPattern p _ ->\n            getActualPattern p\n\n        -- Other pattern are just the pattern itself\n        _ ->\n            node"},{"$":1,"a":{"bV":{"bb":16,"bp":840},"ch":{"bb":1,"bp":780}},"b":"{-| Get a set of all types with exposed constructors or `Nothing` if everything\nis exposed.\n-}\ngetExposedTypes : Module -> Maybe (Set String)\ngetExposedTypes =\n    let\n        keepTypesWithExposedConstructors : Node TopLevelExpose -> Maybe String\n        keepTypesWithExposedConstructors e =\n            case Node.value e of\n                TypeExpose { name } ->\n                    Just name\n\n                _ ->\n                    Nothing\n    in\n    Module.exposingList\n        >> (\\l ->\n                case l of\n                    All _ ->\n                        Nothing\n\n                    Explicit es ->\n                        List.filterMap keepTypesWithExposedConstructors es\n                            |> Set.fromList\n                            |> Just\n           )"},{"$":1,"a":{"bV":{"bb":13,"bp":922},"ch":{"bb":1,"bp":843}},"b":"{-| Given config, context, and a pattern, convert it into a pattern we know\nhow to sort, if possible.\n-}\ngetSortablePattern : RuleConfig -> ModuleContext -> Node Pattern -> Maybe SortablePattern\ngetSortablePattern ((RuleConfig config) as ruleConfig) context node =\n    let\n        go : Node Pattern -> Maybe SortablePattern\n        go =\n            getSortablePattern ruleConfig context\n\n        n : Node Pattern\n        n =\n            getActualPattern node\n\n        makeLiteral : (a -> LiteralPattern) -> a -> Maybe SortablePattern\n        makeLiteral l a =\n            if config.sortLiterals then\n                Just <| Literal <| l a\n\n            else\n                Nothing\n\n        findConstructorOrder : String -> List (Node Pattern) -> ModuleName -> Maybe SortablePattern\n        findConstructorOrder constructor ps moduleName =\n            -- Get types for the module\n            Dict.get moduleName context.customTypes\n                -- Find the type that the constructor belongs to\n                |> Maybe.andThen\n                    (DictX.find\n                        (\\_ { constructors } ->\n                            Set.member constructor constructors\n                        )\n                    )\n                -- Find its constructor order\n                |> Maybe.andThen\n                    (\\( matchedType, { declarationOrder } ) ->\n                        ListX.elemIndex constructor declarationOrder\n                            |> Maybe.map\n                                (\\order ->\n                                    Constructor\n                                        { type_ = ( moduleName, matchedType )\n                                        , order = order\n                                        , subpatterns = List.map go ps\n                                        }\n                                )\n                    )\n    in\n    case Node.value n of\n        -- Find declaration sorting for named patterns and their arguments\n        Pattern.NamedPattern { name } ps ->\n            moduleNameFor context.lookupTable n\n                |> Maybe.andThen (findConstructorOrder name ps)\n\n        -- Tuples and lists we recursively convert each subpattern\n        Pattern.TuplePattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )\n\n        Pattern.ListPattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )\n\n        -- Uncons pattern we recursively convert each subpattern and convert to the equivalent list\n        Pattern.UnConsPattern p1 p2 ->\n            let\n                cons : SortablePattern -> SortablePattern -> Maybe SortablePattern\n                cons x xs =\n                    case xs of\n                        Wildcard ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { subpatterns = [ x ]\n                                    , terminates = False\n                                    }\n\n                        ListTupleOrUncons r ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { r | subpatterns = x :: r.subpatterns }\n\n                        _ ->\n                            -- You can't cons onto a constructor or Literal, so this is a type error\n                            Nothing\n            in\n            Maybe.map2 cons (go p1) (go p2)\n                |> MaybeX.join\n\n        -- Var and _ are wildcards\n        Pattern.AllPattern ->\n            Just Wildcard\n\n        Pattern.VarPattern _ ->\n            Just Wildcard\n\n        -- Literals can be sorted if configured to\n        Pattern.CharPattern c ->\n            makeLiteral CharLiteral c\n\n        Pattern.StringPattern s ->\n            makeLiteral StringLiteral s\n\n        Pattern.IntPattern i ->\n            makeLiteral IntLiteral i\n\n        Pattern.HexPattern i ->\n            makeLiteral IntLiteral i\n\n        Pattern.FloatPattern f ->\n            makeLiteral FloatLiteral f\n\n        _ ->\n            -- Remaining patterns are Unit and Record, which are not sortable, and Parens/As patterns, which we have already unwrapped\n            Nothing"},{"$":1,"a":{"bV":{"bb":15,"bp":977},"ch":{"bb":1,"bp":925}},"b":"{-| The initial project context knows of no types.\n-}\ninitialProjectContext : ProjectContext\ninitialProjectContext =\n    { customTypes = Dict.empty\n    }"},{"$":1,"a":{"bV":{"bb":20,"bp":1104},"ch":{"bb":1,"bp":980}},"b":"{-| A literal pattern. Int and Hex literals are not distinguished, as they are\nsorted identically.\n-}\ntype LiteralPattern\n    = CharLiteral Char\n    | StringLiteral String\n    | IntLiteral Int\n    | FloatLiteral Float"},{"$":1,"a":{"bV":{"bb":17,"bp":1122},"ch":{"bb":1,"bp":1107}},"b":"{-| The module context, consisting of a map from module names to a map of type\nnames to orders.\n\n  - `customTypes` -- Orderings of all known custom types.\n  - `exposedCustomTypes` -- All custom type orders that are exposed from local\n    module.\n  - `fileIsIgnored` -- Whether file should not be checked for errors\n  - `lookupTable` -- Module name lookup table\n  - `extractSourceCode` -- Source extractor for fixes\n\n-}\ntype alias ModuleContext =\n    { customTypes :\n        Dict\n            ModuleName\n            (Dict\n                String\n                { constructors : Set String\n                , declarationOrder : List String\n                }\n            )\n    , exposedCustomTypes :\n        Dict\n            String\n            { constructors : Set String\n            , declarationOrder : List String\n            }\n    , fileIsIgnored : Bool\n    , lookupTable : ModuleNameLookupTable\n    , extractSource : Range -> String\n    }"},{"$":1,"a":{"bV":{"bb":20,"bp":1144},"ch":{"bb":1,"bp":1125}},"b":"{-| Visit each module, first getting types from all declarations and then\nchecking all expressions for `case`s.\n-}\nmoduleVisitor : RuleConfig -> Rule.ModuleRuleSchema schemaState ModuleContext -> Rule.ModuleRuleSchema { schemaState | hasAtLeastOneVisitor : () } ModuleContext\nmoduleVisitor config schema =\n    schema\n        |> Rule.withExpressionEnterVisitor\n            (\\e c ->\n                if c.fileIsIgnored then\n                    ( [], c )\n\n                else\n                    ( expressionVisitor config e c, c )\n            )"},{"$":1,"a":{"bV":{"bb":15,"bp":1211},"ch":{"bb":1,"bp":1147}},"b":"{-| The project context, consisting of a map from module names to a map of type\nnames to orders.\n-}\ntype alias ProjectContext =\n    { customTypes :\n        Dict\n            ModuleName\n            (Dict\n                String\n                { constructors : Set String\n                , declarationOrder : List String\n                }\n            )\n    }"},{"$":1,"a":{"bV":{"bb":20,"bp":1337},"ch":{"bb":1,"bp":1250}},"b":"{-| List patterns may be sorted in one of two ways:\n\n  - `Elementwise` -- Patterns are sorted by comparing elements sequentially at each position (from left to right). This is the same behavior as\n    `List.sort`.\n  - `LengthFirst` -- Shorter patterns always come before longer pattern, with patterns of the same length sorted elementwise at each position.\n\n-}\ntype SortLists\n    = Elementwise\n    | LengthFirst"},{"$":1,"a":{"bV":{"bb":21,"bp":1362},"ch":{"bb":1,"bp":1340}},"b":"{-| Specify how to sort types that are **imported from dependencies**.\n\n  - `DeclarationOrder` -- Sort types in the order they appear in the\n    dependency's source file (or more technically in its documentation); this is\n    identical to the behavior of types defined within your own modules.\n  - `AlphabeticalOrder` -- Sort types alphabetically.\n  - `DoNotSort` -- Do not sort types from dependencies at all. Note that this\n    will render unsortable any patterns requiring types from dependencies to be\n    sorted.\n\n-}\ntype SortTypesFromDependencies\n    = DeclarationOrder\n    | AlphabeticalOrder\n    | DoNotSort"},{"$":1,"a":{"bV":{"bb":80,"bp":1392},"ch":{"bb":1,"bp":1365}},"b":"{-| Any pattern that might be sortable.\n\n  - `Constructor` -- A constructor pattern, with its type, declaration order, and any subpatterns, e.g. `Just 1 ->` becomes\n\n```\nConstructor\n    { order = 0\n    , subpatterns = [ Just (Literal (IntLiteral 1)) ]\n    , type_ = ( [ \"Basics\" ], \"Maybe\" )\n    }\n```\n\n  - `ListTupleOrUncons` -- A list, tuple, or uncons pattern, e.g. `(Nothing, Nothing) ->` becomes\n\n```\nListTupleOrUncons\n    { subpatterns =\n        [ Constructor\n            { order = 1\n            , subpatterns = []\n            , type_ = ( [ \"Basics\" ], \"Maybe\" )\n            }\n        , Constructor\n            { order = 1\n            , subpatterns = []\n            , type_ = ( [ \"Basics\" ], \"Maybe\" )\n            }\n        ]\n    , terminates = True\n    }\n```\n\nand `var :: _ ->` becomes\n\n    ListTupleOrUncons\n        { subpatterns =\n            [ Wildcard ]\n        , terminates = False\n        }\n\n  - `Literal` -- A literal pattern, e.g. `1 ->` becomes\n\n```\nLiteral (IntLiteral 1)\n```\n\n  - `Wildcard` -- A wildcard or var pattern, e.g. `var ->` becomes\n\n```\nWildcard\n```\n\n-}\ntype SortablePattern\n    = Constructor\n        { order : Int\n        , subpatterns : List (Maybe SortablePattern)\n        , type_ : ( ModuleName, String )\n        }\n    | ListTupleOrUncons\n        { subpatterns : List SortablePattern\n        , terminates : Bool\n        }\n    | Literal LiteralPattern\n    | Wildcard"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"src/NoUnsortedTopLevelDeclarations.elm","c":{"bT":1130522341,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"src/NoUnsortedTopLevelDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":6,"bp":196},"ch":{"bb":1,"bp":188}},"b":"{-| Create a new `RuleConfig`. Use the various orderings to then specify\nprimary and fallback orderings.\n-}\nsortTopLevelDeclarations : RuleConfig { noAlphabetical : (), noDependency : (), noExposed : (), noHelper : (), noType : (), noPort : () }\nsortTopLevelDeclarations =\n    RuleConfig { sortBy = [], glues = [] }"},{"$":1,"a":{"bV":{"bb":46,"bp":202},"ch":{"bb":1,"bp":199}},"b":"{-| Sort declarations alphabetically. Note that this decapitalizes the first\nletter before performing the comparison so as to treat types and functions the\nsame. For example, the following is sorted alphabetically:\n\n    type A\n        = A\n\n    a =\n        foo\n\n    b =\n        bar\n\n    z =\n        zed\n\n    type alias Z =\n        A\n\n-}\nalphabetically : RuleConfig { r | noAlphabetical : () } -> RuleConfig r\nalphabetically (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 -> compare (Set.toList <| Set.map StringX.decapitalize d1.namesBound) (Set.toList <| Set.map StringX.decapitalize d2.namesBound))\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":6,"bp":214},"ch":{"bb":1,"bp":205}},"b":"{-| Sort TLDs in the order they are exposed by the module, with private TLDs\ncoming after all those that are exposed. For example, the following is sorted\nby this and then alphabetically:\n\n    module A exposing\n        ( A, a\n        , Z\n        )\n\n    {-|\n\n    @docs A, a\n    @docs Z\n\n    -}\n\n    type A\n        = A\n\n    a =\n        foo\n\n    type alias Z =\n        A\n\n    b =\n        bar\n\n    z =\n        zed\n\n-}\nexposedOrderWithPrivateLast : RuleConfig { r | noExposed : () } -> RuleConfig r\nexposedOrderWithPrivateLast (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.exposedOrder, d2.exposedOrder ) of\n                        ( Just i1, Just i2 ) ->\n                            compare i1 i2\n\n                        ( Just _, Nothing ) ->\n                            LT\n\n                        ( Nothing, Just _ ) ->\n                            GT\n\n                        ( Nothing, Nothing ) ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":11,"bp":222},"ch":{"bb":1,"bp":217}},"b":"{-| Sort TLDs in the order they are exposed by the module, with private TLDs\ncoming before all those that are exposed. For example, the following is sorted\nby this and then alphabetically:\n\n    module A exposing\n        ( A, a\n        , Z\n        )\n\n    {-|\n\n    @docs A, a\n    @docs Z\n\n    -}\n\n    b =\n        bar\n\n    z =\n        zed\n\n    type A\n        = A\n\n    a =\n        foo\n\n    type alias Z =\n        A\n\n-}\nexposedOrderWithPrivateFirst : RuleConfig { r | noExposed : () } -> RuleConfig r\nexposedOrderWithPrivateFirst (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.exposedOrder, d2.exposedOrder ) of\n                        ( Just i1, Just i2 ) ->\n                            compare i1 i2\n\n                        ( Just _, Nothing ) ->\n                            GT\n\n                        ( Nothing, Just _ ) ->\n                            LT\n\n                        ( Nothing, Nothing ) ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":43,"bp":230},"ch":{"bb":1,"bp":225}},"b":"{-| Sort TLDs so that types and type aliases always come before functions (and\nports, if they haven't been sorted already). For example, the following is\nsorted by this order and then alphabetically:\n\n    type A\n        = A\n\n    type alias Z =\n        A\n\n    a =\n        foo\n\n    b =\n        bar\n\n    z =\n        zed\n\n-}\ntypesFirst : RuleConfig { r | noType : () } -> RuleConfig r\ntypesFirst (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.type_, d2.type_ ) of\n                        ( Type, Type ) ->\n                            EQ\n\n                        ( Type, _ ) ->\n                            LT\n\n                        ( _, Type ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":260},"ch":{"bb":1,"bp":233}},"b":"{-| Sort TLDs so that types and type aliases always come after functions (and\nports, if they haven't been sorted already). For example, the following is\nsorted by this order and then alphabetically:\n\n    a =\n        foo\n\n    b =\n        bar\n\n    z =\n        zed\n\n    type A\n        = A\n\n    type alias Z =\n        A\n\n-}\ntypesLast : RuleConfig { r | noType : () } -> RuleConfig r\ntypesLast (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.type_, d2.type_ ) of\n                        ( Type, Type ) ->\n                            EQ\n\n                        ( Type, _ ) ->\n                            GT\n\n                        ( _, Type ) ->\n                            LT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":315},"ch":{"bb":1,"bp":263}},"b":"{-| Sort TLDs so that ports always come before functions (and types, if they\nhaven't been sorted already). For example, the following is sorted by this order\nand then alphabetically:\n\n    port sendMessage : String -> Cmd msg\n\n    type A\n        = A\n\n    a =\n        foo\n\n    b =\n        bar\n\n    type alias Z =\n        A\n\n    z =\n        zed\n\n-}\nportsFirst : RuleConfig { r | noPort : () } -> RuleConfig r\nportsFirst (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.type_, d2.type_ ) of\n                        ( Port, Port ) ->\n                            EQ\n\n                        ( Port, _ ) ->\n                            LT\n\n                        ( _, Port ) ->\n                            GT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":370},"ch":{"bb":1,"bp":318}},"b":"{-| Sort TLDs so that ports always come after functions (and types, if they\nhaven't been sorted already). For example, the following is sorted by this order\nand then alphabetically:\n\n    type A\n        = A\n\n    a =\n        foo\n\n    b =\n        bar\n\n    type alias Z =\n        A\n\n    z =\n        zed\n\n    port sendMessage : String -> Cmd msg\n\n-}\nportsLast : RuleConfig { r | noPort : () } -> RuleConfig r\nportsLast (RuleConfig r) =\n    RuleConfig\n        { r\n            | sortBy =\n                (\\d1 d2 ->\n                    case ( d1.type_, d2.type_ ) of\n                        ( Port, Port ) ->\n                            EQ\n\n                        ( Port, _ ) ->\n                            GT\n\n                        ( _, Port ) ->\n                            LT\n\n                        _ ->\n                            EQ\n                )\n                    :: r.sortBy\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":413},"ch":{"bb":1,"bp":373}},"b":"{-| Helpers are _unexposed_ functions that are used in exactly one other\nfunction. This glue attaches them immediately before the function they are used\nin.\n\nFor example:\n\n    foldrHelper : (a -> b -> b) -> b -> Int -> List a -> b\n    foldrHelper fn acc ctr ls =\n        case ls of\n            [] ->\n                acc\n\n            a :: r1 ->\n                ...\n\n    {-| Reduce a list from the right.\n    -}\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr fn acc ls =\n        foldrHelper fn acc 0 ls\n\n-}\nglueHelpersBefore : RuleConfig { r | noHelper : () } -> RuleConfig r\nglueHelpersBefore (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be helpers\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate ((==) 1 << Tuple.second)\n                            |> Maybe.map (GluedBeforeFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":456},"ch":{"bb":1,"bp":416}},"b":"{-| Helpers are _unexposed_ functions that are used in exactly one other\nfunction. This glue attaches them immediately after the function they are used\nin.\n\nFor example:\n\n    {-| Reduce a list from the right.\n    -}\n    foldr : (a -> b -> b) -> b -> List a -> b\n    foldr fn acc ls =\n        foldrHelper fn acc 0 ls\n\n    foldrHelper : (a -> b -> b) -> b -> Int -> List a -> b\n    foldrHelper fn acc ctr ls =\n        case ls of\n            [] ->\n                acc\n\n            a :: r1 ->\n                ...\n\n-}\nglueHelpersAfter : RuleConfig { r | noHelper : () } -> RuleConfig r\nglueHelpersAfter (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be helpers\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate ((==) 1 << Tuple.second)\n                            |> Maybe.map (GluedAfterFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":501},"ch":{"bb":1,"bp":459}},"b":"{-| Dependencies are _unexposed_ functions that are used in multiple other\nfunctions. This glue attaches them immediately before the first function they\nare used in.\n\nFor example:\n\n    unwrap =\n        some func\n\n    a x =\n        unwrap x\n\n    b x =\n        unwrap x\n\n    c x =\n        unwrap x\n\n-}\nglueDependenciesBeforeFirstDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesBeforeFirstDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be dependencies\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedBeforeFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":546},"ch":{"bb":1,"bp":504}},"b":"{-| Dependencies are _unexposed_ functions that are used in multiple other\nfunctions. This glue attaches them immediately after the first function they\nare used in.\n\nFor example:\n\n    a x =\n        unwrap x\n\n    unwrap =\n        some func\n\n    b x =\n        unwrap x\n\n    c x =\n        unwrap x\n\n-}\nglueDependenciesAfterFirstDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesAfterFirstDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be dependencies\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedAfterFirst << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":584},"ch":{"bb":1,"bp":549}},"b":"{-| Dependencies are _unexposed_ functions that are used in multiple other\nfunctions. This glue attaches them immediately after the last function they\nare used in.\n\nFor example:\n\n    a x =\n        unwrap x\n\n    b x =\n        unwrap x\n\n    c x =\n        unwrap x\n\n    unwrap =\n        some func\n\n-}\nglueDependenciesAfterLastDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesAfterLastDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be dependencies\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedAfterLast << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":622},"ch":{"bb":1,"bp":587}},"b":"{-| Dependencies are _unexposed_ functions that are used in multiple other\nfunctions. This glue attaches them immediately before the last function they\nare used in.\n\nFor example:\n\n    a x =\n        unwrap x\n\n    b x =\n        unwrap x\n\n    unwrap =\n        some func\n\n    c x =\n        unwrap x\n\n-}\nglueDependenciesBeforeLastDependent : RuleConfig { r | noDependency : () } -> RuleConfig r\nglueDependenciesBeforeLastDependent (RuleConfig r) =\n    RuleConfig\n        { r\n            | glues =\n                (\\( i, d ) ds ->\n                    -- Only unexposed functions can be dependencies\n                    if d.exposedOrder == Nothing && d.type_ == Function then\n                        findDependencies ( i, d ) ds\n                            |> validate (\\( _, numberUsedIn ) -> numberUsedIn > 1)\n                            |> Maybe.map (GluedBeforeLast << Tuple.first)\n\n                    else\n                        Nothing\n                )\n                    :: r.glues\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":660},"ch":{"bb":1,"bp":625}},"b":"{-| Collect the range of imports in the module.\n-}\naccumulateImportRange : Node Import -> Context -> Context\naccumulateImportRange i context =\n    { context\n        | moduleImportRange =\n            MaybeX.unpack (\\() -> Just <| Node.range i)\n                (\\r -> Just <| Range.combine [ r, Node.range i ])\n                context.moduleImportRange\n    }"},{"$":1,"a":{"bV":{"bb":10,"bp":698},"ch":{"bb":1,"bp":663}},"b":"{-| Info about the module, as well as the source extractor.\n-}\ntype alias Context =\n    { extractSource : Range -> String\n    , exports : Maybe (List String)\n    , errorRange : Range\n    , unparsedDocComments : List (Node String)\n    , moduleImportRange : Maybe Range\n    }"},{"$":1,"a":{"bV":{"bb":10,"bp":739},"ch":{"bb":1,"bp":701}},"b":"{-| The type of TLD it is.\n-}\ntype DeclarationType\n    = Function\n    | Port\n    | Type"},{"$":1,"a":{"bV":{"bb":10,"bp":780},"ch":{"bb":1,"bp":742}},"b":"{-| Generate declaration info for all TLDs and then check that they are sorted.\n-}\ndeclarationVisitor : RuleConfig r -> List (Node Declaration) -> Context -> List (Error {})\ndeclarationVisitor (RuleConfig { glues, sortBy }) decs context =\n    let\n        applyGlues : List TLD -> Int -> TLD -> TLD\n        applyGlues ds i d =\n            { d | glued = ListX.findMap (\\g -> g ( i, d ) ds) glues }\n    in\n    ListX.uncons context.unparsedDocComments\n        |> MaybeX.unwrap []\n            (\\( c, cs ) ->\n                case Maybe.map (Range.compare (Node.range c)) context.moduleImportRange of\n                    Just GT ->\n                        -- First doc comment is after imports, so cannot be module-associated.\n                        context.unparsedDocComments\n\n                    Nothing ->\n                        -- No module imports, so have to figure it out manually\n                        -- If there are two doc comments before first TLD, then\n                        -- the first must be module But do not need to test for\n                        -- this, because the first would get dropped anyways,\n                        -- since only the latter would possibly get attached.\n                        -- Similarly, do not need to worry if the first TLD has\n                        -- a parsed doc comment, because it would get dropped by\n                        -- going past that TLD. If first is a doc comment with a\n                        -- line that begins with \"@docs\", then it is essentially\n                        -- guaranteed to be for the module, however.\n                        if List.any (String.startsWith \"@docs\") <| String.lines <| Node.value c then\n                            cs\n\n                        else\n                            -- There is no @docs in the comment, so this might be a doc comment belonging to the first TLD, if it is a port.\n                            context.unparsedDocComments\n\n                    _ ->\n                        -- First doc comment is before imports, so is the module doc comment, so drop it\n                        cs\n            )\n        |> (\\docCommentsWithoutModule ->\n                List.foldl (getDecInfo context.exports) ( [], docCommentsWithoutModule ) decs\n           )\n        |> Tuple.first\n        |> List.reverse\n        |> (\\ds -> List.indexedMap (applyGlues ds) ds)\n        |> checkSortingWithGlue context.extractSource \"Top-level declarations\" sortBy context.errorRange"},{"$":1,"a":{"bV":{"bb":40,"bp":796},"ch":{"bb":1,"bp":783}},"b":"{-| Given a list of module exports, generate TLD info from a `declaration`.\n-}\ngetDecInfo : Maybe (List String) -> Node Declaration -> ( List TLD, List (Node String) ) -> ( List TLD, List (Node String) )\ngetDecInfo exports d ( acc, unparsedDocComments ) =\n    let\n        ( immediatelyPreviousDocComment, remainingDocComments ) =\n            ListX.splitWhen (\\c -> Range.compare (Node.range c) (Node.range d) == GT) unparsedDocComments\n                |> Maybe.withDefault\n                    -- No doc comments were after the TLD, so it must be the last\n                    ( unparsedDocComments, [] )\n                |> Tuple.mapFirst ListX.last\n    in\n    ( case Node.value d of\n        FunctionDeclaration { declaration } ->\n            Node.value declaration\n                |> (\\{ name, expression } ->\n                        { type_ = Function\n                        , exposedOrder = Maybe.andThen (ListX.elemIndex <| Node.value name) exports\n                        , namesBound = Set.singleton <| Node.value name\n                        , range = Node.range d\n                        , glued = Nothing\n                        , dependentOnBindings = findAllNamesIn expression\n                        }\n                   )\n                |> Just\n\n        AliasDeclaration { name } ->\n            Just\n                { type_ = Type\n                , exposedOrder = Maybe.andThen (ListX.elemIndex (Node.value name)) exports\n                , namesBound = Set.singleton <| Node.value name\n                , range = Node.range d\n                , glued = Nothing\n                , dependentOnBindings = Set.empty\n                }\n\n        CustomTypeDeclaration { name } ->\n            Just\n                { type_ = Type\n                , exposedOrder = Maybe.andThen (ListX.elemIndex (Node.value name)) exports\n                , namesBound = Set.singleton <| Node.value name\n                , range = Node.range d\n                , glued = Nothing\n                , dependentOnBindings = Set.empty\n                }\n\n        PortDeclaration { name } ->\n            Just\n                { type_ = Port\n                , namesBound = Set.singleton <| Node.value name\n\n                -- Glue doc comment on, since port doc comments are not yet parsed by `elm-syntax`\n                , range = MaybeX.unwrap (Node.range d) (\\c -> Range.combine [ Node.range c, Node.range d ]) immediatelyPreviousDocComment\n                , glued = Nothing\n\n                -- Ports can't be exposed or dependent on other TLDs\n                , dependentOnBindings = Set.empty\n                , exposedOrder = Nothing\n                }\n\n        _ ->\n            -- These are impossible\n            -- Destructuring (Node Pattern) (Node Expression)\n            -- InfixDeclaration Infix\n            Nothing\n    , remainingDocComments\n    )\n        |> Tuple.mapFirst (MaybeX.unwrap acc (\\tld -> tld :: acc))"},{"$":1,"a":{"bV":{"bb":6,"bp":875},"ch":{"bb":1,"bp":866}},"b":"{-| Given a `TLD` and a list of other `TLD`s,\n-}\ntype alias Glue =\n    ( Int, TLD ) -> List TLD -> Maybe GluedTo"},{"$":1,"a":{"bV":{"bb":105,"bp":923},"ch":{"bb":1,"bp":878}},"b":"{-| Create a context with a source extractor.\n-}\ninitialContext : Rule.ContextCreator () Context\ninitialContext =\n    Rule.initContextCreator\n        (\\extractSource () ->\n            { extractSource = extractSource\n            , exports = Nothing\n            , errorRange = Range.emptyRange\n            , unparsedDocComments = []\n            , moduleImportRange = Nothing\n            }\n        )\n        |> Rule.withSourceCodeExtractor"},{"$":1,"a":{"bV":{"bb":67,"bp":993},"ch":{"bb":1,"bp":926}},"b":"{-| Information about a TLD.\n-}\ntype alias TLD =\n    { type_ : DeclarationType\n    , namesBound : Set String\n    , exposedOrder : Maybe Int\n    , range : Range\n    , dependentOnBindings : Set String\n    , glued : Maybe GluedTo\n    }"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedRecordsTest.elm","c":{"bT":87950215,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"tests/NoUnsortedRecordsTest.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":10,"bp":124},"ch":{"bb":1,"bp":50}},"b":"ambiguousRecordError : List String -> String -> Review.Test.ExpectedError\nambiguousRecordError matching under =\n    Review.Test.error\n        { message = \"Ambiguous record encountered.\"\n        , details =\n            [ \"This record could be one of several possible record aliases, so whether or not its fields are sorted could not be determined!\"\n            , \"Try adding a type annotation, or remove reportAmbiguousRecordsWithoutFix from your rule configuration.\"\n            , \"The record matched the following possible aliases: \" ++ String.join \", \" matching\n            ]\n        , under = under\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":345},"ch":{"bb":1,"bp":224}},"b":"avoidBadFixes : Test\navoidBadFixes =\n    describe \"avoids bad fixes\"\n        [ test \"do not splice onto the ends of comments\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Rec =\n    { foo : Int\n    , bar : Int\n    , baz : Int\n    }\n\ntest : Rec -> Rec\ntest r =\n    { r\n        | bar = 1\n        -- comment\n        , foo = 2\n        , baz = 3\n    }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 11, column = 5 }, end = { row = 11, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias Rec =\n    { foo : Int\n    , bar : Int\n    , baz : Int\n    }\n\ntest : Rec -> Rec\ntest r =\n    { r\n        | foo = 2\n        , bar = 1\n        -- comment\n        , baz = 3\n    }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":387},"ch":{"bb":1,"bp":348}},"b":"customTypeArgs : Test\ncustomTypeArgs =\n    describe \"record is an argument of a type\"\n        [ test \"fields are in sorted order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fields are not in sorted order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 7 }, end = { row = 5, column = 8 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"disambiguates by constructor for expressions\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 7 }, end = { row = 7, column = 8 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"disambiguates by constructor arg index for expressions\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { bar = 1, foo = 2, baz = 3 } \"hello\" { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 9 }, end = { row = 6, column = 10 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { foo = 2, bar = 1, baz = 3 } \"hello\" { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 47 }, end = { row = 6, column = 48 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\na = A 3 { bar = 1, foo = 2, baz = 3 } \"hello\" { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                        ]\n        , test \"disambiguates by constructor arg index for patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { bar, foo } _ {foo, bar} -> False\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 9, column = 13 }, end = { row = 9, column = 14 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { foo, bar } _ {foo, bar} -> False\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 9, column = 28 }, end = { row = 9, column = 29 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom\n    = A Int { foo : Int, bar : Int, baz : Int } String { bar : Int, foo : Int, baz : Int }\n\n\na custom =\n    case custom of\n        A _ { bar, foo } _ {bar, foo} -> False\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":437},"ch":{"bb":1,"bp":390}},"b":"dependencySupport : Test\ndependencySupport =\n    describe \"dependency support\"\n        [ test \"will sort based on type alias in dependency with annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na : DeadEnd\na = { problem = BadRepeat, col = 1, row = 2 }\n\"\"\"\n                    |> Review.Test.runWithProjectData (projectWithElmCore |> addDependency elmParser) (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na : DeadEnd\na = { row = 2 , col = 1, problem = BadRepeat}\n\"\"\"\n                        ]\n        , test \"will sort based on type alias in dependency without\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na = { problem = BadRepeat, col = 1, row = 2 }\n\"\"\"\n                    |> Review.Test.runWithProjectData (projectWithElmCore |> addDependency elmParser) (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nimport Parser exposing (DeadEnd, Problem (..))\n\na = { row = 2 , col = 1, problem = BadRepeat}\n\"\"\"\n                        ]\n        , test \"will disambiguate based on dependency function signature (including list type)\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : Problem }\n\na = deadEndsToString [ { problem = BadRepeat, col = 1, row = 2 } ]\n\"\"\"\n                    |> Review.Test.runWithProjectData (projectWithElmCore |> addDependency elmParser) (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 24 }, end = { row = 7, column = 25 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : Problem }\n\na = deadEndsToString [ { row = 2 , col = 1, problem = BadRepeat} ]\n\"\"\"\n                        ]\n        , test \"will disambiguate based on field type\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { col : Int, row : Int, problem : Problem }\na = { problem = BadRepeat, col = 1, row = 2 }\n\"\"\"\n                    |> Review.Test.runWithProjectData (projectWithElmCore |> addDependency elmParser) (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { col : Int, row : Int, problem : Problem }\na = { row = 2 , col = 1, problem = BadRepeat}\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nimport Parser exposing (deadEndsToString, DeadEnd, Problem (..))\n\ntype alias MyDeadEnd = { col : Int, row : Int, problem : String }\n\na : { row : Int, col : Int, problem : Problem }\na = { problem = BadRepeat, col = 1, row = 2 }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":457},"ch":{"bb":1,"bp":440}},"b":"disambiguatesByHasAllFields : Test\ndisambiguatesByHasAllFields =\n    describe \"disambiguates by whether all fields must be present\"\n        [ test \"passes\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { foo = 1, bar = 2, baz = 3}\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fails\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int, extra : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"does not match any when all fields must be present\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na = { baz = 3, bar = 2 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na = { bar = 2 , baz = 3}\n\"\"\"\n                        ]\n        , test \"is ambiguous with record updates\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | baz = 3, bar = 2, foo = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 7 }, end = { row = 7, column = 8 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                        ]\n        , test \"is ambiguous with record updates not sorting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na r = { r | baz = 3, bar = 2, foo = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortAmbiguousRecords\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"patterns do not match any when all fields must be present\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { baz : Int, bar : Int } -> Bool\na _ = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { bar : Int , baz : Int} -> Bool\na _ = True\n\"\"\"\n                        ]\n        , test \"patterns match when all fields must be present\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { bar : Int, foo : Int, baz : Int } -> Bool\na _ = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { foo : Int, baz : Int , bar : Int} -> Bool\na _ = True\n\"\"\"\n                        ]\n        , test \"is ambiguous with generic records\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | baz : Int, bar : Int, foo : Int } -> Bool\na _ = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | bar : Int, baz : Int, foo : Int } -> Bool\na _ = True\n\"\"\"\n                        ]\n        , test \"is ambiguous with generic records not sorting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, baz : Int, bar : Int }\n\ntype alias B = { baz : Int, bar : Int, foo : Int, extra : Int }\n\na : { r | baz : Int, bar : Int, foo : Int } -> Bool\na _ = True\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortAmbiguousRecords\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":504},"ch":{"bb":1,"bp":460}},"b":"disambiguatesByKnownFunctionArgTypes : Test\ndisambiguatesByKnownFunctionArgTypes =\n    describe \"disambiguates by known function arg types\"\n        [ test \"possible because of type annotation in same module\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 12 }, end = { row = 10, column = 13 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"possible because of type annotation in other module\" <|\n            \\() ->\n                [ \"\"\"module B exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"A\"\n                          , [ unsortedError\n                                |> Review.Test.atExactly { start = { row = 8, column = 12 }, end = { row = 8, column = 13 } }\n                                |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"does not keep unexposed functions\" <|\n            \\() ->\n                [ \"\"\"module B exposing (A)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = B.foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> doNotSortAmbiguousRecords\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"does understand unexposed alias from an exposed function\" <|\n            \\() ->\n                [ \"\"\"module B exposing (foo)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B exposing (foo)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"possible because of type annotation in custom type pattern\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom = Custom A\n\nfunc : Custom -> Bool\nfunc c =\n    case c of\n        Custom { bar, foo, baz } -> True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 11, column = 16 }, end = { row = 11, column = 17 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom = Custom A\n\nfunc : Custom -> Bool\nfunc c =\n    case c of\n        Custom { foo, bar, baz } -> True\n\"\"\"\n                        ]\n        , test \"does understand unexposed alias from an exposed constructor\" <|\n            \\() ->\n                [ \"\"\"module B exposing (Custom(..))\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype Custom = Custom A\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B exposing (Custom(..))\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = Custom { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"does not understand unexposed constructor\" <|\n            \\() ->\n                [ \"\"\"module B exposing (A)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype Custom = Custom A\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = B.Custom { bar = 2, baz = 3, foo = 1}\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"does understand imported record constructor\" <|\n            \\() ->\n                [ \"\"\"module B exposing (A)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int } }\n\ntype Custom = Custom A\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B exposing (A)\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = A { foo = 1, bar = 2, baz = 3}\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":699},"ch":{"bb":1,"bp":507}},"b":"disambiguatesByTypeAnnotation : Test\ndisambiguatesByTypeAnnotation =\n    describe \"disambiguates using type annotation\"\n        [ test \"disambiguation is possible because of type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : A\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"disambiguation is possible because of type annotation with type vars\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\n\ntype alias B a = { bar : Int, foo : a, baz : Int }\n\na : A Int\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\n\ntype alias B a = { bar : Int, foo : a, baz : Int }\n\na : A Int\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"disambiguation is possible because of complex type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> String -> ( Int, String, List A )\na i s = ( i, s, [ { bar = 2, foo = 1, baz = 3 } ] )\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 19 }, end = { row = 8, column = 20 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> String -> ( Int, String, List A )\na i s = ( i, s, [ { foo = 1, bar = 2, baz = 3 } ] )\n\"\"\"\n                        ]\n        , test \"disambiguation of pattern is possible because of type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> A -> Int -> Bool\na i1 { bar, foo, baz } i2 = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 6 }, end = { row = 8, column = 7 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Int -> A -> Int -> Bool\na i1 { foo, bar, baz } i2 = True\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":805},"ch":{"bb":1,"bp":702}},"b":"genericRecordSupport : Test\ngenericRecordSupport =\n    describe \"generic records\"\n        [ test \"without additional fields\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic {}\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic {}\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"without additional fields without type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 5 }, end = { row = 5, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"with additional fields\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, y = 2, z = 3, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"with additional fields last\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortGenericFieldsLast\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na : Generic { x : Int, y : Int, z : Int }\na = { foo = 1, bar = 2, baz = 3 , x = 0, y = 2, z = 3}\n\"\"\"\n                        ]\n        , test \"with additional fields without type signature\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { x = 0, bar = 2, z = 3, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 5 }, end = { row = 5, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\n\na = { x = 0, y = 2, z = 3, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"with additional fields that have canonical order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"with additional fields that have canonical order last\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortGenericFieldsLast\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na : Generic A\na = { foo = 1, bar = 2, baz = 3 , yi = 3, er = 2, san = 0}\n\"\"\"\n                        ]\n        , test \"with additional fields that have canonical order without annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias A = { yi : Int, er : Int, san : Int }\n\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"nested generics that have canonical order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 {})\na = { san = 0, bar = 2, yi = 3, er = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 {})\na = { yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"nested generics that have canonical order with additional nesting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { y = 2, x = 6, yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"nested generics that have canonical order with additional nesting at end\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortGenericFieldsLast\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\ntype alias A = { y : Int, x : Int }\n\na : Generic (Generic2 A)\na = { foo = 1, bar = 2, baz = 3 , yi = 3, er = 2, san = 0, y = 2, x = 6}\n\"\"\"\n                        ]\n        , test \"nested generics without canonical order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { x = 6, y = 2, yi = 3, er = 2, san = 0, foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"nested generics without canonical order ambiguous\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportAmbiguousRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ ambiguousRecordError\n                            [ \"A.Generic (A.Generic2)\", \"A.Generic2 (A.Generic)\" ]\n                            \"{ san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\"\n                        ]\n        , test \"nested generics without canonical order report only\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic rec = { rec | foo : Int, bar : Int, baz : Int }\ntype alias Generic2 rec = { rec | yi : Int, er : Int, san : Int }\n\na : Generic (Generic2 { x : Int, y : Int })\na = { san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportUnknownRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unknownRecordError \"{ san = 0, bar = 2, x = 6, yi = 3, er = 2, y = 2, foo = 1, baz = 3 }\"\n                        , unknownRecordError \"{ x : Int, y : Int }\"\n                        ]\n        , test \"prefers canonical match over generic + unknown\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"does not prefer canonical match over generic + canonical\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { baz : Int }\ntype alias Generic rec = { rec | bar : Int, foo : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportAmbiguousRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ ambiguousRecordError [ \"A.A\", \"A.Generic (A.B)\" ] \"{ bar = 2, foo = 1, baz = 3 }\" ]\n        , test \"does not recurse infinitely when not all fields must be present\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Generic a =\n    { a | unrelated : Int, foo : Int }\n\nfunc x =\n    case x of\n        { bar, baz, foo } ->\n            True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"handles weird Elm nested generic behavior\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Gen1 a =\n    { a | y : Int, x : Int }\n\n\ntype alias Gen2 b =\n    { b | x : Char, y : String }\n\ntype alias OtherRec = { y : String, x : Char }\n\na : Gen2 (Gen1 { x : String, y : Float })\na =\n    { y = \"bar\", x = 'a' }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportAmbiguousRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 14, column = 5 }, end = { row = 14, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias Gen1 a =\n    { a | y : Int, x : Int }\n\n\ntype alias Gen2 b =\n    { b | x : Char, y : String }\n\ntype alias OtherRec = { y : String, x : Char }\n\na : Gen2 (Gen1 { x : String, y : Float })\na =\n    { x = 'a' , y = \"bar\"}\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":932},"ch":{"bb":1,"bp":808}},"b":"inExpressions : Test\ninExpressions =\n    describe \"expressions are sorted\"\n        [ test \"sorts expressions\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { b = 1, c = 2, a = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na = { a = 3 , b = 1, c = 2}\n\"\"\"\n                        ]\n        , test \"sorts multiline expressions\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na =\n    { b = 1\n    , c = 2\n    , a = 3\n    }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na =\n    { a = 3\n    \n    , b = 1, c = 2\n    }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1140},"ch":{"bb":1,"bp":935}},"b":"inPatterns : Test\ninPatterns =\n    describe \"patterns are sorted\"\n        [ test \"sorts patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na { foo, baz, bar } = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na { bar, baz, foo } = True\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1296},"ch":{"bb":1,"bp":1143}},"b":"inTypeAnnotations : Test\ninTypeAnnotations =\n    describe \"type annotations are sorted (when not custom types or type aliases)\"\n        [ test \"sorts type annotations\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na : { b : Int, c : Int, a : Int } -> Bool\na _ = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na : { a : Int , b : Int, c : Int} -> Bool\na _ = True\n\"\"\"\n                        ]\n        , test \"sorts multiline type annotations\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na :\n    { b : Int\n    , c : Int\n    , a : Int\n    }\n    -> Bool\na _ =\n    True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na :\n    { a : Int\n    \n    , b : Int, c : Int\n    }\n    -> Bool\na _ =\n    True\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1341},"ch":{"bb":1,"bp":1299}},"b":"localBindingSupport : Test\nlocalBindingSupport =\n    describe \"disambiguates using local bindings\"\n        [ test \"possible because of type annotation in let block\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc =\n    let\n        foo : A -> Bool\n        foo _ = True\n    in\n    foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 12, column = 9 }, end = { row = 12, column = 10 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc =\n    let\n        foo : A -> Bool\n        foo _ = True\n    in\n    foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"possible because of type annotation on function arg\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc foo = foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 16 }, end = { row = 7, column = 17 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc foo = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"possible because of lambda arg\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc = \\\\foo -> foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 20 }, end = { row = 7, column = 21 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : (A -> Bool) -> Bool\nfunc = \\\\foo -> foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"works with record pattern\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { field : Int, foo : (A -> Bool) } -> Bool\nfunc { field, foo } = foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 27 }, end = { row = 7, column = 28 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { field : Int, foo : (A -> Bool) } -> Bool\nfunc { field, foo } = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"works with named pattern\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\ntype Custom = Custom In (A -> Bool)\n\nfunc : Custom -> Bool\nfunc (Custom field foo) = foo { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 31 }, end = { row = 8, column = 32 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\ntype Custom = Custom In (A -> Bool)\n\nfunc : Custom -> Bool\nfunc (Custom field foo) = foo { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1538},"ch":{"bb":1,"bp":1344}},"b":"operatorSupport : Test\noperatorSupport =\n    describe \"operator support\"\n        [ test \"understands |> operator application\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 } |> foo\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 8 }, end = { row = 10, column = 9 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { foo = 1, bar = 2, baz = 3 } |> foo\n\"\"\"\n                        ]\n        , test \"handles parentheses\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 } |> (foo)\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 8 }, end = { row = 10, column = 9 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = { foo = 1, bar = 2, baz = 3 } |> (foo)\n\"\"\"\n                        ]\n        , test \"understands <| operator application\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo <| { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 15 }, end = { row = 10, column = 16 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\nfunc : Bool\nfunc = foo <| { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1631},"ch":{"bb":1,"bp":1541}},"b":"recordConstructorSupport : Test\nrecordConstructorSupport =\n    describe \"using record constructors\"\n        [ test \"possible because of type annotation of field for record constructor\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { bar = 1, foo = 2, baz = 3 } { foo = 2, bar = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 9, column = 7 }, end = { row = 9, column = 8 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { foo = 2, bar = 1, baz = 3 } { foo = 2, bar = 1, baz = 3 }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 9, column = 37 }, end = { row = 9, column = 38 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias C = { a : A, b : B }\n\nfunc =\n    C { bar = 1, foo = 2, baz = 3 } { bar = 1, foo = 2, baz = 3 }\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1739},"ch":{"bb":1,"bp":1634}},"b":"simpleTypeInferenceSupport : Test\nsimpleTypeInferenceSupport =\n    describe \"infers record field types\"\n        [ test \"can disambiguate by type\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : List (List Int), baz : Char }\ntype alias B = { bar : List (List String), foo : Int, baz : Char }\n\nfunc = { bar = [ [], ([3, 4]) ], foo = 3, baz = '2' }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : List (List Int), baz : Char }\ntype alias B = { bar : List (List String), foo : Int, baz : Char }\n\nfunc = { foo = 3, bar = [ [], ([3, 4]) ], baz = '2' }\n\"\"\"\n                        ]\n        , test \"does not incorrectly infer Nothings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Maybe Int, bar : Maybe Float }\n\na = { foo = Nothing, bar = Nothing }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"does not incorrectly infer nested Nothings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Maybe Int, bar : Maybe Float }, er : Int }\n\na = { yi = { foo = Nothing, bar = Nothing }, er = 2 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"infers lambdas\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int -> Int, baz : Char }\ntype alias B = { bar : Int, foo : Int, baz : Char }\n\nfunc = { bar = \\\\i -> i + 1, foo = 3, baz = '2' }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int -> Int, baz : Char }\ntype alias B = { bar : Int, foo : Int, baz : Char }\n\nfunc = { foo = 3, bar = \\\\i -> i + 1, baz = '2' }\n\"\"\"\n                        ]\n        , test \"can disambiguate by type with record types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc = { bar = 2, foo = { a = 3, b = \"b\" }, baz = { a = 2, b = \"r\" }.a }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc = { foo = { a = 3, b = \"b\" }, bar = 2, baz = { a = 2, b = \"r\" }.a }\n\"\"\"\n                        ]\n        , test \"infers let destructuring types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc =\n    let\n        { bar, foo, baz } = A 1 \"string\" 3\n    in\n    { foo = foo, bar = bar, baz = baz }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 9 }, end = { row = 8, column = 10 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc =\n    let\n        { foo, bar, baz } = A 1 \"string\" 3\n    in\n    { foo = foo, bar = bar, baz = baz }\n\"\"\"\n                        ]\n        , test \"infers case pattern types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case {foo = 1, bar = s, baz = 2} of\n        {bar, foo, baz} ->\n            True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 9, column = 9 }, end = { row = 9, column = 10 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case {foo = 1, bar = s, baz = 2} of\n        {foo, bar, baz} ->\n            True\n\"\"\"\n                        ]\n        , test \"assigns case pattern bindings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case s of\n        \"True\" -> True\n        \"False\" -> False\n        str -> {bar = str, foo = 1, baz = 2}\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 11, column = 16 }, end = { row = 11, column = 17 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : String, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : String -> Bool\nfunc s =\n    case s of\n        \"True\" -> True\n        \"False\" -> False\n        str -> {foo = 1, bar = str, baz = 2}\n\"\"\"\n                        ]\n        , test \"infers record update with binding\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nr : A\nr = { foo = 1, bar = 2, baz = 3 }\n\nfunc =\n    { r | baz = 1, foo = 2 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 5 }, end = { row = 10, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nr : A\nr = { foo = 1, bar = 2, baz = 3 }\n\nfunc =\n    { r | foo = 2 , baz = 1}\n\"\"\"\n                        ]\n        , test \"unifies record types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : String, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc r =\n    case List.head [ { r | baz = 1 }, { r | bar = 1 }, { r | foo = \"string\" } ] of\n        Just { bar, baz, foo } -> True\n        Nothing -> False\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 14 }, end = { row = 8, column = 15 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : String, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc r =\n    case List.head [ { r | baz = 1 }, { r | bar = 1 }, { r | foo = \"string\" } ] of\n        Just { foo, bar, baz } -> True\n        Nothing -> False\n\"\"\"\n                        ]\n        , test \"assigns type vars when necessary\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : A\nfunc =\n    identity { foo = 1, bar = 2, baz = 3}\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"assigns type vars when necessary 2\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : a -> A\nfunc =\n    always { foo = 1, bar = 2, baz = 3}\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2166},"ch":{"bb":1,"bp":1742}},"b":"subrecords : Test\nsubrecords =\n    describe \"subrecords\"\n        [ test \"are sorted by default in larger record\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1}\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 23 }, end = { row = 5, column = 24 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                        ]\n        , test \"are not sorted by default from constructor when not part of constructor\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"are sorted from constructor when not part of constructor with setting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias Rec = { yi : { bar : Int, baz : Int, foo : Int }, er : Int }\n\ntype A = A { foo : Int, bar : Int, baz : Int }\n\nfunc = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatCustomTypeRecordsAsCanonical\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"are sorted by default in larger record with type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1}\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 23 }, end = { row = 6, column = 24 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                        ]\n        , test \"are sorted by default in sub sub record\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { er = 1, yi = { bar = 2, foo = 1, baz = 3 } } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 18 }, end = { row = 5, column = 19 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { yi = { bar = 2, foo = 1, baz = 3 } , er = 1} }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 33 }, end = { row = 5, column = 34 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc = { outer = { er = 1, yi = { foo = 1, bar = 2, baz = 3 } } }\n\"\"\"\n                        ]\n        , test \"are sorted by default in larger record with nested expression\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc = { yi = (0, [ { bar = 2, foo = 1, baz = 3 } ]), er = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 21 }, end = { row = 5, column = 22 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc = { yi = (0, [ { foo = 1, bar = 2, baz = 3 } ]), er = 1 }\n\"\"\"\n                        ]\n        , test \"are sorted by default in type annotations\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { er : Int, yi : { bar : Int, foo : Int, baz : Int } }\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { yi : { bar : Int, foo : Int, baz : Int } , er : Int}\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 25 }, end = { row = 5, column = 26 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : { er : Int, yi : { foo : Int, bar : Int, baz : Int } }\nfunc = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 }\n\"\"\"\n                        ]\n        , test \"are sorted by default in sub sub record of type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { er : Int, yi : { bar : Int, foo : Int, baz : Int } } }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 18 }, end = { row = 5, column = 19 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { yi : { bar : Int, foo : Int, baz : Int } , er : Int} }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 35 }, end = { row = 5, column = 36 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { outer : { yi : { foo : Int, bar : Int, baz : Int }, er : Int } }\n\nfunc : { outer : { er : Int, yi : { foo : Int, bar : Int, baz : Int } } }\nfunc = { outer = { yi = { foo = 1, bar = 2, baz = 3 }, er = 1 } }\n\"\"\"\n                        ]\n        , test \"are sorted by default in larger record with nested expression in type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc : { yi : (Int, List { bar : Int, foo : Int, baz : Int }), er : Int }\nfunc = { yi = (0, []), er = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 26 }, end = { row = 5, column = 27 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : ( Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\n\nfunc : { yi : (Int, List { foo : Int, bar : Int, baz : Int }), er : Int }\nfunc = { yi = (0, []), er = 1 }\n\"\"\"\n                        ]\n        , test \"are not sorted with setting in larger record\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { er = 1, yi = { bar = 2, baz = 3, foo = 1 } }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatSubrecordsAsUnknown\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { yi = { bar = 2, baz = 3, foo = 1 } , er = 1}\n\"\"\"\n                        ]\n        , test \"are not sorted with setting in larger record with type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { er = 1, yi = { bar = 2, baz = 3, foo = 1 } }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatSubrecordsAsUnknown\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc : A\nfunc = { yi = { bar = 2, baz = 3, foo = 1 } , er = 1}\n\"\"\"\n                        ]\n        , test \"are not sorted for custom types with setting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = A { bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatSubrecordsAsUnknown\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"are sorted with setting when not in context from alias\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatAllSubrecordsAsCanonical\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { foo = 1 , bar = 2, baz = 3}\n\"\"\"\n                        ]\n        , test \"are sorted with setting when not in context from constructor\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype A = A { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatAllSubrecordsAsCanonical\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype A = A { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\n\nfunc = { foo = 1 , bar = 2, baz = 3}\n\"\"\"\n                        ]\n        , test \"handle ambiguity with subrecords with setting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom\n    = A { foo : Int, bar : Int, baz : Int }\n    | B { bar : Int, foo : Int, baz : Int }\n\na = { bar = 2, baz = 3, foo = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatAllSubrecordsAsCanonical\n                            |> reportAmbiguousRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ ambiguousRecordError [ \"A.A arg0\", \"A.B arg0\" ] \"{ bar = 2, baz = 3, foo = 1 }\"\n                        ]\n        , test \"do not take priority\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\ntype alias B = { baz : Int, bar : Int, foo : Int }\n\nfunc = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> treatAllSubrecordsAsCanonical\n                            |> reportAmbiguousRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { yi : { foo : Int, bar : Int, baz : Int }, er : Int }\ntype alias B = { baz : Int, bar : Int, foo : Int }\n\nfunc = { baz = 3 , bar = 2, foo = 1}\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2299},"ch":{"bb":1,"bp":2169}},"b":"typeVarSupport : Test\ntypeVarSupport =\n    describe \"handles type variables\"\n        [ test \"in custom types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Maybe A\na = Just { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 10 }, end = { row = 8, column = 11 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\na : Maybe A\na = Just { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"in non-dependency custom types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom a = Custom a\n\na : Custom A\na = Custom { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 12 }, end = { row = 10, column = 13 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype Custom a = Custom a\n\na : Custom A\na = Custom { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"in aliases\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias Mebbe a = a\n\na : Mebbe A\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 10, column = 5 }, end = { row = 10, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\ntype alias Mebbe a = a\n\na : Mebbe A\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"can match with type vars\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { foo : String, bar : Int, baz : Int }\nfunc =\n    { bar = 1, foo = \"foo\", baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A a = { foo : a, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : { foo : String, bar : Int, baz : Int }\nfunc =\n    { foo = \"foo\", bar = 1, baz = 3 }\n\"\"\"\n                        ]\n        , test \"can assign type vars\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A a b = { foo : a, bar : b, baz : Maybe Int }\ntype alias B a = { bar : a, foo : a, baz : Maybe Int }\n\nfunc : { foo : String, bar : Int, baz : Maybe a }\nfunc =\n    { bar = 1, foo = \"foo\", baz = Nothing }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 5 }, end = { row = 8, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A a b = { foo : a, bar : b, baz : Maybe Int }\ntype alias B a = { bar : a, foo : a, baz : Maybe Int }\n\nfunc : { foo : String, bar : Int, baz : Maybe a }\nfunc =\n    { foo = \"foo\", bar = 1, baz = Nothing }\n\"\"\"\n                        ]\n        , test \"does not recurse infinitely by a typevar being assigned to itself\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias C z = { y : z }\n\nc : C a -> a\nc = .y\n\nfoo : { a | field : Int } -> C x -> Int\nfoo _ _ = 0\n\nrecord =\n    { f = foo (c 1) (c 2) }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2562},"ch":{"bb":1,"bp":2302}},"b":"typecheckUnambiguous : Test\ntypecheckUnambiguous =\n    describe \"unambiguous records\"\n        [ test \"are not type-checked by default\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, foo = 1.1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { foo = 1.1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"are type-checked with option\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, foo = 1.1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> typecheckAllRecords\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 8 }, end = { row = 5, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfunc = { bar = 2, baz = 3 , foo = 1.1}\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2950},"ch":{"bb":1,"bp":2565}},"b":"unknownRecordError : String -> Review.Test.ExpectedError\nunknownRecordError under =\n    Review.Test.error\n        { message = \"Unknown record encountered.\"\n        , details =\n            [ \"This record did not correspond with any known alias or custom type argument record, so whether or not its fields are sorted could not be determined!\"\n            , \"Create a type alias for this record type, or remove reportUnknownRecordsWithoutFix from your rule configuration.\"\n            ]\n        , under = under\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":3000},"ch":{"bb":1,"bp":2953}},"b":"unknownRecords : Test\nunknownRecords =\n    describe \"unknown records\"\n        [ test \"passes unknown record that is alphabetical\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { a = 1, b = 2, c = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fails unknown record that is not alphabetical\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\na = { a = 1 , b = 2, c = 3}\n\"\"\"\n                        ]\n        , test \"passes unknown record that is not alphabetical with option\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortUnknownRecords\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"reports unknown record that is not alphabetical with option\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { c = 3, b = 2, a = 1 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportUnknownRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unknownRecordError \"{ c = 3, b = 2, a = 1 }\" ]\n        , test \"does not report unknown record with single field even with option\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = { c = 3 }\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportUnknownRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"does not report unit record even with option\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\na = {}\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> reportUnknownRecordsWithoutFix\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":3023},"ch":{"bb":1,"bp":3014}},"b":"usesRecordFieldTypes : Test\nusesRecordFieldTypes =\n    describe \"uses record field types\"\n        [ test \"can disambiguate by field type\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 11 }, end = { row = 8, column = 12 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { foo = 2, bar = 1, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 8, column = 46 }, end = { row = 8, column = 47 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : {a : A, b : B}\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { bar = 2, foo = 1, baz = 3 } }\n\"\"\"\n                        ]\n        , test \"can disambiguate by field type without alias\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 11 }, end = { row = 7, column = 12 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { foo = 2, bar = 1, baz = 3 }, b = { foo = 1, bar = 2, baz = 3 } }\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 46 }, end = { row = 7, column = 47 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { a : { foo : Int, bar : Int, baz : Int }, b : { bar : Int, foo : Int, baz : Int } }\n\nfunc : A\nfunc =\n    { a = { bar = 1, foo = 2, baz = 3 }, b = { bar = 2, foo = 1, baz = 3 } }\n\"\"\"\n                        ]\n        , test \"can disambiguate by type\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { bar : Int, foo : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { foo : Int, bar : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 6 }, end = { row = 7, column = 7 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : { bar : Int, foo : Int, baz : Int } -> Bool\nfunc { foo, bar, baz } = True\n\"\"\"\n                        ]\n        , test \"can disambiguate by type via record access\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { bar = 1, foo = 2, baz = 3 }.bar\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 8 }, end = { row = 7, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { foo = 2, bar = 1, baz = 3 }.bar\n\"\"\"\n                        ]\n        , test \"can disambiguate by type via record access function\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { bar = 1, foo = 2, baz = 3 } |> .bar\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 8 }, end = { row = 7, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\ntype alias B = { bar : String, foo : Int, baz : Int }\n\nfunc : Int\nfunc = { foo = 2, bar = 1, baz = 3 } |> .bar\n\"\"\"\n                        ]\n        , test \"can disambiguate by type with record types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { bar : Int, foo : { a : Int, b : String }, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 8 }, end = { row = 6, column = 9 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { foo : { a : Int, b : String }, bar : Int, baz : Int } -> Bool\nfunc { bar, foo, baz } = True\n\"\"\"\n                        , unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 6 }, end = { row = 7, column = 7 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : { a : Int, b : String }, bar : Int, baz : Int }\ntype alias B = { bar : Int, foo : {a : String, b : String }, baz : Int }\n\nfunc : { bar : Int, foo : { a : Int, b : String }, baz : Int } -> Bool\nfunc { foo, bar, baz } = True\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":3036},"ch":{"bb":1,"bp":3026}},"b":"withAlias : Test\nwithAlias =\n    describe \"record corresponds to a known alias\"\n        [ test \"fields are in sorted order with type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fields are in sorted order without type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fields are in order to multiple matching aliases\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"fields are not in sorted order with type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 5 }, end = { row = 6, column = 6 } }\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na : A\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"fields are not in sorted order without type annotation\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 5, column = 5 }, end = { row = 5, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"fields are not in order to multiple matching aliases with degenerate orders\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 7, column = 5 }, end = { row = 7, column = 6 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\ntype alias B = { foo : Int, bar : Int, baz : Int }\n\na = { foo = 1, bar = 2, baz = 3 }\n\"\"\"\n                        ]\n        , test \"does not keep unexposed aliases\" <|\n            \\() ->\n                [ \"\"\"module B exposing (foo)\n\ntype alias A = { foo : Int, bar : Int, baz : Int }\n\nfoo : A -> Bool\nfoo a = True\n\"\"\"\n                , \"\"\"module A exposing (..)\n\nimport B\n\ntype alias B = { bar : Int, foo : Int, baz : Int }\n\nfunc : Bool\nfunc = { bar = 2, foo = 1, baz = 3 }\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-1,"a":1,"b":"tests/NoUnsortedLetDeclarationsTest.elm","c":{"bT":1771235242,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"tests/NoUnsortedLetDeclarationsTest.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":10,"bp":71},"ch":{"bb":1,"bp":34}},"b":"alphabeticallyTests : Test\nalphabeticallyTests =\n    describe \"alphabetically\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        bar =\n            x\n        baz =\n            y\n        foo =\n            z\n    in\n    foo |> bar |> baz\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        foo =\n            z\n        bar =\n            x\n        baz =\n            y\n    in\n    foo |> bar |> baz\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nf =\n    let\n        bar =\n            x\n        baz =\n            y\n        foo =\n            z\n    in\n    foo |> bar |> baz\n\"\"\"\n                        ]\n        , test \"passes sorted destructuring\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        (Opaque a) =\n            i\n\n        ( z, b ) =\n            j\n\n        { y, c } =\n            k\n\n        d =\n            l\n    in\n    x\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails unsorted destructuring\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        ( z, b ) =\n            j\n\n        (Opaque a) =\n            i\n\n        d =\n            l\n\n        { y, c } =\n            k\n    in\n    x\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        (Opaque a) =\n            i\n\n        ( z, b ) =\n            j\n\n        { y, c } =\n            k\n\n        d =\n            l\n    in\n    x\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":84},"ch":{"bb":1,"bp":74}},"b":"glueDependenciesAfterFirstDependentTests : Test\nglueDependenciesAfterFirstDependentTests =\n    describe \"glueDependenciesAfterFirstDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        help =\n            foo\n\n        b =\n            bar help\n\n        z =\n            zed help\n    in\n    a + b + z\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesAfterFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> glueDependenciesAfterFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        help =\n            foo x\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        z =\n            zed help y\n\n        y =\n            help\n    in\n    a\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":214},"ch":{"bb":1,"bp":87}},"b":"glueDependenciesAfterLastDependentTests : Test\nglueDependenciesAfterLastDependentTests =\n    describe \"glueDependenciesAfterLastDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help\n\n        z =\n            zed help\n\n        help =\n            foo\n    in\n    a + b + z\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesAfterLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> glueDependenciesAfterLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        z =\n            zed help y\n\n        help =\n            foo x\n\n        y =\n            help\n    in\n    a\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":362},"ch":{"bb":1,"bp":217}},"b":"glueDependenciesBeforeFirstDependentTests : Test\nglueDependenciesBeforeFirstDependentTests =\n    describe \"glueDependenciesBeforeFirstDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        help =\n            foo\n\n        a =\n            foo help\n\n        b =\n            bar help\n\n        z =\n            zed help\n    in\n    a + b + z\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is not a dependency if in exactly one func\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar\n\n        help =\n            foo\n\n        z =\n            zed\n    in\n    bar\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is a dependency if multiple bindings used in exactly one func each (not the same)\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        (helpA, helpB) =\n            foo\n\n        a =\n            foo helpA\n\n        b =\n            bar helpB\n\n        z =\n            zed\n    in\n    bar\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        x =\n            y\n\n        b =\n            bar help x\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":510},"ch":{"bb":1,"bp":365}},"b":"glueDependenciesBeforeLastDependentTests : Test\nglueDependenciesBeforeLastDependentTests =\n    describe \"glueDependenciesBeforeLastDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo help\n\n        b =\n            bar help\n\n        help =\n            foo\n\n        z =\n            zed help\n    in\n    a + b + z\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nfunc =\n    let\n        help =\n            foo x\n\n        a =\n            foo help\n\n        b =\n            bar help x\n\n        x =\n            y\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> glueDependenciesBeforeLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nfunc =\n    let\n        a =\n            foo help\n\n        x =\n            y\n\n        b =\n            bar help x\n\n        help =\n            foo x\n\n        y =\n            help\n\n        z =\n            zed help y\n    in\n    a\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":587},"ch":{"bb":1,"bp":513}},"b":"glueHelpersAfterTests : Test\nglueHelpersAfterTests =\n    describe \"glueHelpersAfter\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is not helper if used in multiple funcs\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        calledInB =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo calledInB\n\n        b =\n            bar calledInB\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"does not glue to self\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        dalledInB =\n            foo\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n\n        dalledInB =\n            foo\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"chains properly and ignores mutual dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo\n\n        mutualDep3 =\n            mutualDep1\n\n        b =\n            bar calledInB\n\n        mutualDep2 =\n            bar mutualDep3\n\n        calledInBHelp =\n            bar\n\n        mutualDep1 =\n            mutualDep2\n\n        z =\n            zed\n\n        calledInB =\n            calledInBHelp foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        mutualDep1 =\n            mutualDep2\n\n        mutualDep2 =\n            bar mutualDep3\n\n        mutualDep3 =\n            mutualDep1\n\n        z =\n            zed\n\n        a =\n            foo\n\n        b =\n            bar calledInB\n\n        calledInB =\n            calledInBHelp foo\n\n        calledInBHelp =\n            bar\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"handles mutual recursion when one is not viable for gluing\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n\n        z =\n            zed\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n    in\n    a + b\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":664},"ch":{"bb":1,"bp":590}},"b":"glueHelpersBeforeTests : Test\nglueHelpersBeforeTests =\n    describe \"glueHelpersBefore\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is not helper if used in multiple funcs\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        calledInB =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo calledInB\n\n        b =\n            bar calledInB\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is a helper if multiple bindings used in single binding\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        (help1, help2) =\n            foo\n\n        z =\n            zed\n\n        a =\n            foo\n\n        (y, b) =\n            bar help1 help2\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        (help1, help2) =\n            foo\n\n        (y, b) =\n            bar help1 help2\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"does not glue to self\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            calledInB foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        dalledInB =\n            foo\n\n        a =\n            foo\n\n        b =\n            bar calledInB dalledInB\n\n        calledInB =\n            calledInB foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInB =\n            calledInB foo\n\n        dalledInB =\n            foo\n\n        b =\n            bar calledInB dalledInB\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"chains properly and ignores mutual dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            foo\n\n        mutualDep3 =\n            mutualDep1\n\n        b =\n            bar calledInB\n\n        mutualDep2 =\n            bar mutualDep3\n\n        calledInBHelp =\n            bar\n\n        mutualDep1 =\n            mutualDep2\n\n        z =\n            zed\n\n        calledInB =\n            calledInBHelp foo\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        mutualDep1 =\n            mutualDep2\n\n        mutualDep2 =\n            bar mutualDep3\n\n        mutualDep3 =\n            mutualDep1\n\n        z =\n            zed\n\n        a =\n            foo\n\n        calledInBHelp =\n            bar\n\n        calledInB =\n            calledInBHelp foo\n\n        b =\n            bar calledInB\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"handles mutual recursion when one is not viable for gluing\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfunc =\n    let\n        a =\n            aHelp\n\n        aHelp =\n            a\n\n        b =\n            bar\n\n        z =\n            zed\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\nfunc =\n    let\n        z =\n            zed\n\n        aHelp =\n            a\n\n        a =\n            aHelp\n\n        b =\n            bar\n    in\n    a + b\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":742},"ch":{"bb":1,"bp":667}},"b":"glues : Test\nglues =\n    describe \"glues\"\n        [ glueHelpersBeforeTests\n        , glueHelpersAfterTests\n        , glueDependenciesBeforeFirstDependentTests\n        , glueDependenciesAfterFirstDependentTests\n        , glueDependenciesBeforeLastDependentTests\n        , glueDependenciesAfterLastDependentTests\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":820},"ch":{"bb":1,"bp":745}},"b":"orderings : Test\norderings =\n    describe \"orderings\"\n        [ alphabeticallyTests\n        , usedInExpressionFirstTests\n        , usedInExpressionLastTests\n        , usedInOtherDeclarationsLastTests\n        , usedInOtherDeclarationsFirstTests\n        , valuesBeforeFunctionsTests\n        , valuesAfterFunctionsTests\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":832},"ch":{"bb":1,"bp":823}},"b":"passes : Test\npasses =\n    describe \"passes when\"\n        [ test \"single declaration\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        foo =\n            bar\n    in\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"no orderings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        foo =\n            bar\n        bar =\n            baz\n    in\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1145},"ch":{"bb":1,"bp":835}},"b":"unsortedError : Review.Test.ExpectedError\nunsortedError =\n    Review.Test.error\n        { message = \"Let declarations are not sorted.\"\n        , details =\n            [ \"Let declarations were found out of order.  They should be sorted as specified in the rule configuration.\" ]\n        , under = \"let\"\n        }"},{"$":1,"a":{"bV":{"bb":10,"bp":1409},"ch":{"bb":1,"bp":1148}},"b":"usedInExpressionFirstTests : Test\nusedInExpressionFirstTests =\n    describe \"usedInExpressionFirst\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        -- These are used in the expression\n        y =\n            b\n\n        x =\n            a\n\n        -- These are not\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        a =\n            i\n\n        b =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\"\"\"\n                        ]\n        , test \"falls back to other\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"falls back to other failing\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        y =\n            b\n\n        x =\n            a\n\n        b =\n            j\n\n        a =\n            i\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a =\n            i\n\n        b =\n            j\n    in\n    x + y\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1558},"ch":{"bb":1,"bp":1412}},"b":"usedInExpressionLastTests : Test\nusedInExpressionLastTests =\n    describe \"usedInExpressionLast\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        -- These are not used in the expression\n        x =\n            i\n\n        y =\n            j\n\n        -- These are used in the expression\n        b =\n            y\n\n        a =\n            x\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        b =\n            y\n\n        a =\n            x\n\n        x =\n            i\n\n        y =\n            j\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        b =\n            y\n\n        a =\n            x\n    in\n    a + b\n\"\"\"\n                        ]\n        , test \"falls back to other\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"falls back to other failing\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n\n        a =\n            x\n    in\n    a + b\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInExpressionLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    a + b\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1651},"ch":{"bb":1,"bp":1561}},"b":"usedInOtherDeclarationsFirstTests : Test\nusedInOtherDeclarationsFirstTests =\n    describe \"usedInOtherDeclarationsFirst\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInOtherDeclarationsFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n    in\n    0\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInOtherDeclarationsFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            i\n\n        y =\n            j\n\n        a =\n            x\n\n        b =\n            y\n    in\n    0\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1744},"ch":{"bb":1,"bp":1654}},"b":"usedInOtherDeclarationsLastTests : Test\nusedInOtherDeclarationsLastTests =\n    describe \"usedInOtherDeclarationsLast\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInOtherDeclarationsLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        x =\n            i\n\n        b =\n            y\n\n        y =\n            j\n    in\n    0\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> usedInOtherDeclarationsLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\nf =\n    let\n        a =\n            x\n\n        b =\n            y\n\n        x =\n            i\n\n        y =\n            j\n    in\n    0\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1837},"ch":{"bb":1,"bp":1747}},"b":"valuesAfterFunctionsTests : Test\nvaluesAfterFunctionsTests =\n    describe \"valuesAfterFunctions\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        a i =\n            i\n\n        b j =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> valuesAfterFunctions\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        a i =\n            i\n\n        y =\n            b\n\n        b j =\n            j\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> valuesAfterFunctions\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nf =\n    let\n        a i =\n            i\n\n        b j =\n            j\n\n        x =\n            a\n\n        y =\n            b\n    in\n    x + y\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1847},"ch":{"bb":1,"bp":1840}},"b":"valuesBeforeFunctionsTests : Test\nvaluesBeforeFunctionsTests =\n    describe \"valuesBeforeFunctions\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> valuesBeforeFunctions\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        a i =\n            i\n\n        y =\n            b\n\n        b j =\n            j\n    in\n    x + y\n\"\"\"\n                    |> Review.Test.run\n                        (sortLetDeclarations\n                            |> valuesBeforeFunctions\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\nf =\n    let\n        x =\n            a\n\n        y =\n            b\n\n        a i =\n            i\n\n        b j =\n            j\n    in\n    x + y\n\"\"\"\n                        ]\n        ]"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-1,"a":0,"b":"tests/NoUnsortedCasesTest.elm","c":{"bT":1657986532,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"tests/NoUnsortedCasesTest.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":10,"bp":143},"ch":{"bb":1,"bp":115}},"b":"fails : Test\nfails =\n    describe \"reports an error when\"\n        [ test \"case is not sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                        ]\n        , test \"type is not exposed\" <|\n            \\() ->\n                \"\"\"module A exposing (toString)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (toString)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                        ]\n        , fixesProperly\n        , failsCrossModule\n        , failsWildcards\n        , failsTransparentPatterns\n        , failsTuples\n        , failsLists\n        , failsUncons\n        , failsLiterals\n        , failsTypesFromDependencies\n        , failsSubpatterns\n        , failsOnWhitelist\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":281},"ch":{"bb":1,"bp":146}},"b":"failsCrossModule : Test\nfailsCrossModule =\n    describe \"case is defined in another module\"\n        [ test \"is not sorted\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n        Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with qualified names\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> \"Bar\"\n        A.Foo -> \"Foo\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed\n                                    \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with qualified names disambiguating\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> \"Baz\"\n        A.Bar -> \"Bar\"\n        A.Foo -> \"Foo\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"C\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed\n                                    \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with disambiguation by import\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"C\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed\n                                    \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with local name\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed\n                                    \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":432},"ch":{"bb":1,"bp":284}},"b":"failsLists : Test\nfailsLists =\n    describe \"with lists\"\n        [ failsListsLengthFirst\n        , failsListsElementwise\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":468},"ch":{"bb":1,"bp":435}},"b":"failsListsElementwise : Test\nfailsListsElementwise =\n    describe \"sorted elementwise\"\n        [ test \"is not sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Baz] -> \"Baz\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"in length-first order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"with mixed list/uncons in length-first order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        Foo :: [] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Bar, Foo] -> \"BarFoo\"\n        Bar :: Bar :: [] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Foo :: _ -> \"Foo+\"\n        Bar :: _ -> \"Bar+\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        Foo :: [] -> \"Foo\"\n        Foo :: _ -> \"Foo+\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        Bar :: Bar :: [] -> \"BarBar\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        [Bar, Baz] -> \"BarBaz\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Bar :: _ -> \"Bar+\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":586},"ch":{"bb":1,"bp":471}},"b":"failsListsLengthFirst : Test\nfailsListsLengthFirst =\n    describe \"sorted length-first\"\n        [ test \"is not sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Bar, Bar] -> \"BarBar\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortListPatternsByLength\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"in elementwise order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortListPatternsByLength\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"with mixed list/uncons in elementwise order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        Foo :: Foo :: [] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        Foo :: _ -> \"Foo+\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        [Bar, Baz] -> \"BarBaz\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Bar :: _ -> \"Bar+\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortListPatternsByLength\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        Foo :: Foo :: [] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Foo :: _ -> \"Foo+\"\n        Bar :: _ -> \"Bar+\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":595},"ch":{"bb":1,"bp":589}},"b":"failsLiterals : Test\nfailsLiterals =\n    describe \"with literals\"\n        [ test \"not in literal order with ints\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        2 -> \"2\"\n        0 -> \"0\"\n        4 -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0 -> \"0\"\n        2 -> \"2\"\n        4 -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"not in literal order with hex ints\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0x2 -> \"2\"\n        0x0 -> \"0\"\n        0xF -> \"F\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0x0 -> \"0\"\n        0x2 -> \"2\"\n        0xF -> \"F\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"not in literal order with floats\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Float -> String\ntoString f =\n    case f of\n        2.3 -> \"2\"\n        0.0 -> \"0\"\n        4.0 -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Float -> String\ntoString f =\n    case f of\n        0.0 -> \"0\"\n        2.3 -> \"2\"\n        4.0 -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"not in literal order with Strings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : String -> Char\ntoString s =\n    case s of\n        \"A\" -> 'A'\n        \"C\" -> 'C'\n        \"B\" -> 'B'\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : String -> Char\ntoString s =\n    case s of\n        \"A\" -> 'A'\n        \"B\" -> 'B'\n        \"C\" -> 'C'\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"not in literal order with Chars\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Char -> String\ntoString c =\n    case c of\n        'A' -> \"A\"\n        'C' -> \"C\"\n        'B' -> \"B\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Char -> String\ntoString c =\n    case c of\n        'A' -> \"A\"\n        'B' -> \"B\"\n        'C' -> \"C\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"not in literal order in combination with other types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 2) -> \"0\"\n        (Foo, 0) -> \"0\"\n        (Bar, 2) -> \"2\"\n        (Baz, 2) -> \"2\"\n        (_, 4) -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> \"0\"\n        (Foo, 2) -> \"0\"\n        (Bar, 2) -> \"2\"\n        (Baz, 2) -> \"2\"\n        (_, 4) -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        , test \"in literal order in combination with other types and not sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> \"0\"\n        (Baz, 2) -> \"2\"\n        (Bar, 2) -> \"2\"\n        (_, 4) -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> \"0\"\n        (Bar, 2) -> \"2\"\n        (Baz, 2) -> \"2\"\n        (_, 4) -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":657},"ch":{"bb":1,"bp":598}},"b":"failsOnWhitelist : Test\nfailsOnWhitelist =\n    describe \"on whitelist\"\n        [ test \"not sorted\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with qualified names\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> \"Baz\"\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with qualified names disambiguating\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Baz -> \"Baz\"\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"C\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with disambiguation by import\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"B\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"C\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with local name\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"B\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with sub module\" <|\n            \\() ->\n                [ \"\"\"module A.C.Internal exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A.C.Internal as X\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        X.Baz -> \"Baz\"\n        X.Foo -> \"Foo\"\n        X.Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A.C.Internal\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectErrorsForModules\n                        [ ( \"B\"\n                          , [ unsortedError\n                                |> Review.Test.whenFixed \"\"\"module B exposing (..)\n\nimport A.C.Internal as X\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        X.Baz -> \"Baz\"\n        X.Bar -> \"Bar\"\n        X.Foo -> \"Foo\"\n\"\"\"\n                            ]\n                          )\n                        ]\n        , test \"with import name\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (False, Bar) -> \"Bar\"\n        (False, Foo) -> \"Foo\"\n        (True, Foo) -> \"Foo\"\n        (False, Baz) -> \"Baz\"\n        _ -> \"Rest\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortOnlyMatchingTypes\n                                (\\m t ->\n                                    case ( m, t ) of\n                                        ( \"A\", \"Custom\" ) ->\n                                            True\n\n                                        ( \"Basics\", \"Bool\" ) ->\n                                            True\n\n                                        _ ->\n                                            False\n                                )\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (True, Foo) -> \"Foo\"\n        (False, Foo) -> \"Foo\"\n        (False, Bar) -> \"Bar\"\n        (False, Baz) -> \"Baz\"\n        _ -> \"Rest\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":715},"ch":{"bb":1,"bp":660}},"b":"failsSubpatterns : Test\nfailsSubpatterns =\n    describe \"with subpatterns\"\n        [ test \"not sorted at first level\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Nothing -> \"Nothing\"\n        Just Foo -> \"Foo\"\n        Just Bar -> \"Bar\"\n        Just Baz -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortTypesFromDependenciesAlphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> \"Foo\"\n        Just Bar -> \"Bar\"\n        Just Baz -> \"Baz\"\n        Nothing -> \"Nothing\"\n\"\"\"\n                        ]\n        , test \"not sorted at lower level\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Bar -> \"Bar\"\n        Just Foo -> \"Foo\"\n        Just Baz -> \"Baz\"\n        Nothing -> \"Nothing\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortTypesFromDependenciesAlphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> \"Foo\"\n        Just Bar -> \"Bar\"\n        Just Baz -> \"Baz\"\n        Nothing -> \"Nothing\"\n\"\"\"\n                        ]\n        , test \"with non-sortable patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Bar 2 1 -> \"Bar\"\n        Container Foo 1 2 -> \"Foo\"\n        Container Baz 2 2 -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortLiterals\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Foo 1 2 -> \"Foo\"\n        Container Bar 2 1 -> \"Bar\"\n        Container Baz 2 2 -> \"Baz\"\n\"\"\"\n                        ]\n        , test \"sorts past non-sortable patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Container = Container Int {field : Bool} Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 {field} Baz 1 -> \"Baz\"\n        Container 1 {field} Foo 1 -> \"Foo\"\n        Container 1 {field} Bar 1 -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortLiterals\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Container = Container Int {field : Bool} Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 {field} Foo 1 -> \"Foo\"\n        Container 1 {field} Bar 1 -> \"Bar\"\n        Container 1 {field} Baz 1 -> \"Baz\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":786},"ch":{"bb":1,"bp":718}},"b":"failsTransparentPatterns : Test\nfailsTransparentPatterns =\n    describe \"with transparent patterns\"\n        [ test \"is not sorted with parenthesized patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        (Baz) -> \"Bar\"\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        (Baz) -> \"Bar\"\n\"\"\"\n                        ]\n        , test \"is not sorted with as pattern\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        (Bar as b) -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        (Bar as b) -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":824},"ch":{"bb":1,"bp":789}},"b":"failsTuples : Test\nfailsTuples =\n    describe \"with tuples\"\n        [ test \"is not sorted at first level\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Bar, A) -> \"BarA\"\n        (Bar, B) -> \"BarB\"\n        (Bar, C) -> \"BarC\"\n        (Foo, A) -> \"FooA\"\n        (Foo, B) -> \"FooB\"\n        (Foo, C) -> \"FooC\"\n        (Baz, A) -> \"BazA\"\n        (Baz, B) -> \"BazB\"\n        (Baz, C) -> \"BazC\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> \"FooA\"\n        (Foo, B) -> \"FooB\"\n        (Foo, C) -> \"FooC\"\n        (Bar, A) -> \"BarA\"\n        (Bar, B) -> \"BarB\"\n        (Bar, C) -> \"BarC\"\n        (Baz, A) -> \"BazA\"\n        (Baz, B) -> \"BazB\"\n        (Baz, C) -> \"BazC\"\n\"\"\"\n                        ]\n        , test \"is not sorted at second level\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> \"FooA\"\n        (Foo, C) -> \"FooC\"\n        (Foo, B) -> \"FooB\"\n        (Bar, A) -> \"BarA\"\n        (Bar, B) -> \"BarB\"\n        (Bar, C) -> \"BarC\"\n        (Baz, A) -> \"BazA\"\n        (Baz, B) -> \"BazB\"\n        (Baz, C) -> \"BazC\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> \"FooA\"\n        (Foo, B) -> \"FooB\"\n        (Foo, C) -> \"FooC\"\n        (Bar, A) -> \"BarA\"\n        (Bar, B) -> \"BarB\"\n        (Bar, C) -> \"BarC\"\n        (Baz, A) -> \"BazA\"\n        (Baz, B) -> \"BazB\"\n        (Baz, C) -> \"BazC\"\n\"\"\"\n                        ]\n        , test \"is not sorted with threeples at third level\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> \"FooAFoo\"\n        (Foo, A, Bar) -> \"FooABar\"\n        (Foo, A, Baz) -> \"FooABaz\"\n        (Foo, B, Foo) -> \"FooBFoo\"\n        (Foo, B, Baz) -> \"FooBBaz\"\n        (Foo, B, Bar) -> \"FooBBar\"\n        (Foo, C, Foo) -> \"FooCFoo\"\n        (Foo, C, Bar) -> \"FooCBar\"\n        (Foo, C, Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> \"FooAFoo\"\n        (Foo, A, Bar) -> \"FooABar\"\n        (Foo, A, Baz) -> \"FooABaz\"\n        (Foo, B, Foo) -> \"FooBFoo\"\n        (Foo, B, Bar) -> \"FooBBar\"\n        (Foo, B, Baz) -> \"FooBBaz\"\n        (Foo, C, Foo) -> \"FooCFoo\"\n        (Foo, C, Bar) -> \"FooCBar\"\n        (Foo, C, Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"is not sorted with nested tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> \"FooAFoo\"\n        ((Foo, A), Bar) -> \"FooABar\"\n        ((Foo, A), Baz) -> \"FooABaz\"\n        ((Foo, B), Foo) -> \"FooBFoo\"\n        ((Foo, C), Foo) -> \"FooCFoo\"\n        ((Foo, B), Bar) -> \"FooBBar\"\n        ((Foo, B), Baz) -> \"FooBBaz\"\n        ((Foo, C), Bar) -> \"FooCBar\"\n        ((Foo, C), Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> \"FooAFoo\"\n        ((Foo, A), Bar) -> \"FooABar\"\n        ((Foo, A), Baz) -> \"FooABaz\"\n        ((Foo, B), Foo) -> \"FooBFoo\"\n        ((Foo, B), Bar) -> \"FooBBar\"\n        ((Foo, B), Baz) -> \"FooBBaz\"\n        ((Foo, C), Foo) -> \"FooCFoo\"\n        ((Foo, C), Bar) -> \"FooCBar\"\n        ((Foo, C), Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"is not sorted with deeply nested tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> \"1\"\n        ((Foo, (A, B)), Foo, (A, A)) -> \"2\"\n        ((Foo, (B, A)), Foo, (A, A)) -> \"4\"\n        ((Foo, (A, C)), Foo, (A, A)) -> \"3\"\n        ((Foo, (B, A)), Foo, (A, C)) -> \"5\"\n        ((Foo, (B, A)), Foo, (B, A)) -> \"6\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> \"1\"\n        ((Foo, (A, B)), Foo, (A, A)) -> \"2\"\n        ((Foo, (A, C)), Foo, (A, A)) -> \"3\"\n        ((Foo, (B, A)), Foo, (A, A)) -> \"4\"\n        ((Foo, (B, A)), Foo, (A, C)) -> \"5\"\n        ((Foo, (B, A)), Foo, (B, A)) -> \"6\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":880},"ch":{"bb":1,"bp":827}},"b":"failsTypesFromDependencies : Test\nfailsTypesFromDependencies =\n    describe \"with types from dependencies\"\n        [ test \"in alphabetical order with declaration sorting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> \"False\"\n        True -> \"True\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> \"True\"\n        False -> \"False\"\n\"\"\"\n                        ]\n        , test \"in declaration order with alphabetical sorting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> \"True\"\n        False -> \"False\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortTypesFromDependenciesAlphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> \"False\"\n        True -> \"True\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":949},"ch":{"bb":1,"bp":883}},"b":"failsUncons : Test\nfailsUncons =\n    describe \"with uncons\"\n        [ test \"is not sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> \"Foo\"\n        Baz :: _ -> \"Baz\"\n        Bar :: _ -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> \"Foo\"\n        Bar :: _ -> \"Bar\"\n        Baz :: _ -> \"Baz\"\n\"\"\"\n                        ]\n        , test \"is not sorted including tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Bar, 1) :: (Bar, 2) :: _ -> \"Bar\"\n        (Foo, 1) :: (Foo, 2) :: _ -> \"Foo\"\n        (Baz, 1) :: (Baz, 2) :: _ -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Foo, 1) :: (Foo, 2) :: _ -> \"Foo\"\n        (Bar, 1) :: (Bar, 2) :: _ -> \"Bar\"\n        (Baz, 1) :: (Baz, 2) :: _ -> \"Baz\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1108},"ch":{"bb":1,"bp":952}},"b":"failsWildcards : Test\nfailsWildcards =\n    describe \"with wildcards\"\n        [ test \"is not sorted with all pattern at end\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        _ -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n        _ -> \"Bar\"\n\"\"\"\n                        ]\n        , test \"is not sorted with var pattern at end\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        bar -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n        bar -> \"Bar\"\n\"\"\"\n                        ]\n        , test \"sorts past wildcards where possible with tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, B) -> \"B\"\n        (_, A) -> \"A\"\n        (Bar, _) -> \"BarNotBOrA\"\n        (Foo, _) -> \"FooNotBOrA\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, A) -> \"A\"\n        (_, B) -> \"B\"\n        (Foo, _) -> \"FooNotBOrA\"\n        (Bar, _) -> \"BarNotBOrA\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"sorts past wildcards where possible with lists\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Bar] -> \"_Bar\"\n        [_, Foo] -> \"_Foo\"\n        [Bar, _] -> \"Bar_\"\n        [Foo, _] -> \"Foo_\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Foo] -> \"_Foo\"\n        [_, Bar] -> \"_Bar\"\n        [Foo, _] -> \"Foo_\"\n        [Bar, _] -> \"Bar_\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        , test \"sorts past wildcards where possible with uncons\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Bar :: _ -> \"_Bar_\"\n        _ :: Foo :: _ -> \"_Foo_\"\n        Bar :: _ -> \"Bar_\"\n        Foo :: _ -> \"Foo_\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Foo :: _ -> \"_Foo_\"\n        _ :: Bar :: _ -> \"_Bar_\"\n        Foo :: _ -> \"Foo_\"\n        Bar :: _ -> \"Bar_\"\n        _ -> \"Too many...\"\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1181},"ch":{"bb":1,"bp":1111}},"b":"fixesProperly : Test\nfixesProperly =\n    describe \"automatic fixes\"\n        [ test \"preserve comments\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    -- A block of patterns\n    case custom of\n        Bar ->\n            -- Bar\n            \"Bar\"\n\n        Baz ->\n            -- Baz\n            \"Baz\"\n\n        Foo ->\n            -- Foo\n            \"Foo\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    -- A block of patterns\n    case custom of\n        Foo ->\n            -- Foo\n            \"Foo\"\n\n        Bar ->\n            -- Bar\n            \"Bar\"\n\n        Baz ->\n            -- Baz\n            \"Baz\"\n\"\"\"\n                        ]\n        , test \"work with multiline expression/patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String -> String\ntoString custom string =\n    -- A multiline expression\n    case\n        ( custom\n        , string\n        )\n    of\n        ( Bar, \"A pattern\" ) ->\n            -- Bar\n            \"Bar\"\n\n        ( Baz, foo ) ->\n            -- Baz\n            \"Baz\"\n\n        ( Foo, _ ) ->\n            -- Foo\n            toString\n                |> toPipeline\n                |> andSuch\n\n        _ ->\n            \\\"\\\"\\\"Multiline\n        string\n        expression?\\\"\\\"\\\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String -> String\ntoString custom string =\n    -- A multiline expression\n    case\n        ( custom\n        , string\n        )\n    of\n        ( Foo, _ ) ->\n            -- Foo\n            toString\n                |> toPipeline\n                |> andSuch\n\n        ( Bar, \"A pattern\" ) ->\n            -- Bar\n            \"Bar\"\n\n        ( Baz, foo ) ->\n            -- Baz\n            \"Baz\"\n\n        _ ->\n            \\\"\\\"\\\"Multiline\n        string\n        expression?\\\"\\\"\\\"\n\"\"\"\n                        ]\n        , test \"do not mangle syntax in complex cases\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\ntype A = B | C | D\nfoo bar =\n    let\n        thing =\n            case bar of\n                B ->\n                    \\\\a b ->\n                        case ( Nothing, Nothing ) of\n                            ( Just a_, Just b_ ) ->\n                                GT\n                            ( Just _, Nothing ) ->\n                                LT\n                            ( Nothing, Just _ ) ->\n                                GT\n                            ( Nothing, Nothing ) ->\n                                LT\n                D ->\n                    \\\\a b -> GT\n                C ->\n                    \\\\a b -> GT\n    in\n    thing\n        \"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.atExactly { start = { row = 6, column = 13 }, end = { row = 6, column = 17 } }\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\ntype A = B | C | D\nfoo bar =\n    let\n        thing =\n            case bar of\n                B ->\n                    \\\\a b ->\n                        case ( Nothing, Nothing ) of\n                            ( Just a_, Just b_ ) ->\n                                GT\n                            ( Just _, Nothing ) ->\n                                LT\n                            ( Nothing, Just _ ) ->\n                                GT\n                            ( Nothing, Nothing ) ->\n                                LT\n                C ->\n                    \\\\a b -> GT\n                D ->\n                    \\\\a b -> GT\n    in\n    thing\n        \"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1356},"ch":{"bb":1,"bp":1184}},"b":"matchesName : ( String, String ) -> String -> String -> Bool\nmatchesName ( expM, expT ) m t =\n    m == expM && t == expT"},{"$":1,"a":{"bV":{"bb":10,"bp":1562},"ch":{"bb":1,"bp":1359}},"b":"passes : Test\npasses =\n    describe \"does not report an error when\"\n        [ test \"case is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , passesCrossModule\n        , passesWildcards\n        , passesTransparentPatterns\n        , passesTuples\n        , passesLists\n        , passesUncons\n        , passesLiterals\n        , passesTypesFromDependencies\n        , passesSubpatterns\n        , passesNotOnWhitelist\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1726},"ch":{"bb":1,"bp":1565}},"b":"passesCrossModule : Test\npassesCrossModule =\n    describe \"case is defined in another module\"\n        [ test \"and is sorted\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"but type is not exported (this is a compile error, just for checking context management)\" <|\n            \\() ->\n                [ \"\"\"module A exposing (Custom)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"with qualified names\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"with qualified names disambiguating\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Foo -> \"Foo\"\n        A.Bar -> \"Bar\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"with disambiguation by import\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"with local name\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1790},"ch":{"bb":1,"bp":1729}},"b":"passesLists : Test\npassesLists =\n    describe \"with lists\"\n        [ passesListsLengthFirst\n        , passesListsElementwise\n        , passesUncons\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2021},"ch":{"bb":1,"bp":1793}},"b":"passesListsElementwise : Test\npassesListsElementwise =\n    describe \"sorted elementwise\"\n        [ test \"is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"is sorted with mixed list/uncons\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        Foo :: Foo :: [] -> \"FooFoo\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        Foo :: _ -> \"Foo+\"\n        [Bar] -> \"Bar\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        [Bar, Baz] -> \"BarBaz\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Bar :: _ -> \"Bar+\"\n        [Baz] -> \"Baz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2029},"ch":{"bb":1,"bp":2024}},"b":"passesListsLengthFirst : Test\npassesListsLengthFirst =\n    describe \"sorted length-first\"\n        [ test \"and is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        [Foo] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Foo, Foo] -> \"FooFoo\"\n        [Foo, Bar] -> \"FooBar\"\n        [Foo, Baz] -> \"FooBaz\"\n        [Bar, Foo] -> \"BarFoo\"\n        [Bar, Bar] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        [Foo, Foo, Foo] -> \"FooFooFoo\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortListPatternsByLength\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is sorted with mixed list/uncons\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        [] -> \"\"\n        Foo :: [] -> \"Foo\"\n        [Bar] -> \"Bar\"\n        [Baz] -> \"Baz\"\n        [Bar, Foo] -> \"BarFoo\"\n        Bar :: Bar :: [] -> \"BarBar\"\n        [Bar, Baz] -> \"BarBaz\"\n        Bar :: Bar :: _ -> \"BarBar+\"\n        Bar :: _ :: _ -> \"Bar++\"\n        Foo :: _ -> \"Foo+\"\n        Bar :: _ -> \"Bar+\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortListPatternsByLength\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2195},"ch":{"bb":1,"bp":2032}},"b":"passesLiterals : Test\npassesLiterals =\n    describe \"with literals\"\n        [ test \"in literal order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Int -> String\ntoString i =\n    case i of\n        0 -> \"0\"\n        2 -> \"2\"\n        4 -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"in literal order in combination with other types\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> Int -> String\ntoString c i =\n    case (c, i) of\n        (Foo, 0) -> \"0\"\n        (Bar, 0) -> \"0\"\n        (Bar, 2) -> \"2\"\n        (Baz, 2) -> \"2\"\n        (_, 4) -> \"4\"\n        _ -> \"Something else...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2341},"ch":{"bb":1,"bp":2198}},"b":"passesNotOnWhitelist : Test\npassesNotOnWhitelist =\n    describe \"not on whitelist\"\n        [ test \"not sorted\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Baz -> \"Baz\"\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"B\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with qualified names\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> \"Bar\"\n        A.Foo -> \"Foo\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"B\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with qualified names disambiguating\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        A.Bar -> \"Bar\"\n        A.Foo -> \"Foo\"\n        A.Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"B\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with disambiguation by import\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\"\"\"\n                , \"\"\"module B exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module C exposing (..)\n\nimport A\nimport B exposing (Custom(..))\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with local name\" <|\n            \\() ->\n                [ \"\"\"module A exposing (..)\n\ntype Custom = Baz | Bar | Foo\n\"\"\"\n                , \"\"\"module B exposing (..)\n\nimport A\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Bar -> \"Bar\"\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n\"\"\"\n                ]\n                    |> Review.Test.runOnModules\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with import name\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Bool -> Custom -> String\ntoString b custom =\n    case (b, custom) of\n        (False, Bar) -> \"Bar\"\n        (False, Foo) -> \"Foo\"\n        (True, Foo) -> \"Foo\"\n        (False, Baz) -> \"Baz\"\n        _ -> \"Rest\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortOnlyMatchingTypes (matchesName ( \"A\", \"Custom\" ))\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2403},"ch":{"bb":1,"bp":2344}},"b":"passesSubpatterns : Test\npassesSubpatterns =\n    describe \"with subpatterns\"\n        [ test \"is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Maybe Custom -> String\ntoString custom =\n    case custom of\n        Just Foo -> \"Foo\"\n        Just Bar -> \"Bar\"\n        Just Baz -> \"Baz\"\n        Nothing -> \"Nothing\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortTypesFromDependenciesAlphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"with non-sortable patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Container = Container Custom Int Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container Foo 1 2 -> \"Foo\"\n        Container Bar 2 1 -> \"Bar\"\n        Container Baz 2 2 -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortLiterals\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"does not sort past non-sortable patterns when specified\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Container = Container Int Custom Int\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Container -> String\ntoString c =\n    case c of\n        Container 1 Baz 1 -> \"Baz\"\n        Container 1 Foo 1 -> \"Foo\"\n        Container 1 Bar 1 -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortLiterals\n                            |> doNotLookPastUnsortable\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2605},"ch":{"bb":1,"bp":2406}},"b":"passesTransparentPatterns : Test\npassesTransparentPatterns =\n    describe \"with transparent patterns\"\n        [ test \"and is sorted with parenthesized patterns\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Bar -> \"Bar\"\n        (Baz) -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"and is sorted with as pattern\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        (Bar as b) -> \"Bar\"\n        Baz -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2659},"ch":{"bb":1,"bp":2608}},"b":"passesTuples : Test\npassesTuples =\n    describe \"with tuples\"\n        [ test \"and is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (Foo, A) -> \"FooA\"\n        (Foo, B) -> \"FooB\"\n        (Foo, C) -> \"FooC\"\n        (Bar, A) -> \"BarA\"\n        (Bar, B) -> \"BarB\"\n        (Bar, C) -> \"BarC\"\n        (Baz, A) -> \"BazA\"\n        (Baz, B) -> \"BazB\"\n        (Baz, C) -> \"BazC\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"and is sorted with threeples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case (custom1, custom2, custom3) of\n        (Foo, A, Foo) -> \"FooAFoo\"\n        (Foo, A, Bar) -> \"FooABar\"\n        (Foo, A, Baz) -> \"FooABaz\"\n        (Foo, B, Foo) -> \"FooBFoo\"\n        (Foo, B, Bar) -> \"FooBBar\"\n        (Foo, B, Baz) -> \"FooBBaz\"\n        (Foo, C, Foo) -> \"FooCFoo\"\n        (Foo, C, Bar) -> \"FooCBar\"\n        (Foo, C, Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"and is sorted with nested tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, custom2), custom3) of\n        ((Foo, A), Foo) -> \"FooAFoo\"\n        ((Foo, A), Bar) -> \"FooABar\"\n        ((Foo, A), Baz) -> \"FooABaz\"\n        ((Foo, B), Foo) -> \"FooBFoo\"\n        ((Foo, B), Bar) -> \"FooBBar\"\n        ((Foo, B), Baz) -> \"FooBBaz\"\n        ((Foo, C), Foo) -> \"FooCFoo\"\n        ((Foo, C), Bar) -> \"FooCBar\"\n        ((Foo, C), Baz) -> \"FooCBaz\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"and is sorted with deeply nested tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> Custom1 -> String\ntoString custom1 custom2 custom3 =\n    case ((custom1, (custom2, custom2)), custom3, (custom2, custom2)) of\n        ((Foo, (A, A)), Foo, (A, A)) -> \"1\"\n        ((Foo, (A, B)), Foo, (A, A)) -> \"2\"\n        ((Foo, (A, C)), Foo, (A, A)) -> \"3\"\n        ((Foo, (B, A)), Foo, (A, A)) -> \"4\"\n        ((Foo, (B, A)), Foo, (A, C)) -> \"5\"\n        ((Foo, (B, A)), Foo, (B, A)) -> \"6\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"preserves order when moving wildcards would create compile errors\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Thing\n    = Thing Int Int\n    | OtherThing\n\ntoInt : Thing -> Result a -> Int\ntoInt foo bar =\n    case ( foo, bar) of\n        ( Thing _ _, _ ) ->\n            1\n        ( _, Ok _ ) ->\n            2\n        ( _, Err _ ) ->\n           3\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2805},"ch":{"bb":1,"bp":2662}},"b":"passesTypesFromDependencies : Test\npassesTypesFromDependencies =\n    describe \"with types from dependencies\"\n        [ test \"is sorted in declaration order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        True -> \"True\"\n        False -> \"False\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"is sorted in alphabetical order\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> \"False\"\n        True -> \"True\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> sortTypesFromDependenciesAlphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"in any order when not sorting\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntoString : Bool -> String\ntoString b =\n    case b of\n        False -> \"False\"\n        True -> \"True\"\n\ntoString2 : Bool -> String\ntoString2 b =\n    case b of\n        True -> \"True\"\n        False -> \"False\"\n\"\"\"\n                    |> Review.Test.run\n                        (defaults\n                            |> doNotSortTypesFromDependencies\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":3118},"ch":{"bb":1,"bp":2808}},"b":"passesUncons : Test\npassesUncons =\n    describe \"with uncons\"\n        [ test \"is sorted\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString xs =\n    case xs of\n        Foo :: _ -> \"Foo\"\n        Bar :: _ -> \"Bar\"\n        Baz :: _ -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"is sorted including tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List (Custom, Int) -> String\ntoString xs =\n    case xs of\n        (Foo, 1) :: (Foo, 2) :: _ -> \"Foo\"\n        (Bar, 1) :: (Bar, 2) :: _ -> \"Bar\"\n        (Baz, 1) :: (Baz, 2) :: _ -> \"Baz\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"preserves order when mixed with lists when matches could be equally short in simple case\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\nfoo : List String -> String\nfoo list =\n    case list of\n        [] ->\n            \"\"\n        [ last ] ->\n            last\n        second :: rest ->\n            second ++ rest\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"preserves order when mixed with lists when matches could be equally short in complex case\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Nonempty a\n    = Nonempty a (List a)\n\nfoo : String -> Nonempty String -> String\nfoo fn list =\n    case list of\n        Nonempty first [] ->\n            first\n        Nonempty first [ last ] ->\n            first ++ \" \" ++ fn ++ \" \" ++ last\n        Nonempty first (second :: rest) ->\n            first ++ \", \" ++ foo fn (Nonempty second rest)\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":27,"bp":3123},"ch":{"bb":1,"bp":3121}},"b":"passesWildcards : Test\npassesWildcards =\n    describe \"with wildcards\"\n        [ test \"and is sorted order with all pattern at end\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n        _ -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"and is sorted with var pattern at end\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : Custom -> String\ntoString custom =\n    case custom of\n        Foo -> \"Foo\"\n        Baz -> \"Baz\"\n        bar -> \"Bar\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"preserves control flow when sorting would destroy it with tuples\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom1 = Foo | Bar | Baz\n\ntype Custom2 = A | B | C\n\ntoString : Custom1 -> Custom2 -> String\ntoString custom1 custom2 =\n    case (custom1, custom2) of\n        (_, A) -> \"A\"\n        (Foo, _) -> \"FooNotA\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"control flow is not mangled by transitive assumption\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype T\n    = A\n    | B\n    | C String\n    | D Int\n\nfoo t1 t2=\n    case ( t1, t2 ) of\n        ( A, _ ) ->\n            Just A\n\n        ( _, A ) ->\n            Just A\n\n        ( _, C s ) ->\n            Just (C s)\n\n        ( C s, _ ) ->\n            Just (C s)\n\n        ( B, _ ) ->\n            Just B\n\n        ( _, B ) ->\n            Just B\n\n        ( D _, D i ) ->\n            Just (D i)\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectErrors\n                        [ unsortedError\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\ntype T\n    = A\n    | B\n    | C String\n    | D Int\n\nfoo t1 t2=\n    case ( t1, t2 ) of\n        ( A, _ ) ->\n            Just A\n\n        ( _, A ) ->\n            Just A\n\n        ( _, C s ) ->\n            Just (C s)\n\n        ( B, _ ) ->\n            Just B\n\n        ( C s, _ ) ->\n            Just (C s)\n\n        ( _, B ) ->\n            Just B\n\n        ( D _, D i ) ->\n            Just (D i)\n\"\"\"\n                        ]\n        , test \"preserves control flow when sorting would destroy it with lists\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        [_, Foo] -> \"_Foo\"\n        [Foo, _] -> \"Foo_\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        , test \"preserves control flow when sorting would destroy it with uncons\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\ntype Custom = Foo | Bar | Baz\n\ntoString : List Custom -> String\ntoString cs =\n    case cs of\n        _ :: Foo :: _ -> \"_Foo_\"\n        Foo :: _ -> \"Foo_\"\n        _ -> \"Too many...\"\n\"\"\"\n                    |> Review.Test.run (rule defaults)\n                    |> Review.Test.expectNoErrors\n        ]"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedTopLevelDeclarationsTest.elm","c":{"bT":3507466519,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Top-level declarations were found out of order.  They should be sorted as specified in the rule configuration."]},"fP":"tests/NoUnsortedTopLevelDeclarationsTest.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":10,"bp":61},"ch":{"bb":1,"bp":35}},"b":"alphabeticallyTests : Test\nalphabeticallyTests =\n    describe \"alphabetically\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nbar =\n    x\nbaz =\n    y\nfoo =\n    z\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unordered\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n{-| A\n-}\n\n{-| foo\n-}\nfoo =\n    z\n\n{-| bar\n-}\nbar =\n    x\n\n{-| baz\n-}\nbaz =\n    y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n{-| A\n-}\n\n{-| bar\n-}\nbar =\n    x\n\n{-| baz\n-}\nbaz =\n    y\n\n{-| foo\n-}\nfoo =\n    z\n\"\"\"\n                        ]\n        , test \"passes when ordered with types and aliases\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\ntype A\n    = A\n\na =\n    foo\n\nb =\n    bar\n\nz =\n    zed\n\ntype alias Z =\n    A\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unordered with types and aliases\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\n\n{-| This is fine in this order too.\n-}\ntype Bar = Bar\n\nbar =\n    x\n\n{-| This isn't!\n-}\ntype alias Zed = {}\n{-| foo\n-}\nfoo =\n    z\nbaz =\n    y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing (..)\n\n{-| This is fine in this order too.\n-}\ntype Bar = Bar\n\nbar =\n    x\n\nbaz =\n    y\n{-| foo\n-}\nfoo =\n    z\n{-| This isn't!\n-}\ntype alias Zed = {}\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":74},"ch":{"bb":1,"bp":64}},"b":"docCommentDetectionTests : Test\ndocCommentDetectionTests =\n    describe \"correctly attaches doc comments\"\n        [ test \"when before imports\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-| before import\n-}\n\nimport Dict\n\nport z : () -> Int\n\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\n{-| before import\n-}\n\nimport Dict\n\na = 1\n\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"when after imports\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\nimport Dict\n\n{-| after import\n-}\nport z : () -> Int\n\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\nimport Dict\n\na = 1\n\n{-| after import\n-}\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"no import, but two before\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\nport z : () -> Int\n\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\n{-| doc1\n-}\n\na = 1\n\n{-| doc2\n-}\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"no import, but parsed doc commment\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\na = 1\n\nport z : () -> Int\n\nb = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\n{-| doc1\n-}\n\n{-| doc2\n-}\na = 1\n\nb = 1\n\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"no import, but @docs in comment\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-|\n\n## Expose\n\n@docs a, b\n\n-}\n\nport z : () -> Int\n\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\n{-|\n\n## Expose\n\n@docs a, b\n\n-}\n\na = 1\n\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"no import, no @docs in comment, so assume it's for port\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-| nothing\n-}\nport z : () -> Int\n\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\na = 1\n\n{-| nothing\n-}\nport z : () -> Int\n\"\"\"\n                        ]\n        , test \"multiple ports etc\" <|\n            \\() ->\n                \"\"\"port module A exposing (..)\n\n{-| module\n-}\n\n{-| z\n-}\nport z : () -> Int\n\n{-| G\n-}\ntype G = G\n\n{-| b\n-}\nb = 1\n\nport s : () -> Int\n\n{-| f\n-}\nport f : () -> Int\n\n{-| a\n-}\na = 1\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed\n                                \"\"\"port module A exposing (..)\n\n{-| module\n-}\n\n{-| a\n-}\na = 1\n\n{-| b\n-}\nb = 1\n\n{-| f\n-}\nport f : () -> Int\n\n{-| G\n-}\ntype G = G\n\nport s : () -> Int\n\n{-| z\n-}\nport z : () -> Int\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":216},"ch":{"bb":1,"bp":77}},"b":"exposedOrderWithPrivateFirstTests : Test\nexposedOrderWithPrivateFirstTests =\n    describe \"exposedOrderWithPrivateFirst\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\nz =\n    zed\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unsorted\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateFirst\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nb =\n    bar\n\nz =\n    zed\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":497},"ch":{"bb":1,"bp":393}},"b":"glueDependenciesAfterFirstDependentTests : Test\nglueDependenciesAfterFirstDependentTests =\n    describe \"glueDependenciesAfterFirstDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\nhelp =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\nhelp =\n    foo x\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\nz =\n    zed help y\n\ny =\n    help\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":618},"ch":{"bb":1,"bp":500}},"b":"glueDependenciesAfterLastDependentTests : Test\nglueDependenciesAfterLastDependentTests =\n    describe \"glueDependenciesAfterLastDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\nhelp =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesAfterLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\nz =\n    zed help y\n\nhelp =\n    foo x\n\ny =\n    help\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":733},"ch":{"bb":1,"bp":621}},"b":"glueDependenciesBeforeFirstDependentTests : Test\nglueDependenciesBeforeFirstDependentTests =\n    describe \"glueDependenciesBeforeFirstDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is not a dependency if in exactly one func\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nhelp =\n    foo\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help x\n\nx =\n    y\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeFirstDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":850},"ch":{"bb":1,"bp":736}},"b":"glueDependenciesBeforeLastDependentTests : Test\nglueDependenciesBeforeLastDependentTests =\n    describe \"glueDependenciesBeforeLastDependent\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nhelp =\n    foo\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport help : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nb =\n    bar help\n\nz =\n    zed help\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered and removes cycles\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\nhelp =\n    foo x\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueDependenciesBeforeLastDependent\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed\n                                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo help\n\ntype alias Z =\n    A\n\nx =\n    y\n\nb =\n    bar help x\n\nhelp =\n    foo x\n\ny =\n    help\n\nz =\n    zed help y\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":967},"ch":{"bb":1,"bp":853}},"b":"glueHelpersAfterTests : Test\nglueHelpersAfterTests =\n    describe \"glueHelpersAfter\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    foo\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not helpers\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport calledInB : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n\ndalledInB =\n    foo\n\ncalledInB =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\ncalledInB =\n    foo\n\ndalledInB =\n    foo\n\nz =\n    zed\n\"\"\"\n                        ]\n        , test \"chains properly and ignores mutual dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nmutualDep3 =\n    mutualDep1\n\nb =\n    bar calledInB\n\nmutualDep2 =\n    bar mutualDep3\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nz =\n    zed\n\ncalledInB =\n    calledInBHelp foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    calledInBHelp foo\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nmutualDep2 =\n    bar mutualDep3\n\nmutualDep3 =\n    mutualDep1\n\nz =\n    zed\n\"\"\"\n                        ]\n        , test \"handles mutual recursion when one is not viable for gluing\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\ntype alias Z =\n    A\n\naHelp =\n    a\n\nb =\n    bar\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersAfter\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\naHelp =\n    a\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":979},"ch":{"bb":1,"bp":970}},"b":"glueHelpersBeforeTests : Test\nglueHelpersBeforeTests =\n    describe \"glueHelpersBefore\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    foo\n\nb =\n    bar calledInB\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"ports are not helpers\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\nport calledInB : String -> Cmd msg\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"is not helper if used in multiple funcs\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo calledInB\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB\n\ncalledInB =\n    foo\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"does not glue to self\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    calledInB\n\nb =\n    bar calledInB\n\nz =\n    z\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when not ordered\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n\ndalledInB =\n    foo\n\ncalledInB =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInB =\n    foo\n\ndalledInB =\n    foo\n\nb =\n    bar calledInB dalledInB\n\nz =\n    zed\n\"\"\"\n                        ]\n        , test \"chains properly and ignores mutual dependencies\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\nmutualDep3 =\n    mutualDep1\n\nb =\n    bar calledInB\n\nmutualDep2 =\n    bar mutualDep3\n\ncalledInBHelp =\n    bar\n\nmutualDep1 =\n    mutualDep2\n\nz =\n    zed\n\ncalledInB =\n    calledInBHelp foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    foo\n\ntype alias Z =\n    A\n\ncalledInBHelp =\n    bar\n\ncalledInB =\n    calledInBHelp foo\n\nb =\n    bar calledInB\n\nmutualDep1 =\n    mutualDep2\n\nmutualDep2 =\n    bar mutualDep3\n\nmutualDep3 =\n    mutualDep1\n\nz =\n    zed\n\"\"\"\n                        ]\n        , test \"handles mutual recursion when one is not viable for gluing\" <|\n            \\() ->\n                \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\na =\n    aHelp\n\naHelp =\n    a\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> glueHelpersBefore\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError False\n                            |> Review.Test.whenFixed \"\"\"module A exposing\n    ( A, a\n    , Z\n    )\n\n{-|\n\n@docs A, a\n@docs Z\n\n-}\n\ntype A\n    = A\n\naHelp =\n    a\n\na =\n    aHelp\n\ntype alias Z =\n    A\n\nb =\n    bar\n\nz =\n    zed\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1391},"ch":{"bb":1,"bp":982}},"b":"glues : Test\nglues =\n    describe \"glues\"\n        [ glueHelpersBeforeTests\n        , glueHelpersAfterTests\n        , glueDependenciesBeforeFirstDependentTests\n        , glueDependenciesAfterFirstDependentTests\n        , glueDependenciesBeforeLastDependentTests\n        , glueDependenciesAfterLastDependentTests\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1723},"ch":{"bb":1,"bp":1394}},"b":"orderings : Test\norderings =\n    describe \"orderings\"\n        [ alphabeticallyTests\n        , exposedOrderWithPrivateLastTests\n        , exposedOrderWithPrivateFirstTests\n        , typesFirstTests\n        , typesLastTests\n        , portsFirstTests\n        , portsLastTests\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":1934},"ch":{"bb":1,"bp":1726}},"b":"passes : Test\npasses =\n    describe \"passes when\"\n        [ test \"single declaration\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"no orderings\" <|\n            \\() ->\n                \"\"\"module A exposing (..)\nf =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2105},"ch":{"bb":1,"bp":1937}},"b":"portsFirstTests : Test\nportsFirstTests =\n    describe \"portsFirst\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unsorted\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsFirst\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2276},"ch":{"bb":1,"bp":2108}},"b":"portsLastTests : Test\nportsLastTests =\n    describe \"portsLast\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsLast\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unsorted\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n\ntype alias Z =\n    A\n\na =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> portsLast\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n\nc =\n    bar\n\nport b: String -> Cmd msg\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2447},"ch":{"bb":1,"bp":2279}},"b":"typesFirstTests : Test\ntypesFirstTests =\n    describe \"typesFirst\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n{-| Z\n-}\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\nc =\n    bar\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unsorted\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\ntype A\n    = A\n\nz =\n    zed\n{-| Z\n-}\ntype alias Z =\n    A\n\na =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> typesFirst\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\ntype A\n    = A\n{-| Z\n-}\ntype alias Z =\n    A\n\nz =\n    zed\n\na =\n    foo\n{-| Port doc comment\n-}\nport b: String -> Cmd msg\n\nc =\n    bar\n\"\"\"\n                        ]\n        ]"},{"$":1,"a":{"bV":{"bb":10,"bp":2718},"ch":{"bb":1,"bp":2450}},"b":"typesLastTests : Test\ntypesLastTests =\n    describe \"typesLast\"\n        [ test \"passes when ordered\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nz =\n    zed\n\na =\n    foo\n\nport b: String -> Cmd msg\n\nc =\n    bar\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> typesLast\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectNoErrors\n        , test \"fails when unsorted\" <|\n            \\() ->\n                \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nc =\n    bar\n\ntype A\n    = A\n\nz =\n    zed\n\nport b: String -> Cmd msg\n\ntype alias Z =\n    A\n\na =\n    foo\n\"\"\"\n                    |> Review.Test.run\n                        (sortTopLevelDeclarations\n                            |> typesLast\n                            |> exposedOrderWithPrivateLast\n                            |> alphabetically\n                            |> rule\n                        )\n                    |> Review.Test.expectErrors\n                        [ unsortedError True\n                            |> Review.Test.whenFixed \"\"\"port module A exposing\n    ( A, z\n    , Z\n    )\n\n{-|\n\n@docs A, z\n@docs Z\n\n-}\n\nz =\n    zed\n\na =\n    foo\n\nport b: String -> Cmd msg\n\nc =\n    bar\n\ntype A\n    = A\n\ntype alias Z =\n    A\n\"\"\"\n                        ]\n        ]"}]}},"a3":"Top-level declarations are not sorted.","dh":false,"dX":{"bV":{"bb":7,"bp":1},"ch":{"bb":1,"bp":1}},"dZ":"NoUnsortedTopLevelDeclarations","fe":0}]},"b5":3530670207,"c7":false,"cc":0},"d":{"$":-2},"e":{"$":-2}}}},"dY":{"$":0,"a":{"bT":{"$":0,"a":3715779789},"bd":{"$":0},"b5":3530670207,"cc":0}}}
