{"aR":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Infix"]},"c":{"$":-1,"a":1,"b":"InfixDirection","c":{"fG":{"$":-1,"a":1,"b":"Non","c":0,"d":{"$":-1,"a":1,"b":"Left","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Right","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Left","Right","Non"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","License"]},"c":{"$":-1,"a":1,"b":"License","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Dict"]},"c":{"$":-1,"a":1,"b":"Dict","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Basics"]},"c":{"$":-1,"a":1,"b":"Never","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Float","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Bool","c":{"fG":{"$":-1,"a":1,"b":"True","c":0,"d":{"$":-1,"a":0,"b":"False","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["True","False"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Int","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Order","c":{"fG":{"$":-1,"a":1,"b":"GT","c":0,"d":{"$":-1,"a":1,"b":"EQ","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"LT","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["LT","EQ","GT"]}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Array"]},"c":{"$":-1,"a":1,"b":"Array","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Char"]},"c":{"$":-1,"a":1,"b":"Char","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Docs"]},"c":{"$":-1,"a":1,"b":"Block","c":{"fG":{"$":-1,"a":1,"b":"UnknownBlock","c":0,"d":{"$":-1,"a":0,"b":"MarkdownBlock","c":0,"d":{"$":-1,"a":1,"b":"BinopBlock","c":0,"d":{"$":-1,"a":0,"b":"AliasBlock","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"UnionBlock","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"ValueBlock","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["MarkdownBlock","UnionBlock","AliasBlock","ValueBlock","BinopBlock","UnknownBlock"]}},"d":{"$":-1,"a":0,"b":"Associativity","c":{"fG":{"$":-1,"a":1,"b":"None","c":0,"d":{"$":-1,"a":1,"b":"Left","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Right","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Left","None","Right"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Constraint"]},"c":{"$":-1,"a":1,"b":"Constraint","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Interface"]},"c":{"$":-1,"a":1,"b":"Exposed","c":{"fG":{"$":-1,"a":1,"b":"CustomType","c":0,"d":{"$":-1,"a":1,"b":"Alias","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Operator","c":0,"d":{"$":-1,"a":0,"b":"Function","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["Function","CustomType","Alias","Operator"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Error"]},"c":{"$":-1,"a":1,"b":"Color","c":{"fG":{"$":-1,"a":1,"b":"RED","c":0,"d":{"$":-1,"a":0,"b":"GREEN","c":0,"d":{"$":-1,"a":1,"b":"CYAN","c":0,"d":{"$":-1,"a":0,"b":"Black","c":0,"d":{"$":-1,"a":1,"b":"BLUE","c":0,"d":{"$":-1,"a":0,"b":"BLACK","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Blue","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Cyan","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"MAGENTA","c":0,"d":{"$":-1,"a":1,"b":"Green","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Magenta","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"YELLOW","c":0,"d":{"$":-1,"a":0,"b":"WHITE","c":0,"d":{"$":-1,"a":1,"b":"Red","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"White","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Yellow","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["Red","RED","Magenta","MAGENTA","Yellow","YELLOW","Green","GREEN","Cyan","CYAN","Blue","BLUE","White","WHITE","Black","BLACK"]}},"d":{"$":-1,"a":1,"b":"Chunk","c":{"fG":{"$":-1,"a":1,"b":"Unstyled","c":0,"d":{"$":-1,"a":0,"b":"Styled","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Unstyled","Styled"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Error","c":{"fG":{"$":-1,"a":1,"b":"ModuleProblems","c":0,"d":{"$":-1,"a":0,"b":"GeneralProblem","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["GeneralProblem","ModuleProblems"]}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Project"]},"c":{"$":-1,"a":1,"b":"Project","c":{"fG":{"$":-1,"a":1,"b":"Package","c":0,"d":{"$":-1,"a":0,"b":"Application","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Application","Package"]}},"d":{"$":-1,"a":0,"b":"Exposed","c":{"fG":{"$":-1,"a":1,"b":"ExposedList","c":0,"d":{"$":-1,"a":0,"b":"ExposedDict","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["ExposedList","ExposedDict"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Package"]},"c":{"$":-1,"a":1,"b":"Name","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Module"]},"c":{"$":-1,"a":1,"b":"Name","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Processing"]},"c":{"$":-1,"a":1,"b":"ProcessContext","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Exposing"]},"c":{"$":-1,"a":1,"b":"TopLevelExpose","c":{"fG":{"$":-1,"a":1,"b":"InfixExpose","c":0,"d":{"$":-1,"a":1,"b":"FunctionExpose","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"TypeOrAliasExpose","c":0,"d":{"$":-1,"a":0,"b":"TypeExpose","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["InfixExpose","FunctionExpose","TypeOrAliasExpose","TypeExpose"]}},"d":{"$":-1,"a":0,"b":"Exposing","c":{"fG":{"$":-1,"a":1,"b":"Explicit","c":0,"d":{"$":-1,"a":0,"b":"All","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["All","Explicit"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Declaration"]},"c":{"$":-1,"a":1,"b":"Declaration","c":{"fG":{"$":-1,"a":1,"b":"InfixDeclaration","c":0,"d":{"$":-1,"a":0,"b":"CustomTypeDeclaration","c":0,"d":{"$":-1,"a":1,"b":"AliasDeclaration","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"FunctionDeclaration","c":0,"d":{"$":-1,"a":0,"b":"Destructuring","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"PortDeclaration","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["FunctionDeclaration","AliasDeclaration","CustomTypeDeclaration","PortDeclaration","InfixDeclaration","Destructuring"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Expression"]},"c":{"$":-1,"a":1,"b":"LetDeclaration","c":{"fG":{"$":-1,"a":1,"b":"LetFunction","c":0,"d":{"$":-1,"a":0,"b":"LetDestructuring","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["LetFunction","LetDestructuring"]}},"d":{"$":-1,"a":0,"b":"Expression","c":{"fG":{"$":-1,"a":1,"b":"OperatorApplication","c":0,"d":{"$":-1,"a":1,"b":"Integer","c":0,"d":{"$":-1,"a":0,"b":"FunctionOrValue","c":0,"d":{"$":-1,"a":1,"b":"CharLiteral","c":0,"d":{"$":-1,"a":1,"b":"CaseExpression","c":0,"d":{"$":-1,"a":0,"b":"Application","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Floatable","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Hex","c":0,"d":{"$":-1,"a":1,"b":"GLSLExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"IfBlock","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"Negation","c":0,"d":{"$":-1,"a":0,"b":"LetExpression","c":0,"d":{"$":-1,"a":1,"b":"LambdaExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Literal","c":0,"d":{"$":-1,"a":0,"b":"ListExpr","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Operator","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"RecordAccessFunction","c":0,"d":{"$":-1,"a":1,"b":"PrefixOperator","c":0,"d":{"$":-1,"a":1,"b":"ParenthesizedExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"RecordAccess","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"TupledExpression","c":0,"d":{"$":-1,"a":1,"b":"RecordUpdateExpression","c":0,"d":{"$":-1,"a":0,"b":"RecordExpr","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"UnitExpr","c":0,"d":{"$":-2},"e":{"$":-2}}}}},"cX":{"$":"$L","a":["UnitExpr","Application","OperatorApplication","FunctionOrValue","IfBlock","PrefixOperator","Operator","Integer","Hex","Floatable","Negation","Literal","CharLiteral","TupledExpression","ParenthesizedExpression","LetExpression","CaseExpression","LambdaExpression","RecordExpr","ListExpr","RecordAccess","RecordAccessFunction","RecordUpdateExpression","GLSLExpression"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["List","Extra"]},"c":{"$":-1,"a":1,"b":"Step","c":{"fG":{"$":-1,"a":1,"b":"Stop","c":0,"d":{"$":-1,"a":0,"b":"Continue","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Continue","Stop"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Expect"]},"c":{"$":-1,"a":1,"b":"FloatingPointTolerance","c":{"fG":{"$":-1,"a":1,"b":"AbsoluteOrRelative","c":0,"d":{"$":-1,"a":1,"b":"Absolute","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Relative","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Absolute","Relative","AbsoluteOrRelative"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Type"]},"c":{"$":-1,"a":1,"b":"Type","c":{"fG":{"$":-1,"a":1,"b":"Tuple","c":0,"d":{"$":-1,"a":1,"b":"Record","c":0,"d":{"$":-1,"a":0,"b":"Lambda","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Var","c":0,"d":{"$":-1,"a":0,"b":"Type","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["Var","Lambda","Tuple","Type","Record"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Syntax","Node"]},"c":{"$":-1,"a":1,"b":"Node","c":{"fG":{"$":-1,"a":1,"b":"Node","c":0,"d":{"$":-2},"e":{"$":-2}},"cX":{"$":"$L","a":["Node"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Module"]},"c":{"$":-1,"a":1,"b":"Module","c":{"fG":{"$":-1,"a":1,"b":"NormalModule","c":0,"d":{"$":-1,"a":1,"b":"EffectModule","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"PortModule","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["NormalModule","PortModule","EffectModule"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","TypeAnnotation"]},"c":{"$":-1,"a":1,"b":"TypeAnnotation","c":{"fG":{"$":-1,"a":1,"b":"Record","c":0,"d":{"$":-1,"a":1,"b":"GenericRecord","c":0,"d":{"$":-1,"a":1,"b":"FunctionTypeAnnotation","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"GenericType","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Typed","c":0,"d":{"$":-1,"a":1,"b":"Tupled","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Unit","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["GenericType","Typed","Unit","Tupled","Record","GenericRecord","FunctionTypeAnnotation"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Syntax","Pattern"]},"c":{"$":-1,"a":1,"b":"Pattern","c":{"fG":{"$":-1,"a":1,"b":"StringPattern","c":0,"d":{"$":-1,"a":0,"b":"HexPattern","c":0,"d":{"$":-1,"a":1,"b":"CharPattern","c":0,"d":{"$":-1,"a":1,"b":"AsPattern","c":0,"d":{"$":-1,"a":0,"b":"AllPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"FloatPattern","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"ParenthesizedPattern","c":0,"d":{"$":-1,"a":0,"b":"ListPattern","c":0,"d":{"$":-1,"a":1,"b":"IntPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NamedPattern","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"RecordPattern","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"UnConsPattern","c":0,"d":{"$":-1,"a":1,"b":"TuplePattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"VarPattern","c":0,"d":{"$":-1,"a":0,"b":"UnitPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}},"cX":{"$":"$L","a":["AllPattern","UnitPattern","CharPattern","StringPattern","IntPattern","HexPattern","FloatPattern","TuplePattern","RecordPattern","UnConsPattern","ListPattern","VarPattern","NamedPattern","AsPattern","ParenthesizedPattern"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Version"]},"c":{"$":-1,"a":1,"b":"Version","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph","DOT"]},"c":{"$":-1,"a":1,"b":"Rankdir","c":{"fG":{"$":-1,"a":1,"b":"LR","c":0,"d":{"$":-1,"a":1,"b":"BT","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"TB","c":0,"d":{"$":-1,"a":0,"b":"RL","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["TB","LR","BT","RL"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph"]},"c":{"$":-1,"a":1,"b":"Graph","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"AcyclicGraph","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph","Tree"]},"c":{"$":-1,"a":1,"b":"Tree","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Set"]},"c":{"$":-1,"a":1,"b":"Set","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Platform","Sub"]},"c":{"$":-1,"a":1,"b":"Sub","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Platform"]},"c":{"$":-1,"a":1,"b":"Program","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ProcessId","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Task","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Router","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Maybe"]},"c":{"$":-1,"a":1,"b":"Maybe","c":{"fG":{"$":-1,"a":1,"b":"Nothing","c":0,"d":{"$":-1,"a":0,"b":"Just","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Just","Nothing"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Platform","Cmd"]},"c":{"$":-1,"a":1,"b":"Cmd","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Rule"]},"c":{"$":-1,"a":1,"b":"ModuleRuleSchema","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Error","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Direction","c":{"fG":{"$":-1,"a":1,"b":"OnExit","c":0,"d":{"$":-1,"a":0,"b":"OnEnter","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["OnEnter","OnExit"]}},"d":{"$":-1,"a":1,"b":"ContextCreator","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ElmJsonKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Metadata","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Forbidden","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ModuleKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"Required","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"ProjectRuleSchema","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ProjectData","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ReadmeKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Rule","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Review","Fix"]},"c":{"$":-1,"a":1,"b":"Problem","c":{"fG":{"$":-1,"a":1,"b":"SourceCodeIsNotValid","c":0,"d":{"$":-1,"a":1,"b":"HasCollisionsInFixRanges","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Unchanged","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Unchanged","SourceCodeIsNotValid","HasCollisionsInFixRanges"]}},"d":{"$":-1,"a":0,"b":"FixResult","c":{"fG":{"$":-1,"a":1,"b":"Successful","c":0,"d":{"$":-1,"a":0,"b":"Errored","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Successful","Errored"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Result"]},"c":{"$":-1,"a":1,"b":"Result","c":{"fG":{"$":-1,"a":1,"b":"Ok","c":0,"d":{"$":-1,"a":0,"b":"Err","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Ok","Err"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Project","Dependency"]},"c":{"$":-1,"a":1,"b":"Dependency","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Test"]},"c":{"$":-1,"a":1,"b":"ReviewExpectation","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ExpectedError","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ReviewResult","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Html","Event"]},"c":{"$":-1,"a":1,"b":"Event","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Distribution"]},"c":{"$":-1,"a":1,"b":"DistributionReport","c":{"fG":{"$":-1,"a":1,"b":"DistributionToReport","c":0,"d":{"$":-1,"a":1,"b":"DistributionCheckSucceeded","c":0,"d":{"$":-1,"a":0,"b":"DistributionCheckFailed","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NoDistribution","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["NoDistribution","DistributionToReport","DistributionCheckSucceeded","DistributionCheckFailed"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["String"]},"c":{"$":-1,"a":1,"b":"String","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Runner","Failure"]},"c":{"$":-1,"a":1,"b":"Reason","c":{"fG":{"$":-1,"a":1,"b":"ListDiff","c":0,"d":{"$":-1,"a":0,"b":"Custom","c":0,"d":{"$":-1,"a":1,"b":"Comparison","c":0,"d":{"$":-1,"a":0,"b":"CollectionDiff","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Invalid","c":0,"d":{"$":-1,"a":0,"b":"Equality","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"TODO","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Custom","Equality","Comparison","ListDiff","CollectionDiff","TODO","Invalid"]}},"d":{"$":-1,"a":0,"b":"InvalidReason","c":{"fG":{"$":-1,"a":1,"b":"DuplicatedName","c":0,"d":{"$":-1,"a":1,"b":"DistributionBug","c":0,"d":{"$":-1,"a":1,"b":"BadDescription","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"DistributionInsufficient","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"InvalidFuzzer","c":0,"d":{"$":-1,"a":1,"b":"EmptyList","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NonpositiveFuzzCount","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["EmptyList","NonpositiveFuzzCount","InvalidFuzzer","BadDescription","DuplicatedName","DistributionInsufficient","DistributionBug"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Test","Runner"]},"c":{"$":-1,"a":1,"b":"Simplifiable","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"SeededRunners","c":{"fG":{"$":-1,"a":1,"b":"Plain","c":0,"d":{"$":-1,"a":1,"b":"Only","c":0,"d":{"$":-1,"a":0,"b":"Invalid","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Skipping","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Plain","Only","Skipping","Invalid"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}}}}}}},"c_":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-2}}}},"ew":{"$":1},"b0":{"$":1},"I":{"$":-1,"a":1,"b":"src/Util.elm","c":{"bT":2381303583,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":59,"bp":51},"ci":{"bb":9,"bp":38}},"b":"UnitExpr ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":54},"ci":{"bb":9,"bp":53}},"b":"Application es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":57},"ci":{"bb":9,"bp":56}},"b":"OperatorApplication _ _ e1 e2 ->\n            [ e1, e2 ]"},{"$":1,"a":{"bV":{"bb":58,"bp":60},"ci":{"bb":9,"bp":59}},"b":"FunctionOrValue _ _ ->\n            []"},{"$":1,"a":{"bV":{"bb":66,"bp":64},"ci":{"bb":9,"bp":62}},"b":"IfBlock predExpr thenExpr elseExpr ->\n            [ predExpr, thenExpr, elseExpr ]"},{"$":1,"a":{"bV":{"bb":15,"bp":67},"ci":{"bb":9,"bp":66}},"b":"PrefixOperator _ ->\n            []"},{"$":1,"a":{"bV":{"bb":57,"bp":71},"ci":{"bb":9,"bp":69}},"b":"Operator _ ->\n            []"},{"$":1,"a":{"bV":{"bb":23,"bp":74},"ci":{"bb":9,"bp":73}},"b":"Integer _ ->\n            []"},{"$":1,"a":{"bV":{"bb":45,"bp":77},"ci":{"bb":9,"bp":76}},"b":"Hex _ ->\n            []"},{"$":1,"a":{"bV":{"bb":27,"bp":80},"ci":{"bb":9,"bp":79}},"b":"Floatable _ ->\n            []"},{"$":1,"a":{"bV":{"bb":23,"bp":83},"ci":{"bb":9,"bp":82}},"b":"Negation e ->\n            [ e ]"},{"$":1,"a":{"bV":{"bb":18,"bp":86},"ci":{"bb":9,"bp":85}},"b":"Literal _ ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":89},"ci":{"bb":9,"bp":88}},"b":"CharLiteral _ ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":92},"ci":{"bb":9,"bp":91}},"b":"TupledExpression es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":95},"ci":{"bb":9,"bp":94}},"b":"ParenthesizedExpression e ->\n            [ e ]"},{"$":1,"a":{"bV":{"bb":15,"bp":98},"ci":{"bb":9,"bp":97}},"b":"LetExpression letBlock ->\n            let\n                subExprs : Node LetDeclaration -> Node Expression\n                subExprs n =\n                    case Node.value n of\n                        LetFunction { declaration } ->\n                            Node.value declaration\n                                |> .expression\n\n                        LetDestructuring _ e ->\n                            e\n            in\n            letBlock.expression\n                :: List.map subExprs letBlock.declarations"},{"$":1,"a":{"bV":{"bb":15,"bp":101},"ci":{"bb":9,"bp":100}},"b":"CaseExpression caseBlock ->\n            caseBlock.expression\n                :: List.map Tuple.second caseBlock.cases"},{"$":1,"a":{"bV":{"bb":15,"bp":104},"ci":{"bb":9,"bp":103}},"b":"LambdaExpression { expression } ->\n            [ expression ]"},{"$":1,"a":{"bV":{"bb":15,"bp":107},"ci":{"bb":9,"bp":106}},"b":"RecordExpr setters ->\n            List.map (Tuple.second << Node.value) setters"},{"$":1,"a":{"bV":{"bb":15,"bp":110},"ci":{"bb":9,"bp":109}},"b":"ListExpr es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":113},"ci":{"bb":9,"bp":112}},"b":"RecordAccess record _ ->\n            [ record ]"},{"$":1,"a":{"bV":{"bb":15,"bp":116},"ci":{"bb":9,"bp":115}},"b":"RecordAccessFunction _ ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":119},"ci":{"bb":9,"bp":118}},"b":"RecordUpdateExpression record updaters ->\n            Node.map (FunctionOrValue []) record\n                :: List.map (Tuple.second << Node.value) updaters"},{"$":1,"a":{"bV":{"bb":15,"bp":122},"ci":{"bb":9,"bp":121}},"b":"GLSLExpression _ ->\n            []"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":37},"ci":{"bb":5,"bp":37}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":136},"ci":{"bb":9,"bp":135}},"b":"AllPattern ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":139},"ci":{"bb":9,"bp":138}},"b":"UnitPattern ->\n            []"},{"$":1,"a":{"bV":{"bb":35,"bp":142},"ci":{"bb":9,"bp":141}},"b":"CharPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":145},"ci":{"bb":9,"bp":144}},"b":"StringPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":25,"bp":148},"ci":{"bb":9,"bp":147}},"b":"IntPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":21,"bp":151},"ci":{"bb":9,"bp":150}},"b":"HexPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":40,"bp":154},"ci":{"bb":9,"bp":153}},"b":"FloatPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":21,"bp":157},"ci":{"bb":9,"bp":156}},"b":"TuplePattern ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":160},"ci":{"bb":9,"bp":159}},"b":"RecordPattern ps ->\n            List.map Node.value ps"},{"$":1,"a":{"bV":{"bb":15,"bp":163},"ci":{"bb":9,"bp":162}},"b":"UnConsPattern p ps ->\n            go [ p, ps ]"},{"$":1,"a":{"bV":{"bb":15,"bp":166},"ci":{"bb":9,"bp":165}},"b":"ListPattern ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":169},"ci":{"bb":9,"bp":168}},"b":"VarPattern name ->\n            [ name ]"},{"$":1,"a":{"bV":{"bb":15,"bp":172},"ci":{"bb":9,"bp":171}},"b":"NamedPattern _ ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":175},"ci":{"bb":9,"bp":174}},"b":"AsPattern p name ->\n            Node.value name :: go [ p ]"},{"$":1,"a":{"bV":{"bb":15,"bp":178},"ci":{"bb":9,"bp":177}},"b":"ParenthesizedPattern p ->\n            go [ p ]"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":134},"ci":{"bb":5,"bp":134}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":80,"bp":398},"ci":{"bb":17,"bp":389}},"b":"[] ->\n                    -- Unsortable, so simply use original order\n                    case compare d1.id d2.id of\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = 0 }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = 0 }\n\n                        EQ ->\n                            -- This should never happen\n                            Nothing"},{"$":1,"a":{"bV":{"bb":36,"bp":411},"ci":{"bb":17,"bp":400}},"b":"( priority, o ) :: os_ ->\n                    case o d1.label d2.label of\n                        EQ ->\n                            genEdge os_ ( d1, d2 )\n\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = priority }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = priority }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":388},"ci":{"bb":13,"bp":388}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":73,"bp":407},"ci":{"bb":25,"bp":406}},"b":"EQ ->\n                            -- This should never happen\n                            Nothing"},{"$":1,"a":{"bV":{"bb":36,"bp":411},"ci":{"bb":25,"bp":409}},"b":"GT ->\n                            Just { from = d2.id, to = d1.id, label = 0 }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":402},"ci":{"bb":21,"bp":402}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":51,"bp":392},"ci":{"bb":25,"bp":391}},"b":"LT ->\n                            Just { from = d1.id, to = d2.id, label = priority }"},{"$":1,"a":{"bV":{"bb":80,"bp":395},"ci":{"bb":25,"bp":394}},"b":"EQ ->\n                            genEdge os_ ( d1, d2 )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":390},"ci":{"bb":21,"bp":390}},"d_":"NoUnsortedCases","ff":0}]},"b6":598685499,"c7":false,"cd":{"O":{"$":-1,"a":1,"b":{"$":"$L","a":["Util"]},"c":{"$":-1,"a":1,"b":"GluedTo","c":{"fG":{"$":-1,"a":1,"b":"GluedBeforeFirst","c":0,"d":{"$":-1,"a":1,"b":"GluedAfterLast","c":0,"d":{"$":-1,"a":0,"b":"GluedAfterFirst","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"GluedBeforeLast","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["GluedBeforeFirst","GluedAfterFirst","GluedBeforeLast","GluedAfterLast"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}},"d":{"$":-1,"a":1,"b":"src/NoUnsortedRecords.elm","c":{"bT":2013153282,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":30,"bp":919},"ci":{"bb":25,"bp":888}},"b":"Elm.Type.Record fields (Just _) ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, True )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , -- No constructors for generic records\n                              []\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":926},"ci":{"bb":25,"bp":921}},"b":"Elm.Type.Record fields Nothing ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, False )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , [ ( name\n                                , { customTypeName = Nothing\n                                  , type_ =\n                                        List.map\n                                            (Tuple.second\n                                                >> docTypeToTypeWithPositionalVars moduleName\n                                                    -- Constrained type vars do apply to record constructors\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Arguments only have order if config says so\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                    }\n                                                    args\n                                            )\n                                            fields\n                                            |> makeFunctionTypeWithPositionalVars\n                                                (docTypeToTypeWithPositionalVars moduleName\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Return type *does* have order\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                    }\n                                                    args\n                                                    tipe\n                                                )\n                                  }\n                                )\n                              ]\n                            )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":887},"ci":{"bb":21,"bp":887}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":56,"bp":1202},"ci":{"bb":9,"bp":1201}},"b":"Elm.Type.Var s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":40,"bp":1205},"ci":{"bb":9,"bp":1204}},"b":"Elm.Type.Lambda from to ->\n            FunctionType { from = go from, to = go to }"},{"$":1,"a":{"bV":{"bb":21,"bp":1223},"ci":{"bb":9,"bp":1207}},"b":"Elm.Type.Tuple ts ->\n            TupleType <| List.map go ts"},{"$":1,"a":{"bV":{"bb":18,"bp":1234},"ci":{"bb":9,"bp":1225}},"b":"Elm.Type.Type qualified args ->\n            -- Can't use module name lookup, so just have to hope this is right.\n            String.split \".\" qualified\n                |> ListX.unconsLast\n                |> Maybe.map\n                    (\\( n, m ) ->\n                        if m == [] then\n                            ( moduleName, n )\n\n                        else\n                            ( m, n )\n                    )\n                |> Maybe.withDefault ( moduleName, qualified )\n                |> (\\( mod, name ) ->\n                        makeList mod name args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( mod, name ) <| List.map go args)\n                   )"},{"$":1,"a":{"bV":{"bb":58,"bp":1237},"ci":{"bb":9,"bp":1236}},"b":"Elm.Type.Record fields generic ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Maybe.map (TypeVar Nothing) generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapSecond go) fields\n                }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1200},"ci":{"bb":5,"bp":1200}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":20,"bp":1286},"ci":{"bb":9,"bp":1285}},"b":"CanonicalWhenSubrecord ->\n            Nothing"},{"$":1,"a":{"bV":{"bb":20,"bp":1289},"ci":{"bb":9,"bp":1288}},"b":"CustomTypeArgsAlwaysCanonical ->\n            Just False"},{"$":1,"a":{"bV":{"bb":23,"bp":1292},"ci":{"bb":9,"bp":1291}},"b":"AlwaysUnknown ->\n            Nothing"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":10,"bp":1284},"ci":{"bb":6,"bp":1284}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":72,"bp":1328},"ci":{"bb":17,"bp":1327}},"b":"InfixExpose name ->\n                    { acc | functions = Set.insert name acc.functions }"},{"$":1,"a":{"bV":{"bb":72,"bp":1331},"ci":{"bb":17,"bp":1330}},"b":"FunctionExpose name ->\n                    { acc | functions = Set.insert name acc.functions }"},{"$":1,"a":{"bV":{"bb":72,"bp":1334},"ci":{"bb":17,"bp":1333}},"b":"TypeOrAliasExpose name ->\n                    { acc | types = Set.insert name acc.types }"},{"$":1,"a":{"bV":{"bb":64,"bp":1337},"ci":{"bb":17,"bp":1336}},"b":"TypeExpose { name } ->\n                    { acc | openTypes = Set.insert name acc.openTypes }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":1326},"ci":{"bb":13,"bp":1326}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":1508},"ci":{"bb":17,"bp":1507}},"b":"( True, True ) ->\n                    addExposed (makeInfo ()) acc_"},{"$":1,"a":{"bV":{"bb":50,"bp":1511},"ci":{"bb":17,"bp":1510}},"b":"( True, False ) ->\n                    acc_"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":1506},"ci":{"bb":13,"bp":1506}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":1591},"ci":{"bb":9,"bp":1542}},"b":"AliasDeclaration { name, generics, typeAnnotation } ->\n            let\n                n : String\n                n =\n                    Node.value name\n\n                aliasInfo : ( String, TypeWithPositionalVars )\n                aliasInfo =\n                    ( n\n                    , typeAnnotToTypeWithPositionalVars context\n                        -- Constrained type vars are not respected for aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        (List.map Node.value generics)\n                        typeAnnotation\n                    )\n            in\n            skipIfIgnored (Set.member n << .types)\n                { acc | exposedAliases = aliasInfo :: acc.exposedAliases }\n                (\\() ->\n                    annotToFields typeAnnotation\n                        |> MaybeX.unwrap ( [], [] )\n                            (\\( fields, isGeneric ) ->\n                                ( -- Generic records do not have constructors.\n                                  if isGeneric then\n                                    []\n\n                                  else\n                                    [ ( n\n                                      , { customTypeName = Nothing\n                                        , type_ =\n                                            List.map Node.value generics\n                                                |> (\\vars ->\n                                                        List.map\n                                                            (Node.value\n                                                                >> Tuple.second\n                                                                >> typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                            )\n                                                            fields\n                                                            |> makeFunctionTypeWithPositionalVars\n                                                                (typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                                    typeAnnotation\n                                                                )\n                                                   )\n                                        }\n                                      )\n                                    ]\n                                , knownRecordFromTypeAnnot subrecordTreatment context ( fields, isGeneric )\n                                    |> List.map (Tuple.mapFirst (\\s -> n ++ s))\n                                )\n                            )\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | aliases = aliasInfo :: acc.aliases\n                        , canonicalRecords = newRecords ++ acc.canonicalRecords\n                        , constructors = newConstructors ++ acc.constructors\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                        , exposedConstructors = newConstructors ++ acc.exposedConstructors\n                    }\n                )"},{"$":1,"a":{"bV":{"bb":18,"bp":1666},"ci":{"bb":9,"bp":1593}},"b":"CustomTypeDeclaration { name, generics, constructors } ->\n            let\n                n : String\n                n =\n                    Node.value name\n            in\n            skipIfIgnored (Set.member n << .openTypes)\n                acc\n                (\\() ->\n                    List.foldl\n                        (\\c ( fAcc, rAcc ) ->\n                            Node.value c\n                                |> makeConstructorAndSubrecords\n                                    (List.map Node.value generics\n                                        |> (\\gs ->\n                                                List.map (TypeVar Nothing) gs\n                                                    |> NamedType ( [], n )\n                                                    |> DereferencedType\n                                                    |> assignTypeVars (makePositionalArgTypeVars gs)\n                                                    |> getType\n                                                    |> TypeWithPositionalVars\n                                           )\n                                    )\n                                    generics\n                                |> (\\( n_, type_, rs ) ->\n                                        ( ( n_\n                                          , { customTypeName = Just n\n                                            , type_ = type_\n                                            }\n                                          )\n                                            :: fAcc\n                                        , rs ++ rAcc\n                                        )\n                                   )\n                        )\n                        ( [], [] )\n                        constructors\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | canonicalRecords = newRecords ++ acc.canonicalRecords\n                        , constructors = newConstructors ++ acc.constructors\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                        , exposedConstructors = newConstructors ++ acc.exposedConstructors\n                    }\n                )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1524},"ci":{"bb":5,"bp":1524}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":21,"bp":1846},"ci":{"bb":9,"bp":1831}},"b":"GenericType s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":21,"bp":1849},"ci":{"bb":9,"bp":1848}},"b":"Typed name args ->\n            moduleNameFor context.lookupTable name\n                |> Maybe.withDefault (Tuple.first <| Node.value name)\n                |> (\\moduleName ->\n                        if moduleName == [] then\n                            -- If the module name is empty, then update to current module name\n                            context.moduleName\n\n                        else\n                            moduleName\n                   )\n                |> Tuple.pair (Tuple.second <| Node.value name)\n                |> (\\( n, moduleName ) ->\n                        makeList moduleName n args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( moduleName, n ) <| List.map go args)\n                   )"},{"$":1,"a":{"bV":{"bb":40,"bp":1852},"ci":{"bb":9,"bp":1851}},"b":"Unit ->\n            UnitType"},{"$":1,"a":{"bV":{"bb":18,"bp":1859},"ci":{"bb":9,"bp":1854}},"b":"Tupled ts ->\n            TupleType <| List.map go ts"},{"$":1,"a":{"bV":{"bb":18,"bp":1870},"ci":{"bb":9,"bp":1861}},"b":"Record fs ->\n            RecordType\n                { generic = Nothing\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) fs\n                }"},{"$":1,"a":{"bV":{"bb":56,"bp":1873},"ci":{"bb":9,"bp":1872}},"b":"GenericRecord generic fs ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Just <| TypeVar Nothing <| Node.value generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) <| Node.value fs\n                }"},{"$":1,"a":{"bV":{"bb":58,"bp":1876},"ci":{"bb":9,"bp":1875}},"b":"FunctionTypeAnnotation from to ->\n            FunctionType { from = go from, to = go to }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1830},"ci":{"bb":5,"bp":1830}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":58,"bp":1983},"ci":{"bb":17,"bp":1981}},"b":"UnitType ->\n                    UnitType"},{"$":1,"a":{"bV":{"bb":26,"bp":1990},"ci":{"bb":17,"bp":1985}},"b":"NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )"},{"$":1,"a":{"bV":{"bb":47,"bp":1994},"ci":{"bb":17,"bp":1992}},"b":"RecordType r ->\n                    RecordType\n                        { r\n                            | generic = Maybe.map go r.generic\n                            , fields = List.map (Tuple.mapSecond go) r.fields\n                        }"},{"$":1,"a":{"bV":{"bb":29,"bp":1997},"ci":{"bb":17,"bp":1996}},"b":"TypeVar _ var ->\n                    Dict.get var typeVars\n                        |> Maybe.withDefault t"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":1971},"ci":{"bb":13,"bp":1971}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":58,"bp":2022},"ci":{"bb":17,"bp":2020}},"b":"UnitType ->\n                    UnitType"},{"$":1,"a":{"bV":{"bb":26,"bp":2029},"ci":{"bb":17,"bp":2024}},"b":"NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )"},{"$":1,"a":{"bV":{"bb":50,"bp":2032},"ci":{"bb":17,"bp":2031}},"b":"RecordType r ->\n                    RecordType\n                        { r\n                            | generic = Maybe.map go r.generic\n                            , fields = List.map (Tuple.mapSecond go) r.fields\n                        }"},{"$":1,"a":{"bV":{"bb":29,"bp":2035},"ci":{"bb":17,"bp":2034}},"b":"TypeVar class var ->\n                    TypeVar class (prefix ++ var)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":2010},"ci":{"bb":13,"bp":2010}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":60,"bp":2112},"ci":{"bb":9,"bp":2110}},"b":"TuplePattern ps ->\n            getTupleTypes ps type_\n                |> List.map2 go ps\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":31,"bp":2117},"ci":{"bb":9,"bp":2114}},"b":"RecordPattern ps ->\n            getRecordFieldTypes type_\n                |> (\\ts ->\n                        List.map\n                            (\\p ->\n                                Dict.get (Node.value p) ts\n                                    |> makeType (Node.value p)\n                            )\n                            ps\n                   )\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":31,"bp":2129},"ci":{"bb":9,"bp":2119}},"b":"UnConsPattern p ps ->\n            -- `p` has type in list, and `ps` is overall list type\n            getListType type_\n                |> (\\t -> go p t ++ go ps type_)"},{"$":1,"a":{"bV":{"bb":90,"bp":2139},"ci":{"bb":9,"bp":2131}},"b":"ListPattern ps ->\n            getListType type_\n                |> (\\t -> List.concatMap (\\p -> go p t) ps)"},{"$":1,"a":{"bV":{"bb":49,"bp":2144},"ci":{"bb":9,"bp":2141}},"b":"VarPattern name ->\n            -- Bind `name` to the overall type\n            makeType name type_"},{"$":1,"a":{"bV":{"bb":32,"bp":2148},"ci":{"bb":9,"bp":2146}},"b":"NamedPattern { name } ps ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } type_ pattern name\n                |> Maybe.map (List.map2 (\\p t -> go p (Just t)) ps)\n                |> Maybe.map List.concat\n                -- No type info\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (\\p -> go p Nothing) ps)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":2109},"ci":{"bb":5,"bp":2109}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":57,"bp":2197},"ci":{"bb":9,"bp":2192}},"b":"GenericType _ ->\n            []"},{"$":1,"a":{"bV":{"bb":71,"bp":2204},"ci":{"bb":9,"bp":2199}},"b":"Typed _ types_ ->\n            let\n                typeVars : List (Maybe DereferencedType)\n                typeVars =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (NamedType _ ts) ->\n                            List.map (Just << DereferencedType) ts\n\n                        Just (ListType t) ->\n                            [ Just <| DereferencedType t ]\n\n                        _ ->\n                            List.map (always Nothing) types_\n            in\n            List.map2 go typeVars types_\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":47,"bp":2217},"ci":{"bb":9,"bp":2207}},"b":"Unit ->\n            []"},{"$":1,"a":{"bV":{"bb":31,"bp":2239},"ci":{"bb":9,"bp":2224}},"b":"Record def ->\n            (recordDefToCheckable context (Node.range type_) True hasTypeFromParent def\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value def)"},{"$":1,"a":{"bV":{"bb":15,"bp":2243},"ci":{"bb":9,"bp":2242}},"b":"GenericRecord _ def ->\n            (recordDefToCheckable context (Node.range type_) False hasTypeFromParent (Node.value def)\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value <| Node.value def)"},{"$":1,"a":{"bV":{"bb":15,"bp":2246},"ci":{"bb":9,"bp":2245}},"b":"FunctionTypeAnnotation fromA toA ->\n            let\n                ( fromType, toType ) =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (FunctionType { from, to }) ->\n                            ( Just <| DereferencedType from, Just <| DereferencedType to )\n\n                        _ ->\n                            ( Nothing, Nothing )\n            in\n            go fromType fromA ++ go toType toA"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":2190},"ci":{"bb":5,"bp":2190}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":67,"bp":2230},"ci":{"bb":25,"bp":2229}},"b":"Just (ListType t) ->\n                            [ Just <| DereferencedType t ]"},{"$":1,"a":{"bV":{"bb":59,"bp":2233},"ci":{"bb":25,"bp":2232}},"b":"Just (NamedType _ ts) ->\n                            List.map (Just << DereferencedType) ts"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":2228},"ci":{"bb":21,"bp":2228}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":2279},"ci":{"bb":9,"bp":2277}},"b":"Application es ->\n            -- Try to pull type info from known functions\n            checkApplicationChain config local hasType es"},{"$":1,"a":{"bV":{"bb":25,"bp":2283},"ci":{"bb":9,"bp":2281}},"b":"OperatorApplication op _ e1 e2 ->\n            -- Handle a few known operators\n            checkOperatorApplication (checkApplicationChain config local hasType) op e1 e2"},{"$":1,"a":{"bV":{"bb":41,"bp":2292},"ci":{"bb":9,"bp":2285}},"b":"IfBlock pred thenE elseE ->\n            -- List predicate must have type Bool and branches have same type as overall\n            go (Just <| DereferencedType <| NamedType ( [ \"Basics\" ], \"Bool\" ) []) pred ++ go hasType thenE ++ go hasType elseE"},{"$":1,"a":{"bV":{"bb":58,"bp":2296},"ci":{"bb":9,"bp":2294}},"b":"Negation e ->\n            -- Negation doesn't change a type\n            go hasType e"},{"$":1,"a":{"bV":{"bb":91,"bp":2300},"ci":{"bb":9,"bp":2298}},"b":"TupledExpression es ->\n            -- Tuples must have a tuple type\n            List.map2 go (getTupleTypes es hasType) es\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":128,"bp":2304},"ci":{"bb":9,"bp":2302}},"b":"ParenthesizedExpression e ->\n            -- Parentheses don't change a type\n            go hasType e"},{"$":1,"a":{"bV":{"bb":31,"bp":2309},"ci":{"bb":9,"bp":2306}},"b":"LetExpression { declarations, expression } ->\n            -- Create new bindings from any that have type info\n            let\n                ( newBindings, decsToCheck ) =\n                    List.map (checkLetDeclaration config local << Node.value) declarations\n                        |> List.unzip\n                        |> Tuple.mapFirst (Dict.fromList << List.concat)\n\n                newContext : LocalContext\n                newContext =\n                    { local | localFunctions = Dict.union local.localFunctions newBindings }\n            in\n            checkExpression config newContext hasType expression\n                ++ List.concatMap (\\f -> f newContext) decsToCheck"},{"$":1,"a":{"bV":{"bb":67,"bp":2348},"ci":{"bb":9,"bp":2335}},"b":"RecordExpr recordSetters ->\n            -- A record expression has to have all fields of the known record\n            let\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes hasType\n            in\n            recordSettersToCheckable local (Node.range node) True hasType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)"},{"$":1,"a":{"bV":{"bb":70,"bp":2360},"ci":{"bb":9,"bp":2350}},"b":"ListExpr es ->\n            let\n                -- Lists must have a list type\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) es"},{"$":1,"a":{"bV":{"bb":70,"bp":2379},"ci":{"bb":9,"bp":2362}},"b":"RecordAccess e accessFunc ->\n            go (makeRecordAccessType hasType <| Node.value accessFunc) e"},{"$":1,"a":{"bV":{"bb":73,"bp":2382},"ci":{"bb":9,"bp":2381}},"b":"RecordUpdateExpression _ recordSetters ->\n            -- A record update must have the same type as the record, so type is useful\n            -- A record update expression does not have to have all fields of the known record\n            let\n                updateType : Maybe DereferencedType\n                updateType =\n                    -- Get type from updated var if we don't have a good annotation\n                    hasType\n                        |> MaybeX.orElseLazy (\\() -> inferExprType local node)\n\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes updateType\n            in\n            recordSettersToCheckable local (Node.range node) False updateType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":2275},"ci":{"bb":5,"bp":2275}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":32,"bp":2449},"ci":{"bb":9,"bp":2448}},"b":"\"<|\" ->\n            checkApp [ e1, e2 ]"},{"$":1,"a":{"bV":{"bb":32,"bp":2452},"ci":{"bb":9,"bp":2451}},"b":"\"|>\" ->\n            checkApp [ e2, e1 ]"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":2447},"ci":{"bb":5,"bp":2447}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":2708},"ci":{"bb":9,"bp":2701}},"b":"RecordPattern fields ->\n            recordPatternToCheckable (Node.range node) hasType fields\n                |> checkRecord config context\n                -- No such thing as subrecords for patterns, so we can just return the errors\n                |> Tuple.first"},{"$":1,"a":{"bV":{"bb":41,"bp":2717},"ci":{"bb":9,"bp":2710}},"b":"UnConsPattern p ps ->\n            let\n                -- Uncons has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            go type_ p ++ go type_ ps"},{"$":1,"a":{"bV":{"bb":25,"bp":2721},"ci":{"bb":9,"bp":2719}},"b":"ListPattern ps ->\n            let\n                -- List pattern has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) ps"},{"$":1,"a":{"bV":{"bb":25,"bp":2725},"ci":{"bb":9,"bp":2723}},"b":"NamedPattern { name } pats ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } hasType node name\n                |> Maybe.map (List.map2 (\\p t -> go (Just t) p) pats)\n                |> Maybe.map List.concat\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (go Nothing) pats)"},{"$":1,"a":{"bV":{"bb":84,"bp":2734},"ci":{"bb":9,"bp":2727}},"b":"AsPattern p _ ->\n            -- As pattern does not change type\n            go hasType p"},{"$":1,"a":{"bV":{"bb":31,"bp":2740},"ci":{"bb":9,"bp":2736}},"b":"ParenthesizedPattern p ->\n            -- Parentheses do not change type\n            go hasType p"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":2695},"ci":{"bb":5,"bp":2695}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":61,"bp":3124},"ci":{"bb":29,"bp":3123}},"b":"Just (UnknownFields fs_) ->\n                                let\n                                    alph : List String\n                                    alph =\n                                        List.sort fs_\n                                in\n                                ( List.map\n                                    (\\f ->\n                                        ( f.field\n                                        , ListX.elemIndex f.field alph\n                                            |> Maybe.withDefault -1\n                                            |> (+) ((offsetMult + 1) * genericOffset)\n                                        )\n                                    )\n                                    fs\n                                    |> Dict.fromList\n                                , True\n                                )"},{"$":1,"a":{"bV":{"bb":34,"bp":3143},"ci":{"bb":29,"bp":3126}},"b":"Just (OrderedFields order) ->\n                                go (offsetMult + 1) fs order"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":29,"bp":3122},"ci":{"bb":25,"bp":3122}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":3412},"ci":{"bb":17,"bp":3411}},"b":"( FunctionType f1, FunctionType f2 ) ->\n                    checkListOfTypes typeVars [ f1.from, f1.to ] [ f1.from, f2.to ]"},{"$":1,"a":{"bV":{"bb":84,"bp":3419},"ci":{"bb":17,"bp":3418}},"b":"( ListType t1, ListType t2 ) ->\n                    go typeVars t1 t2"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3404},"ci":{"bb":13,"bp":3404}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3492},"ci":{"bb":17,"bp":3491}},"b":"NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3495},"ci":{"bb":17,"bp":3494}},"b":"NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3490},"ci":{"bb":13,"bp":3490}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3479},"ci":{"bb":17,"bp":3478}},"b":"ListType _ ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3482},"ci":{"bb":17,"bp":3481}},"b":"NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3477},"ci":{"bb":13,"bp":3477}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3454},"ci":{"bb":17,"bp":3453}},"b":"TupleType ts ->\n                    List.all typeIsComparable ts"},{"$":1,"a":{"bV":{"bb":25,"bp":3457},"ci":{"bb":17,"bp":3456}},"b":"ListType t_ ->\n                    typeIsComparable t_"},{"$":1,"a":{"bV":{"bb":25,"bp":3460},"ci":{"bb":17,"bp":3459}},"b":"NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3463},"ci":{"bb":17,"bp":3462}},"b":"NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":40,"bp":3466},"ci":{"bb":17,"bp":3465}},"b":"NamedType ( [ \"Char\" ], \"Char\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":49,"bp":3469},"ci":{"bb":17,"bp":3468}},"b":"NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3452},"ci":{"bb":13,"bp":3452}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":35,"bp":3506},"ci":{"bb":9,"bp":3505}},"b":"Number ->\n            typeIsNumber type_"},{"$":1,"a":{"bV":{"bb":61,"bp":3509},"ci":{"bb":9,"bp":3508}},"b":"Comparable ->\n            typeIsComparable type_"},{"$":1,"a":{"bV":{"bb":31,"bp":3512},"ci":{"bb":9,"bp":3511}},"b":"CompAppend ->\n            typeIsAppendable type_ && typeIsComparable type_"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":3501},"ci":{"bb":5,"bp":3501}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":65,"bp":3537},"ci":{"bb":17,"bp":3536}},"b":"Application es ->\n                    inferApplicationChain local es\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":65,"bp":3540},"ci":{"bb":17,"bp":3539}},"b":"OperatorApplication op _ e1 e2 ->\n                    -- Handle a few known operators\n                    checkOperatorApplication (inferApplicationChain local) op e1 e2\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":67,"bp":3543},"ci":{"bb":17,"bp":3542}},"b":"FunctionOrValue _ name ->\n                    findFunctionType local Nothing node name\n                        |> makeFunc typeVarPrefix"},{"$":1,"a":{"bV":{"bb":68,"bp":3546},"ci":{"bb":17,"bp":3545}},"b":"IfBlock _ e1 e2 ->\n                    -- Try to infer either side and unify\n                    [ go (typeVarPrefix ++ \"If Block True\") e1, go (typeVarPrefix ++ \"If Block False\") e2 ]\n                        |> MaybeX.values\n                        |> unifyTypes"},{"$":1,"a":{"bV":{"bb":64,"bp":3549},"ci":{"bb":17,"bp":3548}},"b":"PrefixOperator p ->\n                    findOperatorType local.context p\n                        |> makeFunc typeVarPrefix"},{"$":1,"a":{"bV":{"bb":47,"bp":3554},"ci":{"bb":17,"bp":3551}},"b":"Operator _ ->\n                    Nothing"},{"$":1,"a":{"bV":{"bb":50,"bp":3566},"ci":{"bb":17,"bp":3556}},"b":"Integer _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []"},{"$":1,"a":{"bV":{"bb":119,"bp":3580},"ci":{"bb":17,"bp":3568}},"b":"Hex _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []"},{"$":1,"a":{"bV":{"bb":50,"bp":3584},"ci":{"bb":17,"bp":3582}},"b":"Floatable _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Float\" ) []"},{"$":1,"a":{"bV":{"bb":39,"bp":3588},"ci":{"bb":17,"bp":3586}},"b":"Negation e ->\n                    go typeVarPrefix e"},{"$":1,"a":{"bV":{"bb":39,"bp":3591},"ci":{"bb":17,"bp":3590}},"b":"Literal _ ->\n                    Just <| NamedType ( [ \"String\" ], \"String\" ) []"},{"$":1,"a":{"bV":{"bb":38,"bp":3597},"ci":{"bb":17,"bp":3593}},"b":"CharLiteral _ ->\n                    Just <| NamedType ( [ \"Char\" ], \"Char\" ) []"},{"$":1,"a":{"bV":{"bb":50,"bp":3601},"ci":{"bb":17,"bp":3599}},"b":"TupledExpression es ->\n                    List.indexedMap (\\i e -> go (typeVarPrefix ++ \"Tuple Expression \" ++ String.fromInt i) e) es\n                        |> MaybeX.combine\n                        |> Maybe.map TupleType"},{"$":1,"a":{"bV":{"bb":38,"bp":3607},"ci":{"bb":17,"bp":3603}},"b":"ParenthesizedExpression e ->\n                    -- Type is just whatever is in parentheses\n                    go typeVarPrefix e"},{"$":1,"a":{"bV":{"bb":45,"bp":3611},"ci":{"bb":17,"bp":3609}},"b":"LetExpression { declarations, expression } ->\n                    let\n                        newBindings : Dict String Type\n                        newBindings =\n                            List.concatMap (bindingsFromLetDeclaration local << Node.value) declarations\n                                |> Dict.fromList\n                    in\n                    inferExprType { local | localFunctions = Dict.union local.localFunctions newBindings } expression\n                        |> Maybe.map (prefixTypeVars typeVarPrefix)\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":38,"bp":3625},"ci":{"bb":17,"bp":3613}},"b":"CaseExpression { cases } ->\n                    -- Try to infer all cases and unify\n                    List.indexedMap (\\i ( _, e ) -> go (typeVarPrefix ++ \"Case Expression \" ++ String.fromInt i) e) cases\n                        |> MaybeX.values\n                        |> unifyTypes"},{"$":1,"a":{"bV":{"bb":45,"bp":3636},"ci":{"bb":17,"bp":3627}},"b":"LambdaExpression { args, expression } ->\n                    let\n                        unwrapArgs : List String -> Maybe Type\n                        unwrapArgs xs =\n                            ListX.uncons xs\n                                |> MaybeX.unpack (\\() -> go typeVarPrefix expression)\n                                    (\\( x, xs_ ) ->\n                                        unwrapArgs xs_\n                                            |> Maybe.map (\\t -> FunctionType { from = TypeVar Nothing <| typeVarPrefix ++ x, to = t })\n                                    )\n                    in\n                    List.indexedMap (\\i _ -> \"lambda arg\" ++ String.fromInt i) args\n                        |> unwrapArgs"},{"$":1,"a":{"bV":{"bb":28,"bp":3639},"ci":{"bb":17,"bp":3638}},"b":"RecordExpr rs ->\n                    rs\n                        |> List.map\n                            (\\n ->\n                                let\n                                    ( f, e ) =\n                                        Node.value n\n                                in\n                                go (typeVarPrefix ++ \"Record Field \" ++ Node.value f) e\n                                    |> Maybe.map (Tuple.pair (Node.value f))\n                            )\n                        |> MaybeX.combine\n                        |> Maybe.map (\\fields -> RecordType { generic = Nothing, canonical = False, fields = fields })"},{"$":1,"a":{"bV":{"bb":29,"bp":3656},"ci":{"bb":17,"bp":3641}},"b":"ListExpr es ->\n                    if List.isEmpty es then\n                        -- An empty list can be anything\n                        Just (ListType (TypeVar Nothing <| typeVarPrefix ++ \"inferred empty list typevar\"))\n\n                    else\n                        -- Have to check all and unify\n                        List.indexedMap (\\i e -> go (typeVarPrefix ++ \"List Element \" ++ String.fromInt i) e) es\n                            |> MaybeX.values\n                            |> unifyTypes\n                            |> Maybe.map ListType"},{"$":1,"a":{"bV":{"bb":28,"bp":3659},"ci":{"bb":17,"bp":3658}},"b":"RecordAccess e accessFunc ->\n                    go typeVarPrefix e\n                        |> Maybe.map DereferencedType\n                        |> getRecordFieldTypes\n                        |> (\\ts ->\n                                Node.value accessFunc\n                                    |> makeAccessFunc\n                                    |> (\\f -> Dict.get f ts)\n                           )\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":45,"bp":3664},"ci":{"bb":17,"bp":3661}},"b":"RecordAccessFunction accessFunc ->\n                    -- We know the expression being accessed is a record with a field of the type of the total expression\n                    makeAccessFunc accessFunc\n                        |> (\\f ->\n                                Just <|\n                                    FunctionType\n                                        { from =\n                                            RecordType\n                                                -- This is, in essence, a generic record with one field\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"record access inferred for \" ++ f\n                                                , canonical = False\n                                                , fields = [ ( f, TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f ) ]\n                                                }\n                                        , to = TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f\n                                        }\n                           )"},{"$":1,"a":{"bV":{"bb":45,"bp":3675},"ci":{"bb":17,"bp":3666}},"b":"RecordUpdateExpression var fs ->\n                    findFunctionType local Nothing var (Node.value var)\n                        |> makeFunc typeVarPrefix\n                        |> MaybeX.orElseLazy\n                            (\\() ->\n                                MaybeX.traverse ((\\( f, e ) -> go (typeVarPrefix ++ \"Record Update Field \" ++ Node.value f) e |> Maybe.map (Tuple.pair (Node.value f))) << Node.value) fs\n                                    |> Maybe.map\n                                        (\\fields ->\n                                            RecordType\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"inferred update generic\"\n                                                , canonical = False\n                                                , fields = fields\n                                                }\n                                        )\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":3691},"ci":{"bb":17,"bp":3677}},"b":"GLSLExpression _ ->\n                    Nothing"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3531},"ci":{"bb":13,"bp":3531}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":3819},"ci":{"bb":9,"bp":3817}},"b":"( TupleType t1s, TupleType t2s ) ->\n            ListX.zip t1s t2s\n                |> MaybeX.traverse (\\( t1, t2 ) -> unifyTypes [ t1, t2 ])\n                |> Maybe.map TupleType"},{"$":1,"a":{"bV":{"bb":39,"bp":3824},"ci":{"bb":9,"bp":3821}},"b":"( ListType t1, ListType t2 ) ->\n            unifyTypes [ t1, t2 ]\n                |> Maybe.map ListType"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":3799},"ci":{"bb":5,"bp":3799}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":87,"bp":3851},"ci":{"bb":41,"bp":3850}},"b":"( ( Just (TypeVar _ _), _ ), ( Nothing, [] ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ ++ only2 }"},{"$":1,"a":{"bV":{"bb":96,"bp":3854},"ci":{"bb":41,"bp":3853}},"b":"( ( Nothing, [] ), ( Just (TypeVar _ _), _ ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ ++ only1 }"},{"$":1,"a":{"bV":{"bb":96,"bp":3857},"ci":{"bb":41,"bp":3856}},"b":"( ( Nothing, [] ), ( Nothing, [] ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":41,"bp":3846},"ci":{"bb":37,"bp":3846}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":1,"b":"src/NoUnsortedLetDeclarations.elm","c":{"bT":2206621460,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":327},"ci":{"bb":25,"bp":326}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":330},"ci":{"bb":25,"bp":329}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":325},"ci":{"bb":21,"bp":325}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":367},"ci":{"bb":25,"bp":366}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":370},"ci":{"bb":25,"bp":369}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":365},"ci":{"bb":21,"bp":365}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":493},"ci":{"bb":25,"bp":492}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":496},"ci":{"bb":25,"bp":495}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":491},"ci":{"bb":21,"bp":491}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":0,"b":"src/NoUnsortedCases.elm","c":{"bT":1178113956,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":64,"bp":1031},"ci":{"bb":9,"bp":1029}},"b":"Pattern.AllPattern ->\n            Just Wildcard"},{"$":1,"a":{"bV":{"bb":22,"bp":1042},"ci":{"bb":9,"bp":1034}},"b":"Pattern.CharPattern c ->\n            makeLiteral CharLiteral c"},{"$":1,"a":{"bV":{"bb":22,"bp":1052},"ci":{"bb":9,"bp":1044}},"b":"Pattern.StringPattern s ->\n            makeLiteral StringLiteral s"},{"$":1,"a":{"bV":{"bb":31,"bp":1077},"ci":{"bb":9,"bp":1055}},"b":"Pattern.IntPattern i ->\n            makeLiteral IntLiteral i"},{"$":1,"a":{"bV":{"bb":26,"bp":1081},"ci":{"bb":9,"bp":1080}},"b":"Pattern.HexPattern i ->\n            makeLiteral IntLiteral i"},{"$":1,"a":{"bV":{"bb":26,"bp":1084},"ci":{"bb":9,"bp":1083}},"b":"Pattern.FloatPattern f ->\n            makeLiteral FloatLiteral f"},{"$":1,"a":{"bV":{"bb":38,"bp":1088},"ci":{"bb":9,"bp":1087}},"b":"Pattern.TuplePattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )"},{"$":1,"a":{"bV":{"bb":40,"bp":1091},"ci":{"bb":9,"bp":1090}},"b":"Pattern.UnConsPattern p1 p2 ->\n            let\n                cons : SortablePattern -> SortablePattern -> Maybe SortablePattern\n                cons x xs =\n                    case xs of\n                        Wildcard ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { subpatterns = [ x ]\n                                    , terminates = False\n                                    }\n\n                        ListTupleOrUncons r ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { r | subpatterns = x :: r.subpatterns }\n\n                        _ ->\n                            -- You can't cons onto a constructor or Literal, so this is a type error\n                            Nothing\n            in\n            Maybe.map2 cons (go p1) (go p2)\n                |> MaybeX.join"},{"$":1,"a":{"bV":{"bb":37,"bp":1094},"ci":{"bb":9,"bp":1093}},"b":"Pattern.ListPattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )"},{"$":1,"a":{"bV":{"bb":37,"bp":1097},"ci":{"bb":9,"bp":1096}},"b":"Pattern.VarPattern _ ->\n            Just Wildcard"},{"$":1,"a":{"bV":{"bb":39,"bp":1100},"ci":{"bb":9,"bp":1099}},"b":"Pattern.NamedPattern { name } ps ->\n            moduleNameFor context.lookupTable n\n                |> Maybe.andThen (findConstructorOrder name ps)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1027},"ci":{"bb":5,"bp":1027}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":1065},"ci":{"bb":25,"bp":1060}},"b":"ListTupleOrUncons r ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { r | subpatterns = x :: r.subpatterns }"},{"$":1,"a":{"bV":{"bb":77,"bp":1070},"ci":{"bb":25,"bp":1067}},"b":"Wildcard ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { subpatterns = [ x ]\n                                    , terminates = False\n                                    }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":1059},"ci":{"bb":21,"bp":1059}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":1115},"ci":{"bb":9,"bp":1114}},"b":"Pattern.AsPattern p _ ->\n            getActualPattern p"},{"$":1,"a":{"bV":{"bb":31,"bp":1118},"ci":{"bb":9,"bp":1117}},"b":"Pattern.ParenthesizedPattern p ->\n            getActualPattern p"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1112},"ci":{"bb":5,"bp":1112}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":26,"bp":1235},"ci":{"bb":9,"bp":1220}},"b":"( [], [] ) ->\n            -- Both have been exhausted, so no problems sorting them\n            True"},{"$":1,"a":{"bV":{"bb":17,"bp":1239},"ci":{"bb":9,"bp":1237}},"b":"( [], _ ) ->\n            -- r1 is shorter than r2, so it is safe to sort it if it terminates\n            r1.terminates"},{"$":1,"a":{"bV":{"bb":26,"bp":1243},"ci":{"bb":9,"bp":1241}},"b":"( x :: xs, y :: ys ) ->\n            -- Check if the head of the lists is sortable\n            case comparePatterns config x y of\n                Just EQ ->\n                    -- If the left-most subpatterns are equal, then they are sortable if the next subpattern is sortable, so recurse\n                    safelySortableListPatterns config\n                        { r1 | subpatterns = xs }\n                        { r2 | subpatterns = ys }\n\n                Just _ ->\n                    -- If the left-most subpattern is sortable, then they can be distinguished and so are safely sortable\n                    True\n\n                Nothing ->\n                    -- If the left-most subpattern is not sortable, they cannot be sorted\n                    False"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1219},"ci":{"bb":5,"bp":1219}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":33,"bp":1273},"ci":{"bb":9,"bp":1272}},"b":"( Constructor c1, Constructor c2 ) ->\n            let\n                goSubs : List (Maybe SortablePattern) -> List (Maybe SortablePattern) -> () -> Maybe Order\n                goSubs pat1s pat2s () =\n                    case ( pat1s, pat2s, lookPastUnsortable ) of\n                        ( (Just p1) :: p1s, (Just p2) :: p2s, _ ) ->\n                            goSubs p1s p2s\n                                |> fallbackCompareWithUnsortableFor (go p1 p2)\n\n                        ( Nothing :: p1s, Nothing :: p2s, True ) ->\n                            -- If at the point where arguments are both unsortable, then proceed past if configured to\n                            goSubs p1s p2s ()\n\n                        ( [], [], _ ) ->\n                            -- Both lists of subpatterns exhausted without a \"winner\", so return EQ\n                            Just EQ\n\n                        _ ->\n                            -- Lists should be even, so other cases aren't sortable\n                            Nothing\n            in\n            -- Fallback to subpatterns\n            goSubs c1.subpatterns c2.subpatterns\n                |> fallbackCompareWithUnsortableFor (Just <| compare c1.order c2.order)"},{"$":1,"a":{"bV":{"bb":88,"bp":1299},"ci":{"bb":9,"bp":1276}},"b":"( ListTupleOrUncons r1, ListTupleOrUncons r2 ) ->\n            case\n                ( ( r1.subpatterns, r1.terminates )\n                , ( r2.subpatterns, r2.terminates )\n                )\n            of\n                -- If the lists are the same length, infinite ones go later\n                ( ( [], False ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( [], True ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], _ ), ( [], _ ) ) ->\n                    Just EQ\n\n                -- If one list is shorter than another, it goes after if it is infinite or before if it isn't\n                ( ( _ :: _, _ ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( _ :: _, _ ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], True ), ( _ :: _, _ ) ) ->\n                    Just LT\n\n                ( ( [], False ), ( _ :: _, _ ) ) ->\n                    Just GT\n\n                -- Otherwise, compare the lists sequentially\n                ( ( p1 :: p1s, _ ), ( p2 :: p2s, _ ) ) ->\n                    compareNonemptyListPatterns ruleConfig ( r1, p1, p1s ) ( r2, p2, p2s )"},{"$":1,"a":{"bV":{"bb":91,"bp":1333},"ci":{"bb":9,"bp":1302}},"b":"( Literal l1, Literal l2 ) ->\n            compareLiteral l1 l2"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1259},"ci":{"bb":5,"bp":1259}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":28,"bp":1310},"ci":{"bb":17,"bp":1309}},"b":"( ( [], True ), ( [], False ) ) ->\n                    Just LT"},{"$":1,"a":{"bV":{"bb":28,"bp":1313},"ci":{"bb":17,"bp":1312}},"b":"( ( [], False ), ( [], True ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":1320},"ci":{"bb":17,"bp":1319}},"b":"( ( [], True ), ( _ :: _, _ ) ) ->\n                    Just LT"},{"$":1,"a":{"bV":{"bb":28,"bp":1323},"ci":{"bb":17,"bp":1322}},"b":"( ( [], False ), ( _ :: _, _ ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":1326},"ci":{"bb":17,"bp":1325}},"b":"( ( _ :: _, _ ), ( [], True ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":1329},"ci":{"bb":17,"bp":1328}},"b":"( ( _ :: _, _ ), ( [], False ) ) ->\n                    Just LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":1303},"ci":{"bb":13,"bp":1303}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":79,"bp":1283},"ci":{"bb":25,"bp":1281}},"b":"( [], [], _ ) ->\n                            -- Both lists of subpatterns exhausted without a \"winner\", so return EQ\n                            Just EQ"},{"$":1,"a":{"bV":{"bb":46,"bp":1287},"ci":{"bb":25,"bp":1285}},"b":"( (Just p1) :: p1s, (Just p2) :: p2s, _ ) ->\n                            goSubs p1s p2s\n                                |> fallbackCompareWithUnsortableFor (go p1 p2)"},{"$":1,"a":{"bV":{"bb":36,"bp":1291},"ci":{"bb":25,"bp":1289}},"b":"( Nothing :: p1s, Nothing :: p2s, True ) ->\n                            -- If at the point where arguments are both unsortable, then proceed past if configured to\n                            goSubs p1s p2s ()"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":1280},"ci":{"bb":21,"bp":1280}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":80,"bp":1382},"ci":{"bb":9,"bp":1380}},"b":"( True, True ) ->\n            -- Compare normally if neither does\n            compare (List.length p1s.subpatterns) (List.length p2s.subpatterns)"},{"$":1,"a":{"bV":{"bb":15,"bp":1385},"ci":{"bb":9,"bp":1384}},"b":"( True, False ) ->\n            LT"},{"$":1,"a":{"bV":{"bb":15,"bp":1388},"ci":{"bb":9,"bp":1387}},"b":"( False, True ) ->\n            GT"},{"$":1,"a":{"bV":{"bb":80,"bp":1392},"ci":{"bb":9,"bp":1390}},"b":"( False, False ) ->\n            -- Flip comparison if both end in wildcards\n            compare (List.length p2s.subpatterns) (List.length p1s.subpatterns)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1379},"ci":{"bb":5,"bp":1379}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"src/NoUnsortedTopLevelDeclarations.elm","c":{"bT":3025250136,"bd":{"$":0},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedRecordsTest.elm","c":{"bT":461532322,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":1,"b":"tests/NoUnsortedLetDeclarationsTest.elm","c":{"bT":449628609,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":0,"b":"tests/NoUnsortedCasesTest.elm","c":{"bT":632637427,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedTopLevelDeclarationsTest.elm","c":{"bT":1278024016,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}}},"dZ":{"$":0,"a":{"bT":{"$":0,"a":3715779789},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-2}}}}}
