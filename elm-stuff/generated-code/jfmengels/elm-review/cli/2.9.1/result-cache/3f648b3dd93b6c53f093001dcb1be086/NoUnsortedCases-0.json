{"aR":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Infix"]},"c":{"$":-1,"a":1,"b":"InfixDirection","c":{"fG":{"$":-1,"a":1,"b":"Non","c":0,"d":{"$":-1,"a":1,"b":"Left","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Right","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Left","Right","Non"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","License"]},"c":{"$":-1,"a":1,"b":"License","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Dict"]},"c":{"$":-1,"a":1,"b":"Dict","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Basics"]},"c":{"$":-1,"a":1,"b":"Never","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Float","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Bool","c":{"fG":{"$":-1,"a":1,"b":"True","c":0,"d":{"$":-1,"a":0,"b":"False","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["True","False"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Int","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Order","c":{"fG":{"$":-1,"a":1,"b":"GT","c":0,"d":{"$":-1,"a":1,"b":"EQ","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"LT","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["LT","EQ","GT"]}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Array"]},"c":{"$":-1,"a":1,"b":"Array","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Char"]},"c":{"$":-1,"a":1,"b":"Char","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Docs"]},"c":{"$":-1,"a":1,"b":"Block","c":{"fG":{"$":-1,"a":1,"b":"UnknownBlock","c":0,"d":{"$":-1,"a":0,"b":"MarkdownBlock","c":0,"d":{"$":-1,"a":1,"b":"BinopBlock","c":0,"d":{"$":-1,"a":0,"b":"AliasBlock","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"UnionBlock","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"ValueBlock","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["MarkdownBlock","UnionBlock","AliasBlock","ValueBlock","BinopBlock","UnknownBlock"]}},"d":{"$":-1,"a":0,"b":"Associativity","c":{"fG":{"$":-1,"a":1,"b":"None","c":0,"d":{"$":-1,"a":1,"b":"Left","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Right","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Left","None","Right"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Constraint"]},"c":{"$":-1,"a":1,"b":"Constraint","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Interface"]},"c":{"$":-1,"a":1,"b":"Exposed","c":{"fG":{"$":-1,"a":1,"b":"CustomType","c":0,"d":{"$":-1,"a":1,"b":"Alias","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Operator","c":0,"d":{"$":-1,"a":0,"b":"Function","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["Function","CustomType","Alias","Operator"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Error"]},"c":{"$":-1,"a":1,"b":"Color","c":{"fG":{"$":-1,"a":1,"b":"RED","c":0,"d":{"$":-1,"a":0,"b":"GREEN","c":0,"d":{"$":-1,"a":1,"b":"CYAN","c":0,"d":{"$":-1,"a":0,"b":"Black","c":0,"d":{"$":-1,"a":1,"b":"BLUE","c":0,"d":{"$":-1,"a":0,"b":"BLACK","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Blue","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Cyan","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"MAGENTA","c":0,"d":{"$":-1,"a":1,"b":"Green","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Magenta","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"YELLOW","c":0,"d":{"$":-1,"a":0,"b":"WHITE","c":0,"d":{"$":-1,"a":1,"b":"Red","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"White","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Yellow","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["Red","RED","Magenta","MAGENTA","Yellow","YELLOW","Green","GREEN","Cyan","CYAN","Blue","BLUE","White","WHITE","Black","BLACK"]}},"d":{"$":-1,"a":1,"b":"Chunk","c":{"fG":{"$":-1,"a":1,"b":"Unstyled","c":0,"d":{"$":-1,"a":0,"b":"Styled","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Unstyled","Styled"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Error","c":{"fG":{"$":-1,"a":1,"b":"ModuleProblems","c":0,"d":{"$":-1,"a":0,"b":"GeneralProblem","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["GeneralProblem","ModuleProblems"]}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Project"]},"c":{"$":-1,"a":1,"b":"Project","c":{"fG":{"$":-1,"a":1,"b":"Package","c":0,"d":{"$":-1,"a":0,"b":"Application","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Application","Package"]}},"d":{"$":-1,"a":0,"b":"Exposed","c":{"fG":{"$":-1,"a":1,"b":"ExposedList","c":0,"d":{"$":-1,"a":0,"b":"ExposedDict","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["ExposedList","ExposedDict"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Package"]},"c":{"$":-1,"a":1,"b":"Name","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Module"]},"c":{"$":-1,"a":1,"b":"Name","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Processing"]},"c":{"$":-1,"a":1,"b":"ProcessContext","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Exposing"]},"c":{"$":-1,"a":1,"b":"TopLevelExpose","c":{"fG":{"$":-1,"a":1,"b":"InfixExpose","c":0,"d":{"$":-1,"a":1,"b":"FunctionExpose","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"TypeOrAliasExpose","c":0,"d":{"$":-1,"a":0,"b":"TypeExpose","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["InfixExpose","FunctionExpose","TypeOrAliasExpose","TypeExpose"]}},"d":{"$":-1,"a":0,"b":"Exposing","c":{"fG":{"$":-1,"a":1,"b":"Explicit","c":0,"d":{"$":-1,"a":0,"b":"All","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["All","Explicit"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Declaration"]},"c":{"$":-1,"a":1,"b":"Declaration","c":{"fG":{"$":-1,"a":1,"b":"InfixDeclaration","c":0,"d":{"$":-1,"a":0,"b":"CustomTypeDeclaration","c":0,"d":{"$":-1,"a":1,"b":"AliasDeclaration","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"FunctionDeclaration","c":0,"d":{"$":-1,"a":0,"b":"Destructuring","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"PortDeclaration","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["FunctionDeclaration","AliasDeclaration","CustomTypeDeclaration","PortDeclaration","InfixDeclaration","Destructuring"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Expression"]},"c":{"$":-1,"a":1,"b":"LetDeclaration","c":{"fG":{"$":-1,"a":1,"b":"LetFunction","c":0,"d":{"$":-1,"a":0,"b":"LetDestructuring","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["LetFunction","LetDestructuring"]}},"d":{"$":-1,"a":0,"b":"Expression","c":{"fG":{"$":-1,"a":1,"b":"OperatorApplication","c":0,"d":{"$":-1,"a":1,"b":"Integer","c":0,"d":{"$":-1,"a":0,"b":"FunctionOrValue","c":0,"d":{"$":-1,"a":1,"b":"CharLiteral","c":0,"d":{"$":-1,"a":1,"b":"CaseExpression","c":0,"d":{"$":-1,"a":0,"b":"Application","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Floatable","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Hex","c":0,"d":{"$":-1,"a":1,"b":"GLSLExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"IfBlock","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"Negation","c":0,"d":{"$":-1,"a":0,"b":"LetExpression","c":0,"d":{"$":-1,"a":1,"b":"LambdaExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Literal","c":0,"d":{"$":-1,"a":0,"b":"ListExpr","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Operator","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"RecordAccessFunction","c":0,"d":{"$":-1,"a":1,"b":"PrefixOperator","c":0,"d":{"$":-1,"a":1,"b":"ParenthesizedExpression","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"RecordAccess","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"TupledExpression","c":0,"d":{"$":-1,"a":1,"b":"RecordUpdateExpression","c":0,"d":{"$":-1,"a":0,"b":"RecordExpr","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"UnitExpr","c":0,"d":{"$":-2},"e":{"$":-2}}}}},"cX":{"$":"$L","a":["UnitExpr","Application","OperatorApplication","FunctionOrValue","IfBlock","PrefixOperator","Operator","Integer","Hex","Floatable","Negation","Literal","CharLiteral","TupledExpression","ParenthesizedExpression","LetExpression","CaseExpression","LambdaExpression","RecordExpr","ListExpr","RecordAccess","RecordAccessFunction","RecordUpdateExpression","GLSLExpression"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["List","Extra"]},"c":{"$":-1,"a":1,"b":"Step","c":{"fG":{"$":-1,"a":1,"b":"Stop","c":0,"d":{"$":-1,"a":0,"b":"Continue","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Continue","Stop"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Expect"]},"c":{"$":-1,"a":1,"b":"FloatingPointTolerance","c":{"fG":{"$":-1,"a":1,"b":"AbsoluteOrRelative","c":0,"d":{"$":-1,"a":1,"b":"Absolute","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Relative","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Absolute","Relative","AbsoluteOrRelative"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Type"]},"c":{"$":-1,"a":1,"b":"Type","c":{"fG":{"$":-1,"a":1,"b":"Tuple","c":0,"d":{"$":-1,"a":1,"b":"Record","c":0,"d":{"$":-1,"a":0,"b":"Lambda","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Var","c":0,"d":{"$":-1,"a":0,"b":"Type","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["Var","Lambda","Tuple","Type","Record"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Syntax","Node"]},"c":{"$":-1,"a":1,"b":"Node","c":{"fG":{"$":-1,"a":1,"b":"Node","c":0,"d":{"$":-2},"e":{"$":-2}},"cX":{"$":"$L","a":["Node"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","Module"]},"c":{"$":-1,"a":1,"b":"Module","c":{"fG":{"$":-1,"a":1,"b":"NormalModule","c":0,"d":{"$":-1,"a":1,"b":"EffectModule","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"PortModule","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["NormalModule","PortModule","EffectModule"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Syntax","TypeAnnotation"]},"c":{"$":-1,"a":1,"b":"TypeAnnotation","c":{"fG":{"$":-1,"a":1,"b":"Record","c":0,"d":{"$":-1,"a":1,"b":"GenericRecord","c":0,"d":{"$":-1,"a":1,"b":"FunctionTypeAnnotation","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"GenericType","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Typed","c":0,"d":{"$":-1,"a":1,"b":"Tupled","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Unit","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["GenericType","Typed","Unit","Tupled","Record","GenericRecord","FunctionTypeAnnotation"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Elm","Syntax","Pattern"]},"c":{"$":-1,"a":1,"b":"Pattern","c":{"fG":{"$":-1,"a":1,"b":"StringPattern","c":0,"d":{"$":-1,"a":0,"b":"HexPattern","c":0,"d":{"$":-1,"a":1,"b":"CharPattern","c":0,"d":{"$":-1,"a":1,"b":"AsPattern","c":0,"d":{"$":-1,"a":0,"b":"AllPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"FloatPattern","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"ParenthesizedPattern","c":0,"d":{"$":-1,"a":0,"b":"ListPattern","c":0,"d":{"$":-1,"a":1,"b":"IntPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NamedPattern","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"RecordPattern","c":0,"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"UnConsPattern","c":0,"d":{"$":-1,"a":1,"b":"TuplePattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"VarPattern","c":0,"d":{"$":-1,"a":0,"b":"UnitPattern","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}},"cX":{"$":"$L","a":["AllPattern","UnitPattern","CharPattern","StringPattern","IntPattern","HexPattern","FloatPattern","TuplePattern","RecordPattern","UnConsPattern","ListPattern","VarPattern","NamedPattern","AsPattern","ParenthesizedPattern"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Elm","Version"]},"c":{"$":-1,"a":1,"b":"Version","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph","DOT"]},"c":{"$":-1,"a":1,"b":"Rankdir","c":{"fG":{"$":-1,"a":1,"b":"LR","c":0,"d":{"$":-1,"a":1,"b":"BT","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"TB","c":0,"d":{"$":-1,"a":0,"b":"RL","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"cX":{"$":"$L","a":["TB","LR","BT","RL"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph"]},"c":{"$":-1,"a":1,"b":"Graph","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"AcyclicGraph","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Graph","Tree"]},"c":{"$":-1,"a":1,"b":"Tree","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Set"]},"c":{"$":-1,"a":1,"b":"Set","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Platform","Sub"]},"c":{"$":-1,"a":1,"b":"Sub","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Platform"]},"c":{"$":-1,"a":1,"b":"Program","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ProcessId","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Task","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Router","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Maybe"]},"c":{"$":-1,"a":1,"b":"Maybe","c":{"fG":{"$":-1,"a":1,"b":"Nothing","c":0,"d":{"$":-1,"a":0,"b":"Just","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Just","Nothing"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Platform","Cmd"]},"c":{"$":-1,"a":1,"b":"Cmd","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Rule"]},"c":{"$":-1,"a":1,"b":"ModuleRuleSchema","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"Error","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Direction","c":{"fG":{"$":-1,"a":1,"b":"OnExit","c":0,"d":{"$":-1,"a":0,"b":"OnEnter","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["OnEnter","OnExit"]}},"d":{"$":-1,"a":1,"b":"ContextCreator","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ElmJsonKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Metadata","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"Forbidden","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ModuleKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":"Required","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"ProjectRuleSchema","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ProjectData","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ReadmeKey","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"Rule","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Review","Fix"]},"c":{"$":-1,"a":1,"b":"Problem","c":{"fG":{"$":-1,"a":1,"b":"SourceCodeIsNotValid","c":0,"d":{"$":-1,"a":1,"b":"HasCollisionsInFixRanges","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Unchanged","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Unchanged","SourceCodeIsNotValid","HasCollisionsInFixRanges"]}},"d":{"$":-1,"a":0,"b":"FixResult","c":{"fG":{"$":-1,"a":1,"b":"Successful","c":0,"d":{"$":-1,"a":0,"b":"Errored","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Successful","Errored"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Result"]},"c":{"$":-1,"a":1,"b":"Result","c":{"fG":{"$":-1,"a":1,"b":"Ok","c":0,"d":{"$":-1,"a":0,"b":"Err","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"cX":{"$":"$L","a":["Ok","Err"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Project","Dependency"]},"c":{"$":-1,"a":1,"b":"Dependency","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Review","Test"]},"c":{"$":-1,"a":1,"b":"ReviewExpectation","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":1,"b":"ExpectedError","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"ReviewResult","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Html","Event"]},"c":{"$":-1,"a":1,"b":"Event","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Distribution"]},"c":{"$":-1,"a":1,"b":"DistributionReport","c":{"fG":{"$":-1,"a":1,"b":"DistributionToReport","c":0,"d":{"$":-1,"a":1,"b":"DistributionCheckSucceeded","c":0,"d":{"$":-1,"a":0,"b":"DistributionCheckFailed","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NoDistribution","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["NoDistribution","DistributionToReport","DistributionCheckSucceeded","DistributionCheckFailed"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["String"]},"c":{"$":-1,"a":1,"b":"String","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":{"$":"$L","a":["Test","Runner","Failure"]},"c":{"$":-1,"a":1,"b":"Reason","c":{"fG":{"$":-1,"a":1,"b":"ListDiff","c":0,"d":{"$":-1,"a":0,"b":"Custom","c":0,"d":{"$":-1,"a":1,"b":"Comparison","c":0,"d":{"$":-1,"a":0,"b":"CollectionDiff","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Invalid","c":0,"d":{"$":-1,"a":0,"b":"Equality","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"TODO","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Custom","Equality","Comparison","ListDiff","CollectionDiff","TODO","Invalid"]}},"d":{"$":-1,"a":0,"b":"InvalidReason","c":{"fG":{"$":-1,"a":1,"b":"DuplicatedName","c":0,"d":{"$":-1,"a":1,"b":"DistributionBug","c":0,"d":{"$":-1,"a":1,"b":"BadDescription","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"DistributionInsufficient","c":0,"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"InvalidFuzzer","c":0,"d":{"$":-1,"a":1,"b":"EmptyList","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"NonpositiveFuzzCount","c":0,"d":{"$":-2},"e":{"$":-2}}}},"cX":{"$":"$L","a":["EmptyList","NonpositiveFuzzCount","InvalidFuzzer","BadDescription","DuplicatedName","DistributionInsufficient","DistributionBug"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-1,"a":0,"b":{"$":"$L","a":["Test","Runner"]},"c":{"$":-1,"a":1,"b":"Simplifiable","c":{"fG":{"$":-2},"cX":{"$":0}},"d":{"$":-1,"a":0,"b":"SeededRunners","c":{"fG":{"$":-1,"a":1,"b":"Plain","c":0,"d":{"$":-1,"a":1,"b":"Only","c":0,"d":{"$":-1,"a":0,"b":"Invalid","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"Skipping","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["Plain","Only","Skipping","Invalid"]}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}}}}}}}}},"c_":{"$":0,"a":{"bT":{"$":0,"a":1211397742},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-2}}}},"ew":{"$":1},"b0":{"$":1},"I":{"$":-1,"a":1,"b":"src/Util.elm","c":{"bT":1775575040,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":53},"ci":{"bb":9,"bp":52}},"b":"AllPattern ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":56},"ci":{"bb":9,"bp":55}},"b":"UnitPattern ->\n            []"},{"$":1,"a":{"bV":{"bb":35,"bp":59},"ci":{"bb":9,"bp":58}},"b":"CharPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":62},"ci":{"bb":9,"bp":61}},"b":"StringPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":25,"bp":65},"ci":{"bb":9,"bp":64}},"b":"IntPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":21,"bp":68},"ci":{"bb":9,"bp":67}},"b":"HexPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":40,"bp":71},"ci":{"bb":9,"bp":70}},"b":"FloatPattern _ ->\n            []"},{"$":1,"a":{"bV":{"bb":21,"bp":74},"ci":{"bb":9,"bp":73}},"b":"TuplePattern ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":77},"ci":{"bb":9,"bp":76}},"b":"RecordPattern ps ->\n            List.map Node.value ps"},{"$":1,"a":{"bV":{"bb":15,"bp":80},"ci":{"bb":9,"bp":79}},"b":"UnConsPattern p ps ->\n            go [ p, ps ]"},{"$":1,"a":{"bV":{"bb":15,"bp":83},"ci":{"bb":9,"bp":82}},"b":"ListPattern ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":86},"ci":{"bb":9,"bp":85}},"b":"VarPattern name ->\n            [ name ]"},{"$":1,"a":{"bV":{"bb":15,"bp":89},"ci":{"bb":9,"bp":88}},"b":"NamedPattern _ ps ->\n            go ps"},{"$":1,"a":{"bV":{"bb":15,"bp":92},"ci":{"bb":9,"bp":91}},"b":"AsPattern p name ->\n            Node.value name :: go [ p ]"},{"$":1,"a":{"bV":{"bb":15,"bp":95},"ci":{"bb":9,"bp":94}},"b":"ParenthesizedPattern p ->\n            go [ p ]"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":51},"ci":{"bb":5,"bp":51}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":80,"bp":467},"ci":{"bb":17,"bp":458}},"b":"[] ->\n                    -- Unsortable, so simply use original order\n                    case compare d1.id d2.id of\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = 0 }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = 0 }\n\n                        EQ ->\n                            -- This should never happen\n                            Nothing"},{"$":1,"a":{"bV":{"bb":36,"bp":480},"ci":{"bb":17,"bp":469}},"b":"( priority, o ) :: os_ ->\n                    case o d1.label d2.label of\n                        EQ ->\n                            genEdge os_ ( d1, d2 )\n\n                        LT ->\n                            Just { from = d1.id, to = d2.id, label = priority }\n\n                        GT ->\n                            Just { from = d2.id, to = d1.id, label = priority }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":457},"ci":{"bb":13,"bp":457}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":73,"bp":476},"ci":{"bb":25,"bp":475}},"b":"EQ ->\n                            -- This should never happen\n                            Nothing"},{"$":1,"a":{"bV":{"bb":36,"bp":480},"ci":{"bb":25,"bp":478}},"b":"GT ->\n                            Just { from = d2.id, to = d1.id, label = 0 }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":471},"ci":{"bb":21,"bp":471}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":51,"bp":461},"ci":{"bb":25,"bp":460}},"b":"LT ->\n                            Just { from = d1.id, to = d2.id, label = priority }"},{"$":1,"a":{"bV":{"bb":80,"bp":464},"ci":{"bb":25,"bp":463}},"b":"EQ ->\n                            genEdge os_ ( d1, d2 )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":459},"ci":{"bb":21,"bp":459}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/Util.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":59,"bp":588},"ci":{"bb":9,"bp":575}},"b":"UnitExpr ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":591},"ci":{"bb":9,"bp":590}},"b":"Application es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":594},"ci":{"bb":9,"bp":593}},"b":"OperatorApplication _ _ e1 e2 ->\n            [ e1, e2 ]"},{"$":1,"a":{"bV":{"bb":58,"bp":597},"ci":{"bb":9,"bp":596}},"b":"FunctionOrValue _ _ ->\n            []"},{"$":1,"a":{"bV":{"bb":66,"bp":601},"ci":{"bb":9,"bp":599}},"b":"IfBlock predExpr thenExpr elseExpr ->\n            [ predExpr, thenExpr, elseExpr ]"},{"$":1,"a":{"bV":{"bb":15,"bp":604},"ci":{"bb":9,"bp":603}},"b":"PrefixOperator _ ->\n            []"},{"$":1,"a":{"bV":{"bb":57,"bp":608},"ci":{"bb":9,"bp":606}},"b":"Operator _ ->\n            []"},{"$":1,"a":{"bV":{"bb":23,"bp":611},"ci":{"bb":9,"bp":610}},"b":"Integer _ ->\n            []"},{"$":1,"a":{"bV":{"bb":45,"bp":614},"ci":{"bb":9,"bp":613}},"b":"Hex _ ->\n            []"},{"$":1,"a":{"bV":{"bb":27,"bp":617},"ci":{"bb":9,"bp":616}},"b":"Floatable _ ->\n            []"},{"$":1,"a":{"bV":{"bb":23,"bp":620},"ci":{"bb":9,"bp":619}},"b":"Negation e ->\n            [ e ]"},{"$":1,"a":{"bV":{"bb":18,"bp":623},"ci":{"bb":9,"bp":622}},"b":"Literal _ ->\n            []"},{"$":1,"a":{"bV":{"bb":18,"bp":626},"ci":{"bb":9,"bp":625}},"b":"CharLiteral _ ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":629},"ci":{"bb":9,"bp":628}},"b":"TupledExpression es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":632},"ci":{"bb":9,"bp":631}},"b":"ParenthesizedExpression e ->\n            [ e ]"},{"$":1,"a":{"bV":{"bb":15,"bp":635},"ci":{"bb":9,"bp":634}},"b":"LetExpression letBlock ->\n            let\n                subExprs : Node LetDeclaration -> Node Expression\n                subExprs n =\n                    case Node.value n of\n                        LetFunction { declaration } ->\n                            Node.value declaration\n                                |> .expression\n\n                        LetDestructuring _ e ->\n                            e\n            in\n            letBlock.expression\n                :: List.map subExprs letBlock.declarations"},{"$":1,"a":{"bV":{"bb":15,"bp":638},"ci":{"bb":9,"bp":637}},"b":"CaseExpression caseBlock ->\n            caseBlock.expression\n                :: List.map Tuple.second caseBlock.cases"},{"$":1,"a":{"bV":{"bb":15,"bp":641},"ci":{"bb":9,"bp":640}},"b":"LambdaExpression { expression } ->\n            [ expression ]"},{"$":1,"a":{"bV":{"bb":15,"bp":644},"ci":{"bb":9,"bp":643}},"b":"RecordExpr setters ->\n            List.map (Tuple.second << Node.value) setters"},{"$":1,"a":{"bV":{"bb":15,"bp":647},"ci":{"bb":9,"bp":646}},"b":"ListExpr es ->\n            es"},{"$":1,"a":{"bV":{"bb":15,"bp":650},"ci":{"bb":9,"bp":649}},"b":"RecordAccess record _ ->\n            [ record ]"},{"$":1,"a":{"bV":{"bb":15,"bp":653},"ci":{"bb":9,"bp":652}},"b":"RecordAccessFunction _ ->\n            []"},{"$":1,"a":{"bV":{"bb":15,"bp":656},"ci":{"bb":9,"bp":655}},"b":"RecordUpdateExpression record updaters ->\n            Node.map (FunctionOrValue []) record\n                :: List.map (Tuple.second << Node.value) updaters"},{"$":1,"a":{"bV":{"bb":15,"bp":659},"ci":{"bb":9,"bp":658}},"b":"GLSLExpression _ ->\n            []"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":574},"ci":{"bb":5,"bp":574}},"d_":"NoUnsortedCases","ff":0}]},"b6":598685499,"c7":false,"cd":{"O":{"$":-1,"a":1,"b":{"$":"$L","a":["Util"]},"c":{"$":-1,"a":1,"b":"GluedTo","c":{"fG":{"$":-1,"a":1,"b":"GluedBeforeFirst","c":0,"d":{"$":-1,"a":1,"b":"GluedAfterLast","c":0,"d":{"$":-1,"a":0,"b":"GluedAfterFirst","c":0,"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"GluedBeforeLast","c":0,"d":{"$":-2},"e":{"$":-2}}},"cX":{"$":"$L","a":["GluedBeforeFirst","GluedAfterFirst","GluedBeforeLast","GluedAfterLast"]}},"d":{"$":-2},"e":{"$":-2}},"d":{"$":-2},"e":{"$":-2}}}},"d":{"$":-1,"a":1,"b":"src/NoUnsortedRecords.elm","c":{"bT":42240150,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":604},"ci":{"bb":17,"bp":603}},"b":"( True, True ) ->\n                    addExposed (makeInfo ()) acc_"},{"$":1,"a":{"bV":{"bb":50,"bp":607},"ci":{"bb":17,"bp":606}},"b":"( True, False ) ->\n                    acc_"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":602},"ci":{"bb":13,"bp":602}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":18,"bp":687},"ci":{"bb":9,"bp":638}},"b":"AliasDeclaration { name, generics, typeAnnotation } ->\n            let\n                aliasInfo : ( String, TypeWithPositionalVars )\n                aliasInfo =\n                    ( n\n                    , typeAnnotToTypeWithPositionalVars context\n                        -- Constrained type vars are not respected for aliases\n                        { constrainedTypeVarsAreRespected = False\n                        , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                        }\n                        (List.map Node.value generics)\n                        typeAnnotation\n                    )\n\n                n : String\n                n =\n                    Node.value name\n            in\n            skipIfIgnored (Set.member n << .types)\n                { acc | exposedAliases = aliasInfo :: acc.exposedAliases }\n                (\\() ->\n                    annotToFields typeAnnotation\n                        |> MaybeX.unwrap ( [], [] )\n                            (\\( fields, isGeneric ) ->\n                                ( -- Generic records do not have constructors.\n                                  if isGeneric then\n                                    []\n\n                                  else\n                                    [ ( n\n                                      , { customTypeName = Nothing\n                                        , type_ =\n                                            List.map Node.value generics\n                                                |> (\\vars ->\n                                                        List.map\n                                                            (Node.value\n                                                                >> Tuple.second\n                                                                >> typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                            )\n                                                            fields\n                                                            |> makeFunctionTypeWithPositionalVars\n                                                                (typeAnnotToTypeWithPositionalVars context\n                                                                    { constrainedTypeVarsAreRespected = True\n                                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                                    }\n                                                                    vars\n                                                                    typeAnnotation\n                                                                )\n                                                   )\n                                        }\n                                      )\n                                    ]\n                                , knownRecordFromTypeAnnot subrecordTreatment context ( fields, isGeneric )\n                                    |> List.map (Tuple.mapFirst (\\s -> n ++ s))\n                                )\n                            )\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | aliases = aliasInfo :: acc.aliases\n                        , canonicalRecords = newRecords ++ acc.canonicalRecords\n                        , constructors = newConstructors ++ acc.constructors\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                        , exposedConstructors = newConstructors ++ acc.exposedConstructors\n                    }\n                )"},{"$":1,"a":{"bV":{"bb":18,"bp":762},"ci":{"bb":9,"bp":689}},"b":"CustomTypeDeclaration { name, generics, constructors } ->\n            let\n                n : String\n                n =\n                    Node.value name\n            in\n            skipIfIgnored (Set.member n << .openTypes)\n                acc\n                (\\() ->\n                    List.foldl\n                        (\\c ( fAcc, rAcc ) ->\n                            Node.value c\n                                |> makeConstructorAndSubrecords\n                                    (List.map Node.value generics\n                                        |> (\\gs ->\n                                                List.map (TypeVar Nothing) gs\n                                                    |> NamedType ( [], n )\n                                                    |> DereferencedType\n                                                    |> assignTypeVars (makePositionalArgTypeVars gs)\n                                                    |> getType\n                                                    |> TypeWithPositionalVars\n                                           )\n                                    )\n                                    generics\n                                |> (\\( n_, type_, rs ) ->\n                                        ( ( n_\n                                          , { customTypeName = Just n\n                                            , type_ = type_\n                                            }\n                                          )\n                                            :: fAcc\n                                        , rs ++ rAcc\n                                        )\n                                   )\n                        )\n                        ( [], [] )\n                        constructors\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | canonicalRecords = newRecords ++ acc.canonicalRecords\n                        , constructors = newConstructors ++ acc.constructors\n                    }\n                )\n                (\\( newConstructors, newRecords ) acc_ ->\n                    { acc_\n                        | exposedCanonicalRecords = newRecords ++ acc.exposedCanonicalRecords\n                        , exposedConstructors = newConstructors ++ acc.exposedConstructors\n                    }\n                )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":620},"ci":{"bb":5,"bp":620}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":58,"bp":853},"ci":{"bb":17,"bp":851}},"b":"UnitType ->\n                    UnitType"},{"$":1,"a":{"bV":{"bb":26,"bp":860},"ci":{"bb":17,"bp":855}},"b":"NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )"},{"$":1,"a":{"bV":{"bb":47,"bp":864},"ci":{"bb":17,"bp":862}},"b":"RecordType r ->\n                    RecordType\n                        { r\n                            | generic = Maybe.map go r.generic\n                            , fields = List.map (Tuple.mapSecond go) r.fields\n                        }"},{"$":1,"a":{"bV":{"bb":29,"bp":867},"ci":{"bb":17,"bp":866}},"b":"TypeVar _ var ->\n                    Dict.get var typeVars\n                        |> Maybe.withDefault t"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":841},"ci":{"bb":13,"bp":841}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":60,"bp":916},"ci":{"bb":9,"bp":914}},"b":"TuplePattern ps ->\n            getTupleTypes ps type_\n                |> List.map2 go ps\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":31,"bp":921},"ci":{"bb":9,"bp":918}},"b":"RecordPattern ps ->\n            getRecordFieldTypes type_\n                |> (\\ts ->\n                        List.map\n                            (\\p ->\n                                Dict.get (Node.value p) ts\n                                    |> makeType (Node.value p)\n                            )\n                            ps\n                   )\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":31,"bp":933},"ci":{"bb":9,"bp":923}},"b":"UnConsPattern p ps ->\n            -- `p` has type in list, and `ps` is overall list type\n            getListType type_\n                |> (\\t -> go p t ++ go ps type_)"},{"$":1,"a":{"bV":{"bb":90,"bp":943},"ci":{"bb":9,"bp":935}},"b":"ListPattern ps ->\n            getListType type_\n                |> (\\t -> List.concatMap (\\p -> go p t) ps)"},{"$":1,"a":{"bV":{"bb":49,"bp":948},"ci":{"bb":9,"bp":945}},"b":"VarPattern name ->\n            -- Bind `name` to the overall type\n            makeType name type_"},{"$":1,"a":{"bV":{"bb":32,"bp":952},"ci":{"bb":9,"bp":950}},"b":"NamedPattern { name } ps ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } type_ pattern name\n                |> Maybe.map (List.map2 (\\p t -> go p (Just t)) ps)\n                |> Maybe.map List.concat\n                -- No type info\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (\\p -> go p Nothing) ps)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":913},"ci":{"bb":5,"bp":913}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":1096},"ci":{"bb":9,"bp":1094}},"b":"Application es ->\n            -- Try to pull type info from known functions\n            checkApplicationChain config local hasType es"},{"$":1,"a":{"bV":{"bb":25,"bp":1100},"ci":{"bb":9,"bp":1098}},"b":"OperatorApplication op _ e1 e2 ->\n            -- Handle a few known operators\n            checkOperatorApplication (checkApplicationChain config local hasType) op e1 e2"},{"$":1,"a":{"bV":{"bb":41,"bp":1109},"ci":{"bb":9,"bp":1102}},"b":"IfBlock pred thenE elseE ->\n            -- List predicate must have type Bool and branches have same type as overall\n            go (Just <| DereferencedType <| NamedType ( [ \"Basics\" ], \"Bool\" ) []) pred ++ go hasType thenE ++ go hasType elseE"},{"$":1,"a":{"bV":{"bb":58,"bp":1113},"ci":{"bb":9,"bp":1111}},"b":"Negation e ->\n            -- Negation doesn't change a type\n            go hasType e"},{"$":1,"a":{"bV":{"bb":91,"bp":1117},"ci":{"bb":9,"bp":1115}},"b":"TupledExpression es ->\n            -- Tuples must have a tuple type\n            List.map2 go (getTupleTypes es hasType) es\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":128,"bp":1121},"ci":{"bb":9,"bp":1119}},"b":"ParenthesizedExpression e ->\n            -- Parentheses don't change a type\n            go hasType e"},{"$":1,"a":{"bV":{"bb":31,"bp":1126},"ci":{"bb":9,"bp":1123}},"b":"LetExpression { declarations, expression } ->\n            -- Create new bindings from any that have type info\n            let\n                ( newBindings, decsToCheck ) =\n                    List.map (checkLetDeclaration config local << Node.value) declarations\n                        |> List.unzip\n                        |> Tuple.mapFirst (Dict.fromList << List.concat)\n\n                newContext : LocalContext\n                newContext =\n                    { local | localFunctions = Dict.union local.localFunctions newBindings }\n            in\n            checkExpression config newContext hasType expression\n                ++ List.concatMap (\\f -> f newContext) decsToCheck"},{"$":1,"a":{"bV":{"bb":67,"bp":1165},"ci":{"bb":9,"bp":1152}},"b":"RecordExpr recordSetters ->\n            -- A record expression has to have all fields of the known record\n            let\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes hasType\n            in\n            recordSettersToCheckable local (Node.range node) True hasType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)"},{"$":1,"a":{"bV":{"bb":70,"bp":1177},"ci":{"bb":9,"bp":1167}},"b":"ListExpr es ->\n            let\n                -- Lists must have a list type\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) es"},{"$":1,"a":{"bV":{"bb":70,"bp":1196},"ci":{"bb":9,"bp":1179}},"b":"RecordAccess e accessFunc ->\n            go (makeRecordAccessType hasType <| Node.value accessFunc) e"},{"$":1,"a":{"bV":{"bb":73,"bp":1199},"ci":{"bb":9,"bp":1198}},"b":"RecordUpdateExpression _ recordSetters ->\n            -- A record update must have the same type as the record, so type is useful\n            -- A record update expression does not have to have all fields of the known record\n            let\n                ts : Dict String DereferencedType\n                ts =\n                    getRecordFieldTypes updateType\n\n                updateType : Maybe DereferencedType\n                updateType =\n                    -- Get type from updated var if we don't have a good annotation\n                    hasType\n                        |> MaybeX.orElseLazy (\\() -> inferExprType local node)\n            in\n            recordSettersToCheckable local (Node.range node) False updateType recordSetters\n                |> checkRecord config local.context\n                -- Used any found record information to check subrecords\n                |> checkFields ts (List.map Node.value recordSetters)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1092},"ci":{"bb":5,"bp":1092}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":32,"bp":1281},"ci":{"bb":9,"bp":1280}},"b":"\"<|\" ->\n            checkApp [ e1, e2 ]"},{"$":1,"a":{"bV":{"bb":32,"bp":1284},"ci":{"bb":9,"bp":1283}},"b":"\"|>\" ->\n            checkApp [ e2, e1 ]"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1279},"ci":{"bb":5,"bp":1279}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":1313},"ci":{"bb":9,"bp":1306}},"b":"RecordPattern fields ->\n            recordPatternToCheckable (Node.range node) hasType fields\n                |> checkRecord config context\n                -- No such thing as subrecords for patterns, so we can just return the errors\n                |> Tuple.first"},{"$":1,"a":{"bV":{"bb":41,"bp":1322},"ci":{"bb":9,"bp":1315}},"b":"UnConsPattern p ps ->\n            let\n                -- Uncons has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            go type_ p ++ go type_ ps"},{"$":1,"a":{"bV":{"bb":25,"bp":1326},"ci":{"bb":9,"bp":1324}},"b":"ListPattern ps ->\n            let\n                -- List pattern has to be a list\n                type_ : Maybe DereferencedType\n                type_ =\n                    getListType hasType\n            in\n            List.concatMap (go type_) ps"},{"$":1,"a":{"bV":{"bb":25,"bp":1330},"ci":{"bb":9,"bp":1328}},"b":"NamedPattern { name } pats ->\n            -- Get type info we've stored and use it to check\n            -- Note that while `findFunctionType` requires local context, a pattern can only be a constructor,\n            -- which cannot be local, so we can just create an empty local context here.\n            findFunctionType { context = context, localFunctions = Dict.empty } hasType node name\n                |> Maybe.map (List.map2 (\\p t -> go (Just t) p) pats)\n                |> Maybe.map List.concat\n                |> MaybeX.withDefaultLazy (\\() -> List.concatMap (go Nothing) pats)"},{"$":1,"a":{"bV":{"bb":84,"bp":1339},"ci":{"bb":9,"bp":1332}},"b":"AsPattern p _ ->\n            -- As pattern does not change type\n            go hasType p"},{"$":1,"a":{"bV":{"bb":31,"bp":1345},"ci":{"bb":9,"bp":1341}},"b":"ParenthesizedPattern p ->\n            -- Parentheses do not change type\n            go hasType p"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1300},"ci":{"bb":5,"bp":1300}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":57,"bp":1536},"ci":{"bb":9,"bp":1531}},"b":"GenericType _ ->\n            []"},{"$":1,"a":{"bV":{"bb":71,"bp":1543},"ci":{"bb":9,"bp":1538}},"b":"Typed _ types_ ->\n            let\n                typeVars : List (Maybe DereferencedType)\n                typeVars =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (NamedType _ ts) ->\n                            List.map (Just << DereferencedType) ts\n\n                        Just (ListType t) ->\n                            [ Just <| DereferencedType t ]\n\n                        _ ->\n                            List.map (always Nothing) types_\n            in\n            List.map2 go typeVars types_\n                |> List.concat"},{"$":1,"a":{"bV":{"bb":47,"bp":1556},"ci":{"bb":9,"bp":1546}},"b":"Unit ->\n            []"},{"$":1,"a":{"bV":{"bb":31,"bp":1578},"ci":{"bb":9,"bp":1563}},"b":"Record def ->\n            (recordDefToCheckable context (Node.range type_) True hasTypeFromParent def\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value def)"},{"$":1,"a":{"bV":{"bb":15,"bp":1582},"ci":{"bb":9,"bp":1581}},"b":"GenericRecord _ def ->\n            (recordDefToCheckable context (Node.range type_) False hasTypeFromParent (Node.value def)\n                |> checkRecord config context\n            )\n                -- Used any found record information to check subrecords\n                |> checkFields (List.map Node.value <| Node.value def)"},{"$":1,"a":{"bV":{"bb":15,"bp":1585},"ci":{"bb":9,"bp":1584}},"b":"FunctionTypeAnnotation fromA toA ->\n            let\n                ( fromType, toType ) =\n                    case Maybe.map getType hasTypeFromParent of\n                        Just (FunctionType { from, to }) ->\n                            ( Just <| DereferencedType from, Just <| DereferencedType to )\n\n                        _ ->\n                            ( Nothing, Nothing )\n            in\n            go fromType fromA ++ go toType toA"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1529},"ci":{"bb":5,"bp":1529}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":67,"bp":1569},"ci":{"bb":25,"bp":1568}},"b":"Just (ListType t) ->\n                            [ Just <| DereferencedType t ]"},{"$":1,"a":{"bV":{"bb":59,"bp":1572},"ci":{"bb":25,"bp":1571}},"b":"Just (NamedType _ ts) ->\n                            List.map (Just << DereferencedType) ts"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":1567},"ci":{"bb":21,"bp":1567}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":30,"bp":1853},"ci":{"bb":25,"bp":1822}},"b":"Elm.Type.Record fields (Just _) ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, True )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , -- No constructors for generic records\n                              []\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":1860},"ci":{"bb":25,"bp":1855}},"b":"Elm.Type.Record fields Nothing ->\n                            ( knownRecordFromDocType subrecordTreatment moduleName ( fields, False )\n                                |> List.map (Tuple.mapFirst (\\s -> name ++ s))\n                            , [ ( name\n                                , { customTypeName = Nothing\n                                  , type_ =\n                                        List.map\n                                            (Tuple.second\n                                                >> docTypeToTypeWithPositionalVars moduleName\n                                                    -- Constrained type vars do apply to record constructors\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Arguments only have order if config says so\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForField subrecordTreatment\n                                                    }\n                                                    args\n                                            )\n                                            fields\n                                            |> makeFunctionTypeWithPositionalVars\n                                                (docTypeToTypeWithPositionalVars moduleName\n                                                    { constrainedTypeVarsAreRespected = True\n\n                                                    -- Return type *does* have order\n                                                    , subrecordIsAlsoCanonical = subrecordCanonicityForRecord subrecordTreatment\n                                                    }\n                                                    args\n                                                    tipe\n                                                )\n                                  }\n                                )\n                              ]\n                            )"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":1821},"ci":{"bb":21,"bp":1821}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":56,"bp":1984},"ci":{"bb":9,"bp":1983}},"b":"Elm.Type.Var s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":40,"bp":1987},"ci":{"bb":9,"bp":1986}},"b":"Elm.Type.Lambda from to ->\n            FunctionType { from = go from, to = go to }"},{"$":1,"a":{"bV":{"bb":21,"bp":2005},"ci":{"bb":9,"bp":1989}},"b":"Elm.Type.Tuple ts ->\n            TupleType <| List.map go ts"},{"$":1,"a":{"bV":{"bb":18,"bp":2016},"ci":{"bb":9,"bp":2007}},"b":"Elm.Type.Type qualified args ->\n            -- Can't use module name lookup, so just have to hope this is right.\n            String.split \".\" qualified\n                |> ListX.unconsLast\n                |> Maybe.map\n                    (\\( n, m ) ->\n                        if m == [] then\n                            ( moduleName, n )\n\n                        else\n                            ( m, n )\n                    )\n                |> Maybe.withDefault ( moduleName, qualified )\n                |> (\\( mod, name ) ->\n                        makeList mod name args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( mod, name ) <| List.map go args)\n                   )"},{"$":1,"a":{"bV":{"bb":58,"bp":2019},"ci":{"bb":9,"bp":2018}},"b":"Elm.Type.Record fields generic ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Maybe.map (TypeVar Nothing) generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapSecond go) fields\n                }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1982},"ci":{"bb":5,"bp":1982}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":72,"bp":2328},"ci":{"bb":17,"bp":2327}},"b":"InfixExpose name ->\n                    { acc | functions = Set.insert name acc.functions }"},{"$":1,"a":{"bV":{"bb":72,"bp":2331},"ci":{"bb":17,"bp":2330}},"b":"FunctionExpose name ->\n                    { acc | functions = Set.insert name acc.functions }"},{"$":1,"a":{"bV":{"bb":72,"bp":2334},"ci":{"bb":17,"bp":2333}},"b":"TypeOrAliasExpose name ->\n                    { acc | types = Set.insert name acc.types }"},{"$":1,"a":{"bV":{"bb":64,"bp":2337},"ci":{"bb":17,"bp":2336}},"b":"TypeExpose { name } ->\n                    { acc | openTypes = Set.insert name acc.openTypes }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":2326},"ci":{"bb":13,"bp":2326}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":65,"bp":2498},"ci":{"bb":17,"bp":2497}},"b":"Application es ->\n                    inferApplicationChain local es\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":65,"bp":2501},"ci":{"bb":17,"bp":2500}},"b":"OperatorApplication op _ e1 e2 ->\n                    -- Handle a few known operators\n                    checkOperatorApplication (inferApplicationChain local) op e1 e2\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":67,"bp":2504},"ci":{"bb":17,"bp":2503}},"b":"FunctionOrValue _ name ->\n                    findFunctionType local Nothing node name\n                        |> makeFunc typeVarPrefix"},{"$":1,"a":{"bV":{"bb":68,"bp":2507},"ci":{"bb":17,"bp":2506}},"b":"IfBlock _ e1 e2 ->\n                    -- Try to infer either side and unify\n                    [ go (typeVarPrefix ++ \"If Block True\") e1, go (typeVarPrefix ++ \"If Block False\") e2 ]\n                        |> MaybeX.values\n                        |> unifyTypes"},{"$":1,"a":{"bV":{"bb":64,"bp":2510},"ci":{"bb":17,"bp":2509}},"b":"PrefixOperator p ->\n                    findOperatorType local.context p\n                        |> makeFunc typeVarPrefix"},{"$":1,"a":{"bV":{"bb":47,"bp":2515},"ci":{"bb":17,"bp":2512}},"b":"Operator _ ->\n                    Nothing"},{"$":1,"a":{"bV":{"bb":50,"bp":2527},"ci":{"bb":17,"bp":2517}},"b":"Integer _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []"},{"$":1,"a":{"bV":{"bb":119,"bp":2541},"ci":{"bb":17,"bp":2529}},"b":"Hex _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Int\" ) []"},{"$":1,"a":{"bV":{"bb":50,"bp":2545},"ci":{"bb":17,"bp":2543}},"b":"Floatable _ ->\n                    Just <| NamedType ( [ \"Basics\" ], \"Float\" ) []"},{"$":1,"a":{"bV":{"bb":39,"bp":2549},"ci":{"bb":17,"bp":2547}},"b":"Negation e ->\n                    go typeVarPrefix e"},{"$":1,"a":{"bV":{"bb":39,"bp":2552},"ci":{"bb":17,"bp":2551}},"b":"Literal _ ->\n                    Just <| NamedType ( [ \"String\" ], \"String\" ) []"},{"$":1,"a":{"bV":{"bb":38,"bp":2558},"ci":{"bb":17,"bp":2554}},"b":"CharLiteral _ ->\n                    Just <| NamedType ( [ \"Char\" ], \"Char\" ) []"},{"$":1,"a":{"bV":{"bb":50,"bp":2562},"ci":{"bb":17,"bp":2560}},"b":"TupledExpression es ->\n                    List.indexedMap (\\i e -> go (typeVarPrefix ++ \"Tuple Expression \" ++ String.fromInt i) e) es\n                        |> MaybeX.combine\n                        |> Maybe.map TupleType"},{"$":1,"a":{"bV":{"bb":38,"bp":2568},"ci":{"bb":17,"bp":2564}},"b":"ParenthesizedExpression e ->\n                    -- Type is just whatever is in parentheses\n                    go typeVarPrefix e"},{"$":1,"a":{"bV":{"bb":45,"bp":2572},"ci":{"bb":17,"bp":2570}},"b":"LetExpression { declarations, expression } ->\n                    let\n                        newBindings : Dict String Type\n                        newBindings =\n                            List.concatMap (bindingsFromLetDeclaration local << Node.value) declarations\n                                |> Dict.fromList\n                    in\n                    inferExprType { local | localFunctions = Dict.union local.localFunctions newBindings } expression\n                        |> Maybe.map (prefixTypeVars typeVarPrefix)\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":38,"bp":2586},"ci":{"bb":17,"bp":2574}},"b":"CaseExpression { cases } ->\n                    -- Try to infer all cases and unify\n                    List.indexedMap (\\i ( _, e ) -> go (typeVarPrefix ++ \"Case Expression \" ++ String.fromInt i) e) cases\n                        |> MaybeX.values\n                        |> unifyTypes"},{"$":1,"a":{"bV":{"bb":45,"bp":2597},"ci":{"bb":17,"bp":2588}},"b":"LambdaExpression { args, expression } ->\n                    let\n                        unwrapArgs : List String -> Maybe Type\n                        unwrapArgs xs =\n                            ListX.uncons xs\n                                |> MaybeX.unpack (\\() -> go typeVarPrefix expression)\n                                    (\\( x, xs_ ) ->\n                                        unwrapArgs xs_\n                                            |> Maybe.map (\\t -> FunctionType { from = TypeVar Nothing <| typeVarPrefix ++ x, to = t })\n                                    )\n                    in\n                    List.indexedMap (\\i _ -> \"lambda arg\" ++ String.fromInt i) args\n                        |> unwrapArgs"},{"$":1,"a":{"bV":{"bb":28,"bp":2600},"ci":{"bb":17,"bp":2599}},"b":"RecordExpr rs ->\n                    rs\n                        |> List.map\n                            (\\n ->\n                                let\n                                    ( f, e ) =\n                                        Node.value n\n                                in\n                                go (typeVarPrefix ++ \"Record Field \" ++ Node.value f) e\n                                    |> Maybe.map (Tuple.pair (Node.value f))\n                            )\n                        |> MaybeX.combine\n                        |> Maybe.map (\\fields -> RecordType { generic = Nothing, canonical = False, fields = fields })"},{"$":1,"a":{"bV":{"bb":29,"bp":2617},"ci":{"bb":17,"bp":2602}},"b":"ListExpr es ->\n                    if List.isEmpty es then\n                        -- An empty list can be anything\n                        Just (ListType (TypeVar Nothing <| typeVarPrefix ++ \"inferred empty list typevar\"))\n\n                    else\n                        -- Have to check all and unify\n                        List.indexedMap (\\i e -> go (typeVarPrefix ++ \"List Element \" ++ String.fromInt i) e) es\n                            |> MaybeX.values\n                            |> unifyTypes\n                            |> Maybe.map ListType"},{"$":1,"a":{"bV":{"bb":28,"bp":2620},"ci":{"bb":17,"bp":2619}},"b":"RecordAccess e accessFunc ->\n                    go typeVarPrefix e\n                        |> Maybe.map DereferencedType\n                        |> getRecordFieldTypes\n                        |> (\\ts ->\n                                Node.value accessFunc\n                                    |> makeAccessFunc\n                                    |> (\\f -> Dict.get f ts)\n                           )\n                        |> Maybe.map getType"},{"$":1,"a":{"bV":{"bb":45,"bp":2625},"ci":{"bb":17,"bp":2622}},"b":"RecordAccessFunction accessFunc ->\n                    -- We know the expression being accessed is a record with a field of the type of the total expression\n                    makeAccessFunc accessFunc\n                        |> (\\f ->\n                                Just <|\n                                    FunctionType\n                                        { from =\n                                            RecordType\n                                                -- This is, in essence, a generic record with one field\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"record access inferred for \" ++ f\n                                                , canonical = False\n                                                , fields = [ ( f, TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f ) ]\n                                                }\n                                        , to = TypeVar Nothing <| typeVarPrefix ++ \"record access inferred field for \" ++ f\n                                        }\n                           )"},{"$":1,"a":{"bV":{"bb":45,"bp":2636},"ci":{"bb":17,"bp":2627}},"b":"RecordUpdateExpression var fs ->\n                    findFunctionType local Nothing var (Node.value var)\n                        |> makeFunc typeVarPrefix\n                        |> MaybeX.orElseLazy\n                            (\\() ->\n                                MaybeX.traverse ((\\( f, e ) -> go (typeVarPrefix ++ \"Record Update Field \" ++ Node.value f) e |> Maybe.map (Tuple.pair (Node.value f))) << Node.value) fs\n                                    |> Maybe.map\n                                        (\\fields ->\n                                            RecordType\n                                                { generic = Just <| TypeVar Nothing <| typeVarPrefix ++ \"inferred update generic\"\n                                                , canonical = False\n                                                , fields = fields\n                                                }\n                                        )\n                            )"},{"$":1,"a":{"bV":{"bb":30,"bp":2652},"ci":{"bb":17,"bp":2638}},"b":"GLSLExpression _ ->\n                    Nothing"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":2492},"ci":{"bb":13,"bp":2492}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":20,"bp":2800},"ci":{"bb":9,"bp":2799}},"b":"CanonicalWhenSubrecord ->\n            Nothing"},{"$":1,"a":{"bV":{"bb":20,"bp":2803},"ci":{"bb":9,"bp":2802}},"b":"CustomTypeArgsAlwaysCanonical ->\n            Just False"},{"$":1,"a":{"bV":{"bb":23,"bp":2806},"ci":{"bb":9,"bp":2805}},"b":"AlwaysUnknown ->\n            Nothing"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":10,"bp":2798},"ci":{"bb":6,"bp":2798}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":61,"bp":2929},"ci":{"bb":29,"bp":2928}},"b":"Just (UnknownFields fs_) ->\n                                let\n                                    alph : List String\n                                    alph =\n                                        List.sort fs_\n                                in\n                                ( List.map\n                                    (\\f ->\n                                        ( f.field\n                                        , ListX.elemIndex f.field alph\n                                            |> Maybe.withDefault -1\n                                            |> (+) ((offsetMult + 1) * genericOffset)\n                                        )\n                                    )\n                                    fs\n                                    |> Dict.fromList\n                                , True\n                                )"},{"$":1,"a":{"bV":{"bb":34,"bp":2948},"ci":{"bb":29,"bp":2931}},"b":"Just (OrderedFields order) ->\n                                go (offsetMult + 1) fs order"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":29,"bp":2927},"ci":{"bb":25,"bp":2927}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3111},"ci":{"bb":17,"bp":3110}},"b":"NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3114},"ci":{"bb":17,"bp":3113}},"b":"NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3109},"ci":{"bb":13,"bp":3109}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3086},"ci":{"bb":17,"bp":3085}},"b":"TupleType ts ->\n                    List.all typeIsComparable ts"},{"$":1,"a":{"bV":{"bb":25,"bp":3089},"ci":{"bb":17,"bp":3088}},"b":"ListType t_ ->\n                    typeIsComparable t_"},{"$":1,"a":{"bV":{"bb":25,"bp":3092},"ci":{"bb":17,"bp":3091}},"b":"NamedType ( [ \"Basics\" ], \"Float\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3095},"ci":{"bb":17,"bp":3094}},"b":"NamedType ( [ \"Basics\" ], \"Int\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":40,"bp":3098},"ci":{"bb":17,"bp":3097}},"b":"NamedType ( [ \"Char\" ], \"Char\" ) [] ->\n                    True"},{"$":1,"a":{"bV":{"bb":49,"bp":3101},"ci":{"bb":17,"bp":3100}},"b":"NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3084},"ci":{"bb":13,"bp":3084}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":25,"bp":3073},"ci":{"bb":17,"bp":3072}},"b":"ListType _ ->\n                    True"},{"$":1,"a":{"bV":{"bb":25,"bp":3076},"ci":{"bb":17,"bp":3075}},"b":"NamedType ( [ \"String\" ], \"String\" ) [] ->\n                    True"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3071},"ci":{"bb":13,"bp":3071}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":35,"bp":3125},"ci":{"bb":9,"bp":3124}},"b":"Number ->\n            typeIsNumber type_"},{"$":1,"a":{"bV":{"bb":61,"bp":3128},"ci":{"bb":9,"bp":3127}},"b":"Comparable ->\n            typeIsComparable type_"},{"$":1,"a":{"bV":{"bb":31,"bp":3131},"ci":{"bb":9,"bp":3130}},"b":"CompAppend ->\n            typeIsAppendable type_ && typeIsComparable type_"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":3120},"ci":{"bb":5,"bp":3120}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":58,"bp":3243},"ci":{"bb":17,"bp":3241}},"b":"UnitType ->\n                    UnitType"},{"$":1,"a":{"bV":{"bb":26,"bp":3250},"ci":{"bb":17,"bp":3245}},"b":"NamedType ( moduleName, name ) ts ->\n                    List.map go ts\n                        |> NamedType ( moduleName, name )"},{"$":1,"a":{"bV":{"bb":50,"bp":3253},"ci":{"bb":17,"bp":3252}},"b":"RecordType r ->\n                    RecordType\n                        { r\n                            | generic = Maybe.map go r.generic\n                            , fields = List.map (Tuple.mapSecond go) r.fields\n                        }"},{"$":1,"a":{"bV":{"bb":29,"bp":3256},"ci":{"bb":17,"bp":3255}},"b":"TypeVar class var ->\n                    TypeVar class (prefix ++ var)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3231},"ci":{"bb":13,"bp":3231}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":21,"bp":3634},"ci":{"bb":9,"bp":3619}},"b":"GenericType s ->\n            makeTypeVar constrainedTypeVarsAreRespected s"},{"$":1,"a":{"bV":{"bb":21,"bp":3637},"ci":{"bb":9,"bp":3636}},"b":"Typed name args ->\n            moduleNameFor context.lookupTable name\n                |> Maybe.withDefault (Tuple.first <| Node.value name)\n                |> (\\moduleName ->\n                        if moduleName == [] then\n                            -- If the module name is empty, then update to current module name\n                            context.moduleName\n\n                        else\n                            moduleName\n                   )\n                |> Tuple.pair (Tuple.second <| Node.value name)\n                |> (\\( n, moduleName ) ->\n                        makeList moduleName n args\n                            |> MaybeX.withDefaultLazy (\\() -> NamedType ( moduleName, n ) <| List.map go args)\n                   )"},{"$":1,"a":{"bV":{"bb":40,"bp":3640},"ci":{"bb":9,"bp":3639}},"b":"Unit ->\n            UnitType"},{"$":1,"a":{"bV":{"bb":18,"bp":3647},"ci":{"bb":9,"bp":3642}},"b":"Tupled ts ->\n            TupleType <| List.map go ts"},{"$":1,"a":{"bV":{"bb":18,"bp":3658},"ci":{"bb":9,"bp":3649}},"b":"Record fs ->\n            RecordType\n                { generic = Nothing\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) fs\n                }"},{"$":1,"a":{"bV":{"bb":56,"bp":3661},"ci":{"bb":9,"bp":3660}},"b":"GenericRecord generic fs ->\n            RecordType\n                { generic =\n                    -- Generic records completely ignore typeclasses, i.e.\n                    -- `type alias G comparable = { comparable | x : Int }`\n                    -- is just a normal generic record.\n                    Just <| TypeVar Nothing <| Node.value generic\n                , canonical = subrecordIsAlsoCanonical /= Nothing\n                , fields = List.map (Tuple.mapBoth Node.value go << Node.value) <| Node.value fs\n                }"},{"$":1,"a":{"bV":{"bb":58,"bp":3664},"ci":{"bb":9,"bp":3663}},"b":"FunctionTypeAnnotation from to ->\n            FunctionType { from = go from, to = go to }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":3618},"ci":{"bb":5,"bp":3618}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":3727},"ci":{"bb":17,"bp":3726}},"b":"( FunctionType f1, FunctionType f2 ) ->\n                    checkListOfTypes typeVars [ f1.from, f1.to ] [ f1.from, f2.to ]"},{"$":1,"a":{"bV":{"bb":84,"bp":3734},"ci":{"bb":17,"bp":3733}},"b":"( ListType t1, ListType t2 ) ->\n                    go typeVars t1 t2"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":3719},"ci":{"bb":13,"bp":3719}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":3825},"ci":{"bb":9,"bp":3823}},"b":"( TupleType t1s, TupleType t2s ) ->\n            ListX.zip t1s t2s\n                |> MaybeX.traverse (\\( t1, t2 ) -> unifyTypes [ t1, t2 ])\n                |> Maybe.map TupleType"},{"$":1,"a":{"bV":{"bb":39,"bp":3830},"ci":{"bb":9,"bp":3827}},"b":"( ListType t1, ListType t2 ) ->\n            unifyTypes [ t1, t2 ]\n                |> Maybe.map ListType"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":3805},"ci":{"bb":5,"bp":3805}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedRecords.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":87,"bp":3857},"ci":{"bb":41,"bp":3856}},"b":"( ( Just (TypeVar _ _), _ ), ( Nothing, [] ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ ++ only2 }"},{"$":1,"a":{"bV":{"bb":96,"bp":3860},"ci":{"bb":41,"bp":3859}},"b":"( ( Nothing, [] ), ( Just (TypeVar _ _), _ ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ ++ only1 }"},{"$":1,"a":{"bV":{"bb":96,"bp":3863},"ci":{"bb":41,"bp":3862}},"b":"( ( Nothing, [] ), ( Nothing, [] ) ) ->\n                                            Just <| RecordType { r1 | fields = both_ }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":41,"bp":3852},"ci":{"bb":37,"bp":3852}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":1,"b":"src/NoUnsortedLetDeclarations.elm","c":{"bT":2099862753,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":292},"ci":{"bb":25,"bp":291}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":295},"ci":{"bb":25,"bp":294}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":290},"ci":{"bb":21,"bp":290}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":332},"ci":{"bb":25,"bp":331}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":335},"ci":{"bb":25,"bp":334}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":330},"ci":{"bb":21,"bp":330}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedLetDeclarations.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":458},"ci":{"bb":25,"bp":457}},"b":"( True, False ) ->\n                            GT"},{"$":1,"a":{"bV":{"bb":31,"bp":461},"ci":{"bb":25,"bp":460}},"b":"( False, True ) ->\n                            LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":456},"ci":{"bb":21,"bp":456}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":0,"b":"src/NoUnsortedCases.elm","c":{"bT":3449543431,"bd":{"$":"$L","a":[{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":80,"bp":641},"ci":{"bb":9,"bp":639}},"b":"( True, True ) ->\n            -- Compare normally if neither does\n            compare (List.length p1s.subpatterns) (List.length p2s.subpatterns)"},{"$":1,"a":{"bV":{"bb":15,"bp":644},"ci":{"bb":9,"bp":643}},"b":"( True, False ) ->\n            LT"},{"$":1,"a":{"bV":{"bb":15,"bp":647},"ci":{"bb":9,"bp":646}},"b":"( False, True ) ->\n            GT"},{"$":1,"a":{"bV":{"bb":80,"bp":651},"ci":{"bb":9,"bp":649}},"b":"( False, False ) ->\n            -- Flip comparison if both end in wildcards\n            compare (List.length p2s.subpatterns) (List.length p1s.subpatterns)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":638},"ci":{"bb":5,"bp":638}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":33,"bp":677},"ci":{"bb":9,"bp":676}},"b":"( Constructor c1, Constructor c2 ) ->\n            let\n                goSubs : List (Maybe SortablePattern) -> List (Maybe SortablePattern) -> () -> Maybe Order\n                goSubs pat1s pat2s () =\n                    case ( pat1s, pat2s, lookPastUnsortable ) of\n                        ( (Just p1) :: p1s, (Just p2) :: p2s, _ ) ->\n                            goSubs p1s p2s\n                                |> fallbackCompareWithUnsortableFor (go p1 p2)\n\n                        ( Nothing :: p1s, Nothing :: p2s, True ) ->\n                            -- If at the point where arguments are both unsortable, then proceed past if configured to\n                            goSubs p1s p2s ()\n\n                        ( [], [], _ ) ->\n                            -- Both lists of subpatterns exhausted without a \"winner\", so return EQ\n                            Just EQ\n\n                        _ ->\n                            -- Lists should be even, so other cases aren't sortable\n                            Nothing\n            in\n            -- Fallback to subpatterns\n            goSubs c1.subpatterns c2.subpatterns\n                |> fallbackCompareWithUnsortableFor (Just <| compare c1.order c2.order)"},{"$":1,"a":{"bV":{"bb":88,"bp":703},"ci":{"bb":9,"bp":680}},"b":"( ListTupleOrUncons r1, ListTupleOrUncons r2 ) ->\n            case\n                ( ( r1.subpatterns, r1.terminates )\n                , ( r2.subpatterns, r2.terminates )\n                )\n            of\n                -- If the lists are the same length, infinite ones go later\n                ( ( [], False ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( [], True ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], _ ), ( [], _ ) ) ->\n                    Just EQ\n\n                -- If one list is shorter than another, it goes after if it is infinite or before if it isn't\n                ( ( _ :: _, _ ), ( [], True ) ) ->\n                    Just GT\n\n                ( ( _ :: _, _ ), ( [], False ) ) ->\n                    Just LT\n\n                ( ( [], True ), ( _ :: _, _ ) ) ->\n                    Just LT\n\n                ( ( [], False ), ( _ :: _, _ ) ) ->\n                    Just GT\n\n                -- Otherwise, compare the lists sequentially\n                ( ( p1 :: p1s, _ ), ( p2 :: p2s, _ ) ) ->\n                    compareNonemptyListPatterns ruleConfig ( r1, p1, p1s ) ( r2, p2, p2s )"},{"$":1,"a":{"bV":{"bb":91,"bp":737},"ci":{"bb":9,"bp":706}},"b":"( Literal l1, Literal l2 ) ->\n            compareLiteral l1 l2"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":663},"ci":{"bb":5,"bp":663}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":28,"bp":714},"ci":{"bb":17,"bp":713}},"b":"( ( [], True ), ( [], False ) ) ->\n                    Just LT"},{"$":1,"a":{"bV":{"bb":28,"bp":717},"ci":{"bb":17,"bp":716}},"b":"( ( [], False ), ( [], True ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":724},"ci":{"bb":17,"bp":723}},"b":"( ( [], True ), ( _ :: _, _ ) ) ->\n                    Just LT"},{"$":1,"a":{"bV":{"bb":28,"bp":727},"ci":{"bb":17,"bp":726}},"b":"( ( [], False ), ( _ :: _, _ ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":730},"ci":{"bb":17,"bp":729}},"b":"( ( _ :: _, _ ), ( [], True ) ) ->\n                    Just GT"},{"$":1,"a":{"bV":{"bb":28,"bp":733},"ci":{"bb":17,"bp":732}},"b":"( ( _ :: _, _ ), ( [], False ) ) ->\n                    Just LT"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":17,"bp":707},"ci":{"bb":13,"bp":707}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":79,"bp":687},"ci":{"bb":25,"bp":685}},"b":"( [], [], _ ) ->\n                            -- Both lists of subpatterns exhausted without a \"winner\", so return EQ\n                            Just EQ"},{"$":1,"a":{"bV":{"bb":46,"bp":691},"ci":{"bb":25,"bp":689}},"b":"( (Just p1) :: p1s, (Just p2) :: p2s, _ ) ->\n                            goSubs p1s p2s\n                                |> fallbackCompareWithUnsortableFor (go p1 p2)"},{"$":1,"a":{"bV":{"bb":36,"bp":695},"ci":{"bb":25,"bp":693}},"b":"( Nothing :: p1s, Nothing :: p2s, True ) ->\n                            -- If at the point where arguments are both unsortable, then proceed past if configured to\n                            goSubs p1s p2s ()"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":684},"ci":{"bb":21,"bp":684}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":31,"bp":1011},"ci":{"bb":9,"bp":1010}},"b":"Pattern.AsPattern p _ ->\n            getActualPattern p"},{"$":1,"a":{"bV":{"bb":31,"bp":1014},"ci":{"bb":9,"bp":1013}},"b":"Pattern.ParenthesizedPattern p ->\n            getActualPattern p"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1008},"ci":{"bb":5,"bp":1008}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":64,"bp":1104},"ci":{"bb":9,"bp":1102}},"b":"Pattern.AllPattern ->\n            Just Wildcard"},{"$":1,"a":{"bV":{"bb":22,"bp":1115},"ci":{"bb":9,"bp":1107}},"b":"Pattern.CharPattern c ->\n            makeLiteral CharLiteral c"},{"$":1,"a":{"bV":{"bb":22,"bp":1125},"ci":{"bb":9,"bp":1117}},"b":"Pattern.StringPattern s ->\n            makeLiteral StringLiteral s"},{"$":1,"a":{"bV":{"bb":31,"bp":1150},"ci":{"bb":9,"bp":1128}},"b":"Pattern.IntPattern i ->\n            makeLiteral IntLiteral i"},{"$":1,"a":{"bV":{"bb":26,"bp":1154},"ci":{"bb":9,"bp":1153}},"b":"Pattern.HexPattern i ->\n            makeLiteral IntLiteral i"},{"$":1,"a":{"bV":{"bb":26,"bp":1157},"ci":{"bb":9,"bp":1156}},"b":"Pattern.FloatPattern f ->\n            makeLiteral FloatLiteral f"},{"$":1,"a":{"bV":{"bb":38,"bp":1161},"ci":{"bb":9,"bp":1160}},"b":"Pattern.TuplePattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )"},{"$":1,"a":{"bV":{"bb":40,"bp":1164},"ci":{"bb":9,"bp":1163}},"b":"Pattern.UnConsPattern p1 p2 ->\n            let\n                cons : SortablePattern -> SortablePattern -> Maybe SortablePattern\n                cons x xs =\n                    case xs of\n                        Wildcard ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { subpatterns = [ x ]\n                                    , terminates = False\n                                    }\n\n                        ListTupleOrUncons r ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { r | subpatterns = x :: r.subpatterns }\n\n                        _ ->\n                            -- You can't cons onto a constructor or Literal, so this is a type error\n                            Nothing\n            in\n            Maybe.map2 cons (go p1) (go p2)\n                |> MaybeX.join"},{"$":1,"a":{"bV":{"bb":37,"bp":1167},"ci":{"bb":9,"bp":1166}},"b":"Pattern.ListPattern ps ->\n            MaybeX.traverse go ps\n                |> Maybe.map\n                    (\\subpatterns ->\n                        ListTupleOrUncons\n                            { subpatterns = subpatterns\n                            , terminates = True\n                            }\n                    )"},{"$":1,"a":{"bV":{"bb":37,"bp":1170},"ci":{"bb":9,"bp":1169}},"b":"Pattern.VarPattern _ ->\n            Just Wildcard"},{"$":1,"a":{"bV":{"bb":39,"bp":1173},"ci":{"bb":9,"bp":1172}},"b":"Pattern.NamedPattern { name } ps ->\n            moduleNameFor context.lookupTable n\n                |> Maybe.andThen (findConstructorOrder name ps)"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1100},"ci":{"bb":5,"bp":1100}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":38,"bp":1138},"ci":{"bb":25,"bp":1133}},"b":"ListTupleOrUncons r ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { r | subpatterns = x :: r.subpatterns }"},{"$":1,"a":{"bV":{"bb":77,"bp":1143},"ci":{"bb":25,"bp":1140}},"b":"Wildcard ->\n                            Just <|\n                                ListTupleOrUncons\n                                    { subpatterns = [ x ]\n                                    , terminates = False\n                                    }"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":25,"bp":1132},"ci":{"bb":21,"bp":1132}},"d_":"NoUnsortedCases","ff":0},{"cY":{"$":"$L","a":["Case patterns were found out of order.  They should be sorted as specified in the rule configuration."]},"fQ":"src/NoUnsortedCases.elm","dH":{"$":0,"a":{"$":"$L","a":[{"$":1,"a":{"bV":{"bb":26,"bp":1284},"ci":{"bb":9,"bp":1269}},"b":"( [], [] ) ->\n            -- Both have been exhausted, so no problems sorting them\n            True"},{"$":1,"a":{"bV":{"bb":17,"bp":1288},"ci":{"bb":9,"bp":1286}},"b":"( [], _ ) ->\n            -- r1 is shorter than r2, so it is safe to sort it if it terminates\n            r1.terminates"},{"$":1,"a":{"bV":{"bb":26,"bp":1292},"ci":{"bb":9,"bp":1290}},"b":"( x :: xs, y :: ys ) ->\n            -- Check if the head of the lists is sortable\n            case comparePatterns config x y of\n                Just EQ ->\n                    -- If the left-most subpatterns are equal, then they are sortable if the next subpattern is sortable, so recurse\n                    safelySortableListPatterns config\n                        { r1 | subpatterns = xs }\n                        { r2 | subpatterns = ys }\n\n                Just _ ->\n                    -- If the left-most subpattern is sortable, then they can be distinguished and so are safely sortable\n                    True\n\n                Nothing ->\n                    -- If the left-most subpattern is not sortable, they cannot be sorted\n                    False"}]}},"a4":"Case patterns are not sorted.","dh":false,"dY":{"bV":{"bb":9,"bp":1268},"ci":{"bb":5,"bp":1268}},"d_":"NoUnsortedCases","ff":0}]},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"src/NoUnsortedTopLevelDeclarations.elm","c":{"bT":2600031148,"bd":{"$":0},"b6":2035766349,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedRecordsTest.elm","c":{"bT":2575785783,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":1,"b":"tests/NoUnsortedLetDeclarationsTest.elm","c":{"bT":1983685284,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-1,"a":0,"b":"tests/NoUnsortedCasesTest.elm","c":{"bT":1133119512,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}},"e":{"$":-2}},"e":{"$":-1,"a":1,"b":"tests/NoUnsortedTopLevelDeclarationsTest.elm","c":{"bT":3504192216,"bd":{"$":0},"b6":598685499,"c7":false,"cd":{"O":{"$":-2}}},"d":{"$":-2},"e":{"$":-2}}}},"dZ":{"$":0,"a":{"bT":{"$":0,"a":3715779789},"bd":{"$":0},"b6":3185875481,"cd":{"O":{"$":-2}}}}}
